(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Hoge"] = factory();
	else
		root["Hoge"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 7633:
/*!**************************************************!*\
  !*** ./node_modules/core-js/es/promise/index.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.aggregate-error */ 9170);
__webpack_require__(/*! ../../modules/es.object.to-string */ 1539);
__webpack_require__(/*! ../../modules/es.promise */ 8674);
__webpack_require__(/*! ../../modules/es.promise.all-settled */ 7922);
__webpack_require__(/*! ../../modules/es.promise.any */ 4668);
__webpack_require__(/*! ../../modules/es.promise.finally */ 7727);
__webpack_require__(/*! ../../modules/es.string.iterator */ 8783);
__webpack_require__(/*! ../../modules/web.dom-collections.iterator */ 3948);
var path = __webpack_require__(/*! ../../internals/path */ 857);

module.exports = path.Promise;


/***/ }),

/***/ 3099:
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-function.js ***!
  \******************************************************/
/***/ (function(module) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ 6077:
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ 111);

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ 1223:
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var create = __webpack_require__(/*! ../internals/object-create */ 30);
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ 3070);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ 5787:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
/***/ (function(module) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ 9670:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ 111);

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ 1318:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ 5656);
var toLength = __webpack_require__(/*! ../internals/to-length */ 7466);
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ 1400);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 7072:
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ 4326:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/***/ (function(module) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ 648:
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ 1694);
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ 4326);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ 9920:
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ 6656);
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ 3887);
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ 1236);
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ 3070);

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ 8544:
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ 7293);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 4994:
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ 3383).IteratorPrototype;
var create = __webpack_require__(/*! ../internals/object-create */ 30);
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ 9114);
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ 8003);
var Iterators = __webpack_require__(/*! ../internals/iterators */ 7497);

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ 8880:
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ 3070);
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ 9114);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 9114:
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/***/ (function(module) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 654:
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-iterator.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ 4994);
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ 9518);
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ 7674);
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ 8003);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ 1913);
var Iterators = __webpack_require__(/*! ../internals/iterators */ 7497);
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ 3383);

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ 9781:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ 7293);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 317:
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var isObject = __webpack_require__(/*! ../internals/is-object */ 111);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 8324:
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/***/ (function(module) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ 6833:
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-ios.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ 8113);

module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);


/***/ }),

/***/ 5268:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-node.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ 4326);
var global = __webpack_require__(/*! ../internals/global */ 7854);

module.exports = classof(global.process) == 'process';


/***/ }),

/***/ 1036:
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-webos-webkit.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ 8113);

module.exports = /web0s(?!.*chrome)/i.test(userAgent);


/***/ }),

/***/ 8113:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 7392:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ 8113);

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ 748:
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/***/ (function(module) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 2109:
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ 1236).f;
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);
var setGlobal = __webpack_require__(/*! ../internals/set-global */ 3505);
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ 9920);
var isForced = __webpack_require__(/*! ../internals/is-forced */ 4705);

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 7293:
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 9974:
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 5005:
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ 857);
var global = __webpack_require__(/*! ../internals/global */ 7854);

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 1246:
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof */ 648);
var Iterators = __webpack_require__(/*! ../internals/iterators */ 7497);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ 7854:
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  /* global globalThis -- safe */
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 6656:
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/***/ (function(module) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ 3501:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 842:
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/host-report-errors.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ 490:
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 4664:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);
var fails = __webpack_require__(/*! ../internals/fails */ 7293);
var createElement = __webpack_require__(/*! ../internals/document-create-element */ 317);

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 8361:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ 7293);
var classof = __webpack_require__(/*! ../internals/classof-raw */ 4326);

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ 2788:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var store = __webpack_require__(/*! ../internals/shared-store */ 5465);

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 9909:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ 8536);
var global = __webpack_require__(/*! ../internals/global */ 7854);
var isObject = __webpack_require__(/*! ../internals/is-object */ 111);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var objectHas = __webpack_require__(/*! ../internals/has */ 6656);
var shared = __webpack_require__(/*! ../internals/shared-store */ 5465);
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ 6200);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ 3501);

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 7659:
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var Iterators = __webpack_require__(/*! ../internals/iterators */ 7497);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ 4705:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ 7293);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 111:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/***/ (function(module) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ 1913:
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/***/ (function(module) {

module.exports = false;


/***/ }),

/***/ 408:
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/iterate.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ 7659);
var toLength = __webpack_require__(/*! ../internals/to-length */ 7466);
var bind = __webpack_require__(/*! ../internals/function-bind-context */ 9974);
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ 1246);
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ 9212);

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator);
      throw error;
    }
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};


/***/ }),

/***/ 9212:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-close.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);

module.exports = function (iterator) {
  var returnMethod = iterator['return'];
  if (returnMethod !== undefined) {
    return anObject(returnMethod.call(iterator)).value;
  }
};


/***/ }),

/***/ 3383:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ 7293);
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ 9518);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var has = __webpack_require__(/*! ../internals/has */ 6656);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ 1913);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 7497:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 5948:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/microtask.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ 1236).f;
var macrotask = __webpack_require__(/*! ../internals/task */ 261).set;
var IS_IOS = __webpack_require__(/*! ../internals/engine-is-ios */ 6833);
var IS_WEBOS_WEBKIT = __webpack_require__(/*! ../internals/engine-is-webos-webkit */ 1036);
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ 5268);

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    then = promise.then;
    notify = function () {
      then.call(promise, flush);
    };
  // Node.js without promises
  } else if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ 3366:
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/native-promise-constructor.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);

module.exports = global.Promise;


/***/ }),

/***/ 133:
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ 5268);
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ 7392);
var fails = __webpack_require__(/*! ../internals/fails */ 7293);

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  /* global Symbol -- required for testing */
  return !Symbol.sham &&
    // Chrome 38 Symbol has incorrect toString conversion
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    (IS_NODE ? V8_VERSION === 38 : V8_VERSION > 37 && V8_VERSION < 41);
});


/***/ }),

/***/ 8536:
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ 2788);

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 8523:
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/new-promise-capability.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ 30:
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ 6048);
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ 748);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ 3501);
var html = __webpack_require__(/*! ../internals/html */ 490);
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ 317);
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ 6200);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject -- old IE */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ 6048:
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ 3070);
var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ 1956);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ 3070:
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ 4664);
var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ 7593);

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 1236:
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ 5296);
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ 9114);
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ 5656);
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ 7593);
var has = __webpack_require__(/*! ../internals/has */ 6656);
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ 4664);

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ 8006:
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ 6324);
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ 748);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 5181:
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 9518:
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ 6656);
var toObject = __webpack_require__(/*! ../internals/to-object */ 7908);
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ 6200);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ 8544);

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 6324:
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ 6656);
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ 5656);
var indexOf = __webpack_require__(/*! ../internals/array-includes */ 1318).indexOf;
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ 3501);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ 1956:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ 6324);
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ 748);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 5296:
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),

/***/ 7674:
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable no-proto -- safe */
var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ 6077);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 288:
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ 1694);
var classof = __webpack_require__(/*! ../internals/classof */ 648);

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ 3887:
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ 8006);
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ 5181);
var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 857:
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);

module.exports = global;


/***/ }),

/***/ 2534:
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/perform.js ***!
  \***************************************************/
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ 9478:
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/promise-resolve.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var isObject = __webpack_require__(/*! ../internals/is-object */ 111);
var newPromiseCapability = __webpack_require__(/*! ../internals/new-promise-capability */ 8523);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ 2248:
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/redefine-all.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ 1320:
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var has = __webpack_require__(/*! ../internals/has */ 6656);
var setGlobal = __webpack_require__(/*! ../internals/set-global */ 3505);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ 2788);
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ 9909);

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ 4488:
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/***/ (function(module) {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 3505:
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 6340:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-species.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ 3070);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ 8003:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ 3070).f;
var has = __webpack_require__(/*! ../internals/has */ 6656);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ 6200:
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var shared = __webpack_require__(/*! ../internals/shared */ 2309);
var uid = __webpack_require__(/*! ../internals/uid */ 9711);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5465:
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var setGlobal = __webpack_require__(/*! ../internals/set-global */ 3505);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ 2309:
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ 1913);
var store = __webpack_require__(/*! ../internals/shared-store */ 5465);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.9.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ 6707:
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/species-constructor.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),

/***/ 8710:
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/string-multibyte.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ 9958);
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ 4488);

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ 261:
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/task.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var fails = __webpack_require__(/*! ../internals/fails */ 7293);
var bind = __webpack_require__(/*! ../internals/function-bind-context */ 9974);
var html = __webpack_require__(/*! ../internals/html */ 490);
var createElement = __webpack_require__(/*! ../internals/document-create-element */ 317);
var IS_IOS = __webpack_require__(/*! ../internals/engine-is-ios */ 6833);
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ 5268);

var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins -- safe
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func -- spec requirement
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    typeof postMessage == 'function' &&
    !global.importScripts &&
    location && location.protocol !== 'file:' &&
    !fails(post)
  ) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ 1400:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ 9958);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5656:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ 8361);
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ 4488);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 9958:
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/***/ (function(module) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ 7466:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ 9958);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 7908:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ 4488);

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 7593:
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ 111);

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 1694:
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 9711:
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/***/ (function(module) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ 3307:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ 133);

module.exports = NATIVE_SYMBOL
  /* global Symbol -- safe */
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 5112:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var shared = __webpack_require__(/*! ../internals/shared */ 2309);
var has = __webpack_require__(/*! ../internals/has */ 6656);
var uid = __webpack_require__(/*! ../internals/uid */ 9711);
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ 133);
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ 3307);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 9170:
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.aggregate-error.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ 9518);
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ 7674);
var create = __webpack_require__(/*! ../internals/object-create */ 30);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ 9114);
var iterate = __webpack_require__(/*! ../internals/iterate */ 408);

var $AggregateError = function AggregateError(errors, message) {
  var that = this;
  if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message);
  if (setPrototypeOf) {
    // eslint-disable-next-line unicorn/error-message -- expected
    that = setPrototypeOf(new Error(undefined), getPrototypeOf(that));
  }
  if (message !== undefined) createNonEnumerableProperty(that, 'message', String(message));
  var errorsArray = [];
  iterate(errors, errorsArray.push, { that: errorsArray });
  createNonEnumerableProperty(that, 'errors', errorsArray);
  return that;
};

$AggregateError.prototype = create(Error.prototype, {
  constructor: createPropertyDescriptor(5, $AggregateError),
  message: createPropertyDescriptor(5, ''),
  name: createPropertyDescriptor(5, 'AggregateError')
});

// `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor
$({ global: true }, {
  AggregateError: $AggregateError
});


/***/ }),

/***/ 6992:
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ 5656);
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ 1223);
var Iterators = __webpack_require__(/*! ../internals/iterators */ 7497);
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ 9909);
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ 654);

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ 1539:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ 1694);
var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);
var toString = __webpack_require__(/*! ../internals/object-to-string */ 288);

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ 7922:
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.all-settled.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ 8523);
var perform = __webpack_require__(/*! ../internals/perform */ 2534);
var iterate = __webpack_require__(/*! ../internals/iterate */ 408);

// `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled
$({ target: 'Promise', stat: true }, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'fulfilled', value: value };
          --remaining || resolve(values);
        }, function (error) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'rejected', reason: error };
          --remaining || resolve(values);
        });
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 4668:
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.any.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ 8523);
var perform = __webpack_require__(/*! ../internals/perform */ 2534);
var iterate = __webpack_require__(/*! ../internals/iterate */ 408);

var PROMISE_ANY_ERROR = 'No one promise resolved';

// `Promise.any` method
// https://tc39.es/ecma262/#sec-promise.any
$({ target: 'Promise', stat: true }, {
  any: function any(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aFunction(C.resolve);
      var errors = [];
      var counter = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyRejected = false;
        errors.push(undefined);
        remaining++;
        promiseResolve.call(C, promise).then(function (value) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyResolved = true;
          resolve(value);
        }, function (error) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyRejected = true;
          errors[index] = error;
          --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 7727:
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.finally.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ 1913);
var NativePromise = __webpack_require__(/*! ../internals/native-promise-constructor */ 3366);
var fails = __webpack_require__(/*! ../internals/fails */ 7293);
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ 6707);
var promiseResolve = __webpack_require__(/*! ../internals/promise-resolve */ 9478);
var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);

// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromise && fails(function () {
  NativePromise.prototype['finally'].call({ then: function () { /* empty */ } }, function () { /* empty */ });
});

// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = typeof onFinally == 'function';
    return this.then(
      isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () { return x; });
      } : onFinally,
      isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () { throw e; });
      } : onFinally
    );
  }
});

// patch native Promise.prototype for native async functions
if (!IS_PURE && typeof NativePromise == 'function' && !NativePromise.prototype['finally']) {
  redefine(NativePromise.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
}


/***/ }),

/***/ 8674:
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ 1913);
var global = __webpack_require__(/*! ../internals/global */ 7854);
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);
var NativePromise = __webpack_require__(/*! ../internals/native-promise-constructor */ 3366);
var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ 2248);
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ 8003);
var setSpecies = __webpack_require__(/*! ../internals/set-species */ 6340);
var isObject = __webpack_require__(/*! ../internals/is-object */ 111);
var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);
var anInstance = __webpack_require__(/*! ../internals/an-instance */ 5787);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ 2788);
var iterate = __webpack_require__(/*! ../internals/iterate */ 408);
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ 7072);
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ 6707);
var task = __webpack_require__(/*! ../internals/task */ 261).set;
var microtask = __webpack_require__(/*! ../internals/microtask */ 5948);
var promiseResolve = __webpack_require__(/*! ../internals/promise-resolve */ 9478);
var hostReportErrors = __webpack_require__(/*! ../internals/host-report-errors */ 842);
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ 8523);
var perform = __webpack_require__(/*! ../internals/perform */ 2534);
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ 9909);
var isForced = __webpack_require__(/*! ../internals/is-forced */ 4705);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ 5268);
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ 7392);

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (V8_VERSION === 66) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    if (!IS_NODE && !NATIVE_REJECTION_EVENT) return true;
  }
  // We need Promise#finally in the pure version for preventing prototype pollution
  if (IS_PURE && !PromiseConstructor.prototype['finally']) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  task.call(global, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  task.call(global, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.es/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.es/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && typeof NativePromise == 'function') {
    nativeThen = NativePromise.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
    // https://github.com/zloirock/core-js/issues/640
    }, { unsafe: true });

    // wrap fetch result
    if (typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
      }
    });
  }
}

$({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.es/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.es/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.es/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.es/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 8783:
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__(/*! ../internals/string-multibyte */ 8710).charAt;
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ 9909);
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ 654);

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ 3948:
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ 8324);
var ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ 6992);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ }),

/***/ 8943:
/*!*******************************************************************!*\
  !*** ./node_modules/guacamole-common-js/dist/guacamole-common.js ***!
  \*******************************************************************/
/***/ (function(module) {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, returning
 * strictly received packets as array buffers. Note that this object will
 * overwrite any installed event handlers on the given Guacamole.InputStream.
 * 
 * @constructor
 * @param {Guacamole.InputStream} stream The stream that data will be read
 *                                       from.
 */
Guacamole.ArrayBufferReader = function(stream) {

    /**
     * Reference to this Guacamole.InputStream.
     * @private
     */
    var guac_reader = this;

    // Receive blobs as array buffers
    stream.onblob = function(data) {

        // Convert to ArrayBuffer
        var binary = window.atob(data);
        var arrayBuffer = new ArrayBuffer(binary.length);
        var bufferView = new Uint8Array(arrayBuffer);

        for (var i=0; i<binary.length; i++)
            bufferView[i] = binary.charCodeAt(i);

        // Call handler, if present
        if (guac_reader.ondata)
            guac_reader.ondata(arrayBuffer);

    };

    // Simply call onend when end received
    stream.onend = function() {
        if (guac_reader.onend)
            guac_reader.onend();
    };

    /**
     * Fired once for every blob of data received.
     * 
     * @event
     * @param {ArrayBuffer} buffer The data packet received.
     */
    this.ondata = null;

    /**
     * Fired once this stream is finished and no further data will be written.
     * @event
     */
    this.onend = null;

};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A writer which automatically writes to the given output stream with arbitrary
 * binary data, supplied as ArrayBuffers.
 * 
 * @constructor
 * @param {Guacamole.OutputStream} stream The stream that data will be written
 *                                        to.
 */
Guacamole.ArrayBufferWriter = function(stream) {

    /**
     * Reference to this Guacamole.StringWriter.
     * @private
     */
    var guac_writer = this;

    // Simply call onack for acknowledgements
    stream.onack = function(status) {
        if (guac_writer.onack)
            guac_writer.onack(status);
    };

    /**
     * Encodes the given data as base64, sending it as a blob. The data must
     * be small enough to fit into a single blob instruction.
     * 
     * @private
     * @param {Uint8Array} bytes The data to send.
     */
    function __send_blob(bytes) {

        var binary = "";

        // Produce binary string from bytes in buffer
        for (var i=0; i<bytes.byteLength; i++)
            binary += String.fromCharCode(bytes[i]);

        // Send as base64
        stream.sendBlob(window.btoa(binary));

    }

    /**
     * The maximum length of any blob sent by this Guacamole.ArrayBufferWriter,
     * in bytes. Data sent via
     * [sendData()]{@link Guacamole.ArrayBufferWriter#sendData} which exceeds
     * this length will be split into multiple blobs. As the Guacamole protocol
     * limits the maximum size of any instruction or instruction element to
     * 8192 bytes, and the contents of blobs will be base64-encoded, this value
     * should only be increased with extreme caution.
     *
     * @type {Number}
     * @default {@link Guacamole.ArrayBufferWriter.DEFAULT_BLOB_LENGTH}
     */
    this.blobLength = Guacamole.ArrayBufferWriter.DEFAULT_BLOB_LENGTH;

    /**
     * Sends the given data.
     * 
     * @param {ArrayBuffer|TypedArray} data The data to send.
     */
    this.sendData = function(data) {

        var bytes = new Uint8Array(data);

        // If small enough to fit into single instruction, send as-is
        if (bytes.length <= guac_writer.blobLength)
            __send_blob(bytes);

        // Otherwise, send as multiple instructions
        else {
            for (var offset=0; offset<bytes.length; offset += guac_writer.blobLength)
                __send_blob(bytes.subarray(offset, offset + guac_writer.blobLength));
        }

    };

    /**
     * Signals that no further text will be sent, effectively closing the
     * stream.
     */
    this.sendEnd = function() {
        stream.sendEnd();
    };

    /**
     * Fired for received data, if acknowledged by the server.
     * @event
     * @param {Guacamole.Status} status The status of the operation.
     */
    this.onack = null;

};

/**
 * The default maximum blob length for new Guacamole.ArrayBufferWriter
 * instances.
 *
 * @constant
 * @type {Number}
 */
Guacamole.ArrayBufferWriter.DEFAULT_BLOB_LENGTH = 6048;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Maintains a singleton instance of the Web Audio API AudioContext class,
 * instantiating the AudioContext only in response to the first call to
 * getAudioContext(), and only if no existing AudioContext instance has been
 * provided via the singleton property. Subsequent calls to getAudioContext()
 * will return the same instance.
 *
 * @namespace
 */
Guacamole.AudioContextFactory = {

    /**
     * A singleton instance of a Web Audio API AudioContext object, or null if
     * no instance has yes been created. This property may be manually set if
     * you wish to supply your own AudioContext instance, but care must be
     * taken to do so as early as possible. Assignments to this property will
     * not retroactively affect the value returned by previous calls to
     * getAudioContext().
     *
     * @type {AudioContext}
     */
    'singleton' : null,

    /**
     * Returns a singleton instance of a Web Audio API AudioContext object.
     *
     * @return {AudioContext}
     *     A singleton instance of a Web Audio API AudioContext object, or null
     *     if the Web Audio API is not supported.
     */
    'getAudioContext' : function getAudioContext() {

        // Fallback to Webkit-specific AudioContext implementation
        var AudioContext = window.AudioContext || window.webkitAudioContext;

        // Get new AudioContext instance if Web Audio API is supported
        if (AudioContext) {
            try {

                // Create new instance if none yet exists
                if (!Guacamole.AudioContextFactory.singleton)
                    Guacamole.AudioContextFactory.singleton = new AudioContext();

                // Return singleton instance
                return Guacamole.AudioContextFactory.singleton;

            }
            catch (e) {
                // Do not use Web Audio API if not allowed by browser
            }
        }

        // Web Audio API not supported
        return null;

    }

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract audio player which accepts, queues and plays back arbitrary audio
 * data. It is up to implementations of this class to provide some means of
 * handling a provided Guacamole.InputStream. Data received along the provided
 * stream is to be played back immediately.
 *
 * @constructor
 */
Guacamole.AudioPlayer = function AudioPlayer() {

    /**
     * Notifies this Guacamole.AudioPlayer that all audio up to the current
     * point in time has been given via the underlying stream, and that any
     * difference in time between queued audio data and the current time can be
     * considered latency.
     */
    this.sync = function sync() {
        // Default implementation - do nothing
    };

};

/**
 * Determines whether the given mimetype is supported by any built-in
 * implementation of Guacamole.AudioPlayer, and thus will be properly handled
 * by Guacamole.AudioPlayer.getInstance().
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by any built-in
 *     Guacamole.AudioPlayer, false otherwise.
 */
Guacamole.AudioPlayer.isSupportedType = function isSupportedType(mimetype) {

    return Guacamole.RawAudioPlayer.isSupportedType(mimetype);

};

/**
 * Returns a list of all mimetypes supported by any built-in
 * Guacamole.AudioPlayer, in rough order of priority. Beware that only the core
 * mimetypes themselves will be listed. Any mimetype parameters, even required
 * ones, will not be included in the list. For example, "audio/L8" is a
 * supported raw audio mimetype that is supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by any built-in Guacamole.AudioPlayer,
 *     excluding any parameters.
 */
Guacamole.AudioPlayer.getSupportedTypes = function getSupportedTypes() {

    return Guacamole.RawAudioPlayer.getSupportedTypes();

};

/**
 * Returns an instance of Guacamole.AudioPlayer providing support for the given
 * audio format. If support for the given audio format is not available, null
 * is returned.
 *
 * @param {Guacamole.InputStream} stream
 *     The Guacamole.InputStream to read audio data from.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data in the provided stream.
 *
 * @return {Guacamole.AudioPlayer}
 *     A Guacamole.AudioPlayer instance supporting the given mimetype and
 *     reading from the given stream, or null if support for the given mimetype
 *     is absent.
 */
Guacamole.AudioPlayer.getInstance = function getInstance(stream, mimetype) {

    // Use raw audio player if possible
    if (Guacamole.RawAudioPlayer.isSupportedType(mimetype))
        return new Guacamole.RawAudioPlayer(stream, mimetype);

    // No support for given mimetype
    return null;

};

/**
 * Implementation of Guacamole.AudioPlayer providing support for raw PCM format
 * audio. This player relies only on the Web Audio API and does not require any
 * browser-level support for its audio formats.
 *
 * @constructor
 * @augments Guacamole.AudioPlayer
 * @param {Guacamole.InputStream} stream
 *     The Guacamole.InputStream to read audio data from.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data in the provided stream, which must be a
 *     "audio/L8" or "audio/L16" mimetype with necessary parameters, such as:
 *     "audio/L16;rate=44100,channels=2".
 */
Guacamole.RawAudioPlayer = function RawAudioPlayer(stream, mimetype) {

    /**
     * The format of audio this player will decode.
     *
     * @private
     * @type {Guacamole.RawAudioFormat}
     */
    var format = Guacamole.RawAudioFormat.parse(mimetype);

    /**
     * An instance of a Web Audio API AudioContext object, or null if the
     * Web Audio API is not supported.
     *
     * @private
     * @type {AudioContext}
     */
    var context = Guacamole.AudioContextFactory.getAudioContext();

    /**
     * The earliest possible time that the next packet could play without
     * overlapping an already-playing packet, in seconds. Note that while this
     * value is in seconds, it is not an integer value and has microsecond
     * resolution.
     *
     * @private
     * @type {Number}
     */
    var nextPacketTime = context.currentTime;

    /**
     * Guacamole.ArrayBufferReader wrapped around the audio input stream
     * provided with this Guacamole.RawAudioPlayer was created.
     *
     * @private
     * @type {Guacamole.ArrayBufferReader}
     */
    var reader = new Guacamole.ArrayBufferReader(stream);

    /**
     * The minimum size of an audio packet split by splitAudioPacket(), in
     * seconds. Audio packets smaller than this will not be split, nor will the
     * split result of a larger packet ever be smaller in size than this
     * minimum.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var MIN_SPLIT_SIZE = 0.02;

    /**
     * The maximum amount of latency to allow between the buffered data stream
     * and the playback position, in seconds. Initially, this is set to
     * roughly one third of a second.
     *
     * @private
     * @type {Number}
     */
    var maxLatency = 0.3;

    /**
     * The type of typed array that will be used to represent each audio packet
     * internally. This will be either Int8Array or Int16Array, depending on
     * whether the raw audio format is 8-bit or 16-bit.
     *
     * @private
     * @constructor
     */
    var SampleArray = (format.bytesPerSample === 1) ? window.Int8Array : window.Int16Array;

    /**
     * The maximum absolute value of any sample within a raw audio packet
     * received by this audio player. This depends only on the size of each
     * sample, and will be 128 for 8-bit audio and 32768 for 16-bit audio.
     *
     * @private
     * @type {Number}
     */
    var maxSampleValue = (format.bytesPerSample === 1) ? 128 : 32768;

    /**
     * The queue of all pending audio packets, as an array of sample arrays.
     * Audio packets which are pending playback will be added to this queue for
     * further manipulation prior to scheduling via the Web Audio API. Once an
     * audio packet leaves this queue and is scheduled via the Web Audio API,
     * no further modifications can be made to that packet.
     *
     * @private
     * @type {SampleArray[]}
     */
    var packetQueue = [];

    /**
     * Given an array of audio packets, returns a single audio packet
     * containing the concatenation of those packets.
     *
     * @private
     * @param {SampleArray[]} packets
     *     The array of audio packets to concatenate.
     *
     * @returns {SampleArray}
     *     A single audio packet containing the concatenation of all given
     *     audio packets. If no packets are provided, this will be undefined.
     */
    var joinAudioPackets = function joinAudioPackets(packets) {

        // Do not bother joining if one or fewer packets are in the queue
        if (packets.length <= 1)
            return packets[0];

        // Determine total sample length of the entire queue
        var totalLength = 0;
        packets.forEach(function addPacketLengths(packet) {
            totalLength += packet.length;
        });

        // Append each packet within queue
        var offset = 0;
        var joined = new SampleArray(totalLength);
        packets.forEach(function appendPacket(packet) {
            joined.set(packet, offset);
            offset += packet.length;
        });

        return joined;

    };

    /**
     * Given a single packet of audio data, splits off an arbitrary length of
     * audio data from the beginning of that packet, returning the split result
     * as an array of two packets. The split location is determined through an
     * algorithm intended to minimize the liklihood of audible clicking between
     * packets. If no such split location is possible, an array containing only
     * the originally-provided audio packet is returned.
     *
     * @private
     * @param {SampleArray} data
     *     The audio packet to split.
     *
     * @returns {SampleArray[]}
     *     An array of audio packets containing the result of splitting the
     *     provided audio packet. If splitting is possible, this array will
     *     contain two packets. If splitting is not possible, this array will
     *     contain only the originally-provided packet.
     */
    var splitAudioPacket = function splitAudioPacket(data) {

        var minValue = Number.MAX_VALUE;
        var optimalSplitLength = data.length;

        // Calculate number of whole samples in the provided audio packet AND
        // in the minimum possible split packet
        var samples = Math.floor(data.length / format.channels);
        var minSplitSamples = Math.floor(format.rate * MIN_SPLIT_SIZE);

        // Calculate the beginning of the "end" of the audio packet
        var start = Math.max(
            format.channels * minSplitSamples,
            format.channels * (samples - minSplitSamples)
        );

        // For all samples at the end of the given packet, find a point where
        // the perceptible volume across all channels is lowest (and thus is
        // the optimal point to split)
        for (var offset = start; offset < data.length; offset += format.channels) {

            // Calculate the sum of all values across all channels (the result
            // will be proportional to the average volume of a sample)
            var totalValue = 0;
            for (var channel = 0; channel < format.channels; channel++) {
                totalValue += Math.abs(data[offset + channel]);
            }

            // If this is the smallest average value thus far, set the split
            // length such that the first packet ends with the current sample
            if (totalValue <= minValue) {
                optimalSplitLength = offset + format.channels;
                minValue = totalValue;
            }

        }

        // If packet is not split, return the supplied packet untouched
        if (optimalSplitLength === data.length)
            return [data];

        // Otherwise, split the packet into two new packets according to the
        // calculated optimal split length
        return [
            new SampleArray(data.buffer.slice(0, optimalSplitLength * format.bytesPerSample)),
            new SampleArray(data.buffer.slice(optimalSplitLength * format.bytesPerSample))
        ];

    };

    /**
     * Pushes the given packet of audio data onto the playback queue. Unlike
     * other private functions within Guacamole.RawAudioPlayer, the type of the
     * ArrayBuffer packet of audio data here need not be specific to the type
     * of audio (as with SampleArray). The ArrayBuffer type provided by a
     * Guacamole.ArrayBufferReader, for example, is sufficient. Any necessary
     * conversions will be performed automatically internally.
     *
     * @private
     * @param {ArrayBuffer} data
     *     A raw packet of audio data that should be pushed onto the audio
     *     playback queue.
     */
    var pushAudioPacket = function pushAudioPacket(data) {
        packetQueue.push(new SampleArray(data));
    };

    /**
     * Shifts off and returns a packet of audio data from the beginning of the
     * playback queue. The length of this audio packet is determined
     * dynamically according to the click-reduction algorithm implemented by
     * splitAudioPacket().
     *
     * @private
     * @returns {SampleArray}
     *     A packet of audio data pulled from the beginning of the playback
     *     queue.
     */
    var shiftAudioPacket = function shiftAudioPacket() {

        // Flatten data in packet queue
        var data = joinAudioPackets(packetQueue);
        if (!data)
            return null;

        // Pull an appropriate amount of data from the front of the queue
        packetQueue = splitAudioPacket(data);
        data = packetQueue.shift();

        return data;

    };

    /**
     * Converts the given audio packet into an AudioBuffer, ready for playback
     * by the Web Audio API. Unlike the raw audio packets received by this
     * audio player, AudioBuffers require floating point samples and are split
     * into isolated planes of channel-specific data.
     *
     * @private
     * @param {SampleArray} data
     *     The raw audio packet that should be converted into a Web Audio API
     *     AudioBuffer.
     *
     * @returns {AudioBuffer}
     *     A new Web Audio API AudioBuffer containing the provided audio data,
     *     converted to the format used by the Web Audio API.
     */
    var toAudioBuffer = function toAudioBuffer(data) {

        // Calculate total number of samples
        var samples = data.length / format.channels;

        // Determine exactly when packet CAN play
        var packetTime = context.currentTime;
        if (nextPacketTime < packetTime)
            nextPacketTime = packetTime;

        // Get audio buffer for specified format
        var audioBuffer = context.createBuffer(format.channels, samples, format.rate);

        // Convert each channel
        for (var channel = 0; channel < format.channels; channel++) {

            var audioData = audioBuffer.getChannelData(channel);

            // Fill audio buffer with data for channel
            var offset = channel;
            for (var i = 0; i < samples; i++) {
                audioData[i] = data[offset] / maxSampleValue;
                offset += format.channels;
            }

        }

        return audioBuffer;

    };

    // Defer playback of received audio packets slightly
    reader.ondata = function playReceivedAudio(data) {

        // Push received samples onto queue
        pushAudioPacket(new SampleArray(data));

        // Shift off an arbitrary packet of audio data from the queue (this may
        // be different in size from the packet just pushed)
        var packet = shiftAudioPacket();
        if (!packet)
            return;

        // Determine exactly when packet CAN play
        var packetTime = context.currentTime;
        if (nextPacketTime < packetTime)
            nextPacketTime = packetTime;

        // Set up buffer source
        var source = context.createBufferSource();
        source.connect(context.destination);

        // Use noteOn() instead of start() if necessary
        if (!source.start)
            source.start = source.noteOn;

        // Schedule packet
        source.buffer = toAudioBuffer(packet);
        source.start(nextPacketTime);

        // Update timeline by duration of scheduled packet
        nextPacketTime += packet.length / format.channels / format.rate;

    };

    /** @override */
    this.sync = function sync() {

        // Calculate elapsed time since last sync
        var now = context.currentTime;

        // Reschedule future playback time such that playback latency is
        // bounded within a reasonable latency threshold
        nextPacketTime = Math.min(nextPacketTime, now + maxLatency);

    };

};

Guacamole.RawAudioPlayer.prototype = new Guacamole.AudioPlayer();

/**
 * Determines whether the given mimetype is supported by
 * Guacamole.RawAudioPlayer.
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by Guacamole.RawAudioPlayer,
 *     false otherwise.
 */
Guacamole.RawAudioPlayer.isSupportedType = function isSupportedType(mimetype) {

    // No supported types if no Web Audio API
    if (!Guacamole.AudioContextFactory.getAudioContext())
        return false;

    return Guacamole.RawAudioFormat.parse(mimetype) !== null;

};

/**
 * Returns a list of all mimetypes supported by Guacamole.RawAudioPlayer. Only
 * the core mimetypes themselves will be listed. Any mimetype parameters, even
 * required ones, will not be included in the list. For example, "audio/L8" is
 * a raw audio mimetype that may be supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by Guacamole.RawAudioPlayer, excluding
 *     any parameters. If the necessary JavaScript APIs for playing raw audio
 *     are absent, this list will be empty.
 */
Guacamole.RawAudioPlayer.getSupportedTypes = function getSupportedTypes() {

    // No supported types if no Web Audio API
    if (!Guacamole.AudioContextFactory.getAudioContext())
        return [];

    // We support 8-bit and 16-bit raw PCM
    return [
        'audio/L8',
        'audio/L16'
    ];

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract audio recorder which streams arbitrary audio data to an underlying
 * Guacamole.OutputStream. It is up to implementations of this class to provide
 * some means of handling this Guacamole.OutputStream. Data produced by the
 * recorder is to be sent along the provided stream immediately.
 *
 * @constructor
 */
Guacamole.AudioRecorder = function AudioRecorder() {

    /**
     * Callback which is invoked when the audio recording process has stopped
     * and the underlying Guacamole stream has been closed normally. Audio will
     * only resume recording if a new Guacamole.AudioRecorder is started. This
     * Guacamole.AudioRecorder instance MAY NOT be reused.
     *
     * @event
     */
    this.onclose = null;

    /**
     * Callback which is invoked when the audio recording process cannot
     * continue due to an error, if it has started at all. The underlying
     * Guacamole stream is automatically closed. Future attempts to record
     * audio should not be made, and this Guacamole.AudioRecorder instance
     * MAY NOT be reused.
     *
     * @event
     */
    this.onerror = null;

};

/**
 * Determines whether the given mimetype is supported by any built-in
 * implementation of Guacamole.AudioRecorder, and thus will be properly handled
 * by Guacamole.AudioRecorder.getInstance().
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by any built-in
 *     Guacamole.AudioRecorder, false otherwise.
 */
Guacamole.AudioRecorder.isSupportedType = function isSupportedType(mimetype) {

    return Guacamole.RawAudioRecorder.isSupportedType(mimetype);

};

/**
 * Returns a list of all mimetypes supported by any built-in
 * Guacamole.AudioRecorder, in rough order of priority. Beware that only the
 * core mimetypes themselves will be listed. Any mimetype parameters, even
 * required ones, will not be included in the list. For example, "audio/L8" is
 * a supported raw audio mimetype that is supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by any built-in
 *     Guacamole.AudioRecorder, excluding any parameters.
 */
Guacamole.AudioRecorder.getSupportedTypes = function getSupportedTypes() {

    return Guacamole.RawAudioRecorder.getSupportedTypes();

};

/**
 * Returns an instance of Guacamole.AudioRecorder providing support for the
 * given audio format. If support for the given audio format is not available,
 * null is returned.
 *
 * @param {Guacamole.OutputStream} stream
 *     The Guacamole.OutputStream to send audio data through.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data to be sent along the provided stream.
 *
 * @return {Guacamole.AudioRecorder}
 *     A Guacamole.AudioRecorder instance supporting the given mimetype and
 *     writing to the given stream, or null if support for the given mimetype
 *     is absent.
 */
Guacamole.AudioRecorder.getInstance = function getInstance(stream, mimetype) {

    // Use raw audio recorder if possible
    if (Guacamole.RawAudioRecorder.isSupportedType(mimetype))
        return new Guacamole.RawAudioRecorder(stream, mimetype);

    // No support for given mimetype
    return null;

};

/**
 * Implementation of Guacamole.AudioRecorder providing support for raw PCM
 * format audio. This recorder relies only on the Web Audio API and does not
 * require any browser-level support for its audio formats.
 *
 * @constructor
 * @augments Guacamole.AudioRecorder
 * @param {Guacamole.OutputStream} stream
 *     The Guacamole.OutputStream to write audio data to.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data to send along the provided stream, which
 *     must be a "audio/L8" or "audio/L16" mimetype with necessary parameters,
 *     such as: "audio/L16;rate=44100,channels=2".
 */
Guacamole.RawAudioRecorder = function RawAudioRecorder(stream, mimetype) {

    /**
     * Reference to this RawAudioRecorder.
     *
     * @private
     * @type {Guacamole.RawAudioRecorder}
     */
    var recorder = this;

    /**
     * The size of audio buffer to request from the Web Audio API when
     * recording or processing audio, in sample-frames. This must be a power of
     * two between 256 and 16384 inclusive, as required by
     * AudioContext.createScriptProcessor().
     *
     * @private
     * @constant
     * @type {Number}
     */
    var BUFFER_SIZE = 2048;

    /**
     * The window size to use when applying Lanczos interpolation, commonly
     * denoted by the variable "a".
     * See: https://en.wikipedia.org/wiki/Lanczos_resampling
     *
     * @private
     * @contant
     * @type Number
     */
    var LANCZOS_WINDOW_SIZE = 3;

    /**
     * The format of audio this recorder will encode.
     *
     * @private
     * @type {Guacamole.RawAudioFormat}
     */
    var format = Guacamole.RawAudioFormat.parse(mimetype);

    /**
     * An instance of a Web Audio API AudioContext object, or null if the
     * Web Audio API is not supported.
     *
     * @private
     * @type {AudioContext}
     */
    var context = Guacamole.AudioContextFactory.getAudioContext();

    // Some browsers do not implement navigator.mediaDevices - this
    // shims in this functionality to ensure code compatibility.
    if (!navigator.mediaDevices)
        navigator.mediaDevices = {};

    // Browsers that either do not implement navigator.mediaDevices
    // at all or do not implement it completely need the getUserMedia
    // method defined.  This shims in this function by detecting
    // one of the supported legacy methods.
    if (!navigator.mediaDevices.getUserMedia)
        navigator.mediaDevices.getUserMedia = (navigator.getUserMedia
                || navigator.webkitGetUserMedia
                || navigator.mozGetUserMedia
                || navigator.msGetUserMedia).bind(navigator);

    /**
     * Guacamole.ArrayBufferWriter wrapped around the audio output stream
     * provided when this Guacamole.RawAudioRecorder was created.
     *
     * @private
     * @type {Guacamole.ArrayBufferWriter}
     */
    var writer = new Guacamole.ArrayBufferWriter(stream);

    /**
     * The type of typed array that will be used to represent each audio packet
     * internally. This will be either Int8Array or Int16Array, depending on
     * whether the raw audio format is 8-bit or 16-bit.
     *
     * @private
     * @constructor
     */
    var SampleArray = (format.bytesPerSample === 1) ? window.Int8Array : window.Int16Array;

    /**
     * The maximum absolute value of any sample within a raw audio packet sent
     * by this audio recorder. This depends only on the size of each sample,
     * and will be 128 for 8-bit audio and 32768 for 16-bit audio.
     *
     * @private
     * @type {Number}
     */
    var maxSampleValue = (format.bytesPerSample === 1) ? 128 : 32768;

    /**
     * The total number of audio samples read from the local audio input device
     * over the life of this audio recorder.
     *
     * @private
     * @type {Number}
     */
    var readSamples = 0;

    /**
     * The total number of audio samples written to the underlying Guacamole
     * connection over the life of this audio recorder.
     *
     * @private
     * @type {Number}
     */
    var writtenSamples = 0;

    /**
     * The audio stream provided by the browser, if allowed. If no stream has
     * yet been received, this will be null.
     *
     * @type MediaStream
     */
    var mediaStream = null;

    /**
     * The source node providing access to the local audio input device.
     *
     * @private
     * @type {MediaStreamAudioSourceNode}
     */
    var source = null;

    /**
     * The script processing node which receives audio input from the media
     * stream source node as individual audio buffers.
     *
     * @private
     * @type {ScriptProcessorNode}
     */
    var processor = null;

    /**
     * The normalized sinc function. The normalized sinc function is defined as
     * 1 for x=0 and sin(PI * x) / (PI * x) for all other values of x.
     *
     * See: https://en.wikipedia.org/wiki/Sinc_function
     *
     * @private
     * @param {Number} x
     *     The point at which the normalized sinc function should be computed.
     *
     * @returns {Number}
     *     The value of the normalized sinc function at x.
     */
    var sinc = function sinc(x) {

        // The value of sinc(0) is defined as 1
        if (x === 0)
            return 1;

        // Otherwise, normlized sinc(x) is sin(PI * x) / (PI * x)
        var piX = Math.PI * x;
        return Math.sin(piX) / piX;

    };

    /**
     * Calculates the value of the Lanczos kernal at point x for a given window
     * size. See: https://en.wikipedia.org/wiki/Lanczos_resampling
     *
     * @private
     * @param {Number} x
     *     The point at which the value of the Lanczos kernel should be
     *     computed.
     *
     * @param {Number} a
     *     The window size to use for the Lanczos kernel.
     *
     * @returns {Number}
     *     The value of the Lanczos kernel at the given point for the given
     *     window size.
     */
    var lanczos = function lanczos(x, a) {

        // Lanczos is sinc(x) * sinc(x / a) for -a < x < a ...
        if (-a < x && x < a)
            return sinc(x) * sinc(x / a);

        // ... and 0 otherwise
        return 0;

    };

    /**
     * Determines the value of the waveform represented by the audio data at
     * the given location. If the value cannot be determined exactly as it does
     * not correspond to an exact sample within the audio data, the value will
     * be derived through interpolating nearby samples.
     *
     * @private
     * @param {Float32Array} audioData
     *     An array of audio data, as returned by AudioBuffer.getChannelData().
     *
     * @param {Number} t
     *     The relative location within the waveform from which the value
     *     should be retrieved, represented as a floating point number between
     *     0 and 1 inclusive, where 0 represents the earliest point in time and
     *     1 represents the latest.
     *
     * @returns {Number}
     *     The value of the waveform at the given location.
     */
    var interpolateSample = function getValueAt(audioData, t) {

        // Convert [0, 1] range to [0, audioData.length - 1]
        var index = (audioData.length - 1) * t;

        // Determine the start and end points for the summation used by the
        // Lanczos interpolation algorithm (see: https://en.wikipedia.org/wiki/Lanczos_resampling)
        var start = Math.floor(index) - LANCZOS_WINDOW_SIZE + 1;
        var end = Math.floor(index) + LANCZOS_WINDOW_SIZE;

        // Calculate the value of the Lanczos interpolation function for the
        // required range
        var sum = 0;
        for (var i = start; i <= end; i++) {
            sum += (audioData[i] || 0) * lanczos(index - i, LANCZOS_WINDOW_SIZE);
        }

        return sum;

    };

    /**
     * Converts the given AudioBuffer into an audio packet, ready for streaming
     * along the underlying output stream. Unlike the raw audio packets used by
     * this audio recorder, AudioBuffers require floating point samples and are
     * split into isolated planes of channel-specific data.
     *
     * @private
     * @param {AudioBuffer} audioBuffer
     *     The Web Audio API AudioBuffer that should be converted to a raw
     *     audio packet.
     *
     * @returns {SampleArray}
     *     A new raw audio packet containing the audio data from the provided
     *     AudioBuffer.
     */
    var toSampleArray = function toSampleArray(audioBuffer) {

        // Track overall amount of data read
        var inSamples = audioBuffer.length;
        readSamples += inSamples;

        // Calculate the total number of samples that should be written as of
        // the audio data just received and adjust the size of the output
        // packet accordingly
        var expectedWrittenSamples = Math.round(readSamples * format.rate / audioBuffer.sampleRate);
        var outSamples = expectedWrittenSamples - writtenSamples;

        // Update number of samples written
        writtenSamples += outSamples;

        // Get array for raw PCM storage
        var data = new SampleArray(outSamples * format.channels);

        // Convert each channel
        for (var channel = 0; channel < format.channels; channel++) {

            var audioData = audioBuffer.getChannelData(channel);

            // Fill array with data from audio buffer channel
            var offset = channel;
            for (var i = 0; i < outSamples; i++) {
                data[offset] = interpolateSample(audioData, i / (outSamples - 1)) * maxSampleValue;
                offset += format.channels;
            }

        }

        return data;

    };

    /**
     * getUserMedia() callback which handles successful retrieval of an
     * audio stream (successful start of recording).
     *
     * @private
     * @param {MediaStream} stream
     *     A MediaStream which provides access to audio data read from the
     *     user's local audio input device.
     */
    var streamReceived = function streamReceived(stream) {

        // Create processing node which receives appropriately-sized audio buffers
        processor = context.createScriptProcessor(BUFFER_SIZE, format.channels, format.channels);
        processor.connect(context.destination);

        // Send blobs when audio buffers are received
        processor.onaudioprocess = function processAudio(e) {
            writer.sendData(toSampleArray(e.inputBuffer).buffer);
        };

        // Connect processing node to user's audio input source
        source = context.createMediaStreamSource(stream);
        source.connect(processor);

        // Attempt to explicitly resume AudioContext, as it may be paused
        // by default
        if (context.state === 'suspended')
            context.resume();

        // Save stream for later cleanup
        mediaStream = stream;

    };

    /**
     * getUserMedia() callback which handles audio recording denial. The
     * underlying Guacamole output stream is closed, and the failure to
     * record is noted using onerror.
     *
     * @private
     */
    var streamDenied = function streamDenied() {

        // Simply end stream if audio access is not allowed
        writer.sendEnd();

        // Notify of closure
        if (recorder.onerror)
            recorder.onerror();

    };

    /**
     * Requests access to the user's microphone and begins capturing audio. All
     * received audio data is resampled as necessary and forwarded to the
     * Guacamole stream underlying this Guacamole.RawAudioRecorder. This
     * function must be invoked ONLY ONCE per instance of
     * Guacamole.RawAudioRecorder.
     *
     * @private
     */
    var beginAudioCapture = function beginAudioCapture() {

        // Attempt to retrieve an audio input stream from the browser
        var promise = navigator.mediaDevices.getUserMedia({
            'audio' : true
        }, streamReceived, streamDenied);

        // Handle stream creation/rejection via Promise for newer versions of
        // getUserMedia()
        if (promise && promise.then)
            promise.then(streamReceived, streamDenied);

    };

    /**
     * Stops capturing audio, if the capture has started, freeing all associated
     * resources. If the capture has not started, this function simply ends the
     * underlying Guacamole stream.
     *
     * @private
     */
    var stopAudioCapture = function stopAudioCapture() {

        // Disconnect media source node from script processor
        if (source)
            source.disconnect();

        // Disconnect associated script processor node
        if (processor)
            processor.disconnect();

        // Stop capture
        if (mediaStream) {
            var tracks = mediaStream.getTracks();
            for (var i = 0; i < tracks.length; i++)
                tracks[i].stop();
        }

        // Remove references to now-unneeded components
        processor = null;
        source = null;
        mediaStream = null;

        // End stream
        writer.sendEnd();

    };

    // Once audio stream is successfully open, request and begin reading audio
    writer.onack = function audioStreamAcknowledged(status) {

        // Begin capture if successful response and not yet started
        if (status.code === Guacamole.Status.Code.SUCCESS && !mediaStream)
            beginAudioCapture();

        // Otherwise stop capture and cease handling any further acks
        else {

            // Stop capturing audio
            stopAudioCapture();
            writer.onack = null;

            // Notify if stream has closed normally
            if (status.code === Guacamole.Status.Code.RESOURCE_CLOSED) {
                if (recorder.onclose)
                    recorder.onclose();
            }

            // Otherwise notify of closure due to error
            else {
                if (recorder.onerror)
                    recorder.onerror();
            }

        }

    };

};

Guacamole.RawAudioRecorder.prototype = new Guacamole.AudioRecorder();

/**
 * Determines whether the given mimetype is supported by
 * Guacamole.RawAudioRecorder.
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by Guacamole.RawAudioRecorder,
 *     false otherwise.
 */
Guacamole.RawAudioRecorder.isSupportedType = function isSupportedType(mimetype) {

    // No supported types if no Web Audio API
    if (!Guacamole.AudioContextFactory.getAudioContext())
        return false;

    return Guacamole.RawAudioFormat.parse(mimetype) !== null;

};

/**
 * Returns a list of all mimetypes supported by Guacamole.RawAudioRecorder. Only
 * the core mimetypes themselves will be listed. Any mimetype parameters, even
 * required ones, will not be included in the list. For example, "audio/L8" is
 * a raw audio mimetype that may be supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by Guacamole.RawAudioRecorder,
 *     excluding any parameters. If the necessary JavaScript APIs for recording
 *     raw audio are absent, this list will be empty.
 */
Guacamole.RawAudioRecorder.getSupportedTypes = function getSupportedTypes() {

    // No supported types if no Web Audio API
    if (!Guacamole.AudioContextFactory.getAudioContext())
        return [];

    // We support 8-bit and 16-bit raw PCM
    return [
        'audio/L8',
        'audio/L16'
    ];

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, assembling all
 * received blobs into a single blob by appending them to each other in order.
 * Note that this object will overwrite any installed event handlers on the
 * given Guacamole.InputStream.
 * 
 * @constructor
 * @param {Guacamole.InputStream} stream The stream that data will be read
 *                                       from.
 * @param {String} mimetype The mimetype of the blob being built.
 */
Guacamole.BlobReader = function(stream, mimetype) {

    /**
     * Reference to this Guacamole.InputStream.
     * @private
     */
    var guac_reader = this;

    /**
     * The length of this Guacamole.InputStream in bytes.
     * @private
     */
    var length = 0;

    // Get blob builder
    var blob_builder;
    if      (window.BlobBuilder)       blob_builder = new BlobBuilder();
    else if (window.WebKitBlobBuilder) blob_builder = new WebKitBlobBuilder();
    else if (window.MozBlobBuilder)    blob_builder = new MozBlobBuilder();
    else
        blob_builder = new (function() {

            var blobs = [];

            /** @ignore */
            this.append = function(data) {
                blobs.push(new Blob([data], {"type": mimetype}));
            };

            /** @ignore */
            this.getBlob = function() {
                return new Blob(blobs, {"type": mimetype});
            };

        })();

    // Append received blobs
    stream.onblob = function(data) {

        // Convert to ArrayBuffer
        var binary = window.atob(data);
        var arrayBuffer = new ArrayBuffer(binary.length);
        var bufferView = new Uint8Array(arrayBuffer);

        for (var i=0; i<binary.length; i++)
            bufferView[i] = binary.charCodeAt(i);

        blob_builder.append(arrayBuffer);
        length += arrayBuffer.byteLength;

        // Call handler, if present
        if (guac_reader.onprogress)
            guac_reader.onprogress(arrayBuffer.byteLength);

        // Send success response
        stream.sendAck("OK", 0x0000);

    };

    // Simply call onend when end received
    stream.onend = function() {
        if (guac_reader.onend)
            guac_reader.onend();
    };

    /**
     * Returns the current length of this Guacamole.InputStream, in bytes.
     * @return {Number} The current length of this Guacamole.InputStream.
     */
    this.getLength = function() {
        return length;
    };

    /**
     * Returns the contents of this Guacamole.BlobReader as a Blob.
     * @return {Blob} The contents of this Guacamole.BlobReader.
     */
    this.getBlob = function() {
        return blob_builder.getBlob();
    };

    /**
     * Fired once for every blob of data received.
     * 
     * @event
     * @param {Number} length The number of bytes received.
     */
    this.onprogress = null;

    /**
     * Fired once this stream is finished and no further data will be written.
     * @event
     */
    this.onend = null;

};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A writer which automatically writes to the given output stream with the
 * contents of provided Blob objects.
 *
 * @constructor
 * @param {Guacamole.OutputStream} stream
 *     The stream that data will be written to.
 */
Guacamole.BlobWriter = function BlobWriter(stream) {

    /**
     * Reference to this Guacamole.BlobWriter.
     *
     * @private
     * @type {Guacamole.BlobWriter}
     */
    var guacWriter = this;

    /**
     * Wrapped Guacamole.ArrayBufferWriter which will be used to send any
     * provided file data.
     *
     * @private
     * @type {Guacamole.ArrayBufferWriter}
     */
    var arrayBufferWriter = new Guacamole.ArrayBufferWriter(stream);

    // Initially, simply call onack for acknowledgements
    arrayBufferWriter.onack = function(status) {
        if (guacWriter.onack)
            guacWriter.onack(status);
    };

    /**
     * Browser-independent implementation of Blob.slice() which uses an end
     * offset to determine the span of the resulting slice, rather than a
     * length.
     *
     * @private
     * @param {Blob} blob
     *     The Blob to slice.
     *
     * @param {Number} start
     *     The starting offset of the slice, in bytes, inclusive.
     *
     * @param {Number} end
     *     The ending offset of the slice, in bytes, exclusive.
     *
     * @returns {Blob}
     *     A Blob containing the data within the given Blob starting at
     *     <code>start</code> and ending at <code>end - 1</code>.
     */
    var slice = function slice(blob, start, end) {

        // Use prefixed implementations if necessary
        var sliceImplementation = (
                blob.slice
             || blob.webkitSlice
             || blob.mozSlice
        ).bind(blob);

        var length = end - start;

        // The old Blob.slice() was length-based (not end-based). Try the
        // length version first, if the two calls are not equivalent.
        if (length !== end) {

            // If the result of the slice() call matches the expected length,
            // trust that result. It must be correct.
            var sliceResult = sliceImplementation(start, length);
            if (sliceResult.size === length)
                return sliceResult;

        }

        // Otherwise, use the most-recent standard: end-based slice()
        return sliceImplementation(start, end);

    };

    /**
     * Sends the contents of the given blob over the underlying stream.
     *
     * @param {Blob} blob
     *     The blob to send.
     */
    this.sendBlob = function sendBlob(blob) {

        var offset = 0;
        var reader = new FileReader();

        /**
         * Reads the next chunk of the blob provided to
         * [sendBlob()]{@link Guacamole.BlobWriter#sendBlob}. The chunk itself
         * is read asynchronously, and will not be available until
         * reader.onload fires.
         *
         * @private
         */
        var readNextChunk = function readNextChunk() {

            // If no further chunks remain, inform of completion and stop
            if (offset >= blob.size) {

                // Fire completion event for completed blob
                if (guacWriter.oncomplete)
                    guacWriter.oncomplete(blob);

                // No further chunks to read
                return;

            }

            // Obtain reference to next chunk as a new blob
            var chunk = slice(blob, offset, offset + arrayBufferWriter.blobLength);
            offset += arrayBufferWriter.blobLength;

            // Attempt to read the blob contents represented by the blob into
            // a new array buffer
            reader.readAsArrayBuffer(chunk);

        };

        // Send each chunk over the stream, continue reading the next chunk
        reader.onload = function chunkLoadComplete() {

            // Send the successfully-read chunk
            arrayBufferWriter.sendData(reader.result);

            // Continue sending more chunks after the latest chunk is
            // acknowledged
            arrayBufferWriter.onack = function sendMoreChunks(status) {

                if (guacWriter.onack)
                    guacWriter.onack(status);

                // Abort transfer if an error occurs
                if (status.isError())
                    return;

                // Inform of blob upload progress via progress events
                if (guacWriter.onprogress)
                    guacWriter.onprogress(blob, offset - arrayBufferWriter.blobLength);

                // Queue the next chunk for reading
                readNextChunk();

            };

        };

        // If an error prevents further reading, inform of error and stop
        reader.onerror = function chunkLoadFailed() {

            // Fire error event, including the context of the error
            if (guacWriter.onerror)
                guacWriter.onerror(blob, offset, reader.error);

        };

        // Begin reading the first chunk
        readNextChunk();

    };

    /**
     * Signals that no further text will be sent, effectively closing the
     * stream.
     */
    this.sendEnd = function sendEnd() {
        arrayBufferWriter.sendEnd();
    };

    /**
     * Fired for received data, if acknowledged by the server.
     *
     * @event
     * @param {Guacamole.Status} status
     *     The status of the operation.
     */
    this.onack = null;

    /**
     * Fired when an error occurs reading a blob passed to
     * [sendBlob()]{@link Guacamole.BlobWriter#sendBlob}. The transfer for the
     * the given blob will cease, but the stream will remain open.
     *
     * @event
     * @param {Blob} blob
     *     The blob that was being read when the error occurred.
     *
     * @param {Number} offset
     *     The offset of the failed read attempt within the blob, in bytes.
     *
     * @param {DOMError} error
     *     The error that occurred.
     */
    this.onerror = null;

    /**
     * Fired for each successfully-read chunk of data as a blob is being sent
     * via [sendBlob()]{@link Guacamole.BlobWriter#sendBlob}.
     *
     * @event
     * @param {Blob} blob
     *     The blob that is being read.
     *
     * @param {Number} offset
     *     The offset of the read that just succeeded.
     */
    this.onprogress = null;

    /**
     * Fired when a blob passed to
     * [sendBlob()]{@link Guacamole.BlobWriter#sendBlob} has finished being
     * sent.
     *
     * @event
     * @param {Blob} blob
     *     The blob that was sent.
     */
    this.oncomplete = null;

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Guacamole protocol client. Given a {@link Guacamole.Tunnel},
 * automatically handles incoming and outgoing Guacamole instructions via the
 * provided tunnel, updating its display using one or more canvas elements.
 * 
 * @constructor
 * @param {Guacamole.Tunnel} tunnel The tunnel to use to send and receive
 *                                  Guacamole instructions.
 */
Guacamole.Client = function(tunnel) {

    var guac_client = this;

    var STATE_IDLE          = 0;
    var STATE_CONNECTING    = 1;
    var STATE_WAITING       = 2;
    var STATE_CONNECTED     = 3;
    var STATE_DISCONNECTING = 4;
    var STATE_DISCONNECTED  = 5;

    var currentState = STATE_IDLE;
    
    var currentTimestamp = 0;
    var pingInterval = null;

    /**
     * Translation from Guacamole protocol line caps to Layer line caps.
     * @private
     */
    var lineCap = {
        0: "butt",
        1: "round",
        2: "square"
    };

    /**
     * Translation from Guacamole protocol line caps to Layer line caps.
     * @private
     */
    var lineJoin = {
        0: "bevel",
        1: "miter",
        2: "round"
    };

    /**
     * The underlying Guacamole display.
     *
     * @private
     * @type {Guacamole.Display}
     */
    var display = new Guacamole.Display();

    /**
     * All available layers and buffers
     *
     * @private
     * @type {Object.<Number, (Guacamole.Display.VisibleLayer|Guacamole.Layer)>}
     */
    var layers = {};
    
    /**
     * All audio players currently in use by the client. Initially, this will
     * be empty, but audio players may be allocated by the server upon request.
     *
     * @private
     * @type {Object.<Number, Guacamole.AudioPlayer>}
     */
    var audioPlayers = {};

    /**
     * All video players currently in use by the client. Initially, this will
     * be empty, but video players may be allocated by the server upon request.
     *
     * @private
     * @type {Object.<Number, Guacamole.VideoPlayer>}
     */
    var videoPlayers = {};

    // No initial parsers
    var parsers = [];

    // No initial streams 
    var streams = [];

    /**
     * All current objects. The index of each object is dictated by the
     * Guacamole server.
     *
     * @private
     * @type {Guacamole.Object[]}
     */
    var objects = [];

    // Pool of available stream indices
    var stream_indices = new Guacamole.IntegerPool();

    // Array of allocated output streams by index
    var output_streams = [];

    function setState(state) {
        if (state != currentState) {
            currentState = state;
            if (guac_client.onstatechange)
                guac_client.onstatechange(currentState);
        }
    }

    function isConnected() {
        return currentState == STATE_CONNECTED
            || currentState == STATE_WAITING;
    }

    /**
     * Produces an opaque representation of Guacamole.Client state which can be
     * later imported through a call to importState(). This object is
     * effectively an independent, compressed snapshot of protocol and display
     * state. Invoking this function implicitly flushes the display.
     *
     * @param {function} callback
     *     Callback which should be invoked once the state object is ready. The
     *     state object will be passed to the callback as the sole parameter.
     *     This callback may be invoked immediately, or later as the display
     *     finishes rendering and becomes ready.
     */
    this.exportState = function exportState(callback) {

        // Start with empty state
        var state = {
            'currentState' : currentState,
            'currentTimestamp' : currentTimestamp,
            'layers' : {}
        };

        var layersSnapshot = {};

        // Make a copy of all current layers (protocol state)
        for (var key in layers) {
            layersSnapshot[key] = layers[key];
        }

        // Populate layers once data is available (display state, requires flush)
        display.flush(function populateLayers() {

            // Export each defined layer/buffer
            for (var key in layersSnapshot) {

                var index = parseInt(key);
                var layer = layersSnapshot[key];
                var canvas = layer.toCanvas();

                // Store layer/buffer dimensions
                var exportLayer = {
                    'width'  : layer.width,
                    'height' : layer.height
                };

                // Store layer/buffer image data, if it can be generated
                if (layer.width && layer.height)
                    exportLayer.url = canvas.toDataURL('image/png');

                // Add layer properties if not a buffer nor the default layer
                if (index > 0) {
                    exportLayer.x = layer.x;
                    exportLayer.y = layer.y;
                    exportLayer.z = layer.z;
                    exportLayer.alpha = layer.alpha;
                    exportLayer.matrix = layer.matrix;
                    exportLayer.parent = getLayerIndex(layer.parent);
                }

                // Store exported layer
                state.layers[key] = exportLayer;

            }

            // Invoke callback now that the state is ready
            callback(state);

        });

    };

    /**
     * Restores Guacamole.Client protocol and display state based on an opaque
     * object from a prior call to exportState(). The Guacamole.Client instance
     * used to export that state need not be the same as this instance.
     *
     * @param {Object} state
     *     An opaque representation of Guacamole.Client state from a prior call
     *     to exportState().
     *
     * @param {function} [callback]
     *     The function to invoke when state has finished being imported. This
     *     may happen immediately, or later as images within the provided state
     *     object are loaded.
     */
    this.importState = function importState(state, callback) {

        var key;
        var index;

        currentState = state.currentState;
        currentTimestamp = state.currentTimestamp;

        // Dispose of all layers
        for (key in layers) {
            index = parseInt(key);
            if (index > 0)
                display.dispose(layers[key]);
        }

        layers = {};

        // Import state of each layer/buffer
        for (key in state.layers) {

            index = parseInt(key);

            var importLayer = state.layers[key];
            var layer = getLayer(index);

            // Reset layer size
            display.resize(layer, importLayer.width, importLayer.height);

            // Initialize new layer if it has associated data
            if (importLayer.url) {
                display.setChannelMask(layer, Guacamole.Layer.SRC);
                display.draw(layer, 0, 0, importLayer.url);
            }

            // Set layer-specific properties if not a buffer nor the default layer
            if (index > 0 && importLayer.parent >= 0) {

                // Apply layer position and set parent
                var parent = getLayer(importLayer.parent);
                display.move(layer, parent, importLayer.x, importLayer.y, importLayer.z);

                // Set layer transparency
                display.shade(layer, importLayer.alpha);

                // Apply matrix transform
                var matrix = importLayer.matrix;
                display.distort(layer,
                    matrix[0], matrix[1], matrix[2],
                    matrix[3], matrix[4], matrix[5]);

            }

        }

        // Flush changes to display
        display.flush(callback);

    };

    /**
     * Returns the underlying display of this Guacamole.Client. The display
     * contains an Element which can be added to the DOM, causing the
     * display to become visible.
     * 
     * @return {Guacamole.Display} The underlying display of this
     *                             Guacamole.Client.
     */
    this.getDisplay = function() {
        return display;
    };

    /**
     * Sends the current size of the screen.
     * 
     * @param {Number} width The width of the screen.
     * @param {Number} height The height of the screen.
     */
    this.sendSize = function(width, height) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        tunnel.sendMessage("size", width, height);

    };

    /**
     * Sends a key event having the given properties as if the user
     * pressed or released a key.
     * 
     * @param {Boolean} pressed Whether the key is pressed (true) or released
     *                          (false).
     * @param {Number} keysym The keysym of the key being pressed or released.
     */
    this.sendKeyEvent = function(pressed, keysym) {
        // Do not send requests if not connected
        if (!isConnected())
            return;

        tunnel.sendMessage("key", keysym, pressed);
    };

    /**
     * Sends a mouse event having the properties provided by the given mouse
     * state.
     * 
     * @param {Guacamole.Mouse.State} mouseState The state of the mouse to send
     *                                           in the mouse event.
     */
    this.sendMouseState = function(mouseState) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        // Update client-side cursor
        display.moveCursor(
            Math.floor(mouseState.x),
            Math.floor(mouseState.y)
        );

        // Build mask
        var buttonMask = 0;
        if (mouseState.left)   buttonMask |= 1;
        if (mouseState.middle) buttonMask |= 2;
        if (mouseState.right)  buttonMask |= 4;
        if (mouseState.up)     buttonMask |= 8;
        if (mouseState.down)   buttonMask |= 16;

        // Send message
        tunnel.sendMessage("mouse", Math.floor(mouseState.x), Math.floor(mouseState.y), buttonMask);
    };

    /**
     * Allocates an available stream index and creates a new
     * Guacamole.OutputStream using that index, associating the resulting
     * stream with this Guacamole.Client. Note that this stream will not yet
     * exist as far as the other end of the Guacamole connection is concerned.
     * Streams exist within the Guacamole protocol only when referenced by an
     * instruction which creates the stream, such as a "clipboard", "file", or
     * "pipe" instruction.
     *
     * @returns {Guacamole.OutputStream}
     *     A new Guacamole.OutputStream with a newly-allocated index and
     *     associated with this Guacamole.Client.
     */
    this.createOutputStream = function createOutputStream() {

        // Allocate index
        var index = stream_indices.next();

        // Return new stream
        var stream = output_streams[index] = new Guacamole.OutputStream(guac_client, index);
        return stream;

    };

    /**
     * Opens a new audio stream for writing, where audio data having the give
     * mimetype will be sent along the returned stream. The instruction
     * necessary to create this stream will automatically be sent.
     *
     * @param {String} mimetype
     *     The mimetype of the audio data that will be sent along the returned
     *     stream.
     *
     * @return {Guacamole.OutputStream}
     *     The created audio stream.
     */
    this.createAudioStream = function(mimetype) {

        // Allocate and associate stream with audio metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("audio", stream.index, mimetype);
        return stream;

    };

    /**
     * Opens a new file for writing, having the given index, mimetype and
     * filename. The instruction necessary to create this stream will
     * automatically be sent.
     *
     * @param {String} mimetype The mimetype of the file being sent.
     * @param {String} filename The filename of the file being sent.
     * @return {Guacamole.OutputStream} The created file stream.
     */
    this.createFileStream = function(mimetype, filename) {

        // Allocate and associate stream with file metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("file", stream.index, mimetype, filename);
        return stream;

    };

    /**
     * Opens a new pipe for writing, having the given name and mimetype. The
     * instruction necessary to create this stream will automatically be sent.
     *
     * @param {String} mimetype The mimetype of the data being sent.
     * @param {String} name The name of the pipe.
     * @return {Guacamole.OutputStream} The created file stream.
     */
    this.createPipeStream = function(mimetype, name) {

        // Allocate and associate stream with pipe metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("pipe", stream.index, mimetype, name);
        return stream;

    };

    /**
     * Opens a new clipboard object for writing, having the given mimetype. The
     * instruction necessary to create this stream will automatically be sent.
     *
     * @param {String} mimetype The mimetype of the data being sent.
     * @param {String} name The name of the pipe.
     * @return {Guacamole.OutputStream} The created file stream.
     */
    this.createClipboardStream = function(mimetype) {

        // Allocate and associate stream with clipboard metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("clipboard", stream.index, mimetype);
        return stream;

    };

    /**
     * Opens a new argument value stream for writing, having the given
     * parameter name and mimetype, requesting that the connection parameter
     * with the given name be updated to the value described by the contents
     * of the following stream. The instruction necessary to create this stream
     * will automatically be sent.
     *
     * @param {String} mimetype
     *     The mimetype of the data being sent.
     *
     * @param {String} name
     *     The name of the connection parameter to attempt to update.
     *
     * @return {Guacamole.OutputStream}
     *     The created argument value stream.
     */
    this.createArgumentValueStream = function createArgumentValueStream(mimetype, name) {

        // Allocate and associate stream with argument value metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("argv", stream.index, mimetype, name);
        return stream;

    };

    /**
     * Creates a new output stream associated with the given object and having
     * the given mimetype and name. The legality of a mimetype and name is
     * dictated by the object itself. The instruction necessary to create this
     * stream will automatically be sent.
     *
     * @param {Number} index
     *     The index of the object for which the output stream is being
     *     created.
     *
     * @param {String} mimetype
     *     The mimetype of the data which will be sent to the output stream.
     *
     * @param {String} name
     *     The defined name of an output stream within the given object.
     *
     * @returns {Guacamole.OutputStream}
     *     An output stream which will write blobs to the named output stream
     *     of the given object.
     */
    this.createObjectOutputStream = function createObjectOutputStream(index, mimetype, name) {

        // Allocate and ssociate stream with object metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("put", index, stream.index, mimetype, name);
        return stream;

    };

    /**
     * Requests read access to the input stream having the given name. If
     * successful, a new input stream will be created.
     *
     * @param {Number} index
     *     The index of the object from which the input stream is being
     *     requested.
     *
     * @param {String} name
     *     The name of the input stream to request.
     */
    this.requestObjectInputStream = function requestObjectInputStream(index, name) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        tunnel.sendMessage("get", index, name);
    };

    /**
     * Acknowledge receipt of a blob on the stream with the given index.
     * 
     * @param {Number} index The index of the stream associated with the
     *                       received blob.
     * @param {String} message A human-readable message describing the error
     *                         or status.
     * @param {Number} code The error code, if any, or 0 for success.
     */
    this.sendAck = function(index, message, code) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        tunnel.sendMessage("ack", index, message, code);
    };

    /**
     * Given the index of a file, writes a blob of data to that file.
     * 
     * @param {Number} index The index of the file to write to.
     * @param {String} data Base64-encoded data to write to the file.
     */
    this.sendBlob = function(index, data) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        tunnel.sendMessage("blob", index, data);
    };

    /**
     * Marks a currently-open stream as complete. The other end of the
     * Guacamole connection will be notified via an "end" instruction that the
     * stream is closed, and the index will be made available for reuse in
     * future streams.
     * 
     * @param {Number} index
     *     The index of the stream to end.
     */
    this.endStream = function(index) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        // Explicitly close stream by sending "end" instruction
        tunnel.sendMessage("end", index);

        // Free associated index and stream if they exist
        if (output_streams[index]) {
            stream_indices.free(index);
            delete output_streams[index];
        }

    };

    /**
     * Fired whenever the state of this Guacamole.Client changes.
     * 
     * @event
     * @param {Number} state The new state of the client.
     */
    this.onstatechange = null;

    /**
     * Fired when the remote client sends a name update.
     * 
     * @event
     * @param {String} name The new name of this client.
     */
    this.onname = null;

    /**
     * Fired when an error is reported by the remote client, and the connection
     * is being closed.
     * 
     * @event
     * @param {Guacamole.Status} status A status object which describes the
     *                                  error.
     */
    this.onerror = null;

    /**
     * Fired when a audio stream is created. The stream provided to this event
     * handler will contain its own event handlers for received data.
     *
     * @event
     * @param {Guacamole.InputStream} stream
     *     The stream that will receive audio data from the server.
     *
     * @param {String} mimetype
     *     The mimetype of the audio data which will be received.
     *
     * @return {Guacamole.AudioPlayer}
     *     An object which implements the Guacamole.AudioPlayer interface and
     *     has been initialied to play the data in the provided stream, or null
     *     if the built-in audio players of the Guacamole client should be
     *     used.
     */
    this.onaudio = null;

    /**
     * Fired when a video stream is created. The stream provided to this event
     * handler will contain its own event handlers for received data.
     *
     * @event
     * @param {Guacamole.InputStream} stream
     *     The stream that will receive video data from the server.
     *
     * @param {Guacamole.Display.VisibleLayer} layer
     *     The destination layer on which the received video data should be
     *     played. It is the responsibility of the Guacamole.VideoPlayer
     *     implementation to play the received data within this layer.
     *
     * @param {String} mimetype
     *     The mimetype of the video data which will be received.
     *
     * @return {Guacamole.VideoPlayer}
     *     An object which implements the Guacamole.VideoPlayer interface and
     *     has been initialied to play the data in the provided stream, or null
     *     if the built-in video players of the Guacamole client should be
     *     used.
     */
    this.onvideo = null;

    /**
     * Fired when the current value of a connection parameter is being exposed
     * by the server.
     *
     * @event
     * @param {Guacamole.InputStream} stream
     *     The stream that will receive connection parameter data from the
     *     server.
     *
     * @param {String} mimetype
     *     The mimetype of the data which will be received.
     *
     * @param {String} name
     *     The name of the connection parameter whose value is being exposed.
     */
    this.onargv = null;

    /**
     * Fired when the clipboard of the remote client is changing.
     * 
     * @event
     * @param {Guacamole.InputStream} stream The stream that will receive
     *                                       clipboard data from the server.
     * @param {String} mimetype The mimetype of the data which will be received.
     */
    this.onclipboard = null;

    /**
     * Fired when a file stream is created. The stream provided to this event
     * handler will contain its own event handlers for received data.
     * 
     * @event
     * @param {Guacamole.InputStream} stream The stream that will receive data
     *                                       from the server.
     * @param {String} mimetype The mimetype of the file received.
     * @param {String} filename The name of the file received.
     */
    this.onfile = null;

    /**
     * Fired when a filesystem object is created. The object provided to this
     * event handler will contain its own event handlers and functions for
     * requesting and handling data.
     *
     * @event
     * @param {Guacamole.Object} object
     *     The created filesystem object.
     *
     * @param {String} name
     *     The name of the filesystem.
     */
    this.onfilesystem = null;

    /**
     * Fired when a pipe stream is created. The stream provided to this event
     * handler will contain its own event handlers for received data;
     * 
     * @event
     * @param {Guacamole.InputStream} stream The stream that will receive data
     *                                       from the server.
     * @param {String} mimetype The mimetype of the data which will be received.
     * @param {String} name The name of the pipe.
     */
    this.onpipe = null;
    
    /**
     * Fired when a "required" instruction is received. A required instruction
     * indicates that additional parameters are required for the connection to
     * continue, such as user credentials.
     * 
     * @event
     * @param {String[]} parameters
     *      The names of the connection parameters that are required to be
     *      provided for the connection to continue.
     */
    this.onrequired = null;

    /**
     * Fired whenever a sync instruction is received from the server, indicating
     * that the server is finished processing any input from the client and
     * has sent any results.
     * 
     * @event
     * @param {Number} timestamp The timestamp associated with the sync
     *                           instruction.
     */
    this.onsync = null;

    /**
     * Returns the layer with the given index, creating it if necessary.
     * Positive indices refer to visible layers, an index of zero refers to
     * the default layer, and negative indices refer to buffers.
     *
     * @private
     * @param {Number} index
     *     The index of the layer to retrieve.
     *
     * @return {Guacamole.Display.VisibleLayer|Guacamole.Layer}
     *     The layer having the given index.
     */
    var getLayer = function getLayer(index) {

        // Get layer, create if necessary
        var layer = layers[index];
        if (!layer) {

            // Create layer based on index
            if (index === 0)
                layer = display.getDefaultLayer();
            else if (index > 0)
                layer = display.createLayer();
            else
                layer = display.createBuffer();
                
            // Add new layer
            layers[index] = layer;

        }

        return layer;

    };

    /**
     * Returns the index passed to getLayer() when the given layer was created.
     * Positive indices refer to visible layers, an index of zero refers to the
     * default layer, and negative indices refer to buffers.
     *
     * @param {Guacamole.Display.VisibleLayer|Guacamole.Layer} layer
     *     The layer whose index should be determined.
     *
     * @returns {Number}
     *     The index of the given layer, or null if no such layer is associated
     *     with this client.
     */
    var getLayerIndex = function getLayerIndex(layer) {

        // Avoid searching if there clearly is no such layer
        if (!layer)
            return null;

        // Search through each layer, returning the index of the given layer
        // once found
        for (var key in layers) {
            if (layer === layers[key])
                return parseInt(key);
        }

        // Otherwise, no such index
        return null;

    };

    function getParser(index) {

        var parser = parsers[index];

        // If parser not yet created, create it, and tie to the
        // oninstruction handler of the tunnel.
        if (parser == null) {
            parser = parsers[index] = new Guacamole.Parser();
            parser.oninstruction = tunnel.oninstruction;
        }

        return parser;

    }

    /**
     * Handlers for all defined layer properties.
     * @private
     */
    var layerPropertyHandlers = {

        "miter-limit": function(layer, value) {
            display.setMiterLimit(layer, parseFloat(value));
        }

    };
    
    /**
     * Handlers for all instruction opcodes receivable by a Guacamole protocol
     * client.
     * @private
     */
    var instructionHandlers = {

        "ack": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var reason = parameters[1];
            var code = parseInt(parameters[2]);

            // Get stream
            var stream = output_streams[stream_index];
            if (stream) {

                // Signal ack if handler defined
                if (stream.onack)
                    stream.onack(new Guacamole.Status(code, reason));

                // If code is an error, invalidate stream if not already
                // invalidated by onack handler
                if (code >= 0x0100 && output_streams[stream_index] === stream) {
                    stream_indices.free(stream_index);
                    delete output_streams[stream_index];
                }

            }

        },

        "arc": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var x = parseInt(parameters[1]);
            var y = parseInt(parameters[2]);
            var radius = parseInt(parameters[3]);
            var startAngle = parseFloat(parameters[4]);
            var endAngle = parseFloat(parameters[5]);
            var negative = parseInt(parameters[6]);

            display.arc(layer, x, y, radius, startAngle, endAngle, negative != 0);

        },

        "argv": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var mimetype = parameters[1];
            var name = parameters[2];

            // Create stream
            if (guac_client.onargv) {
                var stream = streams[stream_index] = new Guacamole.InputStream(guac_client, stream_index);
                guac_client.onargv(stream, mimetype, name);
            }

            // Otherwise, unsupported
            else
                guac_client.sendAck(stream_index, "Receiving argument values unsupported", 0x0100);

        },

        "audio": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var mimetype = parameters[1];

            // Create stream 
            var stream = streams[stream_index] =
                    new Guacamole.InputStream(guac_client, stream_index);

            // Get player instance via callback
            var audioPlayer = null;
            if (guac_client.onaudio)
                audioPlayer = guac_client.onaudio(stream, mimetype);

            // If unsuccessful, try to use a default implementation
            if (!audioPlayer)
                audioPlayer = Guacamole.AudioPlayer.getInstance(stream, mimetype);

            // If we have successfully retrieved an audio player, send success response
            if (audioPlayer) {
                audioPlayers[stream_index] = audioPlayer;
                guac_client.sendAck(stream_index, "OK", 0x0000);
            }

            // Otherwise, mimetype must be unsupported
            else
                guac_client.sendAck(stream_index, "BAD TYPE", 0x030F);

        },

        "blob": function(parameters) {

            // Get stream 
            var stream_index = parseInt(parameters[0]);
            var data = parameters[1];
            var stream = streams[stream_index];

            // Write data
            if (stream && stream.onblob)
                stream.onblob(data);

        },

        "body" : function handleBody(parameters) {

            // Get object
            var objectIndex = parseInt(parameters[0]);
            var object = objects[objectIndex];

            var streamIndex = parseInt(parameters[1]);
            var mimetype = parameters[2];
            var name = parameters[3];

            // Create stream if handler defined
            if (object && object.onbody) {
                var stream = streams[streamIndex] = new Guacamole.InputStream(guac_client, streamIndex);
                object.onbody(stream, mimetype, name);
            }

            // Otherwise, unsupported
            else
                guac_client.sendAck(streamIndex, "Receipt of body unsupported", 0x0100);

        },

        "cfill": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var r = parseInt(parameters[2]);
            var g = parseInt(parameters[3]);
            var b = parseInt(parameters[4]);
            var a = parseInt(parameters[5]);

            display.setChannelMask(layer, channelMask);
            display.fillColor(layer, r, g, b, a);

        },

        "clip": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.clip(layer);

        },

        "clipboard": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var mimetype = parameters[1];

            // Create stream 
            if (guac_client.onclipboard) {
                var stream = streams[stream_index] = new Guacamole.InputStream(guac_client, stream_index);
                guac_client.onclipboard(stream, mimetype);
            }

            // Otherwise, unsupported
            else
                guac_client.sendAck(stream_index, "Clipboard unsupported", 0x0100);

        },

        "close": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.close(layer);

        },

        "copy": function(parameters) {

            var srcL = getLayer(parseInt(parameters[0]));
            var srcX = parseInt(parameters[1]);
            var srcY = parseInt(parameters[2]);
            var srcWidth = parseInt(parameters[3]);
            var srcHeight = parseInt(parameters[4]);
            var channelMask = parseInt(parameters[5]);
            var dstL = getLayer(parseInt(parameters[6]));
            var dstX = parseInt(parameters[7]);
            var dstY = parseInt(parameters[8]);

            display.setChannelMask(dstL, channelMask);
            display.copy(srcL, srcX, srcY, srcWidth, srcHeight, 
                         dstL, dstX, dstY);

        },

        "cstroke": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var cap = lineCap[parseInt(parameters[2])];
            var join = lineJoin[parseInt(parameters[3])];
            var thickness = parseInt(parameters[4]);
            var r = parseInt(parameters[5]);
            var g = parseInt(parameters[6]);
            var b = parseInt(parameters[7]);
            var a = parseInt(parameters[8]);

            display.setChannelMask(layer, channelMask);
            display.strokeColor(layer, cap, join, thickness, r, g, b, a);

        },

        "cursor": function(parameters) {

            var cursorHotspotX = parseInt(parameters[0]);
            var cursorHotspotY = parseInt(parameters[1]);
            var srcL = getLayer(parseInt(parameters[2]));
            var srcX = parseInt(parameters[3]);
            var srcY = parseInt(parameters[4]);
            var srcWidth = parseInt(parameters[5]);
            var srcHeight = parseInt(parameters[6]);

            display.setCursor(cursorHotspotX, cursorHotspotY,
                              srcL, srcX, srcY, srcWidth, srcHeight);

        },

        "curve": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var cp1x = parseInt(parameters[1]);
            var cp1y = parseInt(parameters[2]);
            var cp2x = parseInt(parameters[3]);
            var cp2y = parseInt(parameters[4]);
            var x = parseInt(parameters[5]);
            var y = parseInt(parameters[6]);

            display.curveTo(layer, cp1x, cp1y, cp2x, cp2y, x, y);

        },

        "disconnect" : function handleDisconnect(parameters) {

            // Explicitly tear down connection
            guac_client.disconnect();

        },

        "dispose": function(parameters) {
            
            var layer_index = parseInt(parameters[0]);

            // If visible layer, remove from parent
            if (layer_index > 0) {

                // Remove from parent
                var layer = getLayer(layer_index);
                display.dispose(layer);

                // Delete reference
                delete layers[layer_index];

            }

            // If buffer, just delete reference
            else if (layer_index < 0)
                delete layers[layer_index];

            // Attempting to dispose the root layer currently has no effect.

        },

        "distort": function(parameters) {

            var layer_index = parseInt(parameters[0]);
            var a = parseFloat(parameters[1]);
            var b = parseFloat(parameters[2]);
            var c = parseFloat(parameters[3]);
            var d = parseFloat(parameters[4]);
            var e = parseFloat(parameters[5]);
            var f = parseFloat(parameters[6]);

            // Only valid for visible layers (not buffers)
            if (layer_index >= 0) {
                var layer = getLayer(layer_index);
                display.distort(layer, a, b, c, d, e, f);
            }

        },
 
        "error": function(parameters) {

            var reason = parameters[0];
            var code = parseInt(parameters[1]);

            // Call handler if defined
            if (guac_client.onerror)
                guac_client.onerror(new Guacamole.Status(code, reason));

            guac_client.disconnect();

        },

        "end": function(parameters) {

            var stream_index = parseInt(parameters[0]);

            // Get stream
            var stream = streams[stream_index];
            if (stream) {

                // Signal end of stream if handler defined
                if (stream.onend)
                    stream.onend();

                // Invalidate stream
                delete streams[stream_index];

            }

        },

        "file": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var mimetype = parameters[1];
            var filename = parameters[2];

            // Create stream 
            if (guac_client.onfile) {
                var stream = streams[stream_index] = new Guacamole.InputStream(guac_client, stream_index);
                guac_client.onfile(stream, mimetype, filename);
            }

            // Otherwise, unsupported
            else
                guac_client.sendAck(stream_index, "File transfer unsupported", 0x0100);

        },

        "filesystem" : function handleFilesystem(parameters) {

            var objectIndex = parseInt(parameters[0]);
            var name = parameters[1];

            // Create object, if supported
            if (guac_client.onfilesystem) {
                var object = objects[objectIndex] = new Guacamole.Object(guac_client, objectIndex);
                guac_client.onfilesystem(object, name);
            }

            // If unsupported, simply ignore the availability of the filesystem

        },

        "identity": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.setTransform(layer, 1, 0, 0, 1, 0, 0);

        },

        "img": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var channelMask = parseInt(parameters[1]);
            var layer = getLayer(parseInt(parameters[2]));
            var mimetype = parameters[3];
            var x = parseInt(parameters[4]);
            var y = parseInt(parameters[5]);

            // Create stream
            var stream = streams[stream_index] = new Guacamole.InputStream(guac_client, stream_index);

            // Draw received contents once decoded
            display.setChannelMask(layer, channelMask);
            display.drawStream(layer, x, y, stream, mimetype);

        },

        "jpeg": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var x = parseInt(parameters[2]);
            var y = parseInt(parameters[3]);
            var data = parameters[4];

            display.setChannelMask(layer, channelMask);
            display.draw(layer, x, y, "data:image/jpeg;base64," + data);

        },

        "lfill": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var srcLayer = getLayer(parseInt(parameters[2]));

            display.setChannelMask(layer, channelMask);
            display.fillLayer(layer, srcLayer);

        },

        "line": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var x = parseInt(parameters[1]);
            var y = parseInt(parameters[2]);

            display.lineTo(layer, x, y);

        },

        "lstroke": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var srcLayer = getLayer(parseInt(parameters[2]));

            display.setChannelMask(layer, channelMask);
            display.strokeLayer(layer, srcLayer);

        },

        "mouse" : function handleMouse(parameters) {

            var x = parseInt(parameters[0]);
            var y = parseInt(parameters[1]);

            // Display and move software cursor to received coordinates
            display.showCursor(true);
            display.moveCursor(x, y);

        },

        "move": function(parameters) {
            
            var layer_index = parseInt(parameters[0]);
            var parent_index = parseInt(parameters[1]);
            var x = parseInt(parameters[2]);
            var y = parseInt(parameters[3]);
            var z = parseInt(parameters[4]);

            // Only valid for non-default layers
            if (layer_index > 0 && parent_index >= 0) {
                var layer = getLayer(layer_index);
                var parent = getLayer(parent_index);
                display.move(layer, parent, x, y, z);
            }

        },

        "name": function(parameters) {
            if (guac_client.onname) guac_client.onname(parameters[0]);
        },

        "nest": function(parameters) {
            var parser = getParser(parseInt(parameters[0]));
            parser.receive(parameters[1]);
        },

        "pipe": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var mimetype = parameters[1];
            var name = parameters[2];

            // Create stream 
            if (guac_client.onpipe) {
                var stream = streams[stream_index] = new Guacamole.InputStream(guac_client, stream_index);
                guac_client.onpipe(stream, mimetype, name);
            }

            // Otherwise, unsupported
            else
                guac_client.sendAck(stream_index, "Named pipes unsupported", 0x0100);

        },

        "png": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var x = parseInt(parameters[2]);
            var y = parseInt(parameters[3]);
            var data = parameters[4];

            display.setChannelMask(layer, channelMask);
            display.draw(layer, x, y, "data:image/png;base64," + data);

        },

        "pop": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.pop(layer);

        },

        "push": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.push(layer);

        },
 
        "rect": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var x = parseInt(parameters[1]);
            var y = parseInt(parameters[2]);
            var w = parseInt(parameters[3]);
            var h = parseInt(parameters[4]);

            display.rect(layer, x, y, w, h);

        },
                
        "required": function required(parameters) {
            if (guac_client.onrequired) guac_client.onrequired(parameters);
        },
        
        "reset": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.reset(layer);

        },
        
        "set": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var name = parameters[1];
            var value = parameters[2];

            // Call property handler if defined
            var handler = layerPropertyHandlers[name];
            if (handler)
                handler(layer, value);

        },

        "shade": function(parameters) {
            
            var layer_index = parseInt(parameters[0]);
            var a = parseInt(parameters[1]);

            // Only valid for visible layers (not buffers)
            if (layer_index >= 0) {
                var layer = getLayer(layer_index);
                display.shade(layer, a);
            }

        },

        "size": function(parameters) {

            var layer_index = parseInt(parameters[0]);
            var layer = getLayer(layer_index);
            var width = parseInt(parameters[1]);
            var height = parseInt(parameters[2]);

            display.resize(layer, width, height);

        },
        
        "start": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var x = parseInt(parameters[1]);
            var y = parseInt(parameters[2]);

            display.moveTo(layer, x, y);

        },

        "sync": function(parameters) {

            var timestamp = parseInt(parameters[0]);

            // Flush display, send sync when done
            display.flush(function displaySyncComplete() {

                // Synchronize all audio players
                for (var index in audioPlayers) {
                    var audioPlayer = audioPlayers[index];
                    if (audioPlayer)
                        audioPlayer.sync();
                }

                // Send sync response to server
                if (timestamp !== currentTimestamp) {
                    tunnel.sendMessage("sync", timestamp);
                    currentTimestamp = timestamp;
                }

            });

            // If received first update, no longer waiting.
            if (currentState === STATE_WAITING)
                setState(STATE_CONNECTED);

            // Call sync handler if defined
            if (guac_client.onsync)
                guac_client.onsync(timestamp);

        },

        "transfer": function(parameters) {

            var srcL = getLayer(parseInt(parameters[0]));
            var srcX = parseInt(parameters[1]);
            var srcY = parseInt(parameters[2]);
            var srcWidth = parseInt(parameters[3]);
            var srcHeight = parseInt(parameters[4]);
            var function_index = parseInt(parameters[5]);
            var dstL = getLayer(parseInt(parameters[6]));
            var dstX = parseInt(parameters[7]);
            var dstY = parseInt(parameters[8]);

            /* SRC */
            if (function_index === 0x3)
                display.put(srcL, srcX, srcY, srcWidth, srcHeight, 
                    dstL, dstX, dstY);

            /* Anything else that isn't a NO-OP */
            else if (function_index !== 0x5)
                display.transfer(srcL, srcX, srcY, srcWidth, srcHeight, 
                    dstL, dstX, dstY, Guacamole.Client.DefaultTransferFunction[function_index]);

        },

        "transform": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var a = parseFloat(parameters[1]);
            var b = parseFloat(parameters[2]);
            var c = parseFloat(parameters[3]);
            var d = parseFloat(parameters[4]);
            var e = parseFloat(parameters[5]);
            var f = parseFloat(parameters[6]);

            display.transform(layer, a, b, c, d, e, f);

        },

        "undefine" : function handleUndefine(parameters) {

            // Get object
            var objectIndex = parseInt(parameters[0]);
            var object = objects[objectIndex];

            // Signal end of object definition
            if (object && object.onundefine)
                object.onundefine();

        },

        "video": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var mimetype = parameters[2];

            // Create stream
            var stream = streams[stream_index] =
                    new Guacamole.InputStream(guac_client, stream_index);

            // Get player instance via callback
            var videoPlayer = null;
            if (guac_client.onvideo)
                videoPlayer = guac_client.onvideo(stream, layer, mimetype);

            // If unsuccessful, try to use a default implementation
            if (!videoPlayer)
                videoPlayer = Guacamole.VideoPlayer.getInstance(stream, layer, mimetype);

            // If we have successfully retrieved an video player, send success response
            if (videoPlayer) {
                videoPlayers[stream_index] = videoPlayer;
                guac_client.sendAck(stream_index, "OK", 0x0000);
            }

            // Otherwise, mimetype must be unsupported
            else
                guac_client.sendAck(stream_index, "BAD TYPE", 0x030F);

        }

    };

    tunnel.oninstruction = function(opcode, parameters) {

        var handler = instructionHandlers[opcode];
        if (handler)
            handler(parameters);

    };

    /**
     * Sends a disconnect instruction to the server and closes the tunnel.
     */
    this.disconnect = function() {

        // Only attempt disconnection not disconnected.
        if (currentState != STATE_DISCONNECTED
                && currentState != STATE_DISCONNECTING) {

            setState(STATE_DISCONNECTING);

            // Stop ping
            if (pingInterval)
                window.clearInterval(pingInterval);

            // Send disconnect message and disconnect
            tunnel.sendMessage("disconnect");
            tunnel.disconnect();
            setState(STATE_DISCONNECTED);

        }

    };
    
    /**
     * Connects the underlying tunnel of this Guacamole.Client, passing the
     * given arbitrary data to the tunnel during the connection process.
     *
     * @param data Arbitrary connection data to be sent to the underlying
     *             tunnel during the connection process.
     * @throws {Guacamole.Status} If an error occurs during connection.
     */
    this.connect = function(data) {

        setState(STATE_CONNECTING);

        try {
            tunnel.connect(data);
        }
        catch (status) {
            setState(STATE_IDLE);
            throw status;
        }

        // Ping every 5 seconds (ensure connection alive)
        pingInterval = window.setInterval(function() {
            tunnel.sendMessage("nop");
        }, 5000);

        setState(STATE_WAITING);
    };

};

/**
 * Map of all Guacamole binary raster operations to transfer functions.
 * @private
 */
Guacamole.Client.DefaultTransferFunction = {

    /* BLACK */
    0x0: function (src, dst) {
        dst.red = dst.green = dst.blue = 0x00;
    },

    /* WHITE */
    0xF: function (src, dst) {
        dst.red = dst.green = dst.blue = 0xFF;
    },

    /* SRC */
    0x3: function (src, dst) {
        dst.red   = src.red;
        dst.green = src.green;
        dst.blue  = src.blue;
        dst.alpha = src.alpha;
    },

    /* DEST (no-op) */
    0x5: function (src, dst) {
        // Do nothing
    },

    /* Invert SRC */
    0xC: function (src, dst) {
        dst.red   = 0xFF & ~src.red;
        dst.green = 0xFF & ~src.green;
        dst.blue  = 0xFF & ~src.blue;
        dst.alpha =  src.alpha;
    },
    
    /* Invert DEST */
    0xA: function (src, dst) {
        dst.red   = 0xFF & ~dst.red;
        dst.green = 0xFF & ~dst.green;
        dst.blue  = 0xFF & ~dst.blue;
    },

    /* AND */
    0x1: function (src, dst) {
        dst.red   =  ( src.red   &  dst.red);
        dst.green =  ( src.green &  dst.green);
        dst.blue  =  ( src.blue  &  dst.blue);
    },

    /* NAND */
    0xE: function (src, dst) {
        dst.red   = 0xFF & ~( src.red   &  dst.red);
        dst.green = 0xFF & ~( src.green &  dst.green);
        dst.blue  = 0xFF & ~( src.blue  &  dst.blue);
    },

    /* OR */
    0x7: function (src, dst) {
        dst.red   =  ( src.red   |  dst.red);
        dst.green =  ( src.green |  dst.green);
        dst.blue  =  ( src.blue  |  dst.blue);
    },

    /* NOR */
    0x8: function (src, dst) {
        dst.red   = 0xFF & ~( src.red   |  dst.red);
        dst.green = 0xFF & ~( src.green |  dst.green);
        dst.blue  = 0xFF & ~( src.blue  |  dst.blue);
    },

    /* XOR */
    0x6: function (src, dst) {
        dst.red   =  ( src.red   ^  dst.red);
        dst.green =  ( src.green ^  dst.green);
        dst.blue  =  ( src.blue  ^  dst.blue);
    },

    /* XNOR */
    0x9: function (src, dst) {
        dst.red   = 0xFF & ~( src.red   ^  dst.red);
        dst.green = 0xFF & ~( src.green ^  dst.green);
        dst.blue  = 0xFF & ~( src.blue  ^  dst.blue);
    },

    /* AND inverted source */
    0x4: function (src, dst) {
        dst.red   =  0xFF & (~src.red   &  dst.red);
        dst.green =  0xFF & (~src.green &  dst.green);
        dst.blue  =  0xFF & (~src.blue  &  dst.blue);
    },

    /* OR inverted source */
    0xD: function (src, dst) {
        dst.red   =  0xFF & (~src.red   |  dst.red);
        dst.green =  0xFF & (~src.green |  dst.green);
        dst.blue  =  0xFF & (~src.blue  |  dst.blue);
    },

    /* AND inverted destination */
    0x2: function (src, dst) {
        dst.red   =  0xFF & ( src.red   & ~dst.red);
        dst.green =  0xFF & ( src.green & ~dst.green);
        dst.blue  =  0xFF & ( src.blue  & ~dst.blue);
    },

    /* OR inverted destination */
    0xB: function (src, dst) {
        dst.red   =  0xFF & ( src.red   | ~dst.red);
        dst.green =  0xFF & ( src.green | ~dst.green);
        dst.blue  =  0xFF & ( src.blue  | ~dst.blue);
    }

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, returning
 * received blobs as a single data URI built over the course of the stream.
 * Note that this object will overwrite any installed event handlers on the
 * given Guacamole.InputStream.
 * 
 * @constructor
 * @param {Guacamole.InputStream} stream
 *     The stream that data will be read from.
 */
Guacamole.DataURIReader = function(stream, mimetype) {

    /**
     * Reference to this Guacamole.DataURIReader.
     * @private
     */
    var guac_reader = this;

    /**
     * Current data URI.
     *
     * @private
     * @type {String}
     */
    var uri = 'data:' + mimetype + ';base64,';

    // Receive blobs as array buffers
    stream.onblob = function dataURIReaderBlob(data) {

        // Currently assuming data will ALWAYS be safe to simply append. This
        // will not be true if the received base64 data encodes a number of
        // bytes that isn't a multiple of three (as base64 expands in a ratio
        // of exactly 3:4).
        uri += data;

    };

    // Simply call onend when end received
    stream.onend = function dataURIReaderEnd() {
        if (guac_reader.onend)
            guac_reader.onend();
    };

    /**
     * Returns the data URI of all data received through the underlying stream
     * thus far.
     *
     * @returns {String}
     *     The data URI of all data received through the underlying stream thus
     *     far.
     */
    this.getURI = function getURI() {
        return uri;
    };

    /**
     * Fired once this stream is finished and no further data will be written.
     *
     * @event
     */
    this.onend = null;

};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * The Guacamole display. The display does not deal with the Guacamole
 * protocol, and instead implements a set of graphical operations which
 * embody the set of operations present in the protocol. The order operations
 * are executed is guaranteed to be in the same order as their corresponding
 * functions are called.
 * 
 * @constructor
 */
Guacamole.Display = function() {

    /**
     * Reference to this Guacamole.Display.
     * @private
     */
    var guac_display = this;

    var displayWidth = 0;
    var displayHeight = 0;
    var displayScale = 1;

    // Create display
    var display = document.createElement("div");
    display.style.position = "relative";
    display.style.width = displayWidth + "px";
    display.style.height = displayHeight + "px";

    // Ensure transformations on display originate at 0,0
    display.style.transformOrigin =
    display.style.webkitTransformOrigin =
    display.style.MozTransformOrigin =
    display.style.OTransformOrigin =
    display.style.msTransformOrigin =
        "0 0";

    // Create default layer
    var default_layer = new Guacamole.Display.VisibleLayer(displayWidth, displayHeight);

    // Create cursor layer
    var cursor = new Guacamole.Display.VisibleLayer(0, 0);
    cursor.setChannelMask(Guacamole.Layer.SRC);

    // Add default layer and cursor to display
    display.appendChild(default_layer.getElement());
    display.appendChild(cursor.getElement());

    // Create bounding div 
    var bounds = document.createElement("div");
    bounds.style.position = "relative";
    bounds.style.width = (displayWidth*displayScale) + "px";
    bounds.style.height = (displayHeight*displayScale) + "px";

    // Add display to bounds
    bounds.appendChild(display);

    /**
     * The X coordinate of the hotspot of the mouse cursor. The hotspot is
     * the relative location within the image of the mouse cursor at which
     * each click occurs.
     * 
     * @type {Number}
     */
    this.cursorHotspotX = 0;

    /**
     * The Y coordinate of the hotspot of the mouse cursor. The hotspot is
     * the relative location within the image of the mouse cursor at which
     * each click occurs.
     * 
     * @type {Number}
     */
    this.cursorHotspotY = 0;

    /**
     * The current X coordinate of the local mouse cursor. This is not
     * necessarily the location of the actual mouse - it refers only to
     * the location of the cursor image within the Guacamole display, as
     * last set by moveCursor().
     * 
     * @type {Number}
     */
    this.cursorX = 0;

    /**
     * The current X coordinate of the local mouse cursor. This is not
     * necessarily the location of the actual mouse - it refers only to
     * the location of the cursor image within the Guacamole display, as
     * last set by moveCursor().
     * 
     * @type {Number}
     */
    this.cursorY = 0;

    /**
     * Fired when the default layer (and thus the entire Guacamole display)
     * is resized.
     * 
     * @event
     * @param {Number} width The new width of the Guacamole display.
     * @param {Number} height The new height of the Guacamole display.
     */
    this.onresize = null;

    /**
     * Fired whenever the local cursor image is changed. This can be used to
     * implement special handling of the client-side cursor, or to override
     * the default use of a software cursor layer.
     * 
     * @event
     * @param {HTMLCanvasElement} canvas The cursor image.
     * @param {Number} x The X-coordinate of the cursor hotspot.
     * @param {Number} y The Y-coordinate of the cursor hotspot.
     */
    this.oncursor = null;

    /**
     * The queue of all pending Tasks. Tasks will be run in order, with new
     * tasks added at the end of the queue and old tasks removed from the
     * front of the queue (FIFO). These tasks will eventually be grouped
     * into a Frame.
     * @private
     * @type {Task[]}
     */
    var tasks = [];

    /**
     * The queue of all frames. Each frame is a pairing of an array of tasks
     * and a callback which must be called when the frame is rendered.
     * @private
     * @type {Frame[]}
     */
    var frames = [];

    /**
     * Flushes all pending frames.
     * @private
     */
    function __flush_frames() {

        var rendered_frames = 0;

        // Draw all pending frames, if ready
        while (rendered_frames < frames.length) {

            var frame = frames[rendered_frames];
            if (!frame.isReady())
                break;

            frame.flush();
            rendered_frames++;

        } 

        // Remove rendered frames from array
        frames.splice(0, rendered_frames);

    }

    /**
     * An ordered list of tasks which must be executed atomically. Once
     * executed, an associated (and optional) callback will be called.
     *
     * @private
     * @constructor
     * @param {function} callback The function to call when this frame is
     *                            rendered.
     * @param {Task[]} tasks The set of tasks which must be executed to render
     *                       this frame.
     */
    function Frame(callback, tasks) {

        /**
         * Returns whether this frame is ready to be rendered. This function
         * returns true if and only if ALL underlying tasks are unblocked.
         * 
         * @returns {Boolean} true if all underlying tasks are unblocked,
         *                    false otherwise.
         */
        this.isReady = function() {

            // Search for blocked tasks
            for (var i=0; i < tasks.length; i++) {
                if (tasks[i].blocked)
                    return false;
            }

            // If no blocked tasks, the frame is ready
            return true;

        };

        /**
         * Renders this frame, calling the associated callback, if any, after
         * the frame is complete. This function MUST only be called when no
         * blocked tasks exist. Calling this function with blocked tasks
         * will result in undefined behavior.
         */
        this.flush = function() {

            // Draw all pending tasks.
            for (var i=0; i < tasks.length; i++)
                tasks[i].execute();

            // Call callback
            if (callback) callback();

        };

    }

    /**
     * A container for an task handler. Each operation which must be ordered
     * is associated with a Task that goes into a task queue. Tasks in this
     * queue are executed in order once their handlers are set, while Tasks 
     * without handlers block themselves and any following Tasks from running.
     *
     * @constructor
     * @private
     * @param {function} taskHandler The function to call when this task 
     *                               runs, if any.
     * @param {boolean} blocked Whether this task should start blocked.
     */
    function Task(taskHandler, blocked) {
       
        var task = this;
       
        /**
         * Whether this Task is blocked.
         * 
         * @type {boolean}
         */
        this.blocked = blocked;

        /**
         * Unblocks this Task, allowing it to run.
         */
        this.unblock = function() {
            if (task.blocked) {
                task.blocked = false;
                __flush_frames();
            }
        };

        /**
         * Calls the handler associated with this task IMMEDIATELY. This
         * function does not track whether this task is marked as blocked.
         * Enforcing the blocked status of tasks is up to the caller.
         */
        this.execute = function() {
            if (taskHandler) taskHandler();
        };

    }

    /**
     * Schedules a task for future execution. The given handler will execute
     * immediately after all previous tasks upon frame flush, unless this
     * task is blocked. If any tasks is blocked, the entire frame will not
     * render (and no tasks within will execute) until all tasks are unblocked.
     * 
     * @private
     * @param {function} handler The function to call when possible, if any.
     * @param {boolean} blocked Whether the task should start blocked.
     * @returns {Task} The Task created and added to the queue for future
     *                 running.
     */
    function scheduleTask(handler, blocked) {
        var task = new Task(handler, blocked);
        tasks.push(task);
        return task;
    }

    /**
     * Returns the element which contains the Guacamole display.
     * 
     * @return {Element} The element containing the Guacamole display.
     */
    this.getElement = function() {
        return bounds;
    };

    /**
     * Returns the width of this display.
     * 
     * @return {Number} The width of this display;
     */
    this.getWidth = function() {
        return displayWidth;
    };

    /**
     * Returns the height of this display.
     * 
     * @return {Number} The height of this display;
     */
    this.getHeight = function() {
        return displayHeight;
    };

    /**
     * Returns the default layer of this display. Each Guacamole display always
     * has at least one layer. Other layers can optionally be created within
     * this layer, but the default layer cannot be removed and is the absolute
     * ancestor of all other layers.
     * 
     * @return {Guacamole.Display.VisibleLayer} The default layer.
     */
    this.getDefaultLayer = function() {
        return default_layer;
    };

    /**
     * Returns the cursor layer of this display. Each Guacamole display contains
     * a layer for the image of the mouse cursor. This layer is a special case
     * and exists above all other layers, similar to the hardware mouse cursor.
     * 
     * @return {Guacamole.Display.VisibleLayer} The cursor layer.
     */
    this.getCursorLayer = function() {
        return cursor;
    };

    /**
     * Creates a new layer. The new layer will be a direct child of the default
     * layer, but can be moved to be a child of any other layer. Layers returned
     * by this function are visible.
     * 
     * @return {Guacamole.Display.VisibleLayer} The newly-created layer.
     */
    this.createLayer = function() {
        var layer = new Guacamole.Display.VisibleLayer(displayWidth, displayHeight);
        layer.move(default_layer, 0, 0, 0);
        return layer;
    };

    /**
     * Creates a new buffer. Buffers are invisible, off-screen surfaces. They
     * are implemented in the same manner as layers, but do not provide the
     * same nesting semantics.
     * 
     * @return {Guacamole.Layer} The newly-created buffer.
     */
    this.createBuffer = function() {
        var buffer = new Guacamole.Layer(0, 0);
        buffer.autosize = 1;
        return buffer;
    };

    /**
     * Flush all pending draw tasks, if possible, as a new frame. If the entire
     * frame is not ready, the flush will wait until all required tasks are
     * unblocked.
     * 
     * @param {function} callback The function to call when this frame is
     *                            flushed. This may happen immediately, or
     *                            later when blocked tasks become unblocked.
     */
    this.flush = function(callback) {

        // Add frame, reset tasks
        frames.push(new Frame(callback, tasks));
        tasks = [];

        // Attempt flush
        __flush_frames();

    };

    /**
     * Sets the hotspot and image of the mouse cursor displayed within the
     * Guacamole display.
     * 
     * @param {Number} hotspotX The X coordinate of the cursor hotspot.
     * @param {Number} hotspotY The Y coordinate of the cursor hotspot.
     * @param {Guacamole.Layer} layer The source layer containing the data which
     *                                should be used as the mouse cursor image.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      layer's coordinate space to copy data from.

     */
    this.setCursor = function(hotspotX, hotspotY, layer, srcx, srcy, srcw, srch) {
        scheduleTask(function __display_set_cursor() {

            // Set hotspot
            guac_display.cursorHotspotX = hotspotX;
            guac_display.cursorHotspotY = hotspotY;

            // Reset cursor size
            cursor.resize(srcw, srch);

            // Draw cursor to cursor layer
            cursor.copy(layer, srcx, srcy, srcw, srch, 0, 0);
            guac_display.moveCursor(guac_display.cursorX, guac_display.cursorY);

            // Fire cursor change event
            if (guac_display.oncursor)
                guac_display.oncursor(cursor.toCanvas(), hotspotX, hotspotY);

        });
    };

    /**
     * Sets whether the software-rendered cursor is shown. This cursor differs
     * from the hardware cursor in that it is built into the Guacamole.Display,
     * and relies on its own Guacamole layer to render.
     *
     * @param {Boolean} [shown=true] Whether to show the software cursor.
     */
    this.showCursor = function(shown) {

        var element = cursor.getElement();
        var parent = element.parentNode;

        // Remove from DOM if hidden
        if (shown === false) {
            if (parent)
                parent.removeChild(element);
        }

        // Otherwise, ensure cursor is child of display
        else if (parent !== display)
            display.appendChild(element);

    };

    /**
     * Sets the location of the local cursor to the given coordinates. For the
     * sake of responsiveness, this function performs its action immediately.
     * Cursor motion is not maintained within atomic frames.
     * 
     * @param {Number} x The X coordinate to move the cursor to.
     * @param {Number} y The Y coordinate to move the cursor to.
     */
    this.moveCursor = function(x, y) {

        // Move cursor layer
        cursor.translate(x - guac_display.cursorHotspotX,
                         y - guac_display.cursorHotspotY);

        // Update stored position
        guac_display.cursorX = x;
        guac_display.cursorY = y;

    };

    /**
     * Changes the size of the given Layer to the given width and height.
     * Resizing is only attempted if the new size provided is actually different
     * from the current size.
     * 
     * @param {Guacamole.Layer} layer The layer to resize.
     * @param {Number} width The new width.
     * @param {Number} height The new height.
     */
    this.resize = function(layer, width, height) {
        scheduleTask(function __display_resize() {

            layer.resize(width, height);

            // Resize display if default layer is resized
            if (layer === default_layer) {

                // Update (set) display size
                displayWidth = width;
                displayHeight = height;
                display.style.width = displayWidth + "px";
                display.style.height = displayHeight + "px";

                // Update bounds size
                bounds.style.width = (displayWidth*displayScale) + "px";
                bounds.style.height = (displayHeight*displayScale) + "px";

                // Notify of resize
                if (guac_display.onresize)
                    guac_display.onresize(width, height);

            }

        });
    };

    /**
     * Draws the specified image at the given coordinates. The image specified
     * must already be loaded.
     * 
     * @param {Guacamole.Layer} layer
     *     The layer to draw upon.
     *
     * @param {Number} x
     *     The destination X coordinate.
     *
     * @param {Number} y 
     *     The destination Y coordinate.
     *
     * @param {CanvasImageSource} image
     *     The image to draw. Note that this not a URL.
     */
    this.drawImage = function(layer, x, y, image) {
        scheduleTask(function __display_drawImage() {
            layer.drawImage(x, y, image);
        });
    };

    /**
     * Draws the image contained within the specified Blob at the given
     * coordinates. The Blob specified must already be populated with image
     * data.
     *
     * @param {Guacamole.Layer} layer
     *     The layer to draw upon.
     *
     * @param {Number} x
     *     The destination X coordinate.
     *
     * @param {Number} y
     *     The destination Y coordinate.
     *
     * @param {Blob} blob
     *     The Blob containing the image data to draw.
     */
    this.drawBlob = function(layer, x, y, blob) {

        var task;

        // Prefer createImageBitmap() over blob URLs if available
        if (window.createImageBitmap) {

            var bitmap;

            // Draw image once loaded
            task = scheduleTask(function drawImageBitmap() {
                layer.drawImage(x, y, bitmap);
            }, true);

            // Load image from provided blob
            window.createImageBitmap(blob).then(function bitmapLoaded(decoded) {
                bitmap = decoded;
                task.unblock();
            });

        }

        // Use blob URLs and the Image object if createImageBitmap() is
        // unavailable
        else {

            // Create URL for blob
            var url = URL.createObjectURL(blob);

            // Draw and free blob URL when ready
            task = scheduleTask(function __display_drawBlob() {

                // Draw the image only if it loaded without errors
                if (image.width && image.height)
                    layer.drawImage(x, y, image);

                // Blob URL no longer needed
                URL.revokeObjectURL(url);

            }, true);

            // Load image from URL
            var image = new Image();
            image.onload = task.unblock;
            image.onerror = task.unblock;
            image.src = url;

        }

    };

    /**
     * Draws the image within the given stream at the given coordinates. The
     * image will be loaded automatically, and this and any future operations
     * will wait for the image to finish loading. This function will
     * automatically choose an approriate method for reading and decoding the
     * given image stream, and should be preferred for received streams except
     * where manual decoding of the stream is unavoidable.
     *
     * @param {Guacamole.Layer} layer
     *     The layer to draw upon.
     *
     * @param {Number} x
     *     The destination X coordinate.
     *
     * @param {Number} y
     *     The destination Y coordinate.
     *
     * @param {Guacamole.InputStream} stream
     *     The stream along which image data will be received.
     *
     * @param {String} mimetype
     *     The mimetype of the image within the stream.
     */
    this.drawStream = function drawStream(layer, x, y, stream, mimetype) {

        // If createImageBitmap() is available, load the image as a blob so
        // that function can be used
        if (window.createImageBitmap) {
            var reader = new Guacamole.BlobReader(stream, mimetype);
            reader.onend = function drawImageBlob() {
                guac_display.drawBlob(layer, x, y, reader.getBlob());
            };
        }

        // Lacking createImageBitmap(), fall back to data URIs and the Image
        // object
        else {
            var reader = new Guacamole.DataURIReader(stream, mimetype);
            reader.onend = function drawImageDataURI() {
                guac_display.draw(layer, x, y, reader.getURI());
            };
        }

    };

    /**
     * Draws the image at the specified URL at the given coordinates. The image
     * will be loaded automatically, and this and any future operations will
     * wait for the image to finish loading.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     * @param {String} url The URL of the image to draw.
     */
    this.draw = function(layer, x, y, url) {

        var task = scheduleTask(function __display_draw() {

            // Draw the image only if it loaded without errors
            if (image.width && image.height)
                layer.drawImage(x, y, image);

        }, true);

        var image = new Image();
        image.onload = task.unblock;
        image.onerror = task.unblock;
        image.src = url;

    };

    /**
     * Plays the video at the specified URL within this layer. The video
     * will be loaded automatically, and this and any future operations will
     * wait for the video to finish loading. Future operations will not be
     * executed until the video finishes playing.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {String} mimetype The mimetype of the video to play.
     * @param {Number} duration The duration of the video in milliseconds.
     * @param {String} url The URL of the video to play.
     */
    this.play = function(layer, mimetype, duration, url) {

        // Start loading the video
        var video = document.createElement("video");
        video.type = mimetype;
        video.src = url;

        // Start copying frames when playing
        video.addEventListener("play", function() {
            
            function render_callback() {
                layer.drawImage(0, 0, video);
                if (!video.ended)
                    window.setTimeout(render_callback, 20);
            }
            
            render_callback();
            
        }, false);

        scheduleTask(video.play);

    };

    /**
     * Transfer a rectangle of image data from one Layer to this Layer using the
     * specified transfer function.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Guacamole.Layer} dstLayer The layer to draw upon.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     * @param {Function} transferFunction The transfer function to use to
     *                                    transfer data from source to
     *                                    destination.
     */
    this.transfer = function(srcLayer, srcx, srcy, srcw, srch, dstLayer, x, y, transferFunction) {
        scheduleTask(function __display_transfer() {
            dstLayer.transfer(srcLayer, srcx, srcy, srcw, srch, x, y, transferFunction);
        });
    };

    /**
     * Put a rectangle of image data from one Layer to this Layer directly
     * without performing any alpha blending. Simply copy the data.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Guacamole.Layer} dstLayer The layer to draw upon.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     */
    this.put = function(srcLayer, srcx, srcy, srcw, srch, dstLayer, x, y) {
        scheduleTask(function __display_put() {
            dstLayer.put(srcLayer, srcx, srcy, srcw, srch, x, y);
        });
    };

    /**
     * Copy a rectangle of image data from one Layer to this Layer. This
     * operation will copy exactly the image data that will be drawn once all
     * operations of the source Layer that were pending at the time this
     * function was called are complete. This operation will not alter the
     * size of the source Layer even if its autosize property is set to true.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Guacamole.Layer} dstLayer The layer to draw upon.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     */
    this.copy = function(srcLayer, srcx, srcy, srcw, srch, dstLayer, x, y) {
        scheduleTask(function __display_copy() {
            dstLayer.copy(srcLayer, srcx, srcy, srcw, srch, x, y);
        });
    };

    /**
     * Starts a new path at the specified point.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} x The X coordinate of the point to draw.
     * @param {Number} y The Y coordinate of the point to draw.
     */
    this.moveTo = function(layer, x, y) {
        scheduleTask(function __display_moveTo() {
            layer.moveTo(x, y);
        });
    };

    /**
     * Add the specified line to the current path.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} x The X coordinate of the endpoint of the line to draw.
     * @param {Number} y The Y coordinate of the endpoint of the line to draw.
     */
    this.lineTo = function(layer, x, y) {
        scheduleTask(function __display_lineTo() {
            layer.lineTo(x, y);
        });
    };

    /**
     * Add the specified arc to the current path.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} x The X coordinate of the center of the circle which
     *                   will contain the arc.
     * @param {Number} y The Y coordinate of the center of the circle which
     *                   will contain the arc.
     * @param {Number} radius The radius of the circle.
     * @param {Number} startAngle The starting angle of the arc, in radians.
     * @param {Number} endAngle The ending angle of the arc, in radians.
     * @param {Boolean} negative Whether the arc should be drawn in order of
     *                           decreasing angle.
     */
    this.arc = function(layer, x, y, radius, startAngle, endAngle, negative) {
        scheduleTask(function __display_arc() {
            layer.arc(x, y, radius, startAngle, endAngle, negative);
        });
    };

    /**
     * Starts a new path at the specified point.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} cp1x The X coordinate of the first control point.
     * @param {Number} cp1y The Y coordinate of the first control point.
     * @param {Number} cp2x The X coordinate of the second control point.
     * @param {Number} cp2y The Y coordinate of the second control point.
     * @param {Number} x The X coordinate of the endpoint of the curve.
     * @param {Number} y The Y coordinate of the endpoint of the curve.
     */
    this.curveTo = function(layer, cp1x, cp1y, cp2x, cp2y, x, y) {
        scheduleTask(function __display_curveTo() {
            layer.curveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        });
    };

    /**
     * Closes the current path by connecting the end point with the start
     * point (if any) with a straight line.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     */
    this.close = function(layer) {
        scheduleTask(function __display_close() {
            layer.close();
        });
    };

    /**
     * Add the specified rectangle to the current path.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} x The X coordinate of the upper-left corner of the
     *                   rectangle to draw.
     * @param {Number} y The Y coordinate of the upper-left corner of the
     *                   rectangle to draw.
     * @param {Number} w The width of the rectangle to draw.
     * @param {Number} h The height of the rectangle to draw.
     */
    this.rect = function(layer, x, y, w, h) {
        scheduleTask(function __display_rect() {
            layer.rect(x, y, w, h);
        });
    };

    /**
     * Clip all future drawing operations by the current path. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as fillColor()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} layer The layer to affect.
     */
    this.clip = function(layer) {
        scheduleTask(function __display_clip() {
            layer.clip();
        });
    };

    /**
     * Stroke the current path with the specified color. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {String} cap The line cap style. Can be "round", "square",
     *                     or "butt".
     * @param {String} join The line join style. Can be "round", "bevel",
     *                      or "miter".
     * @param {Number} thickness The line thickness in pixels.
     * @param {Number} r The red component of the color to fill.
     * @param {Number} g The green component of the color to fill.
     * @param {Number} b The blue component of the color to fill.
     * @param {Number} a The alpha component of the color to fill.
     */
    this.strokeColor = function(layer, cap, join, thickness, r, g, b, a) {
        scheduleTask(function __display_strokeColor() {
            layer.strokeColor(cap, join, thickness, r, g, b, a);
        });
    };

    /**
     * Fills the current path with the specified color. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} r The red component of the color to fill.
     * @param {Number} g The green component of the color to fill.
     * @param {Number} b The blue component of the color to fill.
     * @param {Number} a The alpha component of the color to fill.
     */
    this.fillColor = function(layer, r, g, b, a) {
        scheduleTask(function __display_fillColor() {
            layer.fillColor(r, g, b, a);
        });
    };

    /**
     * Stroke the current path with the image within the specified layer. The
     * image data will be tiled infinitely within the stroke. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {String} cap The line cap style. Can be "round", "square",
     *                     or "butt".
     * @param {String} join The line join style. Can be "round", "bevel",
     *                      or "miter".
     * @param {Number} thickness The line thickness in pixels.
     * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
     *                                   within the stroke.
     */
    this.strokeLayer = function(layer, cap, join, thickness, srcLayer) {
        scheduleTask(function __display_strokeLayer() {
            layer.strokeLayer(cap, join, thickness, srcLayer);
        });
    };

    /**
     * Fills the current path with the image within the specified layer. The
     * image data will be tiled infinitely within the stroke. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
     *                                   within the fill.
     */
    this.fillLayer = function(layer, srcLayer) {
        scheduleTask(function __display_fillLayer() {
            layer.fillLayer(srcLayer);
        });
    };

    /**
     * Push current layer state onto stack.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     */
    this.push = function(layer) {
        scheduleTask(function __display_push() {
            layer.push();
        });
    };

    /**
     * Pop layer state off stack.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     */
    this.pop = function(layer) {
        scheduleTask(function __display_pop() {
            layer.pop();
        });
    };

    /**
     * Reset the layer, clearing the stack, the current path, and any transform
     * matrix.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     */
    this.reset = function(layer) {
        scheduleTask(function __display_reset() {
            layer.reset();
        });
    };

    /**
     * Sets the given affine transform (defined with six values from the
     * transform's matrix).
     * 
     * @param {Guacamole.Layer} layer The layer to modify.
     * @param {Number} a The first value in the affine transform's matrix.
     * @param {Number} b The second value in the affine transform's matrix.
     * @param {Number} c The third value in the affine transform's matrix.
     * @param {Number} d The fourth value in the affine transform's matrix.
     * @param {Number} e The fifth value in the affine transform's matrix.
     * @param {Number} f The sixth value in the affine transform's matrix.
     */
    this.setTransform = function(layer, a, b, c, d, e, f) {
        scheduleTask(function __display_setTransform() {
            layer.setTransform(a, b, c, d, e, f);
        });
    };

    /**
     * Applies the given affine transform (defined with six values from the
     * transform's matrix).
     * 
     * @param {Guacamole.Layer} layer The layer to modify.
     * @param {Number} a The first value in the affine transform's matrix.
     * @param {Number} b The second value in the affine transform's matrix.
     * @param {Number} c The third value in the affine transform's matrix.
     * @param {Number} d The fourth value in the affine transform's matrix.
     * @param {Number} e The fifth value in the affine transform's matrix.
     * @param {Number} f The sixth value in the affine transform's matrix.
     */
    this.transform = function(layer, a, b, c, d, e, f) {
        scheduleTask(function __display_transform() {
            layer.transform(a, b, c, d, e, f);
        });
    };

    /**
     * Sets the channel mask for future operations on this Layer.
     * 
     * The channel mask is a Guacamole-specific compositing operation identifier
     * with a single bit representing each of four channels (in order): source
     * image where destination transparent, source where destination opaque,
     * destination where source transparent, and destination where source
     * opaque.
     * 
     * @param {Guacamole.Layer} layer The layer to modify.
     * @param {Number} mask The channel mask for future operations on this
     *                      Layer.
     */
    this.setChannelMask = function(layer, mask) {
        scheduleTask(function __display_setChannelMask() {
            layer.setChannelMask(mask);
        });
    };

    /**
     * Sets the miter limit for stroke operations using the miter join. This
     * limit is the maximum ratio of the size of the miter join to the stroke
     * width. If this ratio is exceeded, the miter will not be drawn for that
     * joint of the path.
     * 
     * @param {Guacamole.Layer} layer The layer to modify.
     * @param {Number} limit The miter limit for stroke operations using the
     *                       miter join.
     */
    this.setMiterLimit = function(layer, limit) {
        scheduleTask(function __display_setMiterLimit() {
            layer.setMiterLimit(limit);
        });
    };

    /**
     * Removes the given layer container entirely, such that it is no longer
     * contained within its parent layer, if any.
     *
     * @param {Guacamole.Display.VisibleLayer} layer
     *     The layer being removed from its parent.
     */
    this.dispose = function dispose(layer) {
        scheduleTask(function disposeLayer() {
            layer.dispose();
        });
    };

    /**
     * Applies the given affine transform (defined with six values from the
     * transform's matrix) to the given layer.
     *
     * @param {Guacamole.Display.VisibleLayer} layer
     *     The layer being distorted.
     *
     * @param {Number} a
     *     The first value in the affine transform's matrix.
     *
     * @param {Number} b
     *     The second value in the affine transform's matrix.
     *
     * @param {Number} c
     *     The third value in the affine transform's matrix.
     *
     * @param {Number} d
     *     The fourth value in the affine transform's matrix.
     *
     * @param {Number} e
     *     The fifth value in the affine transform's matrix.
     *
     * @param {Number} f
     *     The sixth value in the affine transform's matrix.
     */
    this.distort = function distort(layer, a, b, c, d, e, f) {
        scheduleTask(function distortLayer() {
            layer.distort(a, b, c, d, e, f);
        });
    };

    /**
     * Moves the upper-left corner of the given layer to the given X and Y
     * coordinate, sets the Z stacking order, and reparents the layer
     * to the given parent layer.
     *
     * @param {Guacamole.Display.VisibleLayer} layer
     *     The layer being moved.
     *
     * @param {Guacamole.Display.VisibleLayer} parent
     *     The parent to set.
     *
     * @param {Number} x
     *     The X coordinate to move to.
     *
     * @param {Number} y
     *     The Y coordinate to move to.
     *
     * @param {Number} z
     *     The Z coordinate to move to.
     */
    this.move = function move(layer, parent, x, y, z) {
        scheduleTask(function moveLayer() {
            layer.move(parent, x, y, z);
        });
    };

    /**
     * Sets the opacity of the given layer to the given value, where 255 is
     * fully opaque and 0 is fully transparent.
     *
     * @param {Guacamole.Display.VisibleLayer} layer
     *     The layer whose opacity should be set.
     *
     * @param {Number} alpha
     *     The opacity to set.
     */
    this.shade = function shade(layer, alpha) {
        scheduleTask(function shadeLayer() {
            layer.shade(alpha);
        });
    };

    /**
     * Sets the scale of the client display element such that it renders at
     * a relatively smaller or larger size, without affecting the true
     * resolution of the display.
     *
     * @param {Number} scale The scale to resize to, where 1.0 is normal
     *                       size (1:1 scale).
     */
    this.scale = function(scale) {

        display.style.transform =
        display.style.WebkitTransform =
        display.style.MozTransform =
        display.style.OTransform =
        display.style.msTransform =

            "scale(" + scale + "," + scale + ")";

        displayScale = scale;

        // Update bounds size
        bounds.style.width = (displayWidth*displayScale) + "px";
        bounds.style.height = (displayHeight*displayScale) + "px";

    };

    /**
     * Returns the scale of the display.
     *
     * @return {Number} The scale of the display.
     */
    this.getScale = function() {
        return displayScale;
    };

    /**
     * Returns a canvas element containing the entire display, with all child
     * layers composited within.
     *
     * @return {HTMLCanvasElement} A new canvas element containing a copy of
     *                             the display.
     */
    this.flatten = function() {
       
        // Get destination canvas
        var canvas = document.createElement("canvas");
        canvas.width = default_layer.width;
        canvas.height = default_layer.height;

        var context = canvas.getContext("2d");

        // Returns sorted array of children
        function get_children(layer) {

            // Build array of children
            var children = [];
            for (var index in layer.children)
                children.push(layer.children[index]);

            // Sort
            children.sort(function children_comparator(a, b) {

                // Compare based on Z order
                var diff = a.z - b.z;
                if (diff !== 0)
                    return diff;

                // If Z order identical, use document order
                var a_element = a.getElement();
                var b_element = b.getElement();
                var position = b_element.compareDocumentPosition(a_element);

                if (position & Node.DOCUMENT_POSITION_PRECEDING) return -1;
                if (position & Node.DOCUMENT_POSITION_FOLLOWING) return  1;

                // Otherwise, assume same
                return 0;

            });

            // Done
            return children;

        }

        // Draws the contents of the given layer at the given coordinates
        function draw_layer(layer, x, y) {

            // Draw layer
            if (layer.width > 0 && layer.height > 0) {

                // Save and update alpha
                var initial_alpha = context.globalAlpha;
                context.globalAlpha *= layer.alpha / 255.0;

                // Copy data
                context.drawImage(layer.getCanvas(), x, y);

                // Draw all children
                var children = get_children(layer);
                for (var i=0; i<children.length; i++) {
                    var child = children[i];
                    draw_layer(child, x + child.x, y + child.y);
                }

                // Restore alpha
                context.globalAlpha = initial_alpha;

            }

        }

        // Draw default layer and all children
        draw_layer(default_layer, 0, 0);

        // Return new canvas copy
        return canvas;
        
    };

};

/**
 * Simple container for Guacamole.Layer, allowing layers to be easily
 * repositioned and nested. This allows certain operations to be accelerated
 * through DOM manipulation, rather than raster operations.
 * 
 * @constructor
 * @augments Guacamole.Layer
 * @param {Number} width The width of the Layer, in pixels. The canvas element
 *                       backing this Layer will be given this width.
 * @param {Number} height The height of the Layer, in pixels. The canvas element
 *                        backing this Layer will be given this height.
 */
Guacamole.Display.VisibleLayer = function(width, height) {

    Guacamole.Layer.apply(this, [width, height]);

    /**
     * Reference to this layer.
     * @private
     */
    var layer = this;

    /**
     * Identifier which uniquely identifies this layer. This is COMPLETELY
     * UNRELATED to the index of the underlying layer, which is specific
     * to the Guacamole protocol, and not relevant at this level.
     * 
     * @private
     * @type {Number}
     */
    this.__unique_id = Guacamole.Display.VisibleLayer.__next_id++;

    /**
     * The opacity of the layer container, where 255 is fully opaque and 0 is
     * fully transparent.
     */
    this.alpha = 0xFF;

    /**
     * X coordinate of the upper-left corner of this layer container within
     * its parent, in pixels.
     * @type {Number}
     */
    this.x = 0;

    /**
     * Y coordinate of the upper-left corner of this layer container within
     * its parent, in pixels.
     * @type {Number}
     */
    this.y = 0;

    /**
     * Z stacking order of this layer relative to other sibling layers.
     * @type {Number}
     */
    this.z = 0;

    /**
     * The affine transformation applied to this layer container. Each element
     * corresponds to a value from the transformation matrix, with the first
     * three values being the first row, and the last three values being the
     * second row. There are six values total.
     * 
     * @type {Number[]}
     */
    this.matrix = [1, 0, 0, 1, 0, 0];

    /**
     * The parent layer container of this layer, if any.
     * @type {Guacamole.Display.VisibleLayer}
     */
    this.parent = null;

    /**
     * Set of all children of this layer, indexed by layer index. This object
     * will have one property per child.
     */
    this.children = {};

    // Set layer position
    var canvas = layer.getCanvas();
    canvas.style.position = "absolute";
    canvas.style.left = "0px";
    canvas.style.top = "0px";

    // Create div with given size
    var div = document.createElement("div");
    div.appendChild(canvas);
    div.style.width = width + "px";
    div.style.height = height + "px";
    div.style.position = "absolute";
    div.style.left = "0px";
    div.style.top = "0px";
    div.style.overflow = "hidden";

    /**
     * Superclass resize() function.
     * @private
     */
    var __super_resize = this.resize;

    this.resize = function(width, height) {

        // Resize containing div
        div.style.width = width + "px";
        div.style.height = height + "px";

        __super_resize(width, height);

    };
  
    /**
     * Returns the element containing the canvas and any other elements
     * associated with this layer.
     * @returns {Element} The element containing this layer's canvas.
     */
    this.getElement = function() {
        return div;
    };

    /**
     * The translation component of this layer's transform.
     * @private
     */
    var translate = "translate(0px, 0px)"; // (0, 0)

    /**
     * The arbitrary matrix component of this layer's transform.
     * @private
     */
    var matrix = "matrix(1, 0, 0, 1, 0, 0)"; // Identity

    /**
     * Moves the upper-left corner of this layer to the given X and Y
     * coordinate.
     * 
     * @param {Number} x The X coordinate to move to.
     * @param {Number} y The Y coordinate to move to.
     */
    this.translate = function(x, y) {

        layer.x = x;
        layer.y = y;

        // Generate translation
        translate = "translate("
                        + x + "px,"
                        + y + "px)";

        // Set layer transform 
        div.style.transform =
        div.style.WebkitTransform =
        div.style.MozTransform =
        div.style.OTransform =
        div.style.msTransform =

            translate + " " + matrix;

    };

    /**
     * Moves the upper-left corner of this VisibleLayer to the given X and Y
     * coordinate, sets the Z stacking order, and reparents this VisibleLayer
     * to the given VisibleLayer.
     * 
     * @param {Guacamole.Display.VisibleLayer} parent The parent to set.
     * @param {Number} x The X coordinate to move to.
     * @param {Number} y The Y coordinate to move to.
     * @param {Number} z The Z coordinate to move to.
     */
    this.move = function(parent, x, y, z) {

        // Set parent if necessary
        if (layer.parent !== parent) {

            // Maintain relationship
            if (layer.parent)
                delete layer.parent.children[layer.__unique_id];
            layer.parent = parent;
            parent.children[layer.__unique_id] = layer;

            // Reparent element
            var parent_element = parent.getElement();
            parent_element.appendChild(div);

        }

        // Set location
        layer.translate(x, y);
        layer.z = z;
        div.style.zIndex = z;

    };

    /**
     * Sets the opacity of this layer to the given value, where 255 is fully
     * opaque and 0 is fully transparent.
     * 
     * @param {Number} a The opacity to set.
     */
    this.shade = function(a) {
        layer.alpha = a;
        div.style.opacity = a/255.0;
    };

    /**
     * Removes this layer container entirely, such that it is no longer
     * contained within its parent layer, if any.
     */
    this.dispose = function() {

        // Remove from parent container
        if (layer.parent) {
            delete layer.parent.children[layer.__unique_id];
            layer.parent = null;
        }

        // Remove from parent element
        if (div.parentNode)
            div.parentNode.removeChild(div);
        
    };

    /**
     * Applies the given affine transform (defined with six values from the
     * transform's matrix).
     * 
     * @param {Number} a The first value in the affine transform's matrix.
     * @param {Number} b The second value in the affine transform's matrix.
     * @param {Number} c The third value in the affine transform's matrix.
     * @param {Number} d The fourth value in the affine transform's matrix.
     * @param {Number} e The fifth value in the affine transform's matrix.
     * @param {Number} f The sixth value in the affine transform's matrix.
     */
    this.distort = function(a, b, c, d, e, f) {

        // Store matrix
        layer.matrix = [a, b, c, d, e, f];

        // Generate matrix transformation
        matrix =

            /* a c e
             * b d f
             * 0 0 1
             */
    
            "matrix(" + a + "," + b + "," + c + "," + d + "," + e + "," + f + ")";

        // Set layer transform 
        div.style.transform =
        div.style.WebkitTransform =
        div.style.MozTransform =
        div.style.OTransform =
        div.style.msTransform =

            translate + " " + matrix;

    };

};

/**
 * The next identifier to be assigned to the layer container. This identifier
 * uniquely identifies each VisibleLayer, but is unrelated to the index of
 * the layer, which exists at the protocol/client level only.
 * 
 * @private
 * @type {Number}
 */
Guacamole.Display.VisibleLayer.__next_id = 0;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A hidden input field which attempts to keep itself focused at all times,
 * except when another input field has been intentionally focused, whether
 * programatically or by the user. The actual underlying input field, returned
 * by getElement(), may be used as a reliable source of keyboard-related events,
 * particularly composition and input events which may require a focused input
 * field to be dispatched at all.
 *
 * @constructor
 */
Guacamole.InputSink = function InputSink() {

    /**
     * Reference to this instance of Guacamole.InputSink.
     *
     * @private
     * @type {Guacamole.InputSink}
     */
    var sink = this;

    /**
     * The underlying input field, styled to be invisible.
     *
     * @private
     * @type {Element}
     */
    var field = document.createElement('textarea');
    field.style.position   = 'fixed';
    field.style.outline    = 'none';
    field.style.border     = 'none';
    field.style.margin     = '0';
    field.style.padding    = '0';
    field.style.height     = '0';
    field.style.width      = '0';
    field.style.left       = '0';
    field.style.bottom     = '0';
    field.style.resize     = 'none';
    field.style.background = 'transparent';
    field.style.color      = 'transparent';

    // Keep field clear when modified via normal keypresses
    field.addEventListener("keypress", function clearKeypress(e) {
        field.value = '';
    }, false);

    // Keep field clear when modofied via composition events
    field.addEventListener("compositionend", function clearCompletedComposition(e) {
        if (e.data)
            field.value = '';
    }, false);

    // Keep field clear when modofied via input events
    field.addEventListener("input", function clearCompletedInput(e) {
        if (e.data && !e.isComposing)
            field.value = '';
    }, false);

    // Whenever focus is gained, automatically click to ensure cursor is
    // actually placed within the field (the field may simply be highlighted or
    // outlined otherwise)
    field.addEventListener("focus", function focusReceived() {
        window.setTimeout(function deferRefocus() {
            field.click();
            field.select();
        }, 0);
    }, true);

    /**
     * Attempts to focus the underlying input field. The focus attempt occurs
     * asynchronously, and may silently fail depending on browser restrictions.
     */
    this.focus = function focus() {
        window.setTimeout(function deferRefocus() {
            field.focus(); // Focus must be deferred to work reliably across browsers
        }, 0);
    };

    /**
     * Returns the underlying input field. This input field MUST be manually
     * added to the DOM for the Guacamole.InputSink to have any effect.
     *
     * @returns {Element}
     */
    this.getElement = function getElement() {
        return field;
    };

    // Automatically refocus input sink if part of DOM
    document.addEventListener("keydown", function refocusSink(e) {

        // Do not refocus if focus is on an input field
        var focused = document.activeElement;
        if (focused && focused !== document.body) {

            // Only consider focused input fields which are actually visible
            var rect = focused.getBoundingClientRect();
            if (rect.left + rect.width > 0 && rect.top + rect.height > 0)
                return;

        }

        // Refocus input sink instead of handling click
        sink.focus();

    }, true);

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * An input stream abstraction used by the Guacamole client to facilitate
 * transfer of files or other binary data.
 * 
 * @constructor
 * @param {Guacamole.Client} client The client owning this stream.
 * @param {Number} index The index of this stream.
 */
Guacamole.InputStream = function(client, index) {

    /**
     * Reference to this stream.
     * @private
     */
    var guac_stream = this;

    /**
     * The index of this stream.
     * @type {Number}
     */
    this.index = index;

    /**
     * Called when a blob of data is received.
     * 
     * @event
     * @param {String} data The received base64 data.
     */
    this.onblob = null;

    /**
     * Called when this stream is closed.
     * 
     * @event
     */
    this.onend = null;

    /**
     * Acknowledges the receipt of a blob.
     * 
     * @param {String} message A human-readable message describing the error
     *                         or status.
     * @param {Number} code The error code, if any, or 0 for success.
     */
    this.sendAck = function(message, code) {
        client.sendAck(guac_stream.index, message, code);
    };

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Integer pool which returns consistently increasing integers while integers
 * are in use, and previously-used integers when possible.
 * @constructor 
 */
Guacamole.IntegerPool = function() {

    /**
     * Reference to this integer pool.
     *
     * @private
     */
    var guac_pool = this;

    /**
     * Array of available integers.
     *
     * @private
     * @type {Number[]}
     */
    var pool = [];

    /**
     * The next integer to return if no more integers remain.
     * @type {Number}
     */
    this.next_int = 0;

    /**
     * Returns the next available integer in the pool. If possible, a previously
     * used integer will be returned.
     * 
     * @return {Number} The next available integer.
     */
    this.next = function() {

        // If free'd integers exist, return one of those
        if (pool.length > 0)
            return pool.shift();

        // Otherwise, return a new integer
        return guac_pool.next_int++;

    };

    /**
     * Frees the given integer, allowing it to be reused.
     * 
     * @param {Number} integer The integer to free.
     */
    this.free = function(integer) {
        pool.push(integer);
    };

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, assembling all
 * received blobs into a JavaScript object by appending them to each other, in
 * order, and decoding the result as JSON. Note that this object will overwrite
 * any installed event handlers on the given Guacamole.InputStream.
 * 
 * @constructor
 * @param {Guacamole.InputStream} stream
 *     The stream that JSON will be read from.
 */
Guacamole.JSONReader = function guacamoleJSONReader(stream) {

    /**
     * Reference to this Guacamole.JSONReader.
     *
     * @private
     * @type {Guacamole.JSONReader}
     */
    var guacReader = this;

    /**
     * Wrapped Guacamole.StringReader.
     *
     * @private
     * @type {Guacamole.StringReader}
     */
    var stringReader = new Guacamole.StringReader(stream);

    /**
     * All JSON read thus far.
     *
     * @private
     * @type {String}
     */
    var json = '';

    /**
     * Returns the current length of this Guacamole.JSONReader, in characters.
     *
     * @return {Number}
     *     The current length of this Guacamole.JSONReader.
     */
    this.getLength = function getLength() {
        return json.length;
    };

    /**
     * Returns the contents of this Guacamole.JSONReader as a JavaScript
     * object.
     *
     * @return {Object}
     *     The contents of this Guacamole.JSONReader, as parsed from the JSON
     *     contents of the input stream.
     */
    this.getJSON = function getJSON() {
        return JSON.parse(json);
    };

    // Append all received text
    stringReader.ontext = function ontext(text) {

        // Append received text
        json += text;

        // Call handler, if present
        if (guacReader.onprogress)
            guacReader.onprogress(text.length);

    };

    // Simply call onend when end received
    stringReader.onend = function onend() {
        if (guacReader.onend)
            guacReader.onend();
    };

    /**
     * Fired once for every blob of data received.
     * 
     * @event
     * @param {Number} length
     *     The number of characters received.
     */
    this.onprogress = null;

    /**
     * Fired once this stream is finished and no further data will be written.
     *
     * @event
     */
    this.onend = null;

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Provides cross-browser and cross-keyboard keyboard for a specific element.
 * Browser and keyboard layout variation is abstracted away, providing events
 * which represent keys as their corresponding X11 keysym.
 * 
 * @constructor
 * @param {Element|Document} [element]
 *    The Element to use to provide keyboard events. If omitted, at least one
 *    Element must be manually provided through the listenTo() function for
 *    the Guacamole.Keyboard instance to have any effect.
 */
Guacamole.Keyboard = function Keyboard(element) {

    /**
     * Reference to this Guacamole.Keyboard.
     * @private
     */
    var guac_keyboard = this;

    /**
     * An integer value which uniquely identifies this Guacamole.Keyboard
     * instance with respect to other Guacamole.Keyboard instances.
     *
     * @private
     * @type {Number}
     */
    var guacKeyboardID = Guacamole.Keyboard._nextID++;

    /**
     * The name of the property which is added to event objects via markEvent()
     * to note that they have already been handled by this Guacamole.Keyboard.
     *
     * @private
     * @constant
     * @type {String}
     */
    var EVENT_MARKER = '_GUAC_KEYBOARD_HANDLED_BY_' + guacKeyboardID;

    /**
     * Fired whenever the user presses a key with the element associated
     * with this Guacamole.Keyboard in focus.
     * 
     * @event
     * @param {Number} keysym The keysym of the key being pressed.
     * @return {Boolean} true if the key event should be allowed through to the
     *                   browser, false otherwise.
     */
    this.onkeydown = null;

    /**
     * Fired whenever the user releases a key with the element associated
     * with this Guacamole.Keyboard in focus.
     * 
     * @event
     * @param {Number} keysym The keysym of the key being released.
     */
    this.onkeyup = null;

    /**
     * Set of known platform-specific or browser-specific quirks which must be
     * accounted for to properly interpret key events, even if the only way to
     * reliably detect that quirk is to platform/browser-sniff.
     *
     * @private
     * @type {Object.<String, Boolean>}
     */
    var quirks = {

        /**
         * Whether keyup events are universally unreliable.
         *
         * @type {Boolean}
         */
        keyupUnreliable: false,

        /**
         * Whether the Alt key is actually a modifier for typable keys and is
         * thus never used for keyboard shortcuts.
         *
         * @type {Boolean}
         */
        altIsTypableOnly: false,

        /**
         * Whether we can rely on receiving a keyup event for the Caps Lock
         * key.
         *
         * @type {Boolean}
         */
        capsLockKeyupUnreliable: false

    };

    // Set quirk flags depending on platform/browser, if such information is
    // available
    if (navigator && navigator.platform) {

        // All keyup events are unreliable on iOS (sadly)
        if (navigator.platform.match(/ipad|iphone|ipod/i))
            quirks.keyupUnreliable = true;

        // The Alt key on Mac is never used for keyboard shortcuts, and the
        // Caps Lock key never dispatches keyup events
        else if (navigator.platform.match(/^mac/i)) {
            quirks.altIsTypableOnly = true;
            quirks.capsLockKeyupUnreliable = true;
        }

    }

    /**
     * A key event having a corresponding timestamp. This event is non-specific.
     * Its subclasses should be used instead when recording specific key
     * events.
     *
     * @private
     * @constructor
     */
    var KeyEvent = function() {

        /**
         * Reference to this key event.
         */
        var key_event = this;

        /**
         * An arbitrary timestamp in milliseconds, indicating this event's
         * position in time relative to other events.
         *
         * @type {Number}
         */
        this.timestamp = new Date().getTime();

        /**
         * Whether the default action of this key event should be prevented.
         *
         * @type {Boolean}
         */
        this.defaultPrevented = false;

        /**
         * The keysym of the key associated with this key event, as determined
         * by a best-effort guess using available event properties and keyboard
         * state.
         *
         * @type {Number}
         */
        this.keysym = null;

        /**
         * Whether the keysym value of this key event is known to be reliable.
         * If false, the keysym may still be valid, but it's only a best guess,
         * and future key events may be a better source of information.
         *
         * @type {Boolean}
         */
        this.reliable = false;

        /**
         * Returns the number of milliseconds elapsed since this event was
         * received.
         *
         * @return {Number} The number of milliseconds elapsed since this
         *                  event was received.
         */
        this.getAge = function() {
            return new Date().getTime() - key_event.timestamp;
        };

    };

    /**
     * Information related to the pressing of a key, which need not be a key
     * associated with a printable character. The presence or absence of any
     * information within this object is browser-dependent.
     *
     * @private
     * @constructor
     * @augments Guacamole.Keyboard.KeyEvent
     * @param {Number} keyCode The JavaScript key code of the key pressed.
     * @param {String} keyIdentifier The legacy DOM3 "keyIdentifier" of the key
     *                               pressed, as defined at:
     *                               http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
     * @param {String} key The standard name of the key pressed, as defined at:
     *                     http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     * @param {Number} location The location on the keyboard corresponding to
     *                          the key pressed, as defined at:
     *                          http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     */
    var KeydownEvent = function(keyCode, keyIdentifier, key, location) {

        // We extend KeyEvent
        KeyEvent.apply(this);

        /**
         * The JavaScript key code of the key pressed.
         *
         * @type {Number}
         */
        this.keyCode = keyCode;

        /**
         * The legacy DOM3 "keyIdentifier" of the key pressed, as defined at:
         * http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
         *
         * @type {String}
         */
        this.keyIdentifier = keyIdentifier;

        /**
         * The standard name of the key pressed, as defined at:
         * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
         * 
         * @type {String}
         */
        this.key = key;

        /**
         * The location on the keyboard corresponding to the key pressed, as
         * defined at:
         * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
         * 
         * @type {Number}
         */
        this.location = location;

        // If key is known from keyCode or DOM3 alone, use that
        this.keysym =  keysym_from_key_identifier(key, location)
                    || keysym_from_keycode(keyCode, location);

        /**
         * Whether the keyup following this keydown event is known to be
         * reliable. If false, we cannot rely on the keyup event to occur.
         *
         * @type {Boolean}
         */
        this.keyupReliable = !quirks.keyupUnreliable;

        // DOM3 and keyCode are reliable sources if the corresponding key is
        // not a printable key
        if (this.keysym && !isPrintable(this.keysym))
            this.reliable = true;

        // Use legacy keyIdentifier as a last resort, if it looks sane
        if (!this.keysym && key_identifier_sane(keyCode, keyIdentifier))
            this.keysym = keysym_from_key_identifier(keyIdentifier, location, guac_keyboard.modifiers.shift);

        // If a key is pressed while meta is held down, the keyup will
        // never be sent in Chrome (bug #108404)
        if (guac_keyboard.modifiers.meta && this.keysym !== 0xFFE7 && this.keysym !== 0xFFE8)
            this.keyupReliable = false;

        // We cannot rely on receiving keyup for Caps Lock on certain platforms
        else if (this.keysym === 0xFFE5 && quirks.capsLockKeyupUnreliable)
            this.keyupReliable = false;

        // Determine whether default action for Alt+combinations must be prevented
        var prevent_alt = !guac_keyboard.modifiers.ctrl && !quirks.altIsTypableOnly;

        // Determine whether default action for Ctrl+combinations must be prevented
        var prevent_ctrl = !guac_keyboard.modifiers.alt;

        // We must rely on the (potentially buggy) keyIdentifier if preventing
        // the default action is important
        if ((prevent_ctrl && guac_keyboard.modifiers.ctrl)
         || (prevent_alt  && guac_keyboard.modifiers.alt)
         || guac_keyboard.modifiers.meta
         || guac_keyboard.modifiers.hyper)
            this.reliable = true;

        // Record most recently known keysym by associated key code
        recentKeysym[keyCode] = this.keysym;

    };

    KeydownEvent.prototype = new KeyEvent();

    /**
     * Information related to the pressing of a key, which MUST be
     * associated with a printable character. The presence or absence of any
     * information within this object is browser-dependent.
     *
     * @private
     * @constructor
     * @augments Guacamole.Keyboard.KeyEvent
     * @param {Number} charCode The Unicode codepoint of the character that
     *                          would be typed by the key pressed.
     */
    var KeypressEvent = function(charCode) {

        // We extend KeyEvent
        KeyEvent.apply(this);

        /**
         * The Unicode codepoint of the character that would be typed by the
         * key pressed.
         *
         * @type {Number}
         */
        this.charCode = charCode;

        // Pull keysym from char code
        this.keysym = keysym_from_charcode(charCode);

        // Keypress is always reliable
        this.reliable = true;

    };

    KeypressEvent.prototype = new KeyEvent();

    /**
     * Information related to the pressing of a key, which need not be a key
     * associated with a printable character. The presence or absence of any
     * information within this object is browser-dependent.
     *
     * @private
     * @constructor
     * @augments Guacamole.Keyboard.KeyEvent
     * @param {Number} keyCode The JavaScript key code of the key released.
     * @param {String} keyIdentifier The legacy DOM3 "keyIdentifier" of the key
     *                               released, as defined at:
     *                               http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
     * @param {String} key The standard name of the key released, as defined at:
     *                     http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     * @param {Number} location The location on the keyboard corresponding to
     *                          the key released, as defined at:
     *                          http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     */
    var KeyupEvent = function(keyCode, keyIdentifier, key, location) {

        // We extend KeyEvent
        KeyEvent.apply(this);

        /**
         * The JavaScript key code of the key released.
         *
         * @type {Number}
         */
        this.keyCode = keyCode;

        /**
         * The legacy DOM3 "keyIdentifier" of the key released, as defined at:
         * http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
         *
         * @type {String}
         */
        this.keyIdentifier = keyIdentifier;

        /**
         * The standard name of the key released, as defined at:
         * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
         * 
         * @type {String}
         */
        this.key = key;

        /**
         * The location on the keyboard corresponding to the key released, as
         * defined at:
         * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
         * 
         * @type {Number}
         */
        this.location = location;

        // If key is known from keyCode or DOM3 alone, use that
        this.keysym =  keysym_from_keycode(keyCode, location)
                    || keysym_from_key_identifier(key, location); // keyCode is still more reliable for keyup when dead keys are in use

        // Fall back to the most recently pressed keysym associated with the
        // keyCode if the inferred key doesn't seem to actually be pressed
        if (!guac_keyboard.pressed[this.keysym])
            this.keysym = recentKeysym[keyCode] || this.keysym;

        // Keyup is as reliable as it will ever be
        this.reliable = true;

    };

    KeyupEvent.prototype = new KeyEvent();

    /**
     * An array of recorded events, which can be instances of the private
     * KeydownEvent, KeypressEvent, and KeyupEvent classes.
     *
     * @private
     * @type {KeyEvent[]}
     */
    var eventLog = [];

    /**
     * Map of known JavaScript keycodes which do not map to typable characters
     * to their X11 keysym equivalents.
     * @private
     */
    var keycodeKeysyms = {
        8:   [0xFF08], // backspace
        9:   [0xFF09], // tab
        12:  [0xFF0B, 0xFF0B, 0xFF0B, 0xFFB5], // clear       / KP 5
        13:  [0xFF0D], // enter
        16:  [0xFFE1, 0xFFE1, 0xFFE2], // shift
        17:  [0xFFE3, 0xFFE3, 0xFFE4], // ctrl
        18:  [0xFFE9, 0xFFE9, 0xFE03], // alt
        19:  [0xFF13], // pause/break
        20:  [0xFFE5], // caps lock
        27:  [0xFF1B], // escape
        32:  [0x0020], // space
        33:  [0xFF55, 0xFF55, 0xFF55, 0xFFB9], // page up     / KP 9
        34:  [0xFF56, 0xFF56, 0xFF56, 0xFFB3], // page down   / KP 3
        35:  [0xFF57, 0xFF57, 0xFF57, 0xFFB1], // end         / KP 1
        36:  [0xFF50, 0xFF50, 0xFF50, 0xFFB7], // home        / KP 7
        37:  [0xFF51, 0xFF51, 0xFF51, 0xFFB4], // left arrow  / KP 4
        38:  [0xFF52, 0xFF52, 0xFF52, 0xFFB8], // up arrow    / KP 8
        39:  [0xFF53, 0xFF53, 0xFF53, 0xFFB6], // right arrow / KP 6
        40:  [0xFF54, 0xFF54, 0xFF54, 0xFFB2], // down arrow  / KP 2
        45:  [0xFF63, 0xFF63, 0xFF63, 0xFFB0], // insert      / KP 0
        46:  [0xFFFF, 0xFFFF, 0xFFFF, 0xFFAE], // delete      / KP decimal
        91:  [0xFFEB], // left window key (hyper_l)
        92:  [0xFF67], // right window key (menu key?)
        93:  null,     // select key
        96:  [0xFFB0], // KP 0
        97:  [0xFFB1], // KP 1
        98:  [0xFFB2], // KP 2
        99:  [0xFFB3], // KP 3
        100: [0xFFB4], // KP 4
        101: [0xFFB5], // KP 5
        102: [0xFFB6], // KP 6
        103: [0xFFB7], // KP 7
        104: [0xFFB8], // KP 8
        105: [0xFFB9], // KP 9
        106: [0xFFAA], // KP multiply
        107: [0xFFAB], // KP add
        109: [0xFFAD], // KP subtract
        110: [0xFFAE], // KP decimal
        111: [0xFFAF], // KP divide
        112: [0xFFBE], // f1
        113: [0xFFBF], // f2
        114: [0xFFC0], // f3
        115: [0xFFC1], // f4
        116: [0xFFC2], // f5
        117: [0xFFC3], // f6
        118: [0xFFC4], // f7
        119: [0xFFC5], // f8
        120: [0xFFC6], // f9
        121: [0xFFC7], // f10
        122: [0xFFC8], // f11
        123: [0xFFC9], // f12
        144: [0xFF7F], // num lock
        145: [0xFF14], // scroll lock
        225: [0xFE03]  // altgraph (iso_level3_shift)
    };

    /**
     * Map of known JavaScript keyidentifiers which do not map to typable
     * characters to their unshifted X11 keysym equivalents.
     * @private
     */
    var keyidentifier_keysym = {
        "Again": [0xFF66],
        "AllCandidates": [0xFF3D],
        "Alphanumeric": [0xFF30],
        "Alt": [0xFFE9, 0xFFE9, 0xFE03],
        "Attn": [0xFD0E],
        "AltGraph": [0xFE03],
        "ArrowDown": [0xFF54],
        "ArrowLeft": [0xFF51],
        "ArrowRight": [0xFF53],
        "ArrowUp": [0xFF52],
        "Backspace": [0xFF08],
        "CapsLock": [0xFFE5],
        "Cancel": [0xFF69],
        "Clear": [0xFF0B],
        "Convert": [0xFF21],
        "Copy": [0xFD15],
        "Crsel": [0xFD1C],
        "CrSel": [0xFD1C],
        "CodeInput": [0xFF37],
        "Compose": [0xFF20],
        "Control": [0xFFE3, 0xFFE3, 0xFFE4],
        "ContextMenu": [0xFF67],
        "Delete": [0xFFFF],
        "Down": [0xFF54],
        "End": [0xFF57],
        "Enter": [0xFF0D],
        "EraseEof": [0xFD06],
        "Escape": [0xFF1B],
        "Execute": [0xFF62],
        "Exsel": [0xFD1D],
        "ExSel": [0xFD1D],
        "F1": [0xFFBE],
        "F2": [0xFFBF],
        "F3": [0xFFC0],
        "F4": [0xFFC1],
        "F5": [0xFFC2],
        "F6": [0xFFC3],
        "F7": [0xFFC4],
        "F8": [0xFFC5],
        "F9": [0xFFC6],
        "F10": [0xFFC7],
        "F11": [0xFFC8],
        "F12": [0xFFC9],
        "F13": [0xFFCA],
        "F14": [0xFFCB],
        "F15": [0xFFCC],
        "F16": [0xFFCD],
        "F17": [0xFFCE],
        "F18": [0xFFCF],
        "F19": [0xFFD0],
        "F20": [0xFFD1],
        "F21": [0xFFD2],
        "F22": [0xFFD3],
        "F23": [0xFFD4],
        "F24": [0xFFD5],
        "Find": [0xFF68],
        "GroupFirst": [0xFE0C],
        "GroupLast": [0xFE0E],
        "GroupNext": [0xFE08],
        "GroupPrevious": [0xFE0A],
        "FullWidth": null,
        "HalfWidth": null,
        "HangulMode": [0xFF31],
        "Hankaku": [0xFF29],
        "HanjaMode": [0xFF34],
        "Help": [0xFF6A],
        "Hiragana": [0xFF25],
        "HiraganaKatakana": [0xFF27],
        "Home": [0xFF50],
        "Hyper": [0xFFED, 0xFFED, 0xFFEE],
        "Insert": [0xFF63],
        "JapaneseHiragana": [0xFF25],
        "JapaneseKatakana": [0xFF26],
        "JapaneseRomaji": [0xFF24],
        "JunjaMode": [0xFF38],
        "KanaMode": [0xFF2D],
        "KanjiMode": [0xFF21],
        "Katakana": [0xFF26],
        "Left": [0xFF51],
        "Meta": [0xFFE7, 0xFFE7, 0xFFE8],
        "ModeChange": [0xFF7E],
        "NumLock": [0xFF7F],
        "PageDown": [0xFF56],
        "PageUp": [0xFF55],
        "Pause": [0xFF13],
        "Play": [0xFD16],
        "PreviousCandidate": [0xFF3E],
        "PrintScreen": [0xFF61],
        "Redo": [0xFF66],
        "Right": [0xFF53],
        "RomanCharacters": null,
        "Scroll": [0xFF14],
        "Select": [0xFF60],
        "Separator": [0xFFAC],
        "Shift": [0xFFE1, 0xFFE1, 0xFFE2],
        "SingleCandidate": [0xFF3C],
        "Super": [0xFFEB, 0xFFEB, 0xFFEC],
        "Tab": [0xFF09],
        "UIKeyInputDownArrow": [0xFF54],
        "UIKeyInputEscape": [0xFF1B],
        "UIKeyInputLeftArrow": [0xFF51],
        "UIKeyInputRightArrow": [0xFF53],
        "UIKeyInputUpArrow": [0xFF52],
        "Up": [0xFF52],
        "Undo": [0xFF65],
        "Win": [0xFFEB],
        "Zenkaku": [0xFF28],
        "ZenkakuHankaku": [0xFF2A]
    };

    /**
     * All keysyms which should not repeat when held down.
     * @private
     */
    var no_repeat = {
        0xFE03: true, // ISO Level 3 Shift (AltGr)
        0xFFE1: true, // Left shift
        0xFFE2: true, // Right shift
        0xFFE3: true, // Left ctrl 
        0xFFE4: true, // Right ctrl 
        0xFFE5: true, // Caps Lock
        0xFFE7: true, // Left meta 
        0xFFE8: true, // Right meta 
        0xFFE9: true, // Left alt
        0xFFEA: true, // Right alt
        0xFFEB: true, // Left hyper
        0xFFEC: true  // Right hyper
    };

    /**
     * All modifiers and their states.
     */
    this.modifiers = new Guacamole.Keyboard.ModifierState();
        
    /**
     * The state of every key, indexed by keysym. If a particular key is
     * pressed, the value of pressed for that keysym will be true. If a key
     * is not currently pressed, it will not be defined. 
     */
    this.pressed = {};

    /**
     * The state of every key, indexed by keysym, for strictly those keys whose
     * status has been indirectly determined thorugh observation of other key
     * events. If a particular key is implicitly pressed, the value of
     * implicitlyPressed for that keysym will be true. If a key
     * is not currently implicitly pressed (the key is not pressed OR the state
     * of the key is explicitly known), it will not be defined.
     *
     * @private
     * @tyle {Object.<Number, Boolean>}
     */
    var implicitlyPressed = {};

    /**
     * The last result of calling the onkeydown handler for each key, indexed
     * by keysym. This is used to prevent/allow default actions for key events,
     * even when the onkeydown handler cannot be called again because the key
     * is (theoretically) still pressed.
     *
     * @private
     */
    var last_keydown_result = {};

    /**
     * The keysym most recently associated with a given keycode when keydown
     * fired. This object maps keycodes to keysyms.
     *
     * @private
     * @type {Object.<Number, Number>}
     */
    var recentKeysym = {};

    /**
     * Timeout before key repeat starts.
     * @private
     */
    var key_repeat_timeout = null;

    /**
     * Interval which presses and releases the last key pressed while that
     * key is still being held down.
     * @private
     */
    var key_repeat_interval = null;

    /**
     * Given an array of keysyms indexed by location, returns the keysym
     * for the given location, or the keysym for the standard location if
     * undefined.
     * 
     * @private
     * @param {Number[]} keysyms
     *     An array of keysyms, where the index of the keysym in the array is
     *     the location value.
     *
     * @param {Number} location
     *     The location on the keyboard corresponding to the key pressed, as
     *     defined at: http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     */
    var get_keysym = function get_keysym(keysyms, location) {

        if (!keysyms)
            return null;

        return keysyms[location] || keysyms[0];
    };

    /**
     * Returns true if the given keysym corresponds to a printable character,
     * false otherwise.
     *
     * @param {Number} keysym
     *     The keysym to check.
     *
     * @returns {Boolean}
     *     true if the given keysym corresponds to a printable character,
     *     false otherwise.
     */
    var isPrintable = function isPrintable(keysym) {

        // Keysyms with Unicode equivalents are printable
        return (keysym >= 0x00 && keysym <= 0xFF)
            || (keysym & 0xFFFF0000) === 0x01000000;

    };

    function keysym_from_key_identifier(identifier, location, shifted) {

        if (!identifier)
            return null;

        var typedCharacter;

        // If identifier is U+xxxx, decode Unicode character 
        var unicodePrefixLocation = identifier.indexOf("U+");
        if (unicodePrefixLocation >= 0) {
            var hex = identifier.substring(unicodePrefixLocation+2);
            typedCharacter = String.fromCharCode(parseInt(hex, 16));
        }

        // If single character and not keypad, use that as typed character
        else if (identifier.length === 1 && location !== 3)
            typedCharacter = identifier;

        // Otherwise, look up corresponding keysym
        else
            return get_keysym(keyidentifier_keysym[identifier], location);

        // Alter case if necessary
        if (shifted === true)
            typedCharacter = typedCharacter.toUpperCase();
        else if (shifted === false)
            typedCharacter = typedCharacter.toLowerCase();

        // Get codepoint
        var codepoint = typedCharacter.charCodeAt(0);
        return keysym_from_charcode(codepoint);

    }

    function isControlCharacter(codepoint) {
        return codepoint <= 0x1F || (codepoint >= 0x7F && codepoint <= 0x9F);
    }

    function keysym_from_charcode(codepoint) {

        // Keysyms for control characters
        if (isControlCharacter(codepoint)) return 0xFF00 | codepoint;

        // Keysyms for ASCII chars
        if (codepoint >= 0x0000 && codepoint <= 0x00FF)
            return codepoint;

        // Keysyms for Unicode
        if (codepoint >= 0x0100 && codepoint <= 0x10FFFF)
            return 0x01000000 | codepoint;

        return null;

    }

    function keysym_from_keycode(keyCode, location) {
        return get_keysym(keycodeKeysyms[keyCode], location);
    }

    /**
     * Heuristically detects if the legacy keyIdentifier property of
     * a keydown/keyup event looks incorrectly derived. Chrome, and
     * presumably others, will produce the keyIdentifier by assuming
     * the keyCode is the Unicode codepoint for that key. This is not
     * correct in all cases.
     *
     * @private
     * @param {Number} keyCode
     *     The keyCode from a browser keydown/keyup event.
     *
     * @param {String} keyIdentifier
     *     The legacy keyIdentifier from a browser keydown/keyup event.
     *
     * @returns {Boolean}
     *     true if the keyIdentifier looks sane, false if the keyIdentifier
     *     appears incorrectly derived or is missing entirely.
     */
    var key_identifier_sane = function key_identifier_sane(keyCode, keyIdentifier) {

        // Missing identifier is not sane
        if (!keyIdentifier)
            return false;

        // Assume non-Unicode keyIdentifier values are sane
        var unicodePrefixLocation = keyIdentifier.indexOf("U+");
        if (unicodePrefixLocation === -1)
            return true;

        // If the Unicode codepoint isn't identical to the keyCode,
        // then the identifier is likely correct
        var codepoint = parseInt(keyIdentifier.substring(unicodePrefixLocation+2), 16);
        if (keyCode !== codepoint)
            return true;

        // The keyCodes for A-Z and 0-9 are actually identical to their
        // Unicode codepoints
        if ((keyCode >= 65 && keyCode <= 90) || (keyCode >= 48 && keyCode <= 57))
            return true;

        // The keyIdentifier does NOT appear sane
        return false;

    };

    /**
     * Marks a key as pressed, firing the keydown event if registered. Key
     * repeat for the pressed key will start after a delay if that key is
     * not a modifier. The return value of this function depends on the
     * return value of the keydown event handler, if any.
     * 
     * @param {Number} keysym The keysym of the key to press.
     * @return {Boolean} true if event should NOT be canceled, false otherwise.
     */
    this.press = function(keysym) {

        // Don't bother with pressing the key if the key is unknown
        if (keysym === null) return;

        // Only press if released
        if (!guac_keyboard.pressed[keysym]) {

            // Mark key as pressed
            guac_keyboard.pressed[keysym] = true;

            // Send key event
            if (guac_keyboard.onkeydown) {
                var result = guac_keyboard.onkeydown(keysym);
                last_keydown_result[keysym] = result;

                // Stop any current repeat
                window.clearTimeout(key_repeat_timeout);
                window.clearInterval(key_repeat_interval);

                // Repeat after a delay as long as pressed
                if (!no_repeat[keysym])
                    key_repeat_timeout = window.setTimeout(function() {
                        key_repeat_interval = window.setInterval(function() {
                            guac_keyboard.onkeyup(keysym);
                            guac_keyboard.onkeydown(keysym);
                        }, 50);
                    }, 500);

                return result;
            }
        }

        // Return the last keydown result by default, resort to false if unknown
        return last_keydown_result[keysym] || false;

    };

    /**
     * Marks a key as released, firing the keyup event if registered.
     * 
     * @param {Number} keysym The keysym of the key to release.
     */
    this.release = function(keysym) {

        // Only release if pressed
        if (guac_keyboard.pressed[keysym]) {
            
            // Mark key as released
            delete guac_keyboard.pressed[keysym];
            delete implicitlyPressed[keysym];

            // Stop repeat
            window.clearTimeout(key_repeat_timeout);
            window.clearInterval(key_repeat_interval);

            // Send key event
            if (keysym !== null && guac_keyboard.onkeyup)
                guac_keyboard.onkeyup(keysym);

        }

    };

    /**
     * Presses and releases the keys necessary to type the given string of
     * text.
     *
     * @param {String} str
     *     The string to type.
     */
    this.type = function type(str) {

        // Press/release the key corresponding to each character in the string
        for (var i = 0; i < str.length; i++) {

            // Determine keysym of current character
            var codepoint = str.codePointAt ? str.codePointAt(i) : str.charCodeAt(i);
            var keysym = keysym_from_charcode(codepoint);

            // Press and release key for current character
            guac_keyboard.press(keysym);
            guac_keyboard.release(keysym);

        }

    };

    /**
     * Resets the state of this keyboard, releasing all keys, and firing keyup
     * events for each released key.
     */
    this.reset = function() {

        // Release all pressed keys
        for (var keysym in guac_keyboard.pressed)
            guac_keyboard.release(parseInt(keysym));

        // Clear event log
        eventLog = [];

    };

    /**
     * Given the remote and local state of a particular key, resynchronizes the
     * remote state of that key with the local state through pressing or
     * releasing keysyms.
     *
     * @private
     * @param {Boolean} remoteState
     *     Whether the key is currently pressed remotely.
     *
     * @param {Boolean} localState
     *     Whether the key is currently pressed remotely locally. If the state
     *     of the key is not known, this may be undefined.
     *
     * @param {Number[]} keysyms
     *     The keysyms which represent the key being updated.
     *
     * @param {KeyEvent} keyEvent
     *     Guacamole's current best interpretation of the key event being
     *     processed.
     */
    var updateModifierState = function updateModifierState(remoteState,
        localState, keysyms, keyEvent) {

        var i;

        // Do not trust changes in modifier state for events directly involving
        // that modifier: (1) the flag may erroneously be cleared despite
        // another version of the same key still being held and (2) the change
        // in flag may be due to the current event being processed, thus
        // updating things here is at best redundant and at worst incorrect
        if (keysyms.indexOf(keyEvent.keysym) !== -1)
            return;

        // Release all related keys if modifier is implicitly released
        if (remoteState && localState === false) {
            for (i = 0; i < keysyms.length; i++) {
                guac_keyboard.release(keysyms[i]);
            }
        }

        // Press if modifier is implicitly pressed
        else if (!remoteState && localState) {

            // Verify that modifier flag isn't already pressed or already set
            // due to another version of the same key being held down
            for (i = 0; i < keysyms.length; i++) {
                if (guac_keyboard.pressed[keysyms[i]])
                    return;
            }

            // Mark as implicitly pressed only if there is other information
            // within the key event relating to a different key. Some
            // platforms, such as iOS, will send essentially empty key events
            // for modifier keys, using only the modifier flags to signal the
            // identity of the key.
            var keysym = keysyms[0];
            if (keyEvent.keysym)
                implicitlyPressed[keysym] = true;

            guac_keyboard.press(keysym);

        }

    };

    /**
     * Given a keyboard event, updates the local modifier state and remote
     * key state based on the modifier flags within the event. This function
     * pays no attention to keycodes.
     *
     * @private
     * @param {KeyboardEvent} e
     *     The keyboard event containing the flags to update.
     *
     * @param {KeyEvent} keyEvent
     *     Guacamole's current best interpretation of the key event being
     *     processed.
     */
    var syncModifierStates = function syncModifierStates(e, keyEvent) {

        // Get state
        var state = Guacamole.Keyboard.ModifierState.fromKeyboardEvent(e);

        // Resync state of alt
        updateModifierState(guac_keyboard.modifiers.alt, state.alt, [
            0xFFE9, // Left alt
            0xFFEA, // Right alt
            0xFE03  // AltGr
        ], keyEvent);

        // Resync state of shift
        updateModifierState(guac_keyboard.modifiers.shift, state.shift, [
            0xFFE1, // Left shift
            0xFFE2  // Right shift
        ], keyEvent);

        // Resync state of ctrl
        updateModifierState(guac_keyboard.modifiers.ctrl, state.ctrl, [
            0xFFE3, // Left ctrl
            0xFFE4  // Right ctrl
        ], keyEvent);

        // Resync state of meta
        updateModifierState(guac_keyboard.modifiers.meta, state.meta, [
            0xFFE7, // Left meta
            0xFFE8  // Right meta
        ], keyEvent);

        // Resync state of hyper
        updateModifierState(guac_keyboard.modifiers.hyper, state.hyper, [
            0xFFEB, // Left hyper
            0xFFEC  // Right hyper
        ], keyEvent);

        // Update state
        guac_keyboard.modifiers = state;

    };

    /**
     * Returns whether all currently pressed keys were implicitly pressed. A
     * key is implicitly pressed if its status was inferred indirectly from
     * inspection of other key events.
     *
     * @private
     * @returns {Boolean}
     *     true if all currently pressed keys were implicitly pressed, false
     *     otherwise.
     */
    var isStateImplicit = function isStateImplicit() {

        for (var keysym in guac_keyboard.pressed) {
            if (!implicitlyPressed[keysym])
                return false;
        }

        return true;

    };

    /**
     * Reads through the event log, removing events from the head of the log
     * when the corresponding true key presses are known (or as known as they
     * can be).
     * 
     * @private
     * @return {Boolean} Whether the default action of the latest event should
     *                   be prevented.
     */
    function interpret_events() {

        // Do not prevent default if no event could be interpreted
        var handled_event = interpret_event();
        if (!handled_event)
            return false;

        // Interpret as much as possible
        var last_event;
        do {
            last_event = handled_event;
            handled_event = interpret_event();
        } while (handled_event !== null);

        // Reset keyboard state if we cannot expect to receive any further
        // keyup events
        if (isStateImplicit())
            guac_keyboard.reset();

        return last_event.defaultPrevented;

    }

    /**
     * Releases Ctrl+Alt, if both are currently pressed and the given keysym
     * looks like a key that may require AltGr.
     *
     * @private
     * @param {Number} keysym The key that was just pressed.
     */
    var release_simulated_altgr = function release_simulated_altgr(keysym) {

        // Both Ctrl+Alt must be pressed if simulated AltGr is in use
        if (!guac_keyboard.modifiers.ctrl || !guac_keyboard.modifiers.alt)
            return;

        // Assume [A-Z] never require AltGr
        if (keysym >= 0x0041 && keysym <= 0x005A)
            return;

        // Assume [a-z] never require AltGr
        if (keysym >= 0x0061 && keysym <= 0x007A)
            return;

        // Release Ctrl+Alt if the keysym is printable
        if (keysym <= 0xFF || (keysym & 0xFF000000) === 0x01000000) {
            guac_keyboard.release(0xFFE3); // Left ctrl 
            guac_keyboard.release(0xFFE4); // Right ctrl 
            guac_keyboard.release(0xFFE9); // Left alt
            guac_keyboard.release(0xFFEA); // Right alt
        }

    };

    /**
     * Reads through the event log, interpreting the first event, if possible,
     * and returning that event. If no events can be interpreted, due to a
     * total lack of events or the need for more events, null is returned. Any
     * interpreted events are automatically removed from the log.
     * 
     * @private
     * @return {KeyEvent}
     *     The first key event in the log, if it can be interpreted, or null
     *     otherwise.
     */
    var interpret_event = function interpret_event() {

        // Peek at first event in log
        var first = eventLog[0];
        if (!first)
            return null;

        // Keydown event
        if (first instanceof KeydownEvent) {

            var keysym = null;
            var accepted_events = [];

            // If event itself is reliable, no need to wait for other events
            if (first.reliable) {
                keysym = first.keysym;
                accepted_events = eventLog.splice(0, 1);
            }

            // If keydown is immediately followed by a keypress, use the indicated character
            else if (eventLog[1] instanceof KeypressEvent) {
                keysym = eventLog[1].keysym;
                accepted_events = eventLog.splice(0, 2);
            }

            // If keydown is immediately followed by anything else, then no
            // keypress can possibly occur to clarify this event, and we must
            // handle it now
            else if (eventLog[1]) {
                keysym = first.keysym;
                accepted_events = eventLog.splice(0, 1);
            }

            // Fire a key press if valid events were found
            if (accepted_events.length > 0) {

                if (keysym) {

                    // Fire event
                    release_simulated_altgr(keysym);
                    var defaultPrevented = !guac_keyboard.press(keysym);
                    recentKeysym[first.keyCode] = keysym;

                    // Release the key now if we cannot rely on the associated
                    // keyup event
                    if (!first.keyupReliable)
                        guac_keyboard.release(keysym);

                    // Record whether default was prevented
                    for (var i=0; i<accepted_events.length; i++)
                        accepted_events[i].defaultPrevented = defaultPrevented;

                }

                return first;

            }

        } // end if keydown

        // Keyup event
        else if (first instanceof KeyupEvent && !quirks.keyupUnreliable) {

            // Release specific key if known
            var keysym = first.keysym;
            if (keysym) {
                guac_keyboard.release(keysym);
                delete recentKeysym[first.keyCode];
                first.defaultPrevented = true;
            }

            // Otherwise, fall back to releasing all keys
            else {
                guac_keyboard.reset();
                return first;
            }

            return eventLog.shift();

        } // end if keyup

        // Ignore any other type of event (keypress by itself is invalid, and
        // unreliable keyup events should simply be dumped)
        else
            return eventLog.shift();

        // No event interpreted
        return null;

    };

    /**
     * Returns the keyboard location of the key associated with the given
     * keyboard event. The location differentiates key events which otherwise
     * have the same keycode, such as left shift vs. right shift.
     *
     * @private
     * @param {KeyboardEvent} e
     *     A JavaScript keyboard event, as received through the DOM via a
     *     "keydown", "keyup", or "keypress" handler.
     *
     * @returns {Number}
     *     The location of the key event on the keyboard, as defined at:
     *     http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     */
    var getEventLocation = function getEventLocation(e) {

        // Use standard location, if possible
        if ('location' in e)
            return e.location;

        // Failing that, attempt to use deprecated keyLocation
        if ('keyLocation' in e)
            return e.keyLocation;

        // If no location is available, assume left side
        return 0;

    };

    /**
     * Attempts to mark the given Event as having been handled by this
     * Guacamole.Keyboard. If the Event has already been marked as handled,
     * false is returned.
     *
     * @param {Event} e
     *     The Event to mark.
     *
     * @returns {Boolean}
     *     true if the given Event was successfully marked, false if the given
     *     Event was already marked.
     */
    var markEvent = function markEvent(e) {

        // Fail if event is already marked
        if (e[EVENT_MARKER])
            return false;

        // Mark event otherwise
        e[EVENT_MARKER] = true;
        return true;

    };

    /**
     * Attaches event listeners to the given Element, automatically translating
     * received key, input, and composition events into simple keydown/keyup
     * events signalled through this Guacamole.Keyboard's onkeydown and
     * onkeyup handlers.
     *
     * @param {Element|Document} element
     *     The Element to attach event listeners to for the sake of handling
     *     key or input events.
     */
    this.listenTo = function listenTo(element) {

        // When key pressed
        element.addEventListener("keydown", function(e) {

            // Only intercept if handler set
            if (!guac_keyboard.onkeydown) return;

            // Ignore events which have already been handled
            if (!markEvent(e)) return;

            var keyCode;
            if (window.event) keyCode = window.event.keyCode;
            else if (e.which) keyCode = e.which;

            // Fix modifier states
            var keydownEvent = new KeydownEvent(keyCode, e.keyIdentifier, e.key, getEventLocation(e));
            syncModifierStates(e, keydownEvent);

            // Ignore (but do not prevent) the "composition" keycode sent by some
            // browsers when an IME is in use (see: http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html)
            if (keyCode === 229)
                return;

            // Log event
            eventLog.push(keydownEvent);

            // Interpret as many events as possible, prevent default if indicated
            if (interpret_events())
                e.preventDefault();

        }, true);

        // When key pressed
        element.addEventListener("keypress", function(e) {

            // Only intercept if handler set
            if (!guac_keyboard.onkeydown && !guac_keyboard.onkeyup) return;

            // Ignore events which have already been handled
            if (!markEvent(e)) return;

            var charCode;
            if (window.event) charCode = window.event.keyCode;
            else if (e.which) charCode = e.which;

            // Fix modifier states
            var keypressEvent = new KeypressEvent(charCode);
            syncModifierStates(e, keypressEvent);

            // Log event
            eventLog.push(keypressEvent);

            // Interpret as many events as possible, prevent default if indicated
            if (interpret_events())
                e.preventDefault();

        }, true);

        // When key released
        element.addEventListener("keyup", function(e) {

            // Only intercept if handler set
            if (!guac_keyboard.onkeyup) return;

            // Ignore events which have already been handled
            if (!markEvent(e)) return;

            e.preventDefault();

            var keyCode;
            if (window.event) keyCode = window.event.keyCode;
            else if (e.which) keyCode = e.which;

            // Fix modifier states
            var keyupEvent = new KeyupEvent(keyCode, e.keyIdentifier, e.key, getEventLocation(e));
            syncModifierStates(e, keyupEvent);

            // Log event, call for interpretation
            eventLog.push(keyupEvent);
            interpret_events();

        }, true);

        /**
         * Handles the given "input" event, typing the data within the input text.
         * If the event is complete (text is provided), handling of "compositionend"
         * events is suspended, as such events may conflict with input events.
         *
         * @private
         * @param {InputEvent} e
         *     The "input" event to handle.
         */
        var handleInput = function handleInput(e) {

            // Only intercept if handler set
            if (!guac_keyboard.onkeydown && !guac_keyboard.onkeyup) return;

            // Ignore events which have already been handled
            if (!markEvent(e)) return;

            // Type all content written
            if (e.data && !e.isComposing) {
                element.removeEventListener("compositionend", handleComposition, false);
                guac_keyboard.type(e.data);
            }

        };

        /**
         * Handles the given "compositionend" event, typing the data within the
         * composed text. If the event is complete (composed text is provided),
         * handling of "input" events is suspended, as such events may conflict
         * with composition events.
         *
         * @private
         * @param {CompositionEvent} e
         *     The "compositionend" event to handle.
         */
        var handleComposition = function handleComposition(e) {

            // Only intercept if handler set
            if (!guac_keyboard.onkeydown && !guac_keyboard.onkeyup) return;

            // Ignore events which have already been handled
            if (!markEvent(e)) return;

            // Type all content written
            if (e.data) {
                element.removeEventListener("input", handleInput, false);
                guac_keyboard.type(e.data);
            }

        };

        // Automatically type text entered into the wrapped field
        element.addEventListener("input", handleInput, false);
        element.addEventListener("compositionend", handleComposition, false);

    };

    // Listen to given element, if any
    if (element)
        guac_keyboard.listenTo(element);

};

/**
 * The unique numerical identifier to assign to the next Guacamole.Keyboard
 * instance.
 *
 * @private
 * @type {Number}
 */
Guacamole.Keyboard._nextID = 0;

/**
 * The state of all supported keyboard modifiers.
 * @constructor
 */
Guacamole.Keyboard.ModifierState = function() {
    
    /**
     * Whether shift is currently pressed.
     * @type {Boolean}
     */
    this.shift = false;
    
    /**
     * Whether ctrl is currently pressed.
     * @type {Boolean}
     */
    this.ctrl = false;
    
    /**
     * Whether alt is currently pressed.
     * @type {Boolean}
     */
    this.alt = false;
    
    /**
     * Whether meta (apple key) is currently pressed.
     * @type {Boolean}
     */
    this.meta = false;

    /**
     * Whether hyper (windows key) is currently pressed.
     * @type {Boolean}
     */
    this.hyper = false;
    
};

/**
 * Returns the modifier state applicable to the keyboard event given.
 * 
 * @param {KeyboardEvent} e The keyboard event to read.
 * @returns {Guacamole.Keyboard.ModifierState} The current state of keyboard
 *                                             modifiers.
 */
Guacamole.Keyboard.ModifierState.fromKeyboardEvent = function(e) {
    
    var state = new Guacamole.Keyboard.ModifierState();

    // Assign states from old flags
    state.shift = e.shiftKey;
    state.ctrl  = e.ctrlKey;
    state.alt   = e.altKey;
    state.meta  = e.metaKey;

    // Use DOM3 getModifierState() for others
    if (e.getModifierState) {
        state.hyper = e.getModifierState("OS")
                   || e.getModifierState("Super")
                   || e.getModifierState("Hyper")
                   || e.getModifierState("Win");
    }

    return state;
    
};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract ordered drawing surface. Each Layer contains a canvas element and
 * provides simple drawing instructions for drawing to that canvas element,
 * however unlike the canvas element itself, drawing operations on a Layer are
 * guaranteed to run in order, even if such an operation must wait for an image
 * to load before completing.
 * 
 * @constructor
 * 
 * @param {Number} width The width of the Layer, in pixels. The canvas element
 *                       backing this Layer will be given this width.
 *                       
 * @param {Number} height The height of the Layer, in pixels. The canvas element
 *                        backing this Layer will be given this height.
 */
Guacamole.Layer = function(width, height) {

    /**
     * Reference to this Layer.
     * @private
     */
    var layer = this;

    /**
     * The number of pixels the width or height of a layer must change before
     * the underlying canvas is resized. The underlying canvas will be kept at
     * dimensions which are integer multiples of this factor.
     *
     * @private
     * @constant
     * @type Number
     */
    var CANVAS_SIZE_FACTOR = 64;

    /**
     * The canvas element backing this Layer.
     * @private
     */
    var canvas = document.createElement("canvas");

    /**
     * The 2D display context of the canvas element backing this Layer.
     * @private
     */
    var context = canvas.getContext("2d");
    context.save();

    /**
     * Whether the layer has not yet been drawn to. Once any draw operation
     * which affects the underlying canvas is invoked, this flag will be set to
     * false.
     *
     * @private
     * @type Boolean
     */
    var empty = true;

    /**
     * Whether a new path should be started with the next path drawing
     * operations.
     * @private
     */
    var pathClosed = true;

    /**
     * The number of states on the state stack.
     * 
     * Note that there will ALWAYS be one element on the stack, but that
     * element is not exposed. It is only used to reset the layer to its
     * initial state.
     * 
     * @private
     */
    var stackSize = 0;

    /**
     * Map of all Guacamole channel masks to HTML5 canvas composite operation
     * names. Not all channel mask combinations are currently implemented.
     * @private
     */
    var compositeOperation = {
     /* 0x0 NOT IMPLEMENTED */
        0x1: "destination-in",
        0x2: "destination-out",
     /* 0x3 NOT IMPLEMENTED */
        0x4: "source-in",
     /* 0x5 NOT IMPLEMENTED */
        0x6: "source-atop",
     /* 0x7 NOT IMPLEMENTED */
        0x8: "source-out",
        0x9: "destination-atop",
        0xA: "xor",
        0xB: "destination-over",
        0xC: "copy",
     /* 0xD NOT IMPLEMENTED */
        0xE: "source-over",
        0xF: "lighter"
    };

    /**
     * Resizes the canvas element backing this Layer. This function should only
     * be used internally.
     * 
     * @private
     * @param {Number} [newWidth=0]
     *     The new width to assign to this Layer.
     *
     * @param {Number} [newHeight=0]
     *     The new height to assign to this Layer.
     */
    var resize = function resize(newWidth, newHeight) {

        // Default size to zero
        newWidth = newWidth || 0;
        newHeight = newHeight || 0;

        // Calculate new dimensions of internal canvas
        var canvasWidth  = Math.ceil(newWidth  / CANVAS_SIZE_FACTOR) * CANVAS_SIZE_FACTOR;
        var canvasHeight = Math.ceil(newHeight / CANVAS_SIZE_FACTOR) * CANVAS_SIZE_FACTOR;

        // Resize only if canvas dimensions are actually changing
        if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {

            // Copy old data only if relevant and non-empty
            var oldData = null;
            if (!empty && canvas.width !== 0 && canvas.height !== 0) {

                // Create canvas and context for holding old data
                oldData = document.createElement("canvas");
                oldData.width = Math.min(layer.width, newWidth);
                oldData.height = Math.min(layer.height, newHeight);

                var oldDataContext = oldData.getContext("2d");

                // Copy image data from current
                oldDataContext.drawImage(canvas,
                        0, 0, oldData.width, oldData.height,
                        0, 0, oldData.width, oldData.height);

            }

            // Preserve composite operation
            var oldCompositeOperation = context.globalCompositeOperation;

            // Resize canvas
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Redraw old data, if any
            if (oldData)
                context.drawImage(oldData,
                    0, 0, oldData.width, oldData.height,
                    0, 0, oldData.width, oldData.height);

            // Restore composite operation
            context.globalCompositeOperation = oldCompositeOperation;

            // Acknowledge reset of stack (happens on resize of canvas)
            stackSize = 0;
            context.save();

        }

        // If the canvas size is not changing, manually force state reset
        else
            layer.reset();

        // Assign new layer dimensions
        layer.width = newWidth;
        layer.height = newHeight;

    };

    /**
     * Given the X and Y coordinates of the upper-left corner of a rectangle
     * and the rectangle's width and height, resize the backing canvas element
     * as necessary to ensure that the rectangle fits within the canvas
     * element's coordinate space. This function will only make the canvas
     * larger. If the rectangle already fits within the canvas element's
     * coordinate space, the canvas is left unchanged.
     * 
     * @private
     * @param {Number} x The X coordinate of the upper-left corner of the
     *                   rectangle to fit.
     * @param {Number} y The Y coordinate of the upper-left corner of the
     *                   rectangle to fit.
     * @param {Number} w The width of the the rectangle to fit.
     * @param {Number} h The height of the the rectangle to fit.
     */
    function fitRect(x, y, w, h) {
        
        // Calculate bounds
        var opBoundX = w + x;
        var opBoundY = h + y;
        
        // Determine max width
        var resizeWidth;
        if (opBoundX > layer.width)
            resizeWidth = opBoundX;
        else
            resizeWidth = layer.width;

        // Determine max height
        var resizeHeight;
        if (opBoundY > layer.height)
            resizeHeight = opBoundY;
        else
            resizeHeight = layer.height;

        // Resize if necessary
        layer.resize(resizeWidth, resizeHeight);

    }

    /**
     * Set to true if this Layer should resize itself to accomodate the
     * dimensions of any drawing operation, and false (the default) otherwise.
     * 
     * Note that setting this property takes effect immediately, and thus may
     * take effect on operations that were started in the past but have not
     * yet completed. If you wish the setting of this flag to only modify
     * future operations, you will need to make the setting of this flag an
     * operation with sync().
     * 
     * @example
     * // Set autosize to true for all future operations
     * layer.sync(function() {
     *     layer.autosize = true;
     * });
     * 
     * @type {Boolean}
     * @default false
     */
    this.autosize = false;

    /**
     * The current width of this layer.
     * @type {Number}
     */
    this.width = width;

    /**
     * The current height of this layer.
     * @type {Number}
     */
    this.height = height;

    /**
     * Returns the canvas element backing this Layer. Note that the dimensions
     * of the canvas may not exactly match those of the Layer, as resizing a
     * canvas while maintaining its state is an expensive operation.
     *
     * @returns {HTMLCanvasElement}
     *     The canvas element backing this Layer.
     */
    this.getCanvas = function getCanvas() {
        return canvas;
    };

    /**
     * Returns a new canvas element containing the same image as this Layer.
     * Unlike getCanvas(), the canvas element returned is guaranteed to have
     * the exact same dimensions as the Layer.
     *
     * @returns {HTMLCanvasElement}
     *     A new canvas element containing a copy of the image content this
     *     Layer.
     */
    this.toCanvas = function toCanvas() {

        // Create new canvas having same dimensions
        var canvas = document.createElement('canvas');
        canvas.width = layer.width;
        canvas.height = layer.height;

        // Copy image contents to new canvas
        var context = canvas.getContext('2d');
        context.drawImage(layer.getCanvas(), 0, 0);

        return canvas;

    };

    /**
     * Changes the size of this Layer to the given width and height. Resizing
     * is only attempted if the new size provided is actually different from
     * the current size.
     * 
     * @param {Number} newWidth The new width to assign to this Layer.
     * @param {Number} newHeight The new height to assign to this Layer.
     */
    this.resize = function(newWidth, newHeight) {
        if (newWidth !== layer.width || newHeight !== layer.height)
            resize(newWidth, newHeight);
    };

    /**
     * Draws the specified image at the given coordinates. The image specified
     * must already be loaded.
     * 
     * @param {Number} x
     *     The destination X coordinate.
     *
     * @param {Number} y
     *     The destination Y coordinate.
     *
     * @param {CanvasImageSource} image
     *     The image to draw. Note that this is not a URL.
     */
    this.drawImage = function(x, y, image) {
        if (layer.autosize) fitRect(x, y, image.width, image.height);
        context.drawImage(image, x, y);
        empty = false;
    };

    /**
     * Transfer a rectangle of image data from one Layer to this Layer using the
     * specified transfer function.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     * @param {Function} transferFunction The transfer function to use to
     *                                    transfer data from source to
     *                                    destination.
     */
    this.transfer = function(srcLayer, srcx, srcy, srcw, srch, x, y, transferFunction) {

        var srcCanvas = srcLayer.getCanvas();

        // If entire rectangle outside source canvas, stop
        if (srcx >= srcCanvas.width || srcy >= srcCanvas.height) return;

        // Otherwise, clip rectangle to area
        if (srcx + srcw > srcCanvas.width)
            srcw = srcCanvas.width - srcx;

        if (srcy + srch > srcCanvas.height)
            srch = srcCanvas.height - srcy;

        // Stop if nothing to draw.
        if (srcw === 0 || srch === 0) return;

        if (layer.autosize) fitRect(x, y, srcw, srch);

        // Get image data from src and dst
        var src = srcLayer.getCanvas().getContext("2d").getImageData(srcx, srcy, srcw, srch);
        var dst = context.getImageData(x , y, srcw, srch);

        // Apply transfer for each pixel
        for (var i=0; i<srcw*srch*4; i+=4) {

            // Get source pixel environment
            var src_pixel = new Guacamole.Layer.Pixel(
                src.data[i],
                src.data[i+1],
                src.data[i+2],
                src.data[i+3]
            );
                
            // Get destination pixel environment
            var dst_pixel = new Guacamole.Layer.Pixel(
                dst.data[i],
                dst.data[i+1],
                dst.data[i+2],
                dst.data[i+3]
            );

            // Apply transfer function
            transferFunction(src_pixel, dst_pixel);

            // Save pixel data
            dst.data[i  ] = dst_pixel.red;
            dst.data[i+1] = dst_pixel.green;
            dst.data[i+2] = dst_pixel.blue;
            dst.data[i+3] = dst_pixel.alpha;

        }

        // Draw image data
        context.putImageData(dst, x, y);
        empty = false;

    };

    /**
     * Put a rectangle of image data from one Layer to this Layer directly
     * without performing any alpha blending. Simply copy the data.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     */
    this.put = function(srcLayer, srcx, srcy, srcw, srch, x, y) {

        var srcCanvas = srcLayer.getCanvas();

        // If entire rectangle outside source canvas, stop
        if (srcx >= srcCanvas.width || srcy >= srcCanvas.height) return;

        // Otherwise, clip rectangle to area
        if (srcx + srcw > srcCanvas.width)
            srcw = srcCanvas.width - srcx;

        if (srcy + srch > srcCanvas.height)
            srch = srcCanvas.height - srcy;

        // Stop if nothing to draw.
        if (srcw === 0 || srch === 0) return;

        if (layer.autosize) fitRect(x, y, srcw, srch);

        // Get image data from src and dst
        var src = srcLayer.getCanvas().getContext("2d").getImageData(srcx, srcy, srcw, srch);
        context.putImageData(src, x, y);
        empty = false;

    };

    /**
     * Copy a rectangle of image data from one Layer to this Layer. This
     * operation will copy exactly the image data that will be drawn once all
     * operations of the source Layer that were pending at the time this
     * function was called are complete. This operation will not alter the
     * size of the source Layer even if its autosize property is set to true.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     */
    this.copy = function(srcLayer, srcx, srcy, srcw, srch, x, y) {

        var srcCanvas = srcLayer.getCanvas();

        // If entire rectangle outside source canvas, stop
        if (srcx >= srcCanvas.width || srcy >= srcCanvas.height) return;

        // Otherwise, clip rectangle to area
        if (srcx + srcw > srcCanvas.width)
            srcw = srcCanvas.width - srcx;

        if (srcy + srch > srcCanvas.height)
            srch = srcCanvas.height - srcy;

        // Stop if nothing to draw.
        if (srcw === 0 || srch === 0) return;

        if (layer.autosize) fitRect(x, y, srcw, srch);
        context.drawImage(srcCanvas, srcx, srcy, srcw, srch, x, y, srcw, srch);
        empty = false;

    };

    /**
     * Starts a new path at the specified point.
     * 
     * @param {Number} x The X coordinate of the point to draw.
     * @param {Number} y The Y coordinate of the point to draw.
     */
    this.moveTo = function(x, y) {
        
        // Start a new path if current path is closed
        if (pathClosed) {
            context.beginPath();
            pathClosed = false;
        }
        
        if (layer.autosize) fitRect(x, y, 0, 0);
        context.moveTo(x, y);

    };

    /**
     * Add the specified line to the current path.
     * 
     * @param {Number} x The X coordinate of the endpoint of the line to draw.
     * @param {Number} y The Y coordinate of the endpoint of the line to draw.
     */
    this.lineTo = function(x, y) {
        
        // Start a new path if current path is closed
        if (pathClosed) {
            context.beginPath();
            pathClosed = false;
        }
        
        if (layer.autosize) fitRect(x, y, 0, 0);
        context.lineTo(x, y);
        
    };

    /**
     * Add the specified arc to the current path.
     * 
     * @param {Number} x The X coordinate of the center of the circle which
     *                   will contain the arc.
     * @param {Number} y The Y coordinate of the center of the circle which
     *                   will contain the arc.
     * @param {Number} radius The radius of the circle.
     * @param {Number} startAngle The starting angle of the arc, in radians.
     * @param {Number} endAngle The ending angle of the arc, in radians.
     * @param {Boolean} negative Whether the arc should be drawn in order of
     *                           decreasing angle.
     */
    this.arc = function(x, y, radius, startAngle, endAngle, negative) {
        
        // Start a new path if current path is closed
        if (pathClosed) {
            context.beginPath();
            pathClosed = false;
        }
        
        if (layer.autosize) fitRect(x, y, 0, 0);
        context.arc(x, y, radius, startAngle, endAngle, negative);
        
    };

    /**
     * Starts a new path at the specified point.
     * 
     * @param {Number} cp1x The X coordinate of the first control point.
     * @param {Number} cp1y The Y coordinate of the first control point.
     * @param {Number} cp2x The X coordinate of the second control point.
     * @param {Number} cp2y The Y coordinate of the second control point.
     * @param {Number} x The X coordinate of the endpoint of the curve.
     * @param {Number} y The Y coordinate of the endpoint of the curve.
     */
    this.curveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
        
        // Start a new path if current path is closed
        if (pathClosed) {
            context.beginPath();
            pathClosed = false;
        }
        
        if (layer.autosize) fitRect(x, y, 0, 0);
        context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        
    };

    /**
     * Closes the current path by connecting the end point with the start
     * point (if any) with a straight line.
     */
    this.close = function() {
        context.closePath();
        pathClosed = true;
    };

    /**
     * Add the specified rectangle to the current path.
     * 
     * @param {Number} x The X coordinate of the upper-left corner of the
     *                   rectangle to draw.
     * @param {Number} y The Y coordinate of the upper-left corner of the
     *                   rectangle to draw.
     * @param {Number} w The width of the rectangle to draw.
     * @param {Number} h The height of the rectangle to draw.
     */
    this.rect = function(x, y, w, h) {
            
        // Start a new path if current path is closed
        if (pathClosed) {
            context.beginPath();
            pathClosed = false;
        }
        
        if (layer.autosize) fitRect(x, y, w, h);
        context.rect(x, y, w, h);
        
    };

    /**
     * Clip all future drawing operations by the current path. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as fillColor()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     */
    this.clip = function() {

        // Set new clipping region
        context.clip();

        // Path now implicitly closed
        pathClosed = true;

    };

    /**
     * Stroke the current path with the specified color. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {String} cap The line cap style. Can be "round", "square",
     *                     or "butt".
     * @param {String} join The line join style. Can be "round", "bevel",
     *                      or "miter".
     * @param {Number} thickness The line thickness in pixels.
     * @param {Number} r The red component of the color to fill.
     * @param {Number} g The green component of the color to fill.
     * @param {Number} b The blue component of the color to fill.
     * @param {Number} a The alpha component of the color to fill.
     */
    this.strokeColor = function(cap, join, thickness, r, g, b, a) {

        // Stroke with color
        context.lineCap = cap;
        context.lineJoin = join;
        context.lineWidth = thickness;
        context.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + a/255.0 + ")";
        context.stroke();
        empty = false;

        // Path now implicitly closed
        pathClosed = true;

    };

    /**
     * Fills the current path with the specified color. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Number} r The red component of the color to fill.
     * @param {Number} g The green component of the color to fill.
     * @param {Number} b The blue component of the color to fill.
     * @param {Number} a The alpha component of the color to fill.
     */
    this.fillColor = function(r, g, b, a) {

        // Fill with color
        context.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a/255.0 + ")";
        context.fill();
        empty = false;

        // Path now implicitly closed
        pathClosed = true;

    };

    /**
     * Stroke the current path with the image within the specified layer. The
     * image data will be tiled infinitely within the stroke. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {String} cap The line cap style. Can be "round", "square",
     *                     or "butt".
     * @param {String} join The line join style. Can be "round", "bevel",
     *                      or "miter".
     * @param {Number} thickness The line thickness in pixels.
     * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
     *                                   within the stroke.
     */
    this.strokeLayer = function(cap, join, thickness, srcLayer) {

        // Stroke with image data
        context.lineCap = cap;
        context.lineJoin = join;
        context.lineWidth = thickness;
        context.strokeStyle = context.createPattern(
            srcLayer.getCanvas(),
            "repeat"
        );
        context.stroke();
        empty = false;

        // Path now implicitly closed
        pathClosed = true;

    };

    /**
     * Fills the current path with the image within the specified layer. The
     * image data will be tiled infinitely within the stroke. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
     *                                   within the fill.
     */
    this.fillLayer = function(srcLayer) {

        // Fill with image data 
        context.fillStyle = context.createPattern(
            srcLayer.getCanvas(),
            "repeat"
        );
        context.fill();
        empty = false;

        // Path now implicitly closed
        pathClosed = true;

    };

    /**
     * Push current layer state onto stack.
     */
    this.push = function() {

        // Save current state onto stack
        context.save();
        stackSize++;

    };

    /**
     * Pop layer state off stack.
     */
    this.pop = function() {

        // Restore current state from stack
        if (stackSize > 0) {
            context.restore();
            stackSize--;
        }

    };

    /**
     * Reset the layer, clearing the stack, the current path, and any transform
     * matrix.
     */
    this.reset = function() {

        // Clear stack
        while (stackSize > 0) {
            context.restore();
            stackSize--;
        }

        // Restore to initial state
        context.restore();
        context.save();

        // Clear path
        context.beginPath();
        pathClosed = false;

    };

    /**
     * Sets the given affine transform (defined with six values from the
     * transform's matrix).
     * 
     * @param {Number} a The first value in the affine transform's matrix.
     * @param {Number} b The second value in the affine transform's matrix.
     * @param {Number} c The third value in the affine transform's matrix.
     * @param {Number} d The fourth value in the affine transform's matrix.
     * @param {Number} e The fifth value in the affine transform's matrix.
     * @param {Number} f The sixth value in the affine transform's matrix.
     */
    this.setTransform = function(a, b, c, d, e, f) {
        context.setTransform(
            a, b, c,
            d, e, f
          /*0, 0, 1*/
        );
    };

    /**
     * Applies the given affine transform (defined with six values from the
     * transform's matrix).
     * 
     * @param {Number} a The first value in the affine transform's matrix.
     * @param {Number} b The second value in the affine transform's matrix.
     * @param {Number} c The third value in the affine transform's matrix.
     * @param {Number} d The fourth value in the affine transform's matrix.
     * @param {Number} e The fifth value in the affine transform's matrix.
     * @param {Number} f The sixth value in the affine transform's matrix.
     */
    this.transform = function(a, b, c, d, e, f) {
        context.transform(
            a, b, c,
            d, e, f
          /*0, 0, 1*/
        );
    };

    /**
     * Sets the channel mask for future operations on this Layer.
     * 
     * The channel mask is a Guacamole-specific compositing operation identifier
     * with a single bit representing each of four channels (in order): source
     * image where destination transparent, source where destination opaque,
     * destination where source transparent, and destination where source
     * opaque.
     * 
     * @param {Number} mask The channel mask for future operations on this
     *                      Layer.
     */
    this.setChannelMask = function(mask) {
        context.globalCompositeOperation = compositeOperation[mask];
    };

    /**
     * Sets the miter limit for stroke operations using the miter join. This
     * limit is the maximum ratio of the size of the miter join to the stroke
     * width. If this ratio is exceeded, the miter will not be drawn for that
     * joint of the path.
     * 
     * @param {Number} limit The miter limit for stroke operations using the
     *                       miter join.
     */
    this.setMiterLimit = function(limit) {
        context.miterLimit = limit;
    };

    // Initialize canvas dimensions
    resize(width, height);

    // Explicitly render canvas below other elements in the layer (such as
    // child layers). Chrome and others may fail to render layers properly
    // without this.
    canvas.style.zIndex = -1;

};

/**
 * Channel mask for the composite operation "rout".
 */
Guacamole.Layer.ROUT  = 0x2;

/**
 * Channel mask for the composite operation "atop".
 */
Guacamole.Layer.ATOP  = 0x6;

/**
 * Channel mask for the composite operation "xor".
 */
Guacamole.Layer.XOR   = 0xA;

/**
 * Channel mask for the composite operation "rover".
 */
Guacamole.Layer.ROVER = 0xB;

/**
 * Channel mask for the composite operation "over".
 */
Guacamole.Layer.OVER  = 0xE;

/**
 * Channel mask for the composite operation "plus".
 */
Guacamole.Layer.PLUS  = 0xF;

/**
 * Channel mask for the composite operation "rin".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.RIN   = 0x1;

/**
 * Channel mask for the composite operation "in".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.IN    = 0x4;

/**
 * Channel mask for the composite operation "out".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.OUT   = 0x8;

/**
 * Channel mask for the composite operation "ratop".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.RATOP = 0x9;

/**
 * Channel mask for the composite operation "src".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.SRC   = 0xC;

/**
 * Represents a single pixel of image data. All components have a minimum value
 * of 0 and a maximum value of 255.
 * 
 * @constructor
 * 
 * @param {Number} r The red component of this pixel.
 * @param {Number} g The green component of this pixel.
 * @param {Number} b The blue component of this pixel.
 * @param {Number} a The alpha component of this pixel.
 */
Guacamole.Layer.Pixel = function(r, g, b, a) {

    /**
     * The red component of this pixel, where 0 is the minimum value,
     * and 255 is the maximum.
     */
    this.red   = r;

    /**
     * The green component of this pixel, where 0 is the minimum value,
     * and 255 is the maximum.
     */
    this.green = g;

    /**
     * The blue component of this pixel, where 0 is the minimum value,
     * and 255 is the maximum.
     */
    this.blue  = b;

    /**
     * The alpha component of this pixel, where 0 is the minimum value,
     * and 255 is the maximum.
     */
    this.alpha = a;

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Provides cross-browser mouse events for a given element. The events of
 * the given element are automatically populated with handlers that translate
 * mouse events into a non-browser-specific event provided by the
 * Guacamole.Mouse instance.
 * 
 * @constructor
 * @param {Element} element The Element to use to provide mouse events.
 */
Guacamole.Mouse = function(element) {

    /**
     * Reference to this Guacamole.Mouse.
     * @private
     */
    var guac_mouse = this;

    /**
     * The number of mousemove events to require before re-enabling mouse
     * event handling after receiving a touch event.
     */
    this.touchMouseThreshold = 3;

    /**
     * The minimum amount of pixels scrolled required for a single scroll button
     * click.
     */
    this.scrollThreshold = 53;

    /**
     * The number of pixels to scroll per line.
     */
    this.PIXELS_PER_LINE = 18;

    /**
     * The number of pixels to scroll per page.
     */
    this.PIXELS_PER_PAGE = this.PIXELS_PER_LINE * 16;

    /**
     * The current mouse state. The properties of this state are updated when
     * mouse events fire. This state object is also passed in as a parameter to
     * the handler of any mouse events.
     * 
     * @type {Guacamole.Mouse.State}
     */
    this.currentState = new Guacamole.Mouse.State(
        0, 0, 
        false, false, false, false, false
    );

    /**
     * Fired whenever the user presses a mouse button down over the element
     * associated with this Guacamole.Mouse.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousedown = null;

    /**
     * Fired whenever the user releases a mouse button down over the element
     * associated with this Guacamole.Mouse.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmouseup = null;

    /**
     * Fired whenever the user moves the mouse over the element associated with
     * this Guacamole.Mouse.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousemove = null;

    /**
     * Fired whenever the mouse leaves the boundaries of the element associated
     * with this Guacamole.Mouse.
     * 
     * @event
     */
	this.onmouseout = null;

    /**
     * Counter of mouse events to ignore. This decremented by mousemove, and
     * while non-zero, mouse events will have no effect.
     * @private
     */
    var ignore_mouse = 0;

    /**
     * Cumulative scroll delta amount. This value is accumulated through scroll
     * events and results in scroll button clicks if it exceeds a certain
     * threshold.
     *
     * @private
     */
    var scroll_delta = 0;

    function cancelEvent(e) {
        e.stopPropagation();
        if (e.preventDefault) e.preventDefault();
        e.returnValue = false;
    }

    // Block context menu so right-click gets sent properly
    element.addEventListener("contextmenu", function(e) {
        cancelEvent(e);
    }, false);

    element.addEventListener("mousemove", function(e) {

        cancelEvent(e);

        // If ignoring events, decrement counter
        if (ignore_mouse) {
            ignore_mouse--;
            return;
        }

        guac_mouse.currentState.fromClientPosition(element, e.clientX, e.clientY);

        if (guac_mouse.onmousemove)
            guac_mouse.onmousemove(guac_mouse.currentState);

    }, false);

    element.addEventListener("mousedown", function(e) {

        cancelEvent(e);

        // Do not handle if ignoring events
        if (ignore_mouse)
            return;

        switch (e.button) {
            case 0:
                guac_mouse.currentState.left = true;
                break;
            case 1:
                guac_mouse.currentState.middle = true;
                break;
            case 2:
                guac_mouse.currentState.right = true;
                break;
        }

        if (guac_mouse.onmousedown)
            guac_mouse.onmousedown(guac_mouse.currentState);

    }, false);

    element.addEventListener("mouseup", function(e) {

        cancelEvent(e);

        // Do not handle if ignoring events
        if (ignore_mouse)
            return;

        switch (e.button) {
            case 0:
                guac_mouse.currentState.left = false;
                break;
            case 1:
                guac_mouse.currentState.middle = false;
                break;
            case 2:
                guac_mouse.currentState.right = false;
                break;
        }

        if (guac_mouse.onmouseup)
            guac_mouse.onmouseup(guac_mouse.currentState);

    }, false);

    element.addEventListener("mouseout", function(e) {

        // Get parent of the element the mouse pointer is leaving
       	if (!e) e = window.event;

        // Check that mouseout is due to actually LEAVING the element
        var target = e.relatedTarget || e.toElement;
        while (target) {
            if (target === element)
                return;
            target = target.parentNode;
        }

        cancelEvent(e);

        // Release all buttons
        if (guac_mouse.currentState.left
            || guac_mouse.currentState.middle
            || guac_mouse.currentState.right) {

            guac_mouse.currentState.left = false;
            guac_mouse.currentState.middle = false;
            guac_mouse.currentState.right = false;

            if (guac_mouse.onmouseup)
                guac_mouse.onmouseup(guac_mouse.currentState);
        }

        // Fire onmouseout event
        if (guac_mouse.onmouseout)
            guac_mouse.onmouseout();

    }, false);

    // Override selection on mouse event element.
    element.addEventListener("selectstart", function(e) {
        cancelEvent(e);
    }, false);

    // Ignore all pending mouse events when touch events are the apparent source
    function ignorePendingMouseEvents() { ignore_mouse = guac_mouse.touchMouseThreshold; }

    element.addEventListener("touchmove",  ignorePendingMouseEvents, false);
    element.addEventListener("touchstart", ignorePendingMouseEvents, false);
    element.addEventListener("touchend",   ignorePendingMouseEvents, false);

    // Scroll wheel support
    function mousewheel_handler(e) {

        // Determine approximate scroll amount (in pixels)
        var delta = e.deltaY || -e.wheelDeltaY || -e.wheelDelta;

        // If successfully retrieved scroll amount, convert to pixels if not
        // already in pixels
        if (delta) {

            // Convert to pixels if delta was lines
            if (e.deltaMode === 1)
                delta = e.deltaY * guac_mouse.PIXELS_PER_LINE;

            // Convert to pixels if delta was pages
            else if (e.deltaMode === 2)
                delta = e.deltaY * guac_mouse.PIXELS_PER_PAGE;

        }

        // Otherwise, assume legacy mousewheel event and line scrolling
        else
            delta = e.detail * guac_mouse.PIXELS_PER_LINE;
        
        // Update overall delta
        scroll_delta += delta;

        // Up
        if (scroll_delta <= -guac_mouse.scrollThreshold) {

            // Repeatedly click the up button until insufficient delta remains
            do {

                if (guac_mouse.onmousedown) {
                    guac_mouse.currentState.up = true;
                    guac_mouse.onmousedown(guac_mouse.currentState);
                }

                if (guac_mouse.onmouseup) {
                    guac_mouse.currentState.up = false;
                    guac_mouse.onmouseup(guac_mouse.currentState);
                }

                scroll_delta += guac_mouse.scrollThreshold;

            } while (scroll_delta <= -guac_mouse.scrollThreshold);

            // Reset delta
            scroll_delta = 0;

        }

        // Down
        if (scroll_delta >= guac_mouse.scrollThreshold) {

            // Repeatedly click the down button until insufficient delta remains
            do {

                if (guac_mouse.onmousedown) {
                    guac_mouse.currentState.down = true;
                    guac_mouse.onmousedown(guac_mouse.currentState);
                }

                if (guac_mouse.onmouseup) {
                    guac_mouse.currentState.down = false;
                    guac_mouse.onmouseup(guac_mouse.currentState);
                }

                scroll_delta -= guac_mouse.scrollThreshold;

            } while (scroll_delta >= guac_mouse.scrollThreshold);

            // Reset delta
            scroll_delta = 0;

        }

        cancelEvent(e);

    }

    element.addEventListener('DOMMouseScroll', mousewheel_handler, false);
    element.addEventListener('mousewheel',     mousewheel_handler, false);
    element.addEventListener('wheel',          mousewheel_handler, false);

    /**
     * Whether the browser supports CSS3 cursor styling, including hotspot
     * coordinates.
     *
     * @private
     * @type {Boolean}
     */
    var CSS3_CURSOR_SUPPORTED = (function() {

        var div = document.createElement("div");

        // If no cursor property at all, then no support
        if (!("cursor" in div.style))
            return false;

        try {
            // Apply simple 1x1 PNG
            div.style.cursor = "url(data:image/png;base64,"
                             + "iVBORw0KGgoAAAANSUhEUgAAAAEAAAAB"
                             + "AQMAAAAl21bKAAAAA1BMVEX///+nxBvI"
                             + "AAAACklEQVQI12NgAAAAAgAB4iG8MwAA"
                             + "AABJRU5ErkJggg==) 0 0, auto";
        }
        catch (e) {
            return false;
        }

        // Verify cursor property is set to URL with hotspot
        return /\burl\([^()]*\)\s+0\s+0\b/.test(div.style.cursor || "");

    })();

    /**
     * Changes the local mouse cursor to the given canvas, having the given
     * hotspot coordinates. This affects styling of the element backing this
     * Guacamole.Mouse only, and may fail depending on browser support for
     * setting the mouse cursor.
     * 
     * If setting the local cursor is desired, it is up to the implementation
     * to do something else, such as use the software cursor built into
     * Guacamole.Display, if the local cursor cannot be set.
     *
     * @param {HTMLCanvasElement} canvas The cursor image.
     * @param {Number} x The X-coordinate of the cursor hotspot.
     * @param {Number} y The Y-coordinate of the cursor hotspot.
     * @return {Boolean} true if the cursor was successfully set, false if the
     *                   cursor could not be set for any reason.
     */
    this.setCursor = function(canvas, x, y) {

        // Attempt to set via CSS3 cursor styling
        if (CSS3_CURSOR_SUPPORTED) {
            var dataURL = canvas.toDataURL('image/png');
            element.style.cursor = "url(" + dataURL + ") " + x + " " + y + ", auto";
            return true;
        }

        // Otherwise, setting cursor failed
        return false;

    };

};

/**
 * Simple container for properties describing the state of a mouse.
 * 
 * @constructor
 * @param {Number} x The X position of the mouse pointer in pixels.
 * @param {Number} y The Y position of the mouse pointer in pixels.
 * @param {Boolean} left Whether the left mouse button is pressed. 
 * @param {Boolean} middle Whether the middle mouse button is pressed. 
 * @param {Boolean} right Whether the right mouse button is pressed. 
 * @param {Boolean} up Whether the up mouse button is pressed (the fourth
 *                     button, usually part of a scroll wheel). 
 * @param {Boolean} down Whether the down mouse button is pressed (the fifth
 *                       button, usually part of a scroll wheel). 
 */
Guacamole.Mouse.State = function(x, y, left, middle, right, up, down) {

    /**
     * Reference to this Guacamole.Mouse.State.
     * @private
     */
    var guac_state = this;

    /**
     * The current X position of the mouse pointer.
     * @type {Number}
     */
    this.x = x;

    /**
     * The current Y position of the mouse pointer.
     * @type {Number}
     */
    this.y = y;

    /**
     * Whether the left mouse button is currently pressed.
     * @type {Boolean}
     */
    this.left = left;

    /**
     * Whether the middle mouse button is currently pressed.
     * @type {Boolean}
     */
    this.middle = middle;

    /**
     * Whether the right mouse button is currently pressed.
     * @type {Boolean}
     */
    this.right = right;

    /**
     * Whether the up mouse button is currently pressed. This is the fourth
     * mouse button, associated with upward scrolling of the mouse scroll
     * wheel.
     * @type {Boolean}
     */
    this.up = up;

    /**
     * Whether the down mouse button is currently pressed. This is the fifth 
     * mouse button, associated with downward scrolling of the mouse scroll
     * wheel.
     * @type {Boolean}
     */
    this.down = down;

    /**
     * Updates the position represented within this state object by the given
     * element and clientX/clientY coordinates (commonly available within event
     * objects). Position is translated from clientX/clientY (relative to
     * viewport) to element-relative coordinates.
     * 
     * @param {Element} element The element the coordinates should be relative
     *                          to.
     * @param {Number} clientX The X coordinate to translate, viewport-relative.
     * @param {Number} clientY The Y coordinate to translate, viewport-relative.
     */
    this.fromClientPosition = function(element, clientX, clientY) {
    
        guac_state.x = clientX - element.offsetLeft;
        guac_state.y = clientY - element.offsetTop;

        // This is all JUST so we can get the mouse position within the element
        var parent = element.offsetParent;
        while (parent && !(parent === document.body)) {
            guac_state.x -= parent.offsetLeft - parent.scrollLeft;
            guac_state.y -= parent.offsetTop  - parent.scrollTop;

            parent = parent.offsetParent;
        }

        // Element ultimately depends on positioning within document body,
        // take document scroll into account. 
        if (parent) {
            var documentScrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;
            var documentScrollTop = document.body.scrollTop || document.documentElement.scrollTop;

            guac_state.x -= parent.offsetLeft - documentScrollLeft;
            guac_state.y -= parent.offsetTop  - documentScrollTop;
        }

    };

};

/**
 * Provides cross-browser relative touch event translation for a given element.
 * 
 * Touch events are translated into mouse events as if the touches occurred
 * on a touchpad (drag to push the mouse pointer, tap to click).
 * 
 * @constructor
 * @param {Element} element The Element to use to provide touch events.
 */
Guacamole.Mouse.Touchpad = function(element) {

    /**
     * Reference to this Guacamole.Mouse.Touchpad.
     * @private
     */
    var guac_touchpad = this;

    /**
     * The distance a two-finger touch must move per scrollwheel event, in
     * pixels.
     */
    this.scrollThreshold = 20 * (window.devicePixelRatio || 1);

    /**
     * The maximum number of milliseconds to wait for a touch to end for the
     * gesture to be considered a click.
     */
    this.clickTimingThreshold = 250;

    /**
     * The maximum number of pixels to allow a touch to move for the gesture to
     * be considered a click.
     */
    this.clickMoveThreshold = 10 * (window.devicePixelRatio || 1);

    /**
     * The current mouse state. The properties of this state are updated when
     * mouse events fire. This state object is also passed in as a parameter to
     * the handler of any mouse events.
     * 
     * @type {Guacamole.Mouse.State}
     */
    this.currentState = new Guacamole.Mouse.State(
        0, 0, 
        false, false, false, false, false
    );

    /**
     * Fired whenever a mouse button is effectively pressed. This can happen
     * as part of a "click" gesture initiated by the user by tapping one
     * or more fingers over the touchpad element, as part of a "scroll"
     * gesture initiated by dragging two fingers up or down, etc.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousedown = null;

    /**
     * Fired whenever a mouse button is effectively released. This can happen
     * as part of a "click" gesture initiated by the user by tapping one
     * or more fingers over the touchpad element, as part of a "scroll"
     * gesture initiated by dragging two fingers up or down, etc.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmouseup = null;

    /**
     * Fired whenever the user moves the mouse by dragging their finger over
     * the touchpad element.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousemove = null;

    var touch_count = 0;
    var last_touch_x = 0;
    var last_touch_y = 0;
    var last_touch_time = 0;
    var pixels_moved = 0;

    var touch_buttons = {
        1: "left",
        2: "right",
        3: "middle"
    };

    var gesture_in_progress = false;
    var click_release_timeout = null;

    element.addEventListener("touchend", function(e) {
        
        e.preventDefault();
            
        // If we're handling a gesture AND this is the last touch
        if (gesture_in_progress && e.touches.length === 0) {
            
            var time = new Date().getTime();

            // Get corresponding mouse button
            var button = touch_buttons[touch_count];

            // If mouse already down, release anad clear timeout
            if (guac_touchpad.currentState[button]) {

                // Fire button up event
                guac_touchpad.currentState[button] = false;
                if (guac_touchpad.onmouseup)
                    guac_touchpad.onmouseup(guac_touchpad.currentState);

                // Clear timeout, if set
                if (click_release_timeout) {
                    window.clearTimeout(click_release_timeout);
                    click_release_timeout = null;
                }

            }

            // If single tap detected (based on time and distance)
            if (time - last_touch_time <= guac_touchpad.clickTimingThreshold
                    && pixels_moved < guac_touchpad.clickMoveThreshold) {

                // Fire button down event
                guac_touchpad.currentState[button] = true;
                if (guac_touchpad.onmousedown)
                    guac_touchpad.onmousedown(guac_touchpad.currentState);

                // Delay mouse up - mouse up should be canceled if
                // touchstart within timeout.
                click_release_timeout = window.setTimeout(function() {
                    
                    // Fire button up event
                    guac_touchpad.currentState[button] = false;
                    if (guac_touchpad.onmouseup)
                        guac_touchpad.onmouseup(guac_touchpad.currentState);
                    
                    // Gesture now over
                    gesture_in_progress = false;

                }, guac_touchpad.clickTimingThreshold);

            }

            // If we're not waiting to see if this is a click, stop gesture
            if (!click_release_timeout)
                gesture_in_progress = false;

        }

    }, false);

    element.addEventListener("touchstart", function(e) {

        e.preventDefault();

        // Track number of touches, but no more than three
        touch_count = Math.min(e.touches.length, 3);

        // Clear timeout, if set
        if (click_release_timeout) {
            window.clearTimeout(click_release_timeout);
            click_release_timeout = null;
        }

        // Record initial touch location and time for touch movement
        // and tap gestures
        if (!gesture_in_progress) {

            // Stop mouse events while touching
            gesture_in_progress = true;

            // Record touch location and time
            var starting_touch = e.touches[0];
            last_touch_x = starting_touch.clientX;
            last_touch_y = starting_touch.clientY;
            last_touch_time = new Date().getTime();
            pixels_moved = 0;

        }

    }, false);

    element.addEventListener("touchmove", function(e) {

        e.preventDefault();

        // Get change in touch location
        var touch = e.touches[0];
        var delta_x = touch.clientX - last_touch_x;
        var delta_y = touch.clientY - last_touch_y;

        // Track pixels moved
        pixels_moved += Math.abs(delta_x) + Math.abs(delta_y);

        // If only one touch involved, this is mouse move
        if (touch_count === 1) {

            // Calculate average velocity in Manhatten pixels per millisecond
            var velocity = pixels_moved / (new Date().getTime() - last_touch_time);

            // Scale mouse movement relative to velocity
            var scale = 1 + velocity;

            // Update mouse location
            guac_touchpad.currentState.x += delta_x*scale;
            guac_touchpad.currentState.y += delta_y*scale;

            // Prevent mouse from leaving screen

            if (guac_touchpad.currentState.x < 0)
                guac_touchpad.currentState.x = 0;
            else if (guac_touchpad.currentState.x >= element.offsetWidth)
                guac_touchpad.currentState.x = element.offsetWidth - 1;

            if (guac_touchpad.currentState.y < 0)
                guac_touchpad.currentState.y = 0;
            else if (guac_touchpad.currentState.y >= element.offsetHeight)
                guac_touchpad.currentState.y = element.offsetHeight - 1;

            // Fire movement event, if defined
            if (guac_touchpad.onmousemove)
                guac_touchpad.onmousemove(guac_touchpad.currentState);

            // Update touch location
            last_touch_x = touch.clientX;
            last_touch_y = touch.clientY;

        }

        // Interpret two-finger swipe as scrollwheel
        else if (touch_count === 2) {

            // If change in location passes threshold for scroll
            if (Math.abs(delta_y) >= guac_touchpad.scrollThreshold) {

                // Decide button based on Y movement direction
                var button;
                if (delta_y > 0) button = "down";
                else             button = "up";

                // Fire button down event
                guac_touchpad.currentState[button] = true;
                if (guac_touchpad.onmousedown)
                    guac_touchpad.onmousedown(guac_touchpad.currentState);

                // Fire button up event
                guac_touchpad.currentState[button] = false;
                if (guac_touchpad.onmouseup)
                    guac_touchpad.onmouseup(guac_touchpad.currentState);

                // Only update touch location after a scroll has been
                // detected
                last_touch_x = touch.clientX;
                last_touch_y = touch.clientY;

            }

        }

    }, false);

};

/**
 * Provides cross-browser absolute touch event translation for a given element.
 *
 * Touch events are translated into mouse events as if the touches occurred
 * on a touchscreen (tapping anywhere on the screen clicks at that point,
 * long-press to right-click).
 *
 * @constructor
 * @param {Element} element The Element to use to provide touch events.
 */
Guacamole.Mouse.Touchscreen = function(element) {

    /**
     * Reference to this Guacamole.Mouse.Touchscreen.
     * @private
     */
    var guac_touchscreen = this;

    /**
     * Whether a gesture is known to be in progress. If false, touch events
     * will be ignored.
     *
     * @private
     */
    var gesture_in_progress = false;

    /**
     * The start X location of a gesture.
     * @private
     */
    var gesture_start_x = null;

    /**
     * The start Y location of a gesture.
     * @private
     */
    var gesture_start_y = null;

    /**
     * The timeout associated with the delayed, cancellable click release.
     *
     * @private
     */
    var click_release_timeout = null;

    /**
     * The timeout associated with long-press for right click.
     *
     * @private
     */
    var long_press_timeout = null;

    /**
     * The distance a two-finger touch must move per scrollwheel event, in
     * pixels.
     */
    this.scrollThreshold = 20 * (window.devicePixelRatio || 1);

    /**
     * The maximum number of milliseconds to wait for a touch to end for the
     * gesture to be considered a click.
     */
    this.clickTimingThreshold = 250;

    /**
     * The maximum number of pixels to allow a touch to move for the gesture to
     * be considered a click.
     */
    this.clickMoveThreshold = 16 * (window.devicePixelRatio || 1);

    /**
     * The amount of time a press must be held for long press to be
     * detected.
     */
    this.longPressThreshold = 500;

    /**
     * The current mouse state. The properties of this state are updated when
     * mouse events fire. This state object is also passed in as a parameter to
     * the handler of any mouse events.
     *
     * @type {Guacamole.Mouse.State}
     */
    this.currentState = new Guacamole.Mouse.State(
        0, 0,
        false, false, false, false, false
    );

    /**
     * Fired whenever a mouse button is effectively pressed. This can happen
     * as part of a "mousedown" gesture initiated by the user by pressing one
     * finger over the touchscreen element, as part of a "scroll" gesture
     * initiated by dragging two fingers up or down, etc.
     *
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousedown = null;

    /**
     * Fired whenever a mouse button is effectively released. This can happen
     * as part of a "mouseup" gesture initiated by the user by removing the
     * finger pressed against the touchscreen element, or as part of a "scroll"
     * gesture initiated by dragging two fingers up or down, etc.
     *
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmouseup = null;

    /**
     * Fired whenever the user moves the mouse by dragging their finger over
     * the touchscreen element. Note that unlike Guacamole.Mouse.Touchpad,
     * dragging a finger over the touchscreen element will always cause
     * the mouse button to be effectively down, as if clicking-and-dragging.
     *
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousemove = null;

    /**
     * Presses the given mouse button, if it isn't already pressed. Valid
     * button values are "left", "middle", "right", "up", and "down".
     *
     * @private
     * @param {String} button The mouse button to press.
     */
    function press_button(button) {
        if (!guac_touchscreen.currentState[button]) {
            guac_touchscreen.currentState[button] = true;
            if (guac_touchscreen.onmousedown)
                guac_touchscreen.onmousedown(guac_touchscreen.currentState);
        }
    }

    /**
     * Releases the given mouse button, if it isn't already released. Valid
     * button values are "left", "middle", "right", "up", and "down".
     *
     * @private
     * @param {String} button The mouse button to release.
     */
    function release_button(button) {
        if (guac_touchscreen.currentState[button]) {
            guac_touchscreen.currentState[button] = false;
            if (guac_touchscreen.onmouseup)
                guac_touchscreen.onmouseup(guac_touchscreen.currentState);
        }
    }

    /**
     * Clicks (presses and releases) the given mouse button. Valid button
     * values are "left", "middle", "right", "up", and "down".
     *
     * @private
     * @param {String} button The mouse button to click.
     */
    function click_button(button) {
        press_button(button);
        release_button(button);
    }

    /**
     * Moves the mouse to the given coordinates. These coordinates must be
     * relative to the browser window, as they will be translated based on
     * the touch event target's location within the browser window.
     *
     * @private
     * @param {Number} x The X coordinate of the mouse pointer.
     * @param {Number} y The Y coordinate of the mouse pointer.
     */
    function move_mouse(x, y) {
        guac_touchscreen.currentState.fromClientPosition(element, x, y);
        if (guac_touchscreen.onmousemove)
            guac_touchscreen.onmousemove(guac_touchscreen.currentState);
    }

    /**
     * Returns whether the given touch event exceeds the movement threshold for
     * clicking, based on where the touch gesture began.
     *
     * @private
     * @param {TouchEvent} e The touch event to check.
     * @return {Boolean} true if the movement threshold is exceeded, false
     *                   otherwise.
     */
    function finger_moved(e) {
        var touch = e.touches[0] || e.changedTouches[0];
        var delta_x = touch.clientX - gesture_start_x;
        var delta_y = touch.clientY - gesture_start_y;
        return Math.sqrt(delta_x*delta_x + delta_y*delta_y) >= guac_touchscreen.clickMoveThreshold;
    }

    /**
     * Begins a new gesture at the location of the first touch in the given
     * touch event.
     * 
     * @private
     * @param {TouchEvent} e The touch event beginning this new gesture.
     */
    function begin_gesture(e) {
        var touch = e.touches[0];
        gesture_in_progress = true;
        gesture_start_x = touch.clientX;
        gesture_start_y = touch.clientY;
    }

    /**
     * End the current gesture entirely. Wait for all touches to be done before
     * resuming gesture detection.
     * 
     * @private
     */
    function end_gesture() {
        window.clearTimeout(click_release_timeout);
        window.clearTimeout(long_press_timeout);
        gesture_in_progress = false;
    }

    element.addEventListener("touchend", function(e) {

        // Do not handle if no gesture
        if (!gesture_in_progress)
            return;

        // Ignore if more than one touch
        if (e.touches.length !== 0 || e.changedTouches.length !== 1) {
            end_gesture();
            return;
        }

        // Long-press, if any, is over
        window.clearTimeout(long_press_timeout);

        // Always release mouse button if pressed
        release_button("left");

        // If finger hasn't moved enough to cancel the click
        if (!finger_moved(e)) {

            e.preventDefault();

            // If not yet pressed, press and start delay release
            if (!guac_touchscreen.currentState.left) {

                var touch = e.changedTouches[0];
                move_mouse(touch.clientX, touch.clientY);
                press_button("left");

                // Release button after a delay, if not canceled
                click_release_timeout = window.setTimeout(function() {
                    release_button("left");
                    end_gesture();
                }, guac_touchscreen.clickTimingThreshold);

            }

        } // end if finger not moved

    }, false);

    element.addEventListener("touchstart", function(e) {

        // Ignore if more than one touch
        if (e.touches.length !== 1) {
            end_gesture();
            return;
        }

        e.preventDefault();

        // New touch begins a new gesture
        begin_gesture(e);

        // Keep button pressed if tap after left click
        window.clearTimeout(click_release_timeout);

        // Click right button if this turns into a long-press
        long_press_timeout = window.setTimeout(function() {
            var touch = e.touches[0];
            move_mouse(touch.clientX, touch.clientY);
            click_button("right");
            end_gesture();
        }, guac_touchscreen.longPressThreshold);

    }, false);

    element.addEventListener("touchmove", function(e) {

        // Do not handle if no gesture
        if (!gesture_in_progress)
            return;

        // Cancel long press if finger moved
        if (finger_moved(e))
            window.clearTimeout(long_press_timeout);

        // Ignore if more than one touch
        if (e.touches.length !== 1) {
            end_gesture();
            return;
        }

        // Update mouse position if dragging
        if (guac_touchscreen.currentState.left) {

            e.preventDefault();

            // Update state
            var touch = e.touches[0];
            move_mouse(touch.clientX, touch.clientY);

        }

    }, false);

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The namespace used by the Guacamole JavaScript API. Absolutely all classes
 * defined by the Guacamole JavaScript API will be within this namespace.
 *
 * @namespace
 */
var Guacamole = Guacamole || {};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * An object used by the Guacamole client to house arbitrarily-many named
 * input and output streams.
 * 
 * @constructor
 * @param {Guacamole.Client} client
 *     The client owning this object.
 *
 * @param {Number} index
 *     The index of this object.
 */
Guacamole.Object = function guacamoleObject(client, index) {

    /**
     * Reference to this Guacamole.Object.
     *
     * @private
     * @type {Guacamole.Object}
     */
    var guacObject = this;

    /**
     * Map of stream name to corresponding queue of callbacks. The queue of
     * callbacks is guaranteed to be in order of request.
     *
     * @private
     * @type {Object.<String, Function[]>}
     */
    var bodyCallbacks = {};

    /**
     * Removes and returns the callback at the head of the callback queue for
     * the stream having the given name. If no such callbacks exist, null is
     * returned.
     *
     * @private
     * @param {String} name
     *     The name of the stream to retrieve a callback for.
     *
     * @returns {Function}
     *     The next callback associated with the stream having the given name,
     *     or null if no such callback exists.
     */
    var dequeueBodyCallback = function dequeueBodyCallback(name) {

        // If no callbacks defined, simply return null
        var callbacks = bodyCallbacks[name];
        if (!callbacks)
            return null;

        // Otherwise, pull off first callback, deleting the queue if empty
        var callback = callbacks.shift();
        if (callbacks.length === 0)
            delete bodyCallbacks[name];

        // Return found callback
        return callback;

    };

    /**
     * Adds the given callback to the tail of the callback queue for the stream
     * having the given name.
     *
     * @private
     * @param {String} name
     *     The name of the stream to associate with the given callback.
     *
     * @param {Function} callback
     *     The callback to add to the queue of the stream with the given name.
     */
    var enqueueBodyCallback = function enqueueBodyCallback(name, callback) {

        // Get callback queue by name, creating first if necessary
        var callbacks = bodyCallbacks[name];
        if (!callbacks) {
            callbacks = [];
            bodyCallbacks[name] = callbacks;
        }

        // Add callback to end of queue
        callbacks.push(callback);

    };

    /**
     * The index of this object.
     *
     * @type {Number}
     */
    this.index = index;

    /**
     * Called when this object receives the body of a requested input stream.
     * By default, all objects will invoke the callbacks provided to their
     * requestInputStream() functions based on the name of the stream
     * requested. This behavior can be overridden by specifying a different
     * handler here.
     *
     * @event
     * @param {Guacamole.InputStream} inputStream
     *     The input stream of the received body.
     *
     * @param {String} mimetype
     *     The mimetype of the data being received.
     *
     * @param {String} name
     *     The name of the stream whose body has been received.
     */
    this.onbody = function defaultBodyHandler(inputStream, mimetype, name) {

        // Call queued callback for the received body, if any
        var callback = dequeueBodyCallback(name);
        if (callback)
            callback(inputStream, mimetype);

    };

    /**
     * Called when this object is being undefined. Once undefined, no further
     * communication involving this object may occur.
     * 
     * @event
     */
    this.onundefine = null;

    /**
     * Requests read access to the input stream having the given name. If
     * successful, a new input stream will be created.
     *
     * @param {String} name
     *     The name of the input stream to request.
     *
     * @param {Function} [bodyCallback]
     *     The callback to invoke when the body of the requested input stream
     *     is received. This callback will be provided a Guacamole.InputStream
     *     and its mimetype as its two only arguments. If the onbody handler of
     *     this object is overridden, this callback will not be invoked.
     */
    this.requestInputStream = function requestInputStream(name, bodyCallback) {

        // Queue body callback if provided
        if (bodyCallback)
            enqueueBodyCallback(name, bodyCallback);

        // Send request for input stream
        client.requestObjectInputStream(guacObject.index, name);

    };

    /**
     * Creates a new output stream associated with this object and having the
     * given mimetype and name. The legality of a mimetype and name is dictated
     * by the object itself.
     *
     * @param {String} mimetype
     *     The mimetype of the data which will be sent to the output stream.
     *
     * @param {String} name
     *     The defined name of an output stream within this object.
     *
     * @returns {Guacamole.OutputStream}
     *     An output stream which will write blobs to the named output stream
     *     of this object.
     */
    this.createOutputStream = function createOutputStream(mimetype, name) {
        return client.createObjectOutputStream(guacObject.index, mimetype, name);
    };

};

/**
 * The reserved name denoting the root stream of any object. The contents of
 * the root stream MUST be a JSON map of stream name to mimetype.
 *
 * @constant
 * @type {String}
 */
Guacamole.Object.ROOT_STREAM = '/';

/**
 * The mimetype of a stream containing JSON which maps available stream names
 * to their corresponding mimetype. The root stream of a Guacamole.Object MUST
 * have this mimetype.
 *
 * @constant
 * @type {String}
 */
Guacamole.Object.STREAM_INDEX_MIMETYPE = 'application/vnd.glyptodon.guacamole.stream-index+json';

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Dynamic on-screen keyboard. Given the layout object for an on-screen
 * keyboard, this object will construct a clickable on-screen keyboard with its
 * own key events.
 *
 * @constructor
 * @param {Guacamole.OnScreenKeyboard.Layout} layout
 *     The layout of the on-screen keyboard to display.
 */
Guacamole.OnScreenKeyboard = function(layout) {

    /**
     * Reference to this Guacamole.OnScreenKeyboard.
     *
     * @private
     * @type {Guacamole.OnScreenKeyboard}
     */
    var osk = this;

    /**
     * Map of currently-set modifiers to the keysym associated with their
     * original press. When the modifier is cleared, this keysym must be
     * released.
     *
     * @private
     * @type {Object.<String, Number>}
     */
    var modifierKeysyms = {};

    /**
     * Map of all key names to their current pressed states. If a key is not
     * pressed, it may not be in this map at all, but all pressed keys will
     * have a corresponding mapping to true.
     *
     * @private
     * @type {Object.<String, Boolean>}
     */
    var pressed = {};

    /**
     * All scalable elements which are part of the on-screen keyboard. Each
     * scalable element is carefully controlled to ensure the interface layout
     * and sizing remains constant, even on browsers that would otherwise
     * experience rounding error due to unit conversions.
     *
     * @private
     * @type {ScaledElement[]}
     */
    var scaledElements = [];

    /**
     * Adds a CSS class to an element.
     * 
     * @private
     * @function
     * @param {Element} element
     *     The element to add a class to.
     *
     * @param {String} classname
     *     The name of the class to add.
     */
    var addClass = function addClass(element, classname) {

        // If classList supported, use that
        if (element.classList)
            element.classList.add(classname);

        // Otherwise, simply append the class
        else
            element.className += " " + classname;

    };

    /**
     * Removes a CSS class from an element.
     * 
     * @private
     * @function
     * @param {Element} element
     *     The element to remove a class from.
     *
     * @param {String} classname
     *     The name of the class to remove.
     */
    var removeClass = function removeClass(element, classname) {

        // If classList supported, use that
        if (element.classList)
            element.classList.remove(classname);

        // Otherwise, manually filter out classes with given name
        else {
            element.className = element.className.replace(/([^ ]+)[ ]*/g,
                function removeMatchingClasses(match, testClassname) {

                    // If same class, remove
                    if (testClassname === classname)
                        return "";

                    // Otherwise, allow
                    return match;
                    
                }
            );
        }

    };

    /**
     * Counter of mouse events to ignore. This decremented by mousemove, and
     * while non-zero, mouse events will have no effect.
     *
     * @private
     * @type {Number}
     */
    var ignoreMouse = 0;

    /**
     * Ignores all pending mouse events when touch events are the apparent
     * source. Mouse events are ignored until at least touchMouseThreshold
     * mouse events occur without corresponding touch events.
     *
     * @private
     */
    var ignorePendingMouseEvents = function ignorePendingMouseEvents() {
        ignoreMouse = osk.touchMouseThreshold;
    };

    /**
     * An element whose dimensions are maintained according to an arbitrary
     * scale. The conversion factor for these arbitrary units to pixels is
     * provided later via a call to scale().
     *
     * @private
     * @constructor
     * @param {Element} element
     *     The element whose scale should be maintained.
     *
     * @param {Number} width
     *     The width of the element, in arbitrary units, relative to other
     *     ScaledElements.
     *
     * @param {Number} height
     *     The height of the element, in arbitrary units, relative to other
     *     ScaledElements.
     *     
     * @param {Boolean} [scaleFont=false]
     *     Whether the line height and font size should be scaled as well.
     */
    var ScaledElement = function ScaledElement(element, width, height, scaleFont) {

        /**
         * The width of this ScaledElement, in arbitrary units, relative to
         * other ScaledElements.
         *
         * @type {Number}
         */
         this.width = width;

        /**
         * The height of this ScaledElement, in arbitrary units, relative to
         * other ScaledElements.
         *
         * @type {Number}
         */
         this.height = height;
 
        /**
         * Resizes the associated element, updating its dimensions according to
         * the given pixels per unit.
         *
         * @param {Number} pixels
         *     The number of pixels to assign per arbitrary unit.
         */
        this.scale = function(pixels) {

            // Scale element width/height
            element.style.width  = (width  * pixels) + "px";
            element.style.height = (height * pixels) + "px";

            // Scale font, if requested
            if (scaleFont) {
                element.style.lineHeight = (height * pixels) + "px";
                element.style.fontSize   = pixels + "px";
            }

        };

    };

    /**
     * Returns whether all modifiers having the given names are currently
     * active.
     *
     * @private
     * @param {String[]} names
     *     The names of all modifiers to test.
     *
     * @returns {Boolean}
     *     true if all specified modifiers are pressed, false otherwise.
     */
    var modifiersPressed = function modifiersPressed(names) {

        // If any required modifiers are not pressed, return false
        for (var i=0; i < names.length; i++) {

            // Test whether current modifier is pressed
            var name = names[i];
            if (!(name in modifierKeysyms))
                return false;

        }

        // Otherwise, all required modifiers are pressed
        return true;

    };

    /**
     * Returns the single matching Key object associated with the key of the
     * given name, where that Key object's requirements (such as pressed
     * modifiers) are all currently satisfied.
     *
     * @private
     * @param {String} keyName
     *     The name of the key to retrieve.
     *
     * @returns {Guacamole.OnScreenKeyboard.Key}
     *     The Key object associated with the given name, where that object's
     *     requirements are all currently satisfied, or null if no such Key
     *     can be found.
     */
    var getActiveKey = function getActiveKey(keyName) {

        // Get key array for given name
        var keys = osk.keys[keyName];
        if (!keys)
            return null;

        // Find last matching key
        for (var i = keys.length - 1; i >= 0; i--) {

            // Get candidate key
            var candidate = keys[i];

            // If all required modifiers are pressed, use that key
            if (modifiersPressed(candidate.requires))
                return candidate;

        }

        // No valid key
        return null;

    };

    /**
     * Presses the key having the given name, updating the associated key
     * element with the "guac-keyboard-pressed" CSS class. If the key is
     * already pressed, this function has no effect.
     *
     * @private
     * @param {String} keyName
     *     The name of the key to press.
     *
     * @param {String} keyElement
     *     The element associated with the given key.
     */
    var press = function press(keyName, keyElement) {

        // Press key if not yet pressed
        if (!pressed[keyName]) {

            addClass(keyElement, "guac-keyboard-pressed");

            // Get current key based on modifier state
            var key = getActiveKey(keyName);

            // Update modifier state
            if (key.modifier) {

                // Construct classname for modifier
                var modifierClass = "guac-keyboard-modifier-" + getCSSName(key.modifier);

                // Retrieve originally-pressed keysym, if modifier was already pressed
                var originalKeysym = modifierKeysyms[key.modifier];

                // Activate modifier if not pressed
                if (!originalKeysym) {
                    
                    addClass(keyboard, modifierClass);
                    modifierKeysyms[key.modifier] = key.keysym;
                    
                    // Send key event
                    if (osk.onkeydown)
                        osk.onkeydown(key.keysym);

                }

                // Deactivate if not pressed
                else {

                    removeClass(keyboard, modifierClass);
                    delete modifierKeysyms[key.modifier];
                    
                    // Send key event
                    if (osk.onkeyup)
                        osk.onkeyup(originalKeysym);

                }

            }

            // If not modifier, send key event now
            else if (osk.onkeydown)
                osk.onkeydown(key.keysym);

            // Mark key as pressed
            pressed[keyName] = true;

        }

    };

    /**
     * Releases the key having the given name, removing the
     * "guac-keyboard-pressed" CSS class from the associated element. If the
     * key is already released, this function has no effect.
     *
     * @private
     * @param {String} keyName
     *     The name of the key to release.
     *
     * @param {String} keyElement
     *     The element associated with the given key.
     */
    var release = function release(keyName, keyElement) {

        // Release key if currently pressed
        if (pressed[keyName]) {

            removeClass(keyElement, "guac-keyboard-pressed");

            // Get current key based on modifier state
            var key = getActiveKey(keyName);

            // Send key event if not a modifier key
            if (!key.modifier && osk.onkeyup)
                osk.onkeyup(key.keysym);

            // Mark key as released
            pressed[keyName] = false;

        }

    };

    // Create keyboard
    var keyboard = document.createElement("div");
    keyboard.className = "guac-keyboard";

    // Do not allow selection or mouse movement to propagate/register.
    keyboard.onselectstart =
    keyboard.onmousemove   =
    keyboard.onmouseup     =
    keyboard.onmousedown   = function handleMouseEvents(e) {

        // If ignoring events, decrement counter
        if (ignoreMouse)
            ignoreMouse--;

        e.stopPropagation();
        return false;

    };

    /**
     * The number of mousemove events to require before re-enabling mouse
     * event handling after receiving a touch event.
     *
     * @type {Number}
     */
    this.touchMouseThreshold = 3;

    /**
     * Fired whenever the user presses a key on this Guacamole.OnScreenKeyboard.
     * 
     * @event
     * @param {Number} keysym The keysym of the key being pressed.
     */
    this.onkeydown = null;

    /**
     * Fired whenever the user releases a key on this Guacamole.OnScreenKeyboard.
     * 
     * @event
     * @param {Number} keysym The keysym of the key being released.
     */
    this.onkeyup = null;

    /**
     * The keyboard layout provided at time of construction.
     *
     * @type {Guacamole.OnScreenKeyboard.Layout}
     */
    this.layout = new Guacamole.OnScreenKeyboard.Layout(layout);

    /**
     * Returns the element containing the entire on-screen keyboard.
     * @returns {Element} The element containing the entire on-screen keyboard.
     */
    this.getElement = function() {
        return keyboard;
    };

    /**
     * Resizes all elements within this Guacamole.OnScreenKeyboard such that
     * the width is close to but does not exceed the specified width. The
     * height of the keyboard is determined based on the width.
     * 
     * @param {Number} width The width to resize this Guacamole.OnScreenKeyboard
     *                       to, in pixels.
     */
    this.resize = function(width) {

        // Get pixel size of a unit
        var unit = Math.floor(width * 10 / osk.layout.width) / 10;

        // Resize all scaled elements
        for (var i=0; i<scaledElements.length; i++) {
            var scaledElement = scaledElements[i];
            scaledElement.scale(unit);
        }

    };

    /**
     * Given the name of a key and its corresponding definition, which may be
     * an array of keys objects, a number (keysym), a string (key title), or a
     * single key object, returns an array of key objects, deriving any missing
     * properties as needed, and ensuring the key name is defined.
     *
     * @private
     * @param {String} name
     *     The name of the key being coerced into an array of Key objects.
     *
     * @param {Number|String|Guacamole.OnScreenKeyboard.Key|Guacamole.OnScreenKeyboard.Key[]} object
     *     The object defining the behavior of the key having the given name,
     *     which may be the title of the key (a string), the keysym (a number),
     *     a single Key object, or an array of Key objects.
     *     
     * @returns {Guacamole.OnScreenKeyboard.Key[]}
     *     An array of all keys associated with the given name.
     */
    var asKeyArray = function asKeyArray(name, object) {

        // If already an array, just coerce into a true Key[] 
        if (object instanceof Array) {
            var keys = [];
            for (var i=0; i < object.length; i++) {
                keys.push(new Guacamole.OnScreenKeyboard.Key(object[i], name));
            }
            return keys;
        }

        // Derive key object from keysym if that's all we have
        if (typeof object === 'number') {
            return [new Guacamole.OnScreenKeyboard.Key({
                name   : name,
                keysym : object
            })];
        }

        // Derive key object from title if that's all we have
        if (typeof object === 'string') {
            return [new Guacamole.OnScreenKeyboard.Key({
                name  : name,
                title : object
            })];
        }

        // Otherwise, assume it's already a key object, just not an array
        return [new Guacamole.OnScreenKeyboard.Key(object, name)];

    };

    /**
     * Converts the rather forgiving key mapping allowed by
     * Guacamole.OnScreenKeyboard.Layout into a rigorous mapping of key name
     * to key definition, where the key definition is always an array of Key
     * objects.
     *
     * @private
     * @param {Object.<String, Number|String|Guacamole.OnScreenKeyboard.Key|Guacamole.OnScreenKeyboard.Key[]>} keys
     *     A mapping of key name to key definition, where the key definition is
     *     the title of the key (a string), the keysym (a number), a single
     *     Key object, or an array of Key objects.
     *
     * @returns {Object.<String, Guacamole.OnScreenKeyboard.Key[]>}
     *     A more-predictable mapping of key name to key definition, where the
     *     key definition is always simply an array of Key objects.
     */
    var getKeys = function getKeys(keys) {

        var keyArrays = {};

        // Coerce all keys into individual key arrays
        for (var name in layout.keys) {
            keyArrays[name] = asKeyArray(name, keys[name]);
        }

        return keyArrays;

    };

    /**
     * Map of all key names to their corresponding set of keys. Each key name
     * may correspond to multiple keys due to the effect of modifiers.
     *
     * @type {Object.<String, Guacamole.OnScreenKeyboard.Key[]>}
     */
    this.keys = getKeys(layout.keys);

    /**
     * Given an arbitrary string representing the name of some component of the
     * on-screen keyboard, returns a string formatted for use as a CSS class
     * name. The result will be lowercase. Word boundaries previously denoted
     * by CamelCase will be replaced by individual hyphens, as will all
     * contiguous non-alphanumeric characters.
     *
     * @private
     * @param {String} name
     *     An arbitrary string representing the name of some component of the
     *     on-screen keyboard.
     *
     * @returns {String}
     *     A string formatted for use as a CSS class name.
     */
    var getCSSName = function getCSSName(name) {

        // Convert name from possibly-CamelCase to hyphenated lowercase
        var cssName = name
               .replace(/([a-z])([A-Z])/g, '$1-$2')
               .replace(/[^A-Za-z0-9]+/g, '-')
               .toLowerCase();

        return cssName;

    };

    /**
     * Appends DOM elements to the given element as dictated by the layout
     * structure object provided. If a name is provided, an additional CSS
     * class, prepended with "guac-keyboard-", will be added to the top-level
     * element.
     * 
     * If the layout structure object is an array, all elements within that
     * array will be recursively appended as children of a group, and the
     * top-level element will be given the CSS class "guac-keyboard-group".
     *
     * If the layout structure object is an object, all properties within that
     * object will be recursively appended as children of a group, and the
     * top-level element will be given the CSS class "guac-keyboard-group". The
     * name of each property will be applied as the name of each child object
     * for the sake of CSS. Each property will be added in sorted order.
     *
     * If the layout structure object is a string, the key having that name
     * will be appended. The key will be given the CSS class
     * "guac-keyboard-key" and "guac-keyboard-key-NAME", where NAME is the name
     * of the key. If the name of the key is a single character, this will
     * first be transformed into the C-style hexadecimal literal for the
     * Unicode codepoint of that character. For example, the key "A" would
     * become "guac-keyboard-key-0x41".
     * 
     * If the layout structure object is a number, a gap of that size will be
     * inserted. The gap will be given the CSS class "guac-keyboard-gap", and
     * will be scaled according to the same size units as each key.
     *
     * @private
     * @param {Element} element
     *     The element to append elements to.
     *
     * @param {Array|Object|String|Number} object
     *     The layout structure object to use when constructing the elements to
     *     append.
     *
     * @param {String} [name]
     *     The name of the top-level element being appended, if any.
     */
    var appendElements = function appendElements(element, object, name) {

        var i;

        // Create div which will become the group or key
        var div = document.createElement('div');

        // Add class based on name, if name given
        if (name)
            addClass(div, 'guac-keyboard-' + getCSSName(name));

        // If an array, append each element
        if (object instanceof Array) {

            // Add group class
            addClass(div, 'guac-keyboard-group');

            // Append all elements of array
            for (i=0; i < object.length; i++)
                appendElements(div, object[i]);

        }

        // If an object, append each property value
        else if (object instanceof Object) {

            // Add group class
            addClass(div, 'guac-keyboard-group');

            // Append all children, sorted by name
            var names = Object.keys(object).sort();
            for (i=0; i < names.length; i++) {
                var name = names[i];
                appendElements(div, object[name], name);
            }

        }

        // If a number, create as a gap 
        else if (typeof object === 'number') {

            // Add gap class
            addClass(div, 'guac-keyboard-gap');

            // Maintain scale
            scaledElements.push(new ScaledElement(div, object, object));

        }

        // If a string, create as a key
        else if (typeof object === 'string') {

            // If key name is only one character, use codepoint for name
            var keyName = object;
            if (keyName.length === 1)
                keyName = '0x' + keyName.charCodeAt(0).toString(16);

            // Add key container class
            addClass(div, 'guac-keyboard-key-container');

            // Create key element which will contain all possible caps
            var keyElement = document.createElement('div');
            keyElement.className = 'guac-keyboard-key '
                                 + 'guac-keyboard-key-' + getCSSName(keyName);

            // Add all associated keys as caps within DOM
            var keys = osk.keys[object];
            if (keys) {
                for (i=0; i < keys.length; i++) {

                    // Get current key
                    var key = keys[i];

                    // Create cap element for key
                    var capElement = document.createElement('div');
                    capElement.className   = 'guac-keyboard-cap';
                    capElement.textContent = key.title;

                    // Add classes for any requirements
                    for (var j=0; j < key.requires.length; j++) {
                        var requirement = key.requires[j];
                        addClass(capElement, 'guac-keyboard-requires-' + getCSSName(requirement));
                        addClass(keyElement, 'guac-keyboard-uses-'     + getCSSName(requirement));
                    }

                    // Add cap to key within DOM
                    keyElement.appendChild(capElement);

                }
            }

            // Add key to DOM, maintain scale
            div.appendChild(keyElement);
            scaledElements.push(new ScaledElement(div, osk.layout.keyWidths[object] || 1, 1, true));

            /**
             * Handles a touch event which results in the pressing of an OSK
             * key. Touch events will result in mouse events being ignored for
             * touchMouseThreshold events.
             *
             * @private
             * @param {TouchEvent} e
             *     The touch event being handled.
             */
            var touchPress = function touchPress(e) {
                e.preventDefault();
                ignoreMouse = osk.touchMouseThreshold;
                press(object, keyElement);
            };

            /**
             * Handles a touch event which results in the release of an OSK
             * key. Touch events will result in mouse events being ignored for
             * touchMouseThreshold events.
             *
             * @private
             * @param {TouchEvent} e
             *     The touch event being handled.
             */
            var touchRelease = function touchRelease(e) {
                e.preventDefault();
                ignoreMouse = osk.touchMouseThreshold;
                release(object, keyElement);
            };

            /**
             * Handles a mouse event which results in the pressing of an OSK
             * key. If mouse events are currently being ignored, this handler
             * does nothing.
             *
             * @private
             * @param {MouseEvent} e
             *     The touch event being handled.
             */
            var mousePress = function mousePress(e) {
                e.preventDefault();
                if (ignoreMouse === 0)
                    press(object, keyElement);
            };

            /**
             * Handles a mouse event which results in the release of an OSK
             * key. If mouse events are currently being ignored, this handler
             * does nothing.
             *
             * @private
             * @param {MouseEvent} e
             *     The touch event being handled.
             */
            var mouseRelease = function mouseRelease(e) {
                e.preventDefault();
                if (ignoreMouse === 0)
                    release(object, keyElement);
            };

            // Handle touch events on key
            keyElement.addEventListener("touchstart", touchPress,   true);
            keyElement.addEventListener("touchend",   touchRelease, true);

            // Handle mouse events on key
            keyElement.addEventListener("mousedown", mousePress,   true);
            keyElement.addEventListener("mouseup",   mouseRelease, true);
            keyElement.addEventListener("mouseout",  mouseRelease, true);

        } // end if object is key name

        // Add newly-created group/key
        element.appendChild(div);

    };

    // Create keyboard layout in DOM
    appendElements(keyboard, layout.layout);

};

/**
 * Represents an entire on-screen keyboard layout, including all available
 * keys, their behaviors, and their relative position and sizing.
 *
 * @constructor
 * @param {Guacamole.OnScreenKeyboard.Layout|Object} template
 *     The object whose identically-named properties will be used to initialize
 *     the properties of this layout.
 */
Guacamole.OnScreenKeyboard.Layout = function(template) {

    /**
     * The language of keyboard layout, such as "en_US". This property is for
     * informational purposes only, but it is recommend to conform to the
     * [language code]_[country code] format.
     *
     * @type {String}
     */
    this.language = template.language;

    /**
     * The type of keyboard layout, such as "qwerty". This property is for
     * informational purposes only, and does not conform to any standard.
     *
     * @type {String}
     */
    this.type = template.type;

    /**
     * Map of key name to corresponding keysym, title, or key object. If only
     * the keysym or title is provided, the key object will be created
     * implicitly. In all cases, the name property of the key object will be
     * taken from the name given in the mapping.
     *
     * @type {Object.<String, Number|String|Guacamole.OnScreenKeyboard.Key|Guacamole.OnScreenKeyboard.Key[]>}
     */
    this.keys = template.keys;

    /**
     * Arbitrarily nested, arbitrarily grouped key names. The contents of the
     * layout will be traversed to produce an identically-nested grouping of
     * keys in the DOM tree. All strings will be transformed into their
     * corresponding sets of keys, while all objects and arrays will be
     * transformed into named groups and anonymous groups respectively. Any
     * numbers present will be transformed into gaps of that size, scaled
     * according to the same units as each key.
     *
     * @type {Object}
     */
    this.layout = template.layout;

    /**
     * The width of the entire keyboard, in arbitrary units. The width of each
     * key is relative to this width, as both width values are assumed to be in
     * the same units. The conversion factor between these units and pixels is
     * derived later via a call to resize() on the Guacamole.OnScreenKeyboard.
     *
     * @type {Number}
     */
    this.width = template.width;

    /**
     * The width of each key, in arbitrary units, relative to other keys in
     * this layout. The true pixel size of each key will be determined by the
     * overall size of the keyboard. If not defined here, the width of each
     * key will default to 1.
     *
     * @type {Object.<String, Number>}
     */
    this.keyWidths = template.keyWidths || {};

};

/**
 * Represents a single key, or a single possible behavior of a key. Each key
 * on the on-screen keyboard must have at least one associated
 * Guacamole.OnScreenKeyboard.Key, whether that key is explicitly defined or
 * implied, and may have multiple Guacamole.OnScreenKeyboard.Key if behavior
 * depends on modifier states.
 *
 * @constructor
 * @param {Guacamole.OnScreenKeyboard.Key|Object} template
 *     The object whose identically-named properties will be used to initialize
 *     the properties of this key.
 *     
 * @param {String} [name]
 *     The name to use instead of any name provided within the template, if
 *     any. If omitted, the name within the template will be used, assuming the
 *     template contains a name.
 */
Guacamole.OnScreenKeyboard.Key = function(template, name) {

    /**
     * The unique name identifying this key within the keyboard layout.
     *
     * @type {String}
     */
    this.name = name || template.name;

    /**
     * The human-readable title that will be displayed to the user within the
     * key. If not provided, this will be derived from the key name.
     *
     * @type {String}
     */
    this.title = template.title || this.name;

    /**
     * The keysym to be pressed/released when this key is pressed/released. If
     * not provided, this will be derived from the title if the title is a
     * single character.
     *
     * @type {Number}
     */
    this.keysym = template.keysym || (function deriveKeysym(title) {

        // Do not derive keysym if title is not exactly one character
        if (!title || title.length !== 1)
            return null;

        // For characters between U+0000 and U+00FF, the keysym is the codepoint
        var charCode = title.charCodeAt(0);
        if (charCode >= 0x0000 && charCode <= 0x00FF)
            return charCode;

        // For characters between U+0100 and U+10FFFF, the keysym is the codepoint or'd with 0x01000000
        if (charCode >= 0x0100 && charCode <= 0x10FFFF)
            return 0x01000000 | charCode;

        // Unable to derive keysym
        return null;

    })(this.title);

    /**
     * The name of the modifier set when the key is pressed and cleared when
     * this key is released, if any. The names of modifiers are distinct from
     * the names of keys; both the "RightShift" and "LeftShift" keys may set
     * the "shift" modifier, for example. By default, the key will affect no
     * modifiers.
     * 
     * @type {String}
     */
    this.modifier = template.modifier;

    /**
     * An array containing the names of each modifier required for this key to
     * have an effect. For example, a lowercase letter may require nothing,
     * while an uppercase letter would require "shift", assuming the Shift key
     * is named "shift" within the layout. By default, the key will require
     * no modifiers.
     *
     * @type {String[]}
     */
    this.requires = template.requires || [];

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract stream which can receive data.
 * 
 * @constructor
 * @param {Guacamole.Client} client The client owning this stream.
 * @param {Number} index The index of this stream.
 */
Guacamole.OutputStream = function(client, index) {

    /**
     * Reference to this stream.
     * @private
     */
    var guac_stream = this;

    /**
     * The index of this stream.
     * @type {Number}
     */
    this.index = index;

    /**
     * Fired whenever an acknowledgement is received from the server, indicating
     * that a stream operation has completed, or an error has occurred.
     * 
     * @event
     * @param {Guacamole.Status} status The status of the operation.
     */
    this.onack = null;

    /**
     * Writes the given base64-encoded data to this stream as a blob.
     * 
     * @param {String} data The base64-encoded data to send.
     */
    this.sendBlob = function(data) {
        client.sendBlob(guac_stream.index, data);
    };

    /**
     * Closes this stream.
     */
    this.sendEnd = function() {
        client.endStream(guac_stream.index);
    };

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Simple Guacamole protocol parser that invokes an oninstruction event when
 * full instructions are available from data received via receive().
 * 
 * @constructor
 */
Guacamole.Parser = function() {

    /**
     * Reference to this parser.
     * @private
     */
    var parser = this;

    /**
     * Current buffer of received data. This buffer grows until a full
     * element is available. After a full element is available, that element
     * is flushed into the element buffer.
     * 
     * @private
     */
    var buffer = "";

    /**
     * Buffer of all received, complete elements. After an entire instruction
     * is read, this buffer is flushed, and a new instruction begins.
     * 
     * @private
     */
    var element_buffer = [];

    // The location of the last element's terminator
    var element_end = -1;

    // Where to start the next length search or the next element
    var start_index = 0;

    /**
     * Appends the given instruction data packet to the internal buffer of
     * this Guacamole.Parser, executing all completed instructions at
     * the beginning of this buffer, if any.
     *
     * @param {String} packet The instruction data to receive.
     */
    this.receive = function(packet) {

        // Truncate buffer as necessary
        if (start_index > 4096 && element_end >= start_index) {

            buffer = buffer.substring(start_index);

            // Reset parse relative to truncation
            element_end -= start_index;
            start_index = 0;

        }

        // Append data to buffer
        buffer += packet;

        // While search is within currently received data
        while (element_end < buffer.length) {

            // If we are waiting for element data
            if (element_end >= start_index) {

                // We now have enough data for the element. Parse.
                var element = buffer.substring(start_index, element_end);
                var terminator = buffer.substring(element_end, element_end+1);

                // Add element to array
                element_buffer.push(element);

                // If last element, handle instruction
                if (terminator == ";") {

                    // Get opcode
                    var opcode = element_buffer.shift();

                    // Call instruction handler.
                    if (parser.oninstruction != null)
                        parser.oninstruction(opcode, element_buffer);

                    // Clear elements
                    element_buffer.length = 0;

                }
                else if (terminator != ',')
                    throw new Error("Illegal terminator.");

                // Start searching for length at character after
                // element terminator
                start_index = element_end + 1;

            }

            // Search for end of length
            var length_end = buffer.indexOf(".", start_index);
            if (length_end != -1) {

                // Parse length
                var length = parseInt(buffer.substring(element_end+1, length_end));
                if (isNaN(length))
                    throw new Error("Non-numeric character in element length.");

                // Calculate start of element
                start_index = length_end + 1;

                // Calculate location of element terminator
                element_end = start_index + length;

            }
            
            // If no period yet, continue search when more data
            // is received
            else {
                start_index = buffer.length;
                break;
            }

        } // end parse loop

    };

    /**
     * Fired once for every complete Guacamole instruction received, in order.
     * 
     * @event
     * @param {String} opcode The Guacamole instruction opcode.
     * @param {Array} parameters The parameters provided for the instruction,
     *                           if any.
     */
    this.oninstruction = null;

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A description of the format of raw PCM audio, such as that used by
 * Guacamole.RawAudioPlayer and Guacamole.RawAudioRecorder. This object
 * describes the number of bytes per sample, the number of channels, and the
 * overall sample rate.
 *
 * @constructor
 * @param {Guacamole.RawAudioFormat|Object} template
 *     The object whose properties should be copied into the corresponding
 *     properties of the new Guacamole.RawAudioFormat.
 */
Guacamole.RawAudioFormat = function RawAudioFormat(template) {

    /**
     * The number of bytes in each sample of audio data. This value is
     * independent of the number of channels.
     *
     * @type {Number}
     */
    this.bytesPerSample = template.bytesPerSample;

    /**
     * The number of audio channels (ie: 1 for mono, 2 for stereo).
     *
     * @type {Number}
     */
    this.channels = template.channels;

    /**
     * The number of samples per second, per channel.
     *
     * @type {Number}
     */
    this.rate = template.rate;

};

/**
 * Parses the given mimetype, returning a new Guacamole.RawAudioFormat
 * which describes the type of raw audio data represented by that mimetype. If
 * the mimetype is not a supported raw audio data mimetype, null is returned.
 *
 * @param {String} mimetype
 *     The audio mimetype to parse.
 *
 * @returns {Guacamole.RawAudioFormat}
 *     A new Guacamole.RawAudioFormat which describes the type of raw
 *     audio data represented by the given mimetype, or null if the given
 *     mimetype is not supported.
 */
Guacamole.RawAudioFormat.parse = function parseFormat(mimetype) {

    var bytesPerSample;

    // Rate is absolutely required - if null is still present later, the
    // mimetype must not be supported
    var rate = null;

    // Default for both "audio/L8" and "audio/L16" is one channel
    var channels = 1;

    // "audio/L8" has one byte per sample
    if (mimetype.substring(0, 9) === 'audio/L8;') {
        mimetype = mimetype.substring(9);
        bytesPerSample = 1;
    }

    // "audio/L16" has two bytes per sample
    else if (mimetype.substring(0, 10) === 'audio/L16;') {
        mimetype = mimetype.substring(10);
        bytesPerSample = 2;
    }

    // All other types are unsupported
    else
        return null;

    // Parse all parameters
    var parameters = mimetype.split(',');
    for (var i = 0; i < parameters.length; i++) {

        var parameter = parameters[i];

        // All parameters must have an equals sign separating name from value
        var equals = parameter.indexOf('=');
        if (equals === -1)
            return null;

        // Parse name and value from parameter string
        var name  = parameter.substring(0, equals);
        var value = parameter.substring(equals+1);

        // Handle each supported parameter
        switch (name) {

            // Number of audio channels
            case 'channels':
                channels = parseInt(value);
                break;

            // Sample rate
            case 'rate':
                rate = parseInt(value);
                break;

            // All other parameters are unsupported
            default:
                return null;

        }

    };

    // The rate parameter is required
    if (rate === null)
        return null;

    // Return parsed format details
    return new Guacamole.RawAudioFormat({
        bytesPerSample : bytesPerSample,
        channels       : channels,
        rate           : rate
    });

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A recording of a Guacamole session. Given a {@link Guacamole.Tunnel}, the
 * Guacamole.SessionRecording automatically handles incoming Guacamole
 * instructions, storing them for playback. Playback of the recording may be
 * controlled through function calls to the Guacamole.SessionRecording, even
 * while the recording has not yet finished being created or downloaded.
 *
 * @constructor
 * @param {Guacamole.Tunnel} tunnel
 *     The Guacamole.Tunnel from which the instructions of the recording should
 *     be read.
 */
Guacamole.SessionRecording = function SessionRecording(tunnel) {

    /**
     * Reference to this Guacamole.SessionRecording.
     *
     * @private
     * @type {Guacamole.SessionRecording}
     */
    var recording = this;

    /**
     * The minimum number of characters which must have been read between
     * keyframes.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var KEYFRAME_CHAR_INTERVAL = 16384;

    /**
     * The minimum number of milliseconds which must elapse between keyframes.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var KEYFRAME_TIME_INTERVAL = 5000;

    /**
     * The maximum amount of time to spend in any particular seek operation
     * before returning control to the main thread, in milliseconds. Seek
     * operations exceeding this amount of time will proceed asynchronously.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var MAXIMUM_SEEK_TIME = 5;

    /**
     * All frames parsed from the provided tunnel.
     *
     * @private
     * @type {Guacamole.SessionRecording._Frame[]}
     */
    var frames = [];

    /**
     * All instructions which have been read since the last frame was added to
     * the frames array.
     *
     * @private
     * @type {Guacamole.SessionRecording._Frame.Instruction[]}
     */
    var instructions = [];

    /**
     * The approximate number of characters which have been read from the
     * provided tunnel since the last frame was flagged for use as a keyframe.
     *
     * @private
     * @type {Number}
     */
    var charactersSinceLastKeyframe = 0;

    /**
     * The timestamp of the last frame which was flagged for use as a keyframe.
     * If no timestamp has yet been flagged, this will be 0.
     *
     * @private
     * @type {Number}
     */
    var lastKeyframeTimestamp = 0;

    /**
     * Tunnel which feeds arbitrary instructions to the client used by this
     * Guacamole.SessionRecording for playback of the session recording.
     *
     * @private
     * @type {Guacamole.SessionRecording._PlaybackTunnel}
     */
    var playbackTunnel = new Guacamole.SessionRecording._PlaybackTunnel();

    /**
     * Guacamole.Client instance used for visible playback of the session
     * recording.
     *
     * @private
     * @type {Guacamole.Client}
     */
    var playbackClient = new Guacamole.Client(playbackTunnel);

    /**
     * The current frame rendered within the playback client. If no frame is
     * yet rendered, this will be -1.
     *
     * @private
     * @type {Number}
     */
    var currentFrame = -1;

    /**
     * The timestamp of the frame when playback began, in milliseconds. If
     * playback is not in progress, this will be null.
     *
     * @private
     * @type {Number}
     */
    var startVideoTimestamp = null;

    /**
     * The real-world timestamp when playback began, in milliseconds. If
     * playback is not in progress, this will be null.
     *
     * @private
     * @type {Number}
     */
    var startRealTimestamp = null;

    /**
     * The ID of the timeout which will continue the in-progress seek
     * operation. If no seek operation is in progress, the ID stored here (if
     * any) will not be valid.
     *
     * @private
     * @type {Number}
     */
    var seekTimeout = null;

    // Start playback client connected
    playbackClient.connect();

    // Hide cursor unless mouse position is received
    playbackClient.getDisplay().showCursor(false);

    // Read instructions from provided tunnel, extracting each frame
    tunnel.oninstruction = function handleInstruction(opcode, args) {

        // Store opcode and arguments for received instruction
        var instruction = new Guacamole.SessionRecording._Frame.Instruction(opcode, args.slice());
        instructions.push(instruction);
        charactersSinceLastKeyframe += instruction.getSize();

        // Once a sync is received, store all instructions since the last
        // frame as a new frame
        if (opcode === 'sync') {

            // Parse frame timestamp from sync instruction
            var timestamp = parseInt(args[0]);

            // Add a new frame containing the instructions read since last frame
            var frame = new Guacamole.SessionRecording._Frame(timestamp, instructions);
            frames.push(frame);

            // This frame should eventually become a keyframe if enough data
            // has been processed and enough recording time has elapsed, or if
            // this is the absolute first frame
            if (frames.length === 1 || (charactersSinceLastKeyframe >= KEYFRAME_CHAR_INTERVAL
                    && timestamp - lastKeyframeTimestamp >= KEYFRAME_TIME_INTERVAL)) {
                frame.keyframe = true;
                lastKeyframeTimestamp = timestamp;
                charactersSinceLastKeyframe = 0;
            }

            // Clear set of instructions in preparation for next frame
            instructions = [];

            // Notify that additional content is available
            if (recording.onprogress)
                recording.onprogress(recording.getDuration());

        }

    };

    /**
     * Converts the given absolute timestamp to a timestamp which is relative
     * to the first frame in the recording.
     *
     * @private
     * @param {Number} timestamp
     *     The timestamp to convert to a relative timestamp.
     *
     * @returns {Number}
     *     The difference in milliseconds between the given timestamp and the
     *     first frame of the recording, or zero if no frames yet exist.
     */
    var toRelativeTimestamp = function toRelativeTimestamp(timestamp) {

        // If no frames yet exist, all timestamps are zero
        if (frames.length === 0)
            return 0;

        // Calculate timestamp relative to first frame
        return timestamp - frames[0].timestamp;

    };

    /**
     * Searches through the given region of frames for the frame having a
     * relative timestamp closest to the timestamp given.
     *
     * @private
     * @param {Number} minIndex
     *     The index of the first frame in the region (the frame having the
     *     smallest timestamp).
     *
     * @param {Number} maxIndex
     *     The index of the last frame in the region (the frame having the
     *     largest timestamp).
     *
     * @param {Number} timestamp
     *     The relative timestamp to search for, where zero denotes the first
     *     frame in the recording.
     *
     * @returns {Number}
     *     The index of the frame having a relative timestamp closest to the
     *     given value.
     */
    var findFrame = function findFrame(minIndex, maxIndex, timestamp) {

        // Do not search if the region contains only one element
        if (minIndex === maxIndex)
            return minIndex;

        // Split search region into two halves
        var midIndex = Math.floor((minIndex + maxIndex) / 2);
        var midTimestamp = toRelativeTimestamp(frames[midIndex].timestamp);

        // If timestamp is within lesser half, search again within that half
        if (timestamp < midTimestamp && midIndex > minIndex)
            return findFrame(minIndex, midIndex - 1, timestamp);

        // If timestamp is within greater half, search again within that half
        if (timestamp > midTimestamp && midIndex < maxIndex)
            return findFrame(midIndex + 1, maxIndex, timestamp);

        // Otherwise, we lucked out and found a frame with exactly the
        // desired timestamp
        return midIndex;

    };

    /**
     * Replays the instructions associated with the given frame, sending those
     * instructions to the playback client.
     *
     * @private
     * @param {Number} index
     *     The index of the frame within the frames array which should be
     *     replayed.
     */
    var replayFrame = function replayFrame(index) {

        var frame = frames[index];

        // Replay all instructions within the retrieved frame
        for (var i = 0; i < frame.instructions.length; i++) {
            var instruction = frame.instructions[i];
            playbackTunnel.receiveInstruction(instruction.opcode, instruction.args);
        }

        // Store client state if frame is flagged as a keyframe
        if (frame.keyframe && !frame.clientState) {
            playbackClient.exportState(function storeClientState(state) {
                frame.clientState = state;
            });
        }

    };

    /**
     * Moves the playback position to the given frame, resetting the state of
     * the playback client and replaying frames as necessary. The seek
     * operation will proceed asynchronously. If a seek operation is already in
     * progress, that seek is first aborted. The progress of the seek operation
     * can be observed through the onseek handler and the provided callback.
     *
     * @private
     * @param {Number} index
     *     The index of the frame which should become the new playback
     *     position.
     *
     * @param {function} callback
     *     The callback to invoke once the seek operation has completed.
     *
     * @param {Number} [delay=0]
     *     The number of milliseconds that the seek operation should be
     *     scheduled to take.
     */
    var seekToFrame = function seekToFrame(index, callback, delay) {

        // Abort any in-progress seek
        abortSeek();

        // Replay frames asynchronously
        seekTimeout = window.setTimeout(function continueSeek() {

            var startIndex;

            // Back up until startIndex represents current state
            for (startIndex = index; startIndex >= 0; startIndex--) {

                var frame = frames[startIndex];

                // If we've reached the current frame, startIndex represents
                // current state by definition
                if (startIndex === currentFrame)
                    break;

                // If frame has associated absolute state, make that frame the
                // current state
                if (frame.clientState) {
                    playbackClient.importState(frame.clientState);
                    break;
                }

            }

            // Advance to frame index after current state
            startIndex++;

            var startTime = new Date().getTime();

            // Replay any applicable incremental frames
            for (; startIndex <= index; startIndex++) {

                // Stop seeking if the operation is taking too long
                var currentTime = new Date().getTime();
                if (currentTime - startTime >= MAXIMUM_SEEK_TIME)
                    break;

                replayFrame(startIndex);
            }

            // Current frame is now at requested index
            currentFrame = startIndex - 1;

            // Notify of changes in position
            if (recording.onseek)
                recording.onseek(recording.getPosition());

            // If the seek operation has not yet completed, schedule continuation
            if (currentFrame !== index)
                seekToFrame(index, callback,
                    Math.max(delay - (new Date().getTime() - startTime), 0));

            // Notify that the requested seek has completed
            else
                callback();

        }, delay || 0);

    };

    /**
     * Aborts the seek operation currently in progress, if any. If no seek
     * operation is in progress, this function has no effect.
     *
     * @private
     */
    var abortSeek = function abortSeek() {
        window.clearTimeout(seekTimeout);
    };

    /**
     * Advances playback to the next frame in the frames array and schedules
     * playback of the frame following that frame based on their associated
     * timestamps. If no frames exist after the next frame, playback is paused.
     *
     * @private
     */
    var continuePlayback = function continuePlayback() {

        // If frames remain after advancing, schedule next frame
        if (currentFrame + 1 < frames.length) {

            // Pull the upcoming frame
            var next = frames[currentFrame + 1];

            // Calculate the real timestamp corresponding to when the next
            // frame begins
            var nextRealTimestamp = next.timestamp - startVideoTimestamp + startRealTimestamp;

            // Calculate the relative delay between the current time and
            // the next frame start
            var delay = Math.max(nextRealTimestamp - new Date().getTime(), 0);

            // Advance to next frame after enough time has elapsed
            seekToFrame(currentFrame + 1, function frameDelayElapsed() {
                continuePlayback();
            }, delay);

        }

        // Otherwise stop playback
        else
            recording.pause();

    };

    /**
     * Fired when new frames have become available while the recording is
     * being downloaded.
     *
     * @event
     * @param {Number} duration
     *     The new duration of the recording, in milliseconds.
     */
    this.onprogress = null;

    /**
     * Fired whenever playback of the recording has started.
     *
     * @event
     */
    this.onplay = null;

    /**
     * Fired whenever playback of the recording has been paused. This may
     * happen when playback is explicitly paused with a call to pause(), or
     * when playback is implicitly paused due to reaching the end of the
     * recording.
     *
     * @event
     */
    this.onpause = null;

    /**
     * Fired whenever the playback position within the recording changes.
     *
     * @event
     * @param {Number} position
     *     The new position within the recording, in milliseconds.
     */
    this.onseek = null;

    /**
     * Connects the underlying tunnel, beginning download of the Guacamole
     * session. Playback of the Guacamole session cannot occur until at least
     * one frame worth of instructions has been downloaded.
     *
     * @param {String} data
     *     The data to send to the tunnel when connecting.
     */
    this.connect = function connect(data) {
        tunnel.connect(data);
    };

    /**
     * Disconnects the underlying tunnel, stopping further download of the
     * Guacamole session.
     */
    this.disconnect = function disconnect() {
        tunnel.disconnect();
    };

    /**
     * Returns the underlying display of the Guacamole.Client used by this
     * Guacamole.SessionRecording for playback. The display contains an Element
     * which can be added to the DOM, causing the display (and thus playback of
     * the recording) to become visible.
     *
     * @return {Guacamole.Display}
     *     The underlying display of the Guacamole.Client used by this
     *     Guacamole.SessionRecording for playback.
     */
    this.getDisplay = function getDisplay() {
        return playbackClient.getDisplay();
    };

    /**
     * Returns whether playback is currently in progress.
     *
     * @returns {Boolean}
     *     true if playback is currently in progress, false otherwise.
     */
    this.isPlaying = function isPlaying() {
        return !!startVideoTimestamp;
    };

    /**
     * Returns the current playback position within the recording, in
     * milliseconds, where zero is the start of the recording.
     *
     * @returns {Number}
     *     The current playback position within the recording, in milliseconds.
     */
    this.getPosition = function getPosition() {

        // Position is simply zero if playback has not started at all
        if (currentFrame === -1)
            return 0;

        // Return current position as a millisecond timestamp relative to the
        // start of the recording
        return toRelativeTimestamp(frames[currentFrame].timestamp);

    };

    /**
     * Returns the duration of this recording, in milliseconds. If the
     * recording is still being downloaded, this value will gradually increase.
     *
     * @returns {Number}
     *     The duration of this recording, in milliseconds.
     */
    this.getDuration = function getDuration() {

        // If no frames yet exist, duration is zero
        if (frames.length === 0)
            return 0;

        // Recording duration is simply the timestamp of the last frame
        return toRelativeTimestamp(frames[frames.length - 1].timestamp);

    };

    /**
     * Begins continuous playback of the recording downloaded thus far.
     * Playback of the recording will continue until pause() is invoked or
     * until no further frames exist. Playback is initially paused when a
     * Guacamole.SessionRecording is created, and must be explicitly started
     * through a call to this function. If playback is already in progress,
     * this function has no effect. If a seek operation is in progress,
     * playback resumes at the current position, and the seek is aborted as if
     * completed.
     */
    this.play = function play() {

        // If playback is not already in progress and frames remain,
        // begin playback
        if (!recording.isPlaying() && currentFrame + 1 < frames.length) {

            // Notify that playback is starting
            if (recording.onplay)
                recording.onplay();

            // Store timestamp of playback start for relative scheduling of
            // future frames
            var next = frames[currentFrame + 1];
            startVideoTimestamp = next.timestamp;
            startRealTimestamp = new Date().getTime();

            // Begin playback of video
            continuePlayback();

        }

    };

    /**
     * Seeks to the given position within the recording. If the recording is
     * currently being played back, playback will continue after the seek is
     * performed. If the recording is currently paused, playback will be
     * paused after the seek is performed. If a seek operation is already in
     * progress, that seek is first aborted. The seek operation will proceed
     * asynchronously.
     *
     * @param {Number} position
     *     The position within the recording to seek to, in milliseconds.
     *
     * @param {function} [callback]
     *     The callback to invoke once the seek operation has completed.
     */
    this.seek = function seek(position, callback) {

        // Do not seek if no frames exist
        if (frames.length === 0)
            return;

        // Pause playback, preserving playback state
        var originallyPlaying = recording.isPlaying();
        recording.pause();

        // Perform seek
        seekToFrame(findFrame(0, frames.length - 1, position), function restorePlaybackState() {

            // Restore playback state
            if (originallyPlaying)
                recording.play();

            // Notify that seek has completed
            if (callback)
                callback();

        });

    };

    /**
     * Pauses playback of the recording, if playback is currently in progress.
     * If playback is not in progress, this function has no effect. If a seek
     * operation is in progress, the seek is aborted. Playback is initially
     * paused when a Guacamole.SessionRecording is created, and must be
     * explicitly started through a call to play().
     */
    this.pause = function pause() {

        // Abort any in-progress seek / playback
        abortSeek();

        // Stop playback only if playback is in progress
        if (recording.isPlaying()) {

            // Notify that playback is stopping
            if (recording.onpause)
                recording.onpause();

            // Playback is stopped
            startVideoTimestamp = null;
            startRealTimestamp = null;

        }

    };

};

/**
 * A single frame of Guacamole session data. Each frame is made up of the set
 * of instructions used to generate that frame, and the timestamp as dictated
 * by the "sync" instruction terminating the frame. Optionally, a frame may
 * also be associated with a snapshot of Guacamole client state, such that the
 * frame can be rendered without replaying all previous frames.
 *
 * @private
 * @constructor
 * @param {Number} timestamp
 *     The timestamp of this frame, as dictated by the "sync" instruction which
 *     terminates the frame.
 *
 * @param {Guacamole.SessionRecording._Frame.Instruction[]} instructions
 *     All instructions which are necessary to generate this frame relative to
 *     the previous frame in the Guacamole session.
 */
Guacamole.SessionRecording._Frame = function _Frame(timestamp, instructions) {

    /**
     * Whether this frame should be used as a keyframe if possible. This value
     * is purely advisory. The stored clientState must eventually be manually
     * set for the frame to be used as a keyframe. By default, frames are not
     * keyframes.
     *
     * @type {Boolean}
     * @default false
     */
    this.keyframe = false;

    /**
     * The timestamp of this frame, as dictated by the "sync" instruction which
     * terminates the frame.
     *
     * @type {Number}
     */
    this.timestamp = timestamp;

    /**
     * All instructions which are necessary to generate this frame relative to
     * the previous frame in the Guacamole session.
     *
     * @type {Guacamole.SessionRecording._Frame.Instruction[]}
     */
    this.instructions = instructions;

    /**
     * A snapshot of client state after this frame was rendered, as returned by
     * a call to exportState(). If no such snapshot has been taken, this will
     * be null.
     *
     * @type {Object}
     * @default null
     */
    this.clientState = null;

};

/**
 * A Guacamole protocol instruction. Each Guacamole protocol instruction is
 * made up of an opcode and set of arguments.
 *
 * @private
 * @constructor
 * @param {String} opcode
 *     The opcode of this Guacamole instruction.
 *
 * @param {String[]} args
 *     All arguments associated with this Guacamole instruction.
 */
Guacamole.SessionRecording._Frame.Instruction = function Instruction(opcode, args) {

    /**
     * Reference to this Guacamole.SessionRecording._Frame.Instruction.
     *
     * @private
     * @type {Guacamole.SessionRecording._Frame.Instruction}
     */
    var instruction = this;

    /**
     * The opcode of this Guacamole instruction.
     *
     * @type {String}
     */
    this.opcode = opcode;

    /**
     * All arguments associated with this Guacamole instruction.
     *
     * @type {String[]}
     */
    this.args = args;

    /**
     * Returns the approximate number of characters which make up this
     * instruction. This value is only approximate as it excludes the length
     * prefixes and various delimiters used by the Guacamole protocol; only
     * the content of the opcode and each argument is taken into account.
     *
     * @returns {Number}
     *     The approximate size of this instruction, in characters.
     */
    this.getSize = function getSize() {

        // Init with length of opcode
        var size = instruction.opcode.length;

        // Add length of all arguments
        for (var i = 0; i < instruction.args.length; i++)
            size += instruction.args[i].length;

        return size;

    };

};

/**
 * A read-only Guacamole.Tunnel implementation which streams instructions
 * received through explicit calls to its receiveInstruction() function.
 *
 * @private
 * @constructor
 * @augments {Guacamole.Tunnel}
 */
Guacamole.SessionRecording._PlaybackTunnel = function _PlaybackTunnel() {

    /**
     * Reference to this Guacamole.SessionRecording._PlaybackTunnel.
     *
     * @private
     * @type {Guacamole.SessionRecording._PlaybackTunnel}
     */
    var tunnel = this;

    this.connect = function connect(data) {
        // Do nothing
    };

    this.sendMessage = function sendMessage(elements) {
        // Do nothing
    };

    this.disconnect = function disconnect() {
        // Do nothing
    };

    /**
     * Invokes this tunnel's oninstruction handler, notifying users of this
     * tunnel (such as a Guacamole.Client instance) that an instruction has
     * been received. If the oninstruction handler has not been set, this
     * function has no effect.
     *
     * @param {String} opcode
     *     The opcode of the Guacamole instruction.
     *
     * @param {String[]} args
     *     All arguments associated with this Guacamole instruction.
     */
    this.receiveInstruction = function receiveInstruction(opcode, args) {
        if (tunnel.oninstruction)
            tunnel.oninstruction(opcode, args);
    };

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A Guacamole status. Each Guacamole status consists of a status code, defined
 * by the protocol, and an optional human-readable message, usually only
 * included for debugging convenience.
 *
 * @constructor
 * @param {Number} code
 *     The Guacamole status code, as defined by Guacamole.Status.Code.
 *
 * @param {String} [message]
 *     An optional human-readable message.
 */
Guacamole.Status = function(code, message) {

    /**
     * Reference to this Guacamole.Status.
     * @private
     */
    var guac_status = this;

    /**
     * The Guacamole status code.
     * @see Guacamole.Status.Code
     * @type {Number}
     */
    this.code = code;

    /**
     * An arbitrary human-readable message associated with this status, if any.
     * The human-readable message is not required, and is generally provided
     * for debugging purposes only. For user feedback, it is better to translate
     * the Guacamole status code into a message.
     * 
     * @type {String}
     */
    this.message = message;

    /**
     * Returns whether this status represents an error.
     * @returns {Boolean} true if this status represents an error, false
     *                    otherwise.
     */
    this.isError = function() {
        return guac_status.code < 0 || guac_status.code > 0x00FF;
    };

};

/**
 * Enumeration of all Guacamole status codes.
 */
Guacamole.Status.Code = {

    /**
     * The operation succeeded.
     *
     * @type {Number}
     */
    "SUCCESS": 0x0000,

    /**
     * The requested operation is unsupported.
     *
     * @type {Number}
     */
    "UNSUPPORTED": 0x0100,

    /**
     * The operation could not be performed due to an internal failure.
     *
     * @type {Number}
     */
    "SERVER_ERROR": 0x0200,

    /**
     * The operation could not be performed as the server is busy.
     *
     * @type {Number}
     */
    "SERVER_BUSY": 0x0201,

    /**
     * The operation could not be performed because the upstream server is not
     * responding.
     *
     * @type {Number}
     */
    "UPSTREAM_TIMEOUT": 0x0202,

    /**
     * The operation was unsuccessful due to an error or otherwise unexpected
     * condition of the upstream server.
     *
     * @type {Number}
     */
    "UPSTREAM_ERROR": 0x0203,

    /**
     * The operation could not be performed as the requested resource does not
     * exist.
     *
     * @type {Number}
     */
    "RESOURCE_NOT_FOUND": 0x0204,

    /**
     * The operation could not be performed as the requested resource is
     * already in use.
     *
     * @type {Number}
     */
    "RESOURCE_CONFLICT": 0x0205,

    /**
     * The operation could not be performed as the requested resource is now
     * closed.
     *
     * @type {Number}
     */
    "RESOURCE_CLOSED": 0x0206,

    /**
     * The operation could not be performed because the upstream server does
     * not appear to exist.
     *
     * @type {Number}
     */
    "UPSTREAM_NOT_FOUND": 0x0207,

    /**
     * The operation could not be performed because the upstream server is not
     * available to service the request.
     *
     * @type {Number}
     */
    "UPSTREAM_UNAVAILABLE": 0x0208,

    /**
     * The session within the upstream server has ended because it conflicted
     * with another session.
     *
     * @type {Number}
     */
    "SESSION_CONFLICT": 0x0209,

    /**
     * The session within the upstream server has ended because it appeared to
     * be inactive.
     *
     * @type {Number}
     */
    "SESSION_TIMEOUT": 0x020A,

    /**
     * The session within the upstream server has been forcibly terminated.
     *
     * @type {Number}
     */
    "SESSION_CLOSED": 0x020B,

    /**
     * The operation could not be performed because bad parameters were given.
     *
     * @type {Number}
     */
    "CLIENT_BAD_REQUEST": 0x0300,

    /**
     * Permission was denied to perform the operation, as the user is not yet
     * authorized (not yet logged in, for example).
     *
     * @type {Number}
     */
    "CLIENT_UNAUTHORIZED": 0x0301,

    /**
     * Permission was denied to perform the operation, and this permission will
     * not be granted even if the user is authorized.
     *
     * @type {Number}
     */
    "CLIENT_FORBIDDEN": 0x0303,

    /**
     * The client took too long to respond.
     *
     * @type {Number}
     */
    "CLIENT_TIMEOUT": 0x0308,

    /**
     * The client sent too much data.
     *
     * @type {Number}
     */
    "CLIENT_OVERRUN": 0x030D,

    /**
     * The client sent data of an unsupported or unexpected type.
     *
     * @type {Number}
     */
    "CLIENT_BAD_TYPE": 0x030F,

    /**
     * The operation failed because the current client is already using too
     * many resources.
     *
     * @type {Number}
     */
    "CLIENT_TOO_MANY": 0x031D

};

/**
 * Returns the Guacamole protocol status code which most closely
 * represents the given HTTP status code.
 *
 * @param {Number} status
 *     The HTTP status code to translate into a Guacamole protocol status
 *     code.
 *
 * @returns {Number}
 *     The Guacamole protocol status code which most closely represents the
 *     given HTTP status code.
 */
Guacamole.Status.Code.fromHTTPCode = function fromHTTPCode(status) {

    // Translate status codes with known equivalents
    switch (status) {

        // HTTP 400 - Bad request
        case 400:
            return Guacamole.Status.Code.CLIENT_BAD_REQUEST;

        // HTTP 403 - Forbidden
        case 403:
            return Guacamole.Status.Code.CLIENT_FORBIDDEN;

        // HTTP 404 - Resource not found
        case 404:
            return Guacamole.Status.Code.RESOURCE_NOT_FOUND;

        // HTTP 429 - Too many requests
        case 429:
            return Guacamole.Status.Code.CLIENT_TOO_MANY;

        // HTTP 503 - Server unavailable
        case 503:
            return Guacamole.Status.Code.SERVER_BUSY;

    }

    // Default all other codes to generic internal error
    return Guacamole.Status.Code.SERVER_ERROR;

};

/**
 * Returns the Guacamole protocol status code which most closely
 * represents the given WebSocket status code.
 *
 * @param {Number} code
 *     The WebSocket status code to translate into a Guacamole protocol
 *     status code.
 *
 * @returns {Number}
 *     The Guacamole protocol status code which most closely represents the
 *     given WebSocket status code.
 */
Guacamole.Status.Code.fromWebSocketCode = function fromWebSocketCode(code) {

    // Translate status codes with known equivalents
    switch (code) {

        // Successful disconnect (no error)
        case 1000: // Normal Closure
            return Guacamole.Status.Code.SUCCESS;

        // Codes which indicate the server is not reachable
        case 1006: // Abnormal Closure (also signalled by JavaScript when the connection cannot be opened in the first place)
        case 1015: // TLS Handshake
            return Guacamole.Status.Code.UPSTREAM_NOT_FOUND;

        // Codes which indicate the server is reachable but busy/unavailable
        case 1001: // Going Away
        case 1012: // Service Restart
        case 1013: // Try Again Later
        case 1014: // Bad Gateway
            return Guacamole.Status.Code.UPSTREAM_UNAVAILABLE;

    }

    // Default all other codes to generic internal error
    return Guacamole.Status.Code.SERVER_ERROR;

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, returning
 * strictly text data. Note that this object will overwrite any installed event
 * handlers on the given Guacamole.InputStream.
 * 
 * @constructor
 * @param {Guacamole.InputStream} stream The stream that data will be read
 *                                       from.
 */
Guacamole.StringReader = function(stream) {

    /**
     * Reference to this Guacamole.InputStream.
     * @private
     */
    var guac_reader = this;

    /**
     * Wrapped Guacamole.ArrayBufferReader.
     * @private
     * @type {Guacamole.ArrayBufferReader}
     */
    var array_reader = new Guacamole.ArrayBufferReader(stream);

    /**
     * The number of bytes remaining for the current codepoint.
     *
     * @private
     * @type {Number}
     */
    var bytes_remaining = 0;

    /**
     * The current codepoint value, as calculated from bytes read so far.
     *
     * @private
     * @type {Number}
     */
    var codepoint = 0;

    /**
     * Decodes the given UTF-8 data into a Unicode string. The data may end in
     * the middle of a multibyte character.
     * 
     * @private
     * @param {ArrayBuffer} buffer Arbitrary UTF-8 data.
     * @return {String} A decoded Unicode string.
     */
    function __decode_utf8(buffer) {

        var text = "";

        var bytes = new Uint8Array(buffer);
        for (var i=0; i<bytes.length; i++) {

            // Get current byte
            var value = bytes[i];

            // Start new codepoint if nothing yet read
            if (bytes_remaining === 0) {

                // 1 byte (0xxxxxxx)
                if ((value | 0x7F) === 0x7F)
                    text += String.fromCharCode(value);

                // 2 byte (110xxxxx)
                else if ((value | 0x1F) === 0xDF) {
                    codepoint = value & 0x1F;
                    bytes_remaining = 1;
                }

                // 3 byte (1110xxxx)
                else if ((value | 0x0F )=== 0xEF) {
                    codepoint = value & 0x0F;
                    bytes_remaining = 2;
                }

                // 4 byte (11110xxx)
                else if ((value | 0x07) === 0xF7) {
                    codepoint = value & 0x07;
                    bytes_remaining = 3;
                }

                // Invalid byte
                else
                    text += "\uFFFD";

            }

            // Continue existing codepoint (10xxxxxx)
            else if ((value | 0x3F) === 0xBF) {

                codepoint = (codepoint << 6) | (value & 0x3F);
                bytes_remaining--;

                // Write codepoint if finished
                if (bytes_remaining === 0)
                    text += String.fromCharCode(codepoint);

            }

            // Invalid byte
            else {
                bytes_remaining = 0;
                text += "\uFFFD";
            }

        }

        return text;

    }

    // Receive blobs as strings
    array_reader.ondata = function(buffer) {

        // Decode UTF-8
        var text = __decode_utf8(buffer);

        // Call handler, if present
        if (guac_reader.ontext)
            guac_reader.ontext(text);

    };

    // Simply call onend when end received
    array_reader.onend = function() {
        if (guac_reader.onend)
            guac_reader.onend();
    };

    /**
     * Fired once for every blob of text data received.
     * 
     * @event
     * @param {String} text The data packet received.
     */
    this.ontext = null;

    /**
     * Fired once this stream is finished and no further data will be written.
     * @event
     */
    this.onend = null;

};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A writer which automatically writes to the given output stream with text
 * data.
 * 
 * @constructor
 * @param {Guacamole.OutputStream} stream The stream that data will be written
 *                                        to.
 */
Guacamole.StringWriter = function(stream) {

    /**
     * Reference to this Guacamole.StringWriter.
     * @private
     */
    var guac_writer = this;

    /**
     * Wrapped Guacamole.ArrayBufferWriter.
     * @private
     * @type {Guacamole.ArrayBufferWriter}
     */
    var array_writer = new Guacamole.ArrayBufferWriter(stream);

    /**
     * Internal buffer for UTF-8 output.
     * @private
     */
    var buffer = new Uint8Array(8192);

    /**
     * The number of bytes currently in the buffer.
     * @private
     */
    var length = 0;

    // Simply call onack for acknowledgements
    array_writer.onack = function(status) {
        if (guac_writer.onack)
            guac_writer.onack(status);
    };

    /**
     * Expands the size of the underlying buffer by the given number of bytes,
     * updating the length appropriately.
     * 
     * @private
     * @param {Number} bytes The number of bytes to add to the underlying
     *                       buffer.
     */
    function __expand(bytes) {

        // Resize buffer if more space needed
        if (length+bytes >= buffer.length) {
            var new_buffer = new Uint8Array((length+bytes)*2);
            new_buffer.set(buffer);
            buffer = new_buffer;
        }

        length += bytes;

    }

    /**
     * Appends a single Unicode character to the current buffer, resizing the
     * buffer if necessary. The character will be encoded as UTF-8.
     * 
     * @private
     * @param {Number} codepoint The codepoint of the Unicode character to
     *                           append.
     */
    function __append_utf8(codepoint) {

        var mask;
        var bytes;

        // 1 byte
        if (codepoint <= 0x7F) {
            mask = 0x00;
            bytes = 1;
        }

        // 2 byte
        else if (codepoint <= 0x7FF) {
            mask = 0xC0;
            bytes = 2;
        }

        // 3 byte
        else if (codepoint <= 0xFFFF) {
            mask = 0xE0;
            bytes = 3;
        }

        // 4 byte
        else if (codepoint <= 0x1FFFFF) {
            mask = 0xF0;
            bytes = 4;
        }

        // If invalid codepoint, append replacement character
        else {
            __append_utf8(0xFFFD);
            return;
        }

        // Offset buffer by size
        __expand(bytes);
        var offset = length - 1;

        // Add trailing bytes, if any
        for (var i=1; i<bytes; i++) {
            buffer[offset--] = 0x80 | (codepoint & 0x3F);
            codepoint >>= 6;
        }

        // Set initial byte
        buffer[offset] = mask | codepoint;

    }

    /**
     * Encodes the given string as UTF-8, returning an ArrayBuffer containing
     * the resulting bytes.
     * 
     * @private
     * @param {String} text The string to encode as UTF-8.
     * @return {Uint8Array} The encoded UTF-8 data.
     */
    function __encode_utf8(text) {

        // Fill buffer with UTF-8
        for (var i=0; i<text.length; i++) {
            var codepoint = text.charCodeAt(i);
            __append_utf8(codepoint);
        }

        // Flush buffer
        if (length > 0) {
            var out_buffer = buffer.subarray(0, length);
            length = 0;
            return out_buffer;
        }

    }

    /**
     * Sends the given text.
     * 
     * @param {String} text The text to send.
     */
    this.sendText = function(text) {
        if (text.length)
            array_writer.sendData(__encode_utf8(text));
    };

    /**
     * Signals that no further text will be sent, effectively closing the
     * stream.
     */
    this.sendEnd = function() {
        array_writer.sendEnd();
    };

    /**
     * Fired for received data, if acknowledged by the server.
     * @event
     * @param {Guacamole.Status} status The status of the operation.
     */
    this.onack = null;

};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Core object providing abstract communication for Guacamole. This object
 * is a null implementation whose functions do nothing. Guacamole applications
 * should use {@link Guacamole.HTTPTunnel} instead, or implement their own tunnel based
 * on this one.
 * 
 * @constructor
 * @see Guacamole.HTTPTunnel
 */
Guacamole.Tunnel = function() {

    /**
     * Connect to the tunnel with the given optional data. This data is
     * typically used for authentication. The format of data accepted is
     * up to the tunnel implementation.
     * 
     * @param {String} data The data to send to the tunnel when connecting.
     */
    this.connect = function(data) {};
    
    /**
     * Disconnect from the tunnel.
     */
    this.disconnect = function() {};
    
    /**
     * Send the given message through the tunnel to the service on the other
     * side. All messages are guaranteed to be received in the order sent.
     * 
     * @param {...*} elements
     *     The elements of the message to send to the service on the other side
     *     of the tunnel.
     */
    this.sendMessage = function(elements) {};

    /**
     * Changes the stored numeric state of this tunnel, firing the onstatechange
     * event if the new state is different and a handler has been defined.
     *
     * @private
     * @param {Number} state
     *     The new state of this tunnel.
     */
    this.setState = function(state) {

        // Notify only if state changes
        if (state !== this.state) {
            this.state = state;
            if (this.onstatechange)
                this.onstatechange(state);
        }

    };

    /**
     * Changes the stored UUID that uniquely identifies this tunnel, firing the
     * onuuid event if a handler has been defined.
     *
     * @private
     * @param {String} uuid
     *     The new state of this tunnel.
     */
    this.setUUID = function setUUID(uuid) {
        this.uuid = uuid;
        if (this.onuuid)
            this.onuuid(uuid);
    };

    /**
     * Returns whether this tunnel is currently connected.
     *
     * @returns {Boolean}
     *     true if this tunnel is currently connected, false otherwise.
     */
    this.isConnected = function isConnected() {
        return this.state === Guacamole.Tunnel.State.OPEN
            || this.state === Guacamole.Tunnel.State.UNSTABLE;
    };

    /**
     * The current state of this tunnel.
     * 
     * @type {Number}
     */
    this.state = Guacamole.Tunnel.State.CONNECTING;

    /**
     * The maximum amount of time to wait for data to be received, in
     * milliseconds. If data is not received within this amount of time,
     * the tunnel is closed with an error. The default value is 15000.
     *
     * @type {Number}
     */
    this.receiveTimeout = 15000;

    /**
     * The amount of time to wait for data to be received before considering
     * the connection to be unstable, in milliseconds. If data is not received
     * within this amount of time, the tunnel status is updated to warn that
     * the connection appears unresponsive and may close. The default value is
     * 1500.
     * 
     * @type {Number}
     */
    this.unstableThreshold = 1500;

    /**
     * The UUID uniquely identifying this tunnel. If not yet known, this will
     * be null.
     *
     * @type {String}
     */
    this.uuid = null;

    /**
     * Fired when the UUID that uniquely identifies this tunnel is known.
     *
     * @event
     * @param {String}
     *     The UUID uniquely identifying this tunnel.
     */
    this.onuuid = null;

    /**
     * Fired whenever an error is encountered by the tunnel.
     * 
     * @event
     * @param {Guacamole.Status} status A status object which describes the
     *                                  error.
     */
    this.onerror = null;

    /**
     * Fired whenever the state of the tunnel changes.
     * 
     * @event
     * @param {Number} state The new state of the client.
     */
    this.onstatechange = null;

    /**
     * Fired once for every complete Guacamole instruction received, in order.
     * 
     * @event
     * @param {String} opcode The Guacamole instruction opcode.
     * @param {Array} parameters The parameters provided for the instruction,
     *                           if any.
     */
    this.oninstruction = null;

};

/**
 * The Guacamole protocol instruction opcode reserved for arbitrary internal
 * use by tunnel implementations. The value of this opcode is guaranteed to be
 * the empty string (""). Tunnel implementations may use this opcode for any
 * purpose. It is currently used by the HTTP tunnel to mark the end of the HTTP
 * response, and by the WebSocket tunnel to transmit the tunnel UUID and send
 * connection stability test pings/responses.
 *
 * @constant
 * @type {String}
 */
Guacamole.Tunnel.INTERNAL_DATA_OPCODE = '';

/**
 * All possible tunnel states.
 */
Guacamole.Tunnel.State = {

    /**
     * A connection is in pending. It is not yet known whether connection was
     * successful.
     * 
     * @type {Number}
     */
    "CONNECTING": 0,

    /**
     * Connection was successful, and data is being received.
     * 
     * @type {Number}
     */
    "OPEN": 1,

    /**
     * The connection is closed. Connection may not have been successful, the
     * tunnel may have been explicitly closed by either side, or an error may
     * have occurred.
     * 
     * @type {Number}
     */
    "CLOSED": 2,

    /**
     * The connection is open, but communication through the tunnel appears to
     * be disrupted, and the connection may close as a result.
     *
     * @type {Number}
     */
    "UNSTABLE" : 3

};

/**
 * Guacamole Tunnel implemented over HTTP via XMLHttpRequest.
 * 
 * @constructor
 * @augments Guacamole.Tunnel
 *
 * @param {String} tunnelURL
 *     The URL of the HTTP tunneling service.
 *
 * @param {Boolean} [crossDomain=false]
 *     Whether tunnel requests will be cross-domain, and thus must use CORS
 *     mechanisms and headers. By default, it is assumed that tunnel requests
 *     will be made to the same domain.
 *
 * @param {Object} [extraTunnelHeaders={}]
 *     Key value pairs containing the header names and values of any additional
 *     headers to be sent in tunnel requests. By default, no extra headers will
 *     be added.
 */
Guacamole.HTTPTunnel = function(tunnelURL, crossDomain, extraTunnelHeaders) {

    /**
     * Reference to this HTTP tunnel.
     * @private
     */
    var tunnel = this;

    var TUNNEL_CONNECT = tunnelURL + "?connect";
    var TUNNEL_READ    = tunnelURL + "?read:";
    var TUNNEL_WRITE   = tunnelURL + "?write:";

    var POLLING_ENABLED     = 1;
    var POLLING_DISABLED    = 0;

    // Default to polling - will be turned off automatically if not needed
    var pollingMode = POLLING_ENABLED;

    var sendingMessages = false;
    var outputMessageBuffer = "";

    // If requests are expected to be cross-domain, the cookie that the HTTP
    // tunnel depends on will only be sent if withCredentials is true
    var withCredentials = !!crossDomain;

    /**
     * The current receive timeout ID, if any.
     * @private
     */
    var receive_timeout = null;

    /**
     * The current connection stability timeout ID, if any.
     *
     * @private
     * @type {Number}
     */
    var unstableTimeout = null;

    /**
     * The current connection stability test ping interval ID, if any. This
     * will only be set upon successful connection.
     *
     * @private
     * @type {Number}
     */
    var pingInterval = null;

    /**
     * The number of milliseconds to wait between connection stability test
     * pings.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var PING_FREQUENCY = 500;

    /**
     * Additional headers to be sent in tunnel requests. This dictionary can be
     * populated with key/value header pairs to pass information such as authentication
     * tokens, etc.
     *
     * @private
     */
    var extraHeaders = extraTunnelHeaders || {};

    /**
     * Adds the configured additional headers to the given request.
     *
     * @param {XMLHttpRequest} request
     *     The request where the configured extra headers will be added.
     *
     * @param {Object} headers
     *     The headers to be added to the request.
     *
     * @private
     */
    function addExtraHeaders(request, headers) {
        for (var name in headers) {
            request.setRequestHeader(name, headers[name]);
        }
    }

    /**
     * Initiates a timeout which, if data is not received, causes the tunnel
     * to close with an error.
     * 
     * @private
     */
    function reset_timeout() {

        // Get rid of old timeouts (if any)
        window.clearTimeout(receive_timeout);
        window.clearTimeout(unstableTimeout);

        // Clear unstable status
        if (tunnel.state === Guacamole.Tunnel.State.UNSTABLE)
            tunnel.setState(Guacamole.Tunnel.State.OPEN);

        // Set new timeout for tracking overall connection timeout
        receive_timeout = window.setTimeout(function () {
            close_tunnel(new Guacamole.Status(Guacamole.Status.Code.UPSTREAM_TIMEOUT, "Server timeout."));
        }, tunnel.receiveTimeout);

        // Set new timeout for tracking suspected connection instability
        unstableTimeout = window.setTimeout(function() {
            tunnel.setState(Guacamole.Tunnel.State.UNSTABLE);
        }, tunnel.unstableThreshold);

    }

    /**
     * Closes this tunnel, signaling the given status and corresponding
     * message, which will be sent to the onerror handler if the status is
     * an error status.
     * 
     * @private
     * @param {Guacamole.Status} status The status causing the connection to
     *                                  close;
     */
    function close_tunnel(status) {

        // Get rid of old timeouts (if any)
        window.clearTimeout(receive_timeout);
        window.clearTimeout(unstableTimeout);

        // Cease connection test pings
        window.clearInterval(pingInterval);

        // Ignore if already closed
        if (tunnel.state === Guacamole.Tunnel.State.CLOSED)
            return;

        // If connection closed abnormally, signal error.
        if (status.code !== Guacamole.Status.Code.SUCCESS && tunnel.onerror) {

            // Ignore RESOURCE_NOT_FOUND if we've already connected, as that
            // only signals end-of-stream for the HTTP tunnel.
            if (tunnel.state === Guacamole.Tunnel.State.CONNECTING
                    || status.code !== Guacamole.Status.Code.RESOURCE_NOT_FOUND)
                tunnel.onerror(status);

        }

        // Reset output message buffer
        sendingMessages = false;

        // Mark as closed
        tunnel.setState(Guacamole.Tunnel.State.CLOSED);

    }


    this.sendMessage = function() {

        // Do not attempt to send messages if not connected
        if (!tunnel.isConnected())
            return;

        // Do not attempt to send empty messages
        if (arguments.length === 0)
            return;

        /**
         * Converts the given value to a length/string pair for use as an
         * element in a Guacamole instruction.
         * 
         * @private
         * @param value The value to convert.
         * @return {String} The converted value. 
         */
        function getElement(value) {
            var string = new String(value);
            return string.length + "." + string; 
        }

        // Initialized message with first element
        var message = getElement(arguments[0]);

        // Append remaining elements
        for (var i=1; i<arguments.length; i++)
            message += "," + getElement(arguments[i]);

        // Final terminator
        message += ";";

        // Add message to buffer
        outputMessageBuffer += message;

        // Send if not currently sending
        if (!sendingMessages)
            sendPendingMessages();

    };

    function sendPendingMessages() {

        // Do not attempt to send messages if not connected
        if (!tunnel.isConnected())
            return;

        if (outputMessageBuffer.length > 0) {

            sendingMessages = true;

            var message_xmlhttprequest = new XMLHttpRequest();
            message_xmlhttprequest.open("POST", TUNNEL_WRITE + tunnel.uuid);
            message_xmlhttprequest.withCredentials = withCredentials;
            addExtraHeaders(message_xmlhttprequest, extraHeaders);
            message_xmlhttprequest.setRequestHeader("Content-type", "application/octet-stream");

            // Once response received, send next queued event.
            message_xmlhttprequest.onreadystatechange = function() {
                if (message_xmlhttprequest.readyState === 4) {

                    reset_timeout();

                    // If an error occurs during send, handle it
                    if (message_xmlhttprequest.status !== 200)
                        handleHTTPTunnelError(message_xmlhttprequest);

                    // Otherwise, continue the send loop
                    else
                        sendPendingMessages();

                }
            };

            message_xmlhttprequest.send(outputMessageBuffer);
            outputMessageBuffer = ""; // Clear buffer

        }
        else
            sendingMessages = false;

    }

    function handleHTTPTunnelError(xmlhttprequest) {

        // Pull status code directly from headers provided by Guacamole
        var code = parseInt(xmlhttprequest.getResponseHeader("Guacamole-Status-Code"));
        if (code) {
            var message = xmlhttprequest.getResponseHeader("Guacamole-Error-Message");
            close_tunnel(new Guacamole.Status(code, message));
        }

        // Failing that, derive a Guacamole status code from the HTTP status
        // code provided by the browser
        else if (xmlhttprequest.status)
            close_tunnel(new Guacamole.Status(
                Guacamole.Status.Code.fromHTTPCode(xmlhttprequest.status),
                    xmlhttprequest.statusText));

        // Otherwise, assume server is unreachable
        else
            close_tunnel(new Guacamole.Status(Guacamole.Status.Code.UPSTREAM_NOT_FOUND));

    }

    function handleResponse(xmlhttprequest) {

        var interval = null;
        var nextRequest = null;

        var dataUpdateEvents = 0;

        // The location of the last element's terminator
        var elementEnd = -1;

        // Where to start the next length search or the next element
        var startIndex = 0;

        // Parsed elements
        var elements = new Array();

        function parseResponse() {

            // Do not handle responses if not connected
            if (!tunnel.isConnected()) {
                
                // Clean up interval if polling
                if (interval !== null)
                    clearInterval(interval);
                
                return;
            }

            // Do not parse response yet if not ready
            if (xmlhttprequest.readyState < 2) return;

            // Attempt to read status
            var status;
            try { status = xmlhttprequest.status; }

            // If status could not be read, assume successful.
            catch (e) { status = 200; }

            // Start next request as soon as possible IF request was successful
            if (!nextRequest && status === 200)
                nextRequest = makeRequest();

            // Parse stream when data is received and when complete.
            if (xmlhttprequest.readyState === 3 ||
                xmlhttprequest.readyState === 4) {

                reset_timeout();

                // Also poll every 30ms (some browsers don't repeatedly call onreadystatechange for new data)
                if (pollingMode === POLLING_ENABLED) {
                    if (xmlhttprequest.readyState === 3 && !interval)
                        interval = setInterval(parseResponse, 30);
                    else if (xmlhttprequest.readyState === 4 && interval)
                        clearInterval(interval);
                }

                // If canceled, stop transfer
                if (xmlhttprequest.status === 0) {
                    tunnel.disconnect();
                    return;
                }

                // Halt on error during request
                else if (xmlhttprequest.status !== 200) {
                    handleHTTPTunnelError(xmlhttprequest);
                    return;
                }

                // Attempt to read in-progress data
                var current;
                try { current = xmlhttprequest.responseText; }

                // Do not attempt to parse if data could not be read
                catch (e) { return; }

                // While search is within currently received data
                while (elementEnd < current.length) {

                    // If we are waiting for element data
                    if (elementEnd >= startIndex) {

                        // We now have enough data for the element. Parse.
                        var element = current.substring(startIndex, elementEnd);
                        var terminator = current.substring(elementEnd, elementEnd+1);

                        // Add element to array
                        elements.push(element);

                        // If last element, handle instruction
                        if (terminator === ";") {

                            // Get opcode
                            var opcode = elements.shift();

                            // Call instruction handler.
                            if (tunnel.oninstruction)
                                tunnel.oninstruction(opcode, elements);

                            // Clear elements
                            elements.length = 0;

                        }

                        // Start searching for length at character after
                        // element terminator
                        startIndex = elementEnd + 1;

                    }

                    // Search for end of length
                    var lengthEnd = current.indexOf(".", startIndex);
                    if (lengthEnd !== -1) {

                        // Parse length
                        var length = parseInt(current.substring(elementEnd+1, lengthEnd));

                        // If we're done parsing, handle the next response.
                        if (length === 0) {

                            // Clean up interval if polling
                            if (interval)
                                clearInterval(interval);
                           
                            // Clean up object
                            xmlhttprequest.onreadystatechange = null;
                            xmlhttprequest.abort();

                            // Start handling next request
                            if (nextRequest)
                                handleResponse(nextRequest);

                            // Done parsing
                            break;

                        }

                        // Calculate start of element
                        startIndex = lengthEnd + 1;

                        // Calculate location of element terminator
                        elementEnd = startIndex + length;

                    }
                    
                    // If no period yet, continue search when more data
                    // is received
                    else {
                        startIndex = current.length;
                        break;
                    }

                } // end parse loop

            }

        }

        // If response polling enabled, attempt to detect if still
        // necessary (via wrapping parseResponse())
        if (pollingMode === POLLING_ENABLED) {
            xmlhttprequest.onreadystatechange = function() {

                // If we receive two or more readyState==3 events,
                // there is no need to poll.
                if (xmlhttprequest.readyState === 3) {
                    dataUpdateEvents++;
                    if (dataUpdateEvents >= 2) {
                        pollingMode = POLLING_DISABLED;
                        xmlhttprequest.onreadystatechange = parseResponse;
                    }
                }

                parseResponse();
            };
        }

        // Otherwise, just parse
        else
            xmlhttprequest.onreadystatechange = parseResponse;

        parseResponse();

    }

    /**
     * Arbitrary integer, unique for each tunnel read request.
     * @private
     */
    var request_id = 0;

    function makeRequest() {

        // Make request, increment request ID
        var xmlhttprequest = new XMLHttpRequest();
        xmlhttprequest.open("GET", TUNNEL_READ + tunnel.uuid + ":" + (request_id++));
        xmlhttprequest.withCredentials = withCredentials;
        addExtraHeaders(xmlhttprequest, extraHeaders);
        xmlhttprequest.send(null);

        return xmlhttprequest;

    }

    this.connect = function(data) {

        // Start waiting for connect
        reset_timeout();

        // Mark the tunnel as connecting
        tunnel.setState(Guacamole.Tunnel.State.CONNECTING);

        // Start tunnel and connect
        var connect_xmlhttprequest = new XMLHttpRequest();
        connect_xmlhttprequest.onreadystatechange = function() {

            if (connect_xmlhttprequest.readyState !== 4)
                return;

            // If failure, throw error
            if (connect_xmlhttprequest.status !== 200) {
                handleHTTPTunnelError(connect_xmlhttprequest);
                return;
            }

            reset_timeout();

            // Get UUID from response
            tunnel.setUUID(connect_xmlhttprequest.responseText);

            // Mark as open
            tunnel.setState(Guacamole.Tunnel.State.OPEN);

            // Ping tunnel endpoint regularly to test connection stability
            pingInterval = setInterval(function sendPing() {
                tunnel.sendMessage("nop");
            }, PING_FREQUENCY);

            // Start reading data
            handleResponse(makeRequest());

        };

        connect_xmlhttprequest.open("POST", TUNNEL_CONNECT, true);
        connect_xmlhttprequest.withCredentials = withCredentials;
        addExtraHeaders(connect_xmlhttprequest, extraHeaders);
        connect_xmlhttprequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded; charset=UTF-8");
        connect_xmlhttprequest.send(data);

    };

    this.disconnect = function() {
        close_tunnel(new Guacamole.Status(Guacamole.Status.Code.SUCCESS, "Manually closed."));
    };

};

Guacamole.HTTPTunnel.prototype = new Guacamole.Tunnel();

/**
 * Guacamole Tunnel implemented over WebSocket via XMLHttpRequest.
 * 
 * @constructor
 * @augments Guacamole.Tunnel
 * @param {String} tunnelURL The URL of the WebSocket tunneling service.
 */
Guacamole.WebSocketTunnel = function(tunnelURL) {

    /**
     * Reference to this WebSocket tunnel.
     * @private
     */
    var tunnel = this;

    /**
     * The WebSocket used by this tunnel.
     * @private
     */
    var socket = null;

    /**
     * The current receive timeout ID, if any.
     * @private
     */
    var receive_timeout = null;

    /**
     * The current connection stability timeout ID, if any.
     *
     * @private
     * @type {Number}
     */
    var unstableTimeout = null;

    /**
     * The current connection stability test ping interval ID, if any. This
     * will only be set upon successful connection.
     *
     * @private
     * @type {Number}
     */
    var pingInterval = null;

    /**
     * The WebSocket protocol corresponding to the protocol used for the current
     * location.
     * @private
     */
    var ws_protocol = {
        "http:":  "ws:",
        "https:": "wss:"
    };

    /**
     * The number of milliseconds to wait between connection stability test
     * pings.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var PING_FREQUENCY = 500;

    // Transform current URL to WebSocket URL

    // If not already a websocket URL
    if (   tunnelURL.substring(0, 3) !== "ws:"
        && tunnelURL.substring(0, 4) !== "wss:") {

        var protocol = ws_protocol[window.location.protocol];

        // If absolute URL, convert to absolute WS URL
        if (tunnelURL.substring(0, 1) === "/")
            tunnelURL =
                protocol
                + "//" + window.location.host
                + tunnelURL;

        // Otherwise, construct absolute from relative URL
        else {

            // Get path from pathname
            var slash = window.location.pathname.lastIndexOf("/");
            var path  = window.location.pathname.substring(0, slash + 1);

            // Construct absolute URL
            tunnelURL =
                protocol
                + "//" + window.location.host
                + path
                + tunnelURL;

        }

    }

    /**
     * Initiates a timeout which, if data is not received, causes the tunnel
     * to close with an error.
     * 
     * @private
     */
    function reset_timeout() {

        // Get rid of old timeouts (if any)
        window.clearTimeout(receive_timeout);
        window.clearTimeout(unstableTimeout);

        // Clear unstable status
        if (tunnel.state === Guacamole.Tunnel.State.UNSTABLE)
            tunnel.setState(Guacamole.Tunnel.State.OPEN);

        // Set new timeout for tracking overall connection timeout
        receive_timeout = window.setTimeout(function () {
            close_tunnel(new Guacamole.Status(Guacamole.Status.Code.UPSTREAM_TIMEOUT, "Server timeout."));
        }, tunnel.receiveTimeout);

        // Set new timeout for tracking suspected connection instability
        unstableTimeout = window.setTimeout(function() {
            tunnel.setState(Guacamole.Tunnel.State.UNSTABLE);
        }, tunnel.unstableThreshold);

    }

    /**
     * Closes this tunnel, signaling the given status and corresponding
     * message, which will be sent to the onerror handler if the status is
     * an error status.
     * 
     * @private
     * @param {Guacamole.Status} status The status causing the connection to
     *                                  close;
     */
    function close_tunnel(status) {

        // Get rid of old timeouts (if any)
        window.clearTimeout(receive_timeout);
        window.clearTimeout(unstableTimeout);

        // Cease connection test pings
        window.clearInterval(pingInterval);

        // Ignore if already closed
        if (tunnel.state === Guacamole.Tunnel.State.CLOSED)
            return;

        // If connection closed abnormally, signal error.
        if (status.code !== Guacamole.Status.Code.SUCCESS && tunnel.onerror)
            tunnel.onerror(status);

        // Mark as closed
        tunnel.setState(Guacamole.Tunnel.State.CLOSED);

        socket.close();

    }

    this.sendMessage = function(elements) {

        // Do not attempt to send messages if not connected
        if (!tunnel.isConnected())
            return;

        // Do not attempt to send empty messages
        if (arguments.length === 0)
            return;

        /**
         * Converts the given value to a length/string pair for use as an
         * element in a Guacamole instruction.
         * 
         * @private
         * @param value The value to convert.
         * @return {String} The converted value. 
         */
        function getElement(value) {
            var string = new String(value);
            return string.length + "." + string; 
        }

        // Initialized message with first element
        var message = getElement(arguments[0]);

        // Append remaining elements
        for (var i=1; i<arguments.length; i++)
            message += "," + getElement(arguments[i]);

        // Final terminator
        message += ";";

        socket.send(message);

    };

    this.connect = function(data) {

        reset_timeout();

        // Mark the tunnel as connecting
        tunnel.setState(Guacamole.Tunnel.State.CONNECTING);

        // Connect socket
        socket = new WebSocket(tunnelURL + "?" + data, "guacamole");

        socket.onopen = function(event) {
            reset_timeout();

            // Ping tunnel endpoint regularly to test connection stability
            pingInterval = setInterval(function sendPing() {
                tunnel.sendMessage(Guacamole.Tunnel.INTERNAL_DATA_OPCODE,
                    "ping", new Date().getTime());
            }, PING_FREQUENCY);

        };

        socket.onclose = function(event) {

            // Pull status code directly from closure reason provided by Guacamole
            if (event.reason)
                close_tunnel(new Guacamole.Status(parseInt(event.reason), event.reason));

            // Failing that, derive a Guacamole status code from the WebSocket
            // status code provided by the browser
            else if (event.code)
                close_tunnel(new Guacamole.Status(Guacamole.Status.Code.fromWebSocketCode(event.code)));

            // Otherwise, assume server is unreachable
            else
                close_tunnel(new Guacamole.Status(Guacamole.Status.Code.UPSTREAM_NOT_FOUND));

        };
        
        socket.onmessage = function(event) {

            reset_timeout();

            var message = event.data;
            var startIndex = 0;
            var elementEnd;

            var elements = [];

            do {

                // Search for end of length
                var lengthEnd = message.indexOf(".", startIndex);
                if (lengthEnd !== -1) {

                    // Parse length
                    var length = parseInt(message.substring(elementEnd+1, lengthEnd));

                    // Calculate start of element
                    startIndex = lengthEnd + 1;

                    // Calculate location of element terminator
                    elementEnd = startIndex + length;

                }
                
                // If no period, incomplete instruction.
                else
                    close_tunnel(new Guacamole.Status(Guacamole.Status.Code.SERVER_ERROR, "Incomplete instruction."));

                // We now have enough data for the element. Parse.
                var element = message.substring(startIndex, elementEnd);
                var terminator = message.substring(elementEnd, elementEnd+1);

                // Add element to array
                elements.push(element);

                // If last element, handle instruction
                if (terminator === ";") {

                    // Get opcode
                    var opcode = elements.shift();

                    // Update state and UUID when first instruction received
                    if (tunnel.uuid === null) {

                        // Associate tunnel UUID if received
                        if (opcode === Guacamole.Tunnel.INTERNAL_DATA_OPCODE)
                            tunnel.setUUID(elements[0]);

                        // Tunnel is now open and UUID is available
                        tunnel.setState(Guacamole.Tunnel.State.OPEN);

                    }

                    // Call instruction handler.
                    if (opcode !== Guacamole.Tunnel.INTERNAL_DATA_OPCODE && tunnel.oninstruction)
                        tunnel.oninstruction(opcode, elements);

                    // Clear elements
                    elements.length = 0;

                }

                // Start searching for length at character after
                // element terminator
                startIndex = elementEnd + 1;

            } while (startIndex < message.length);

        };

    };

    this.disconnect = function() {
        close_tunnel(new Guacamole.Status(Guacamole.Status.Code.SUCCESS, "Manually closed."));
    };

};

Guacamole.WebSocketTunnel.prototype = new Guacamole.Tunnel();

/**
 * Guacamole Tunnel which cycles between all specified tunnels until
 * no tunnels are left. Another tunnel is used if an error occurs but
 * no instructions have been received. If an instruction has been
 * received, or no tunnels remain, the error is passed directly out
 * through the onerror handler (if defined).
 * 
 * @constructor
 * @augments Guacamole.Tunnel
 * @param {...*} tunnelChain
 *     The tunnels to use, in order of priority.
 */
Guacamole.ChainedTunnel = function(tunnelChain) {

    /**
     * Reference to this chained tunnel.
     * @private
     */
    var chained_tunnel = this;

    /**
     * Data passed in via connect(), to be used for
     * wrapped calls to other tunnels' connect() functions.
     * @private
     */
    var connect_data;

    /**
     * Array of all tunnels passed to this ChainedTunnel through the
     * constructor arguments.
     * @private
     */
    var tunnels = [];

    /**
     * The tunnel committed via commit_tunnel(), if any, or null if no tunnel
     * has yet been committed.
     *
     * @private
     * @type {Guacamole.Tunnel}
     */
    var committedTunnel = null;

    // Load all tunnels into array
    for (var i=0; i<arguments.length; i++)
        tunnels.push(arguments[i]);

    /**
     * Sets the current tunnel.
     * 
     * @private
     * @param {Guacamole.Tunnel} tunnel The tunnel to set as the current tunnel.
     */
    function attach(tunnel) {

        // Set own functions to tunnel's functions
        chained_tunnel.disconnect  = tunnel.disconnect;
        chained_tunnel.sendMessage = tunnel.sendMessage;

        /**
         * Fails the currently-attached tunnel, attaching a new tunnel if
         * possible.
         *
         * @private
         * @param {Guacamole.Status} [status]
         *     An object representing the failure that occured in the
         *     currently-attached tunnel, if known.
         *
         * @return {Guacamole.Tunnel}
         *     The next tunnel, or null if there are no more tunnels to try or
         *     if no more tunnels should be tried.
         */
        var failTunnel = function failTunnel(status) {

            // Do not attempt to continue using next tunnel on server timeout
            if (status && status.code === Guacamole.Status.Code.UPSTREAM_TIMEOUT) {
                tunnels = [];
                return null;
            }

            // Get next tunnel
            var next_tunnel = tunnels.shift();

            // If there IS a next tunnel, try using it.
            if (next_tunnel) {
                tunnel.onerror = null;
                tunnel.oninstruction = null;
                tunnel.onstatechange = null;
                attach(next_tunnel);
            }

            return next_tunnel;

        };

        /**
         * Use the current tunnel from this point forward. Do not try any more
         * tunnels, even if the current tunnel fails.
         * 
         * @private
         */
        function commit_tunnel() {

            tunnel.onstatechange = chained_tunnel.onstatechange;
            tunnel.oninstruction = chained_tunnel.oninstruction;
            tunnel.onerror = chained_tunnel.onerror;
            tunnel.onuuid = chained_tunnel.onuuid;

            // Assign UUID if already known
            if (tunnel.uuid)
                chained_tunnel.setUUID(tunnel.uuid);

            committedTunnel = tunnel;

        }

        // Wrap own onstatechange within current tunnel
        tunnel.onstatechange = function(state) {

            switch (state) {

                // If open, use this tunnel from this point forward.
                case Guacamole.Tunnel.State.OPEN:
                    commit_tunnel();
                    if (chained_tunnel.onstatechange)
                        chained_tunnel.onstatechange(state);
                    break;

                // If closed, mark failure, attempt next tunnel
                case Guacamole.Tunnel.State.CLOSED:
                    if (!failTunnel() && chained_tunnel.onstatechange)
                        chained_tunnel.onstatechange(state);
                    break;
                
            }

        };

        // Wrap own oninstruction within current tunnel
        tunnel.oninstruction = function(opcode, elements) {

            // Accept current tunnel
            commit_tunnel();

            // Invoke handler
            if (chained_tunnel.oninstruction)
                chained_tunnel.oninstruction(opcode, elements);

        };

        // Attach next tunnel on error
        tunnel.onerror = function(status) {

            // Mark failure, attempt next tunnel
            if (!failTunnel(status) && chained_tunnel.onerror)
                chained_tunnel.onerror(status);

        };

        // Attempt connection
        tunnel.connect(connect_data);
        
    }

    this.connect = function(data) {
       
        // Remember connect data
        connect_data = data;

        // Get committed tunnel if exists or the first tunnel on the list
        var next_tunnel = committedTunnel ? committedTunnel : tunnels.shift();

        // Attach first tunnel
        if (next_tunnel)
            attach(next_tunnel);

        // If there IS no first tunnel, error
        else if (chained_tunnel.onerror)
            chained_tunnel.onerror(Guacamole.Status.Code.SERVER_ERROR, "No tunnels to try.");

    };
    
};

Guacamole.ChainedTunnel.prototype = new Guacamole.Tunnel();

/**
 * Guacamole Tunnel which replays a Guacamole protocol dump from a static file
 * received via HTTP. Instructions within the file are parsed and handled as
 * quickly as possible, while the file is being downloaded.
 *
 * @constructor
 * @augments Guacamole.Tunnel
 * @param {String} url
 *     The URL of a Guacamole protocol dump.
 *
 * @param {Boolean} [crossDomain=false]
 *     Whether tunnel requests will be cross-domain, and thus must use CORS
 *     mechanisms and headers. By default, it is assumed that tunnel requests
 *     will be made to the same domain.
 *
 * @param {Object} [extraTunnelHeaders={}]
 *     Key value pairs containing the header names and values of any additional
 *     headers to be sent in tunnel requests. By default, no extra headers will
 *     be added.
 */
Guacamole.StaticHTTPTunnel = function StaticHTTPTunnel(url, crossDomain, extraTunnelHeaders) {

    /**
     * Reference to this Guacamole.StaticHTTPTunnel.
     *
     * @private
     */
    var tunnel = this;

    /**
     * The current, in-progress HTTP request. If no request is currently in
     * progress, this will be null.
     *
     * @private
     * @type {XMLHttpRequest}
     */
    var xhr = null;

    /**
     * Additional headers to be sent in tunnel requests. This dictionary can be
     * populated with key/value header pairs to pass information such as authentication
     * tokens, etc.
     *
     * @private
     */
    var extraHeaders = extraTunnelHeaders || {};

    /**
     * Adds the configured additional headers to the given request.
     *
     * @param {XMLHttpRequest} request
     *     The request where the configured extra headers will be added.
     *
     * @param {Object} headers
     *     The headers to be added to the request.
     *
     * @private
     */
    function addExtraHeaders(request, headers) {
        for (var name in headers) {
            request.setRequestHeader(name, headers[name]);
        }
    }

    this.sendMessage = function sendMessage(elements) {
        // Do nothing
    };

    this.connect = function connect(data) {

        // Ensure any existing connection is killed
        tunnel.disconnect();

        // Connection is now starting
        tunnel.setState(Guacamole.Tunnel.State.CONNECTING);

        // Start a new connection
        xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.withCredentials = !!crossDomain;
        addExtraHeaders(xhr, extraHeaders);
        xhr.responseType = 'text';
        xhr.send(null);

        var offset = 0;

        // Create Guacamole protocol parser specifically for this connection
        var parser = new Guacamole.Parser();

        // Invoke tunnel's oninstruction handler for each parsed instruction
        parser.oninstruction = function instructionReceived(opcode, args) {
            if (tunnel.oninstruction)
                tunnel.oninstruction(opcode, args);
        };

        // Continuously parse received data
        xhr.onreadystatechange = function readyStateChanged() {

            // Parse while data is being received
            if (xhr.readyState === 3 || xhr.readyState === 4) {

                // Connection is open
                tunnel.setState(Guacamole.Tunnel.State.OPEN);

                var buffer = xhr.responseText;
                var length = buffer.length;

                // Parse only the portion of data which is newly received
                if (offset < length) {
                    parser.receive(buffer.substring(offset));
                    offset = length;
                }

            }

            // Clean up and close when done
            if (xhr.readyState === 4)
                tunnel.disconnect();

        };

        // Reset state and close upon error
        xhr.onerror = function httpError() {

            // Fail if file could not be downloaded via HTTP
            if (tunnel.onerror)
                tunnel.onerror(new Guacamole.Status(
                    Guacamole.Status.Code.fromHTTPCode(xhr.status), xhr.statusText));

            tunnel.disconnect();
        };

    };

    this.disconnect = function disconnect() {

        // Abort and dispose of XHR if a request is in progress
        if (xhr) {
            xhr.abort();
            xhr = null;
        }

        // Connection is now closed
        tunnel.setState(Guacamole.Tunnel.State.CLOSED);

    };

};

Guacamole.StaticHTTPTunnel.prototype = new Guacamole.Tunnel();

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * The unique ID of this version of the Guacamole JavaScript API. This ID will
 * be the version string of the guacamole-common-js Maven project, and can be
 * used in downstream applications as a sanity check that the proper version
 * of the APIs is being used (in case an older version is cached, for example).
 *
 * @type {String}
 */
Guacamole.API_VERSION = "1.3.0";

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract video player which accepts, queues and plays back arbitrary video
 * data. It is up to implementations of this class to provide some means of
 * handling a provided Guacamole.InputStream and rendering the received data to
 * the provided Guacamole.Display.VisibleLayer. Data received along the
 * provided stream is to be played back immediately.
 *
 * @constructor
 */
Guacamole.VideoPlayer = function VideoPlayer() {

    /**
     * Notifies this Guacamole.VideoPlayer that all video up to the current
     * point in time has been given via the underlying stream, and that any
     * difference in time between queued video data and the current time can be
     * considered latency.
     */
    this.sync = function sync() {
        // Default implementation - do nothing
    };

};

/**
 * Determines whether the given mimetype is supported by any built-in
 * implementation of Guacamole.VideoPlayer, and thus will be properly handled
 * by Guacamole.VideoPlayer.getInstance().
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by any built-in
 *     Guacamole.VideoPlayer, false otherwise.
 */
Guacamole.VideoPlayer.isSupportedType = function isSupportedType(mimetype) {

    // There are currently no built-in video players (and therefore no
    // supported types)
    return false;

};

/**
 * Returns a list of all mimetypes supported by any built-in
 * Guacamole.VideoPlayer, in rough order of priority. Beware that only the core
 * mimetypes themselves will be listed. Any mimetype parameters, even required
 * ones, will not be included in the list.
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by any built-in Guacamole.VideoPlayer,
 *     excluding any parameters.
 */
Guacamole.VideoPlayer.getSupportedTypes = function getSupportedTypes() {

    // There are currently no built-in video players (and therefore no
    // supported types)
    return [];

};

/**
 * Returns an instance of Guacamole.VideoPlayer providing support for the given
 * video format. If support for the given video format is not available, null
 * is returned.
 *
 * @param {Guacamole.InputStream} stream
 *     The Guacamole.InputStream to read video data from.
 *
 * @param {Guacamole.Display.VisibleLayer} layer
 *     The destination layer in which this Guacamole.VideoPlayer should play
 *     the received video data.
 *
 * @param {String} mimetype
 *     The mimetype of the video data in the provided stream.
 *
 * @return {Guacamole.VideoPlayer}
 *     A Guacamole.VideoPlayer instance supporting the given mimetype and
 *     reading from the given stream, or null if support for the given mimetype
 *     is absent.
 */
Guacamole.VideoPlayer.getInstance = function getInstance(stream, layer, mimetype) {

    // There are currently no built-in video players
    return null;

};
module.exports = Guacamole;

/***/ }),

/***/ 5298:
/*!**************************!*\
  !*** ./Scripts/DnLib.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Greeter": function() { return /* binding */ Greeter; },
/* harmony export */   "TestClass2": function() { return /* binding */ TestClass2; },
/* harmony export */   "TestClass1": function() { return /* binding */ TestClass1; }
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var Greeter = /** @class */ (function () {
    function Greeter() {
    }
    Greeter.greet = function (message) {
        return "Hello, " + message + "!";
    };
    return Greeter;
}());

var TestClass2 = /** @class */ (function () {
    function TestClass2() {
    }
    TestClass2.Hello2 = function (message) {
        console.log("Hello " + message);
    };
    return TestClass2;
}());

var TestClass1 = /** @class */ (function () {
    function TestClass1() {
    }
    TestClass1.Hello = function (message) {
        console.log("Hello " + message);
    };
    TestClass1.SleepAsync = function (msec) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        setTimeout(function () {
                            resolve();
                        }, msec);
                    })];
            });
        });
    };
    TestClass1.HelloAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.log("start");
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < 20)) return [3 /*break*/, 4];
                        if (i >= 10) {
                            throw "This is Error !!!";
                        }
                        return [4 /*yield*/, this.SleepAsync(50)];
                    case 2:
                        _a.sent();
                        console.log("Neko_ 111 : " + i);
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4:
                        console.log("end");
                        return [2 /*return*/];
                }
            });
        });
    };
    return TestClass1;
}());



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!**************************!*\
  !*** ./Scripts/DnApp.ts ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tom": function() { return /* binding */ Tom; },
/* harmony export */   "default": function() { return /* binding */ sampleFunctionExported1; },
/* harmony export */   "TestFunc2": function() { return /* binding */ TestFunc2; }
/* harmony export */ });
/* harmony import */ var core_js_es_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/es/promise */ 7633);
/* harmony import */ var core_js_es_promise__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_es_promise__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _DnLib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DnLib */ 5298);
/* harmony import */ var guacamole_common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! guacamole-common-js */ 8943);
/* harmony import */ var guacamole_common_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(guacamole_common_js__WEBPACK_IMPORTED_MODULE_2__);



//import * as Guacamole from "./guacamole-common";
//console.log("Hello World");
//alert(Greeter.greet("world 021"));
_DnLib__WEBPACK_IMPORTED_MODULE_1__.TestClass2.Hello2("Inu");
_DnLib__WEBPACK_IMPORTED_MODULE_1__.TestClass1.Hello("Neko");
//TestFunc1();
function TestFunc1() {
    console.log("--a");
    var task = _DnLib__WEBPACK_IMPORTED_MODULE_1__.TestClass1.HelloAsync();
    task["catch"](function (x) {
        alert(x);
    });
    console.log("--b");
}
var Tom = /** @class */ (function () {
    function Tom() {
    }
    Tom.HtmlTest1 = function () {
        console.log("Tom Html test 1");
    };
    Tom.GuacamoleTest1 = function (display) {
        var tunnel = new (guacamole_common_js__WEBPACK_IMPORTED_MODULE_2___default().WebSocketTunnel)("Model.WebSocketUrl");
        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        tunnel.onerror = function (status) {
            console.log(status);
            alert("Tunnel Error Code: " + status.code);
        };
        // Instantiate client, using a WebSocket tunnel for communications.
        // @ts-ignore
        var guac = new (guacamole_common_js__WEBPACK_IMPORTED_MODULE_2___default().Client)(tunnel);
        // Add client to display div
        display.appendChild(guac.getDisplay().getElement());
        // Error handler
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        guac.onerror = function (status) {
            console.log(status);
            alert("Remote Desktop Error Code: " + status.code);
        };
        guac.connect("id=Model.SessionId");
        window.onunload = function () {
            guac.disconnect();
        };
    };
    return Tom;
}());

function sampleFunctionExported1() {
    console.log("sampleFunctionExported1");
}
function TestFunc2() {
    console.log("TestFunc2");
}

}();
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ib2dlL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWlzLWlvcy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS1pcy1ub2RlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWlzLXdlYm9zLXdlYmtpdC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9ob3N0LXJlcG9ydC1lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9taWNyb3Rhc2suanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtcHJvbWlzZS1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wZXJmb3JtLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Rhc2suanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYWdncmVnYXRlLWVycm9yLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5hbGwtc2V0dGxlZC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmFueS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmZpbmFsbHkuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2d1YWNhbW9sZS1jb21tb24tanMvZGlzdC9ndWFjYW1vbGUtY29tbW9uLmpzIiwid2VicGFjazovL0hvZ2UvLi9TY3JpcHRzL0RuTGliLnRzIiwid2VicGFjazovL0hvZ2Uvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vSG9nZS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9Ib2dlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9Ib2dlL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vSG9nZS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL0hvZ2Uvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9Ib2dlLy4vU2NyaXB0cy9EbkFwcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7O0FDVkEsbUJBQU8sQ0FBQyw0Q0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyw2Q0FBbUM7QUFDM0MsbUJBQU8sQ0FBQyxvQ0FBMEI7QUFDbEMsbUJBQU8sQ0FBQyxnREFBc0M7QUFDOUMsbUJBQU8sQ0FBQyx3Q0FBOEI7QUFDdEMsbUJBQU8sQ0FBQyw0Q0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyw0Q0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyxzREFBNEM7QUFDcEQsV0FBVyxtQkFBTyxDQUFDLCtCQUFzQjs7QUFFekM7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7OztBQ0pBLGVBQWUsbUJBQU8sQ0FBQyxpQ0FBd0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7QUNOQSxzQkFBc0IsbUJBQU8sQ0FBQywwQ0FBZ0M7QUFDOUQsYUFBYSxtQkFBTyxDQUFDLG9DQUE0QjtBQUNqRCwyQkFBMkIsbUJBQU8sQ0FBQywrQ0FBcUM7O0FBRXhFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7O0FDSkEsZUFBZSxtQkFBTyxDQUFDLGlDQUF3Qjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDs7QUFFdEQsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFD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ZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwr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O0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7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QUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGVBQWU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx5Q0FBeUMsK0NBQStDOztBQUV4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7O0FBRUEsU0FBUzs7QUFFVCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMseUJBQXlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1Qjs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyxpQkFBaUI7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFxQjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBZ0Q7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQixnQkFBZ0I7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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N0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QkFBcUIsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDL0MsQ0FBQyxDQUFDO1FBRUYsbUVBQW1FO1FBQ25FLGFBQWE7UUFDYixJQUFNLElBQUksR0FBRyxJQUFJLG1FQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTFDLDRCQUE0QjtRQUM1QixPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBRXBELGdCQUFnQjtRQUNoQiw4REFBOEQ7UUFDOUQsSUFBSSxDQUFDLE9BQU8sR0FBRyxVQUFVLE1BQVc7WUFFaEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNwQixLQUFLLENBQUMsNkJBQTZCLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZELENBQUMsQ0FBQztRQUVGLElBQUksQ0FBQyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUVuQyxNQUFNLENBQUMsUUFBUSxHQUFHO1lBRWQsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3RCLENBQUM7SUFDTCxDQUFDO0lBQ0wsVUFBQztBQUFELENBQUM7O0FBRWMsU0FBUyx1QkFBdUI7SUFFM0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFFTSxTQUFTLFNBQVM7SUFFckIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUM3QixDQUFDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkhvZ2VcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiSG9nZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHNlbGYsIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuYWdncmVnYXRlLWVycm9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMucHJvbWlzZScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5wcm9taXNlLmFsbC1zZXR0bGVkJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnByb21pc2UuYW55Jyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnByb21pc2UuZmluYWxseScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvcicpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguUHJvbWlzZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpICYmIGl0ICE9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3Qgc2V0IFwiICsgU3RyaW5nKGl0KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZShudWxsKVxuICB9KTtcbn1cblxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCAnICsgKG5hbWUgPyBuYW1lICsgJyAnIDogJycpICsgJ2ludm9jYXRpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgY2xhc3NvZlJhdyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vd24ta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhcyh0YXJnZXQsIGtleSkpIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgfVxufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJykuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3RvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJyk7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoSVNfUFVSRSkgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7IH07XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcbiAgfVxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG4iLCJ2YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gLyhpcGhvbmV8aXBvZHxpcGFkKS4qYXBwbGV3ZWJraXQvaS50ZXN0KHVzZXJBZ2VudCk7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzc29mKGdsb2JhbC5wcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG4iLCJ2YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gL3dlYjBzKD8hLipjaHJvbWUpL2kudGVzdCh1c2VyQWdlbnQpO1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQnKTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gKyBtYXRjaFsxXTtcbn0gZWxzZSBpZiAodXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uICYmICt2ZXJzaW9uO1xuIiwiLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcbiAgICB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsInZhciBwYXRoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhdGgnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PSAnZnVuY3Rpb24nID8gdmFyaWFibGUgOiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24ocGF0aFtuYW1lc3BhY2VdKSB8fCBhRnVuY3Rpb24oZ2xvYmFsW25hbWVzcGFjZV0pXG4gICAgOiBwYXRoW25hbWVzcGFjZV0gJiYgcGF0aFtuYW1lc3BhY2VdW21ldGhvZF0gfHwgZ2xvYmFsW25hbWVzcGFjZV0gJiYgZ2xvYmFsW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCJ2YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9XG4gIC8qIGdsb2JhbCBnbG9iYWxUaGlzIC0tIHNhZmUgKi9cbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGU7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY29uc29sZS5lcnJvcihhKSA6IGNvbnNvbGUuZXJyb3IoYSwgYik7XG4gIH1cbn07XG4iLCJ2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbnZhciBzcGxpdCA9ICcnLnNwbGl0O1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdC5jYWxsKGl0LCAnJykgOiBPYmplY3QoaXQpO1xufSA6IE9iamVjdDtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi50b1N0cmluZztcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGAzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICh0eXBlb2Ygc3RvcmUuaW5zcGVjdFNvdXJjZSAhPSAnZnVuY3Rpb24nKSB7XG4gIHN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZy5jYWxsKGl0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZS5pbnNwZWN0U291cmNlO1xuIiwidmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIG9iamVjdEhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIHZhciB3bWdldCA9IHN0b3JlLmdldDtcbiAgdmFyIHdtaGFzID0gc3RvcmUuaGFzO1xuICB2YXIgd21zZXQgPSBzdG9yZS5zZXQ7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldC5jYWxsKHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0LmNhbGwoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXG4gICAgOiB0eXBlb2YgZGV0ZWN0aW9uID09ICdmdW5jdGlvbicgPyBmYWlscyhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZC5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICdQJztcblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZvcmNlZDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1jbG9zZScpO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDtcbiAgdmFyIEFTX0VOVFJJRVMgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuQVNfRU5UUklFUyk7XG4gIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XG4gIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG4gIHZhciBmbiA9IGJpbmQodW5ib3VuZEZ1bmN0aW9uLCB0aGF0LCAxICsgQVNfRU5UUklFUyArIElOVEVSUlVQVEVEKTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHRydWUsIGNvbmRpdGlvbik7XG4gIH07XG5cbiAgdmFyIGNhbGxGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChBU19FTlRSSUVTKSB7XG4gICAgICBhbk9iamVjdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTtcbiAgfVxuXG4gIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICB3aGlsZSAoIShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgdmFyIHJldHVybk1ldGhvZCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgaWYgKHJldHVybk1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFuT2JqZWN0KHJldHVybk1ldGhvZC5jYWxsKGl0ZXJhdG9yKSkudmFsdWU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihnZXRQcm90b3R5cGVPZihhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9O1xuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5cbmlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuaWYgKCghSVNfUFVSRSB8fCBORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpIHtcbiAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Rhc2snKS5zZXQ7XG52YXIgSVNfSU9TID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1pb3MnKTtcbnZhciBJU19XRUJPU19XRUJLSVQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLXdlYm9zLXdlYmtpdCcpO1xudmFyIElTX05PREUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLW5vZGUnKTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xuLy8gTm9kZS5qcyAxMSBzaG93cyBFeHBlcmltZW50YWxXYXJuaW5nIG9uIGdldHRpbmcgYHF1ZXVlTWljcm90YXNrYFxudmFyIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWwsICdxdWV1ZU1pY3JvdGFzaycpO1xudmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTtcblxudmFyIGZsdXNoLCBoZWFkLCBsYXN0LCBub3RpZnksIHRvZ2dsZSwgbm9kZSwgcHJvbWlzZSwgdGhlbjtcblxuLy8gbW9kZXJuIGVuZ2luZXMgaGF2ZSBxdWV1ZU1pY3JvdGFzayBtZXRob2RcbmlmICghcXVldWVNaWNyb3Rhc2spIHtcbiAgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKElTX05PREUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgLy8gYWxzbyBleGNlcHQgV2ViT1MgV2Via2l0IGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84OThcbiAgaWYgKCFJU19JT1MgJiYgIUlTX05PREUgJiYgIUlTX1dFQk9TX1dFQktJVCAmJiBNdXRhdGlvbk9ic2VydmVyICYmIGRvY3VtZW50KSB7XG4gICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB0aGVuID0gcHJvbWlzZS50aGVuO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoZW4uY2FsbChwcm9taXNlLCBmbHVzaCk7XG4gICAgfTtcbiAgLy8gTm9kZS5qcyB3aXRob3V0IHByb21pc2VzXG4gIH0gZWxzZSBpZiAoSVNfTk9ERSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVldWVNaWNyb3Rhc2sgfHwgZnVuY3Rpb24gKGZuKSB7XG4gIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgaWYgKCFoZWFkKSB7XG4gICAgaGVhZCA9IHRhc2s7XG4gICAgbm90aWZ5KCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuUHJvbWlzZTtcbiIsInZhciBJU19OT0RFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1ub2RlJyk7XG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbicpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbiAgcmV0dXJuICFTeW1ib2wuc2hhbSAmJlxuICAgIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAoSVNfTk9ERSA/IFY4X1ZFUlNJT04gPT09IDM4IDogVjhfVkVSU0lPTiA+IDM3ICYmIFY4X1ZFUlNJT04gPCA0MSk7XG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZScpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlKFdlYWtNYXApKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xuXG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcblxuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9odG1sJyk7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG4gIHJldHVybiB0ZW1wO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDc1XG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xufTtcblxuLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuLy8gYXZvaWQgSUUgR0MgYnVnXG52YXIgYWN0aXZlWERvY3VtZW50O1xudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUgKi9cbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBkb2N1bWVudC5kb21haW4gJiYgbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IGFjdGl2ZVhEb2N1bWVudCA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpO1xuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIFByb3BlcnRpZXNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG5cbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIXByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwidmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlcicpO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuZXhwb3J0cy5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIHNldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldDtcbiAgICBzZXR0ZXIuY2FsbCh0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlci5jYWxsKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbn07XG4iLCJ2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgdmFsdWU6IGVycm9yIH07XG4gIH1cbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZScpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcblxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHVuc2FmZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMudW5zYWZlIDogZmFsc2U7XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zID8gISFvcHRpb25zLmVudW1lcmFibGUgOiBmYWxzZTtcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuICB2YXIgc3RhdGU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnICYmICFoYXModmFsdWUsICduYW1lJykpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSh2YWx1ZSwgJ25hbWUnLCBrZXkpO1xuICAgIH1cbiAgICBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgICBpZiAoIXN0YXRlLnNvdXJjZSkge1xuICAgICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8ga2V5IDogJycpO1xuICAgIH1cbiAgfVxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcbiAgICBzaW1wbGUgPSB0cnVlO1xuICB9XG4gIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCBrZXksIHZhbHVlKTtcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0pO1xuIiwiLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbCwga2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVNdKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIH0pO1xuICB9XG59O1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICAgIGRlZmluZVByb3BlcnR5KGl0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2V0R2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwnKTtcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgc2V0R2xvYmFsKFNIQVJFRCwge30pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlO1xuIiwidmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuOS4xJyxcbiAgbW9kZTogSVNfUFVSRSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDIxIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxuLy8gYFNwZWNpZXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNwZWNpZXNjb25zdHJ1Y3RvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFGdW5jdGlvbihTKTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IGNvZGVQb2ludEF0LCBhdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcbiAgICAgIHx8IChzZWNvbmQgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkcgPyBTLmNoYXJBdChwb3NpdGlvbikgOiBmaXJzdFxuICAgICAgICA6IENPTlZFUlRfVE9fU1RSSU5HID8gUy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyAyKSA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgY29kZUF0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbiAgY2hhckF0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG52YXIgSVNfSU9TID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1pb3MnKTtcbnZhciBJU19OT0RFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1ub2RlJyk7XG5cbnZhciBsb2NhdGlvbiA9IGdsb2JhbC5sb2NhdGlvbjtcbnZhciBzZXQgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xuXG52YXIgcnVuID0gZnVuY3Rpb24gKGlkKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcblxudmFyIHJ1bm5lciA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJ1bihpZCk7XG4gIH07XG59O1xuXG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuKGV2ZW50LmRhdGEpO1xufTtcblxudmFyIHBvc3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgLy8gb2xkIGVuZ2luZXMgaGF2ZSBub3QgbG9jYXRpb24ub3JpZ2luXG4gIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0KTtcbn07XG5cbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0IHx8ICFjbGVhcikge1xuICBzZXQgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBzcGVjIHJlcXVpcmVtZW50XG4gICAgICAodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSkuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhciA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChJU19OT0RFKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2socnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhydW5uZXIoaWQpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIC8vIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjI0XG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwgJiYgIUlTX0lPUykge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gYmluZChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoXG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiZcbiAgICB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICFnbG9iYWwuaW1wb3J0U2NyaXB0cyAmJlxuICAgIGxvY2F0aW9uICYmIGxvY2F0aW9uLnByb3RvY29sICE9PSAnZmlsZTonICYmXG4gICAgIWZhaWxzKHBvc3QpXG4gICkge1xuICAgIGRlZmVyID0gcG9zdDtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChydW5uZXIoaWQpLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgY2xlYXI6IGNsZWFyXG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcbiIsIi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG4iLCJ2YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBUb0ludGVnZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc05hTihhcmd1bWVudCA9ICthcmd1bWVudCkgPyAwIDogKGFyZ3VtZW50ID4gMCA/IGZsb29yIDogY2VpbCkoYXJndW1lbnQpO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsInZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgUFJFRkVSUkVEX1NUUklORykge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFBSRUZFUlJFRF9TVFJJTkcgJiYgdHlwZW9mIChmbiA9IGlucHV0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaW5wdXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVBSRUZFUlJFRF9TVFJJTkcgJiYgdHlwZW9mIChmbiA9IGlucHV0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcbiIsInZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgU3RyaW5nKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArICgrK2lkICsgcG9zdGZpeCkudG9TdHJpbmcoMzYpO1xufTtcbiIsInZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfU1lNQk9MXG4gIC8qIGdsb2JhbCBTeW1ib2wgLS0gc2FmZSAqL1xuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXMoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXMoU3ltYm9sLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZicpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xuXG52YXIgJEFnZ3JlZ2F0ZUVycm9yID0gZnVuY3Rpb24gQWdncmVnYXRlRXJyb3IoZXJyb3JzLCBtZXNzYWdlKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgaWYgKCEodGhhdCBpbnN0YW5jZW9mICRBZ2dyZWdhdGVFcnJvcikpIHJldHVybiBuZXcgJEFnZ3JlZ2F0ZUVycm9yKGVycm9ycywgbWVzc2FnZSk7XG4gIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2Vycm9yLW1lc3NhZ2UgLS0gZXhwZWN0ZWRcbiAgICB0aGF0ID0gc2V0UHJvdG90eXBlT2YobmV3IEVycm9yKHVuZGVmaW5lZCksIGdldFByb3RvdHlwZU9mKHRoYXQpKTtcbiAgfVxuICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkodGhhdCwgJ21lc3NhZ2UnLCBTdHJpbmcobWVzc2FnZSkpO1xuICB2YXIgZXJyb3JzQXJyYXkgPSBbXTtcbiAgaXRlcmF0ZShlcnJvcnMsIGVycm9yc0FycmF5LnB1c2gsIHsgdGhhdDogZXJyb3JzQXJyYXkgfSk7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSh0aGF0LCAnZXJyb3JzJywgZXJyb3JzQXJyYXkpO1xuICByZXR1cm4gdGhhdDtcbn07XG5cbiRBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUgPSBjcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoNSwgJEFnZ3JlZ2F0ZUVycm9yKSxcbiAgbWVzc2FnZTogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDUsICcnKSxcbiAgbmFtZTogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDUsICdBZ2dyZWdhdGVFcnJvcicpXG59KTtcblxuLy8gYEFnZ3JlZ2F0ZUVycm9yYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hZ2dyZWdhdGUtZXJyb3ItY29uc3RydWN0b3JcbiQoeyBnbG9iYWw6IHRydWUgfSwge1xuICBBZ2dyZWdhdGVFcnJvcjogJEFnZ3JlZ2F0ZUVycm9yXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yJyk7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBpbmRleCwgZG9uZTogZmFsc2UgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCJ2YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZycpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbmlmICghVE9fU1RSSU5HX1RBR19TVVBQT1JUKSB7XG4gIHJlZGVmaW5lKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIHRvU3RyaW5nLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGVyZm9ybScpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xuXG4vLyBgUHJvbWlzZS5hbGxTZXR0bGVkYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5hbGxzZXR0bGVkXG4kKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUgfSwge1xuICBhbGxTZXR0bGVkOiBmdW5jdGlvbiBhbGxTZXR0bGVkKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZihDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByb21pc2VSZXNvbHZlID0gYUZ1bmN0aW9uKEMucmVzb2x2ZSk7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIHByb21pc2VSZXNvbHZlLmNhbGwoQywgcHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB7IHN0YXR1czogJ2Z1bGZpbGxlZCcsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0geyBzdGF0dXM6ICdyZWplY3RlZCcsIHJlYXNvbjogZXJyb3IgfTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGVyZm9ybScpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xuXG52YXIgUFJPTUlTRV9BTllfRVJST1IgPSAnTm8gb25lIHByb21pc2UgcmVzb2x2ZWQnO1xuXG4vLyBgUHJvbWlzZS5hbnlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLmFueVxuJCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlIH0sIHtcbiAgYW55OiBmdW5jdGlvbiBhbnkoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvbWlzZVJlc29sdmUgPSBhRnVuY3Rpb24oQy5yZXNvbHZlKTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgdmFyIGFscmVhZHlSZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICB2YXIgYWxyZWFkeVJlamVjdGVkID0gZmFsc2U7XG4gICAgICAgIGVycm9ycy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlSZWplY3RlZCB8fCBhbHJlYWR5UmVzb2x2ZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5UmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeVJlamVjdGVkIHx8IGFscmVhZHlSZXNvbHZlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlSZWplY3RlZCA9IHRydWU7XG4gICAgICAgICAgZXJyb3JzW2luZGV4XSA9IGVycm9yO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlamVjdChuZXcgKGdldEJ1aWx0SW4oJ0FnZ3JlZ2F0ZUVycm9yJykpKGVycm9ycywgUFJPTUlTRV9BTllfRVJST1IpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlamVjdChuZXcgKGdldEJ1aWx0SW4oJ0FnZ3JlZ2F0ZUVycm9yJykpKGVycm9ycywgUFJPTUlTRV9BTllfRVJST1IpKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIE5hdGl2ZVByb21pc2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXByb21pc2UtY29uc3RydWN0b3InKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLXJlc29sdmUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xuXG4vLyBTYWZhcmkgYnVnIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDA4MjlcbnZhciBOT05fR0VORVJJQyA9ICEhTmF0aXZlUHJvbWlzZSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIE5hdGl2ZVByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10uY2FsbCh7IHRoZW46IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSB9LCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbi8vIGBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUuZmluYWxseVxuJCh7IHRhcmdldDogJ1Byb21pc2UnLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBOT05fR0VORVJJQyB9LCB7XG4gICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGdldEJ1aWx0SW4oJ1Byb21pc2UnKSk7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2Ygb25GaW5hbGx5ID09ICdmdW5jdGlvbic7XG4gICAgcmV0dXJuIHRoaXMudGhlbihcbiAgICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG4gICAgICB9IDogb25GaW5hbGx5LFxuICAgICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IGU7IH0pO1xuICAgICAgfSA6IG9uRmluYWxseVxuICAgICk7XG4gIH1cbn0pO1xuXG4vLyBwYXRjaCBuYXRpdmUgUHJvbWlzZS5wcm90b3R5cGUgZm9yIG5hdGl2ZSBhc3luYyBmdW5jdGlvbnNcbmlmICghSVNfUFVSRSAmJiB0eXBlb2YgTmF0aXZlUHJvbWlzZSA9PSAnZnVuY3Rpb24nICYmICFOYXRpdmVQcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddKSB7XG4gIHJlZGVmaW5lKE5hdGl2ZVByb21pc2UucHJvdG90eXBlLCAnZmluYWxseScsIGdldEJ1aWx0SW4oJ1Byb21pc2UnKS5wcm90b3R5cGVbJ2ZpbmFsbHknXSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBOYXRpdmVQcm9taXNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1wcm9taXNlLWNvbnN0cnVjdG9yJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZS1hbGwnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9taWNyb3Rhc2snKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLXJlc29sdmUnKTtcbnZhciBob3N0UmVwb3J0RXJyb3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hvc3QtcmVwb3J0LWVycm9ycycpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BlcmZvcm0nKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfTk9ERSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtaXMtbm9kZScpO1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihQUk9NSVNFKTtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IgPSBOYXRpdmVQcm9taXNlO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyICRmZXRjaCA9IGdldEJ1aWx0SW4oJ2ZldGNoJyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5O1xudmFyIERJU1BBVENIX0VWRU5UID0gISEoZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRXZlbnQgJiYgZ2xvYmFsLmRpc3BhdGNoRXZlbnQpO1xudmFyIE5BVElWRV9SRUpFQ1RJT05fRVZFTlQgPSB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbic7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG52YXIgSW50ZXJuYWwsIE93blByb21pc2VDYXBhYmlsaXR5LCBQcm9taXNlV3JhcHBlciwgbmF0aXZlVGhlbjtcblxudmFyIEZPUkNFRCA9IGlzRm9yY2VkKFBST01JU0UsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBpbnNwZWN0U291cmNlKFByb21pc2VDb25zdHJ1Y3RvcikgIT09IFN0cmluZyhQcm9taXNlQ29uc3RydWN0b3IpO1xuICBpZiAoIUdMT0JBTF9DT1JFX0pTX1BST01JU0UpIHtcbiAgICAvLyBWOCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gICAgLy8gV2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgICBpZiAoVjhfVkVSU0lPTiA9PT0gNjYpIHJldHVybiB0cnVlO1xuICAgIC8vIFVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICBpZiAoIUlTX05PREUgJiYgIU5BVElWRV9SRUpFQ1RJT05fRVZFTlQpIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIFdlIG5lZWQgUHJvbWlzZSNmaW5hbGx5IGluIHRoZSBwdXJlIHZlcnNpb24gZm9yIHByZXZlbnRpbmcgcHJvdG90eXBlIHBvbGx1dGlvblxuICBpZiAoSVNfUFVSRSAmJiAhUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZVsnZmluYWxseSddKSByZXR1cm4gdHJ1ZTtcbiAgLy8gV2UgY2FuJ3QgdXNlIEBAc3BlY2llcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbiAgaWYgKFY4X1ZFUlNJT04gPj0gNTEgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFByb21pc2VDb25zdHJ1Y3RvcikpIHJldHVybiBmYWxzZTtcbiAgLy8gRGV0ZWN0IGNvcnJlY3RuZXNzIG9mIHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlQ29uc3RydWN0b3IucmVzb2x2ZSgxKTtcbiAgdmFyIEZha2VQcm9taXNlID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICBleGVjKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgfTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9O1xuICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IEZha2VQcm9taXNlO1xuICByZXR1cm4gIShwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlKTtcbn0pO1xuXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9IEZPUkNFRCB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICBQcm9taXNlQ29uc3RydWN0b3IuYWxsKGl0ZXJhYmxlKVsnY2F0Y2gnXShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xuXG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHN0YXRlLCBpc1JlamVjdCkge1xuICBpZiAoc3RhdGUubm90aWZpZWQpIHJldHVybjtcbiAgc3RhdGUubm90aWZpZWQgPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBzdGF0ZS5yZWFjdGlvbnM7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIG9rID0gc3RhdGUuc3RhdGUgPT0gRlVMRklMTEVEO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IGNoYWluW2luZGV4KytdO1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUucmVqZWN0aW9uID09PSBVTkhBTkRMRUQpIG9uSGFuZGxlVW5oYW5kbGVkKHN0YXRlKTtcbiAgICAgICAgICAgIHN0YXRlLnJlamVjdGlvbiA9IEhBTkRMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIGNhbiB0aHJvd1xuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUucmVhY3Rpb25zID0gW107XG4gICAgc3RhdGUubm90aWZpZWQgPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXN0YXRlLnJlamVjdGlvbikgb25VbmhhbmRsZWQoc3RhdGUpO1xuICB9KTtcbn07XG5cbnZhciBkaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIHByb21pc2UsIHJlYXNvbikge1xuICB2YXIgZXZlbnQsIGhhbmRsZXI7XG4gIGlmIChESVNQQVRDSF9FVkVOVCkge1xuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9IGVsc2UgZXZlbnQgPSB7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcmVhc29uIH07XG4gIGlmICghTkFUSVZFX1JFSkVDVElPTl9FVkVOVCAmJiAoaGFuZGxlciA9IGdsb2JhbFsnb24nICsgbmFtZV0pKSBoYW5kbGVyKGV2ZW50KTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gVU5IQU5ETEVEX1JFSkVDVElPTikgaG9zdFJlcG9ydEVycm9ycygnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgcmVhc29uKTtcbn07XG5cbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIElTX1VOSEFORExFRCA9IGlzVW5oYW5kbGVkKHN0YXRlKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChJU19VTkhBTkRMRUQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoSVNfTk9ERSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChVTkhBTkRMRURfUkVKRUNUSU9OLCBwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBzdGF0ZS5yZWplY3Rpb24gPSBJU19OT0RFIHx8IGlzVW5oYW5kbGVkKHN0YXRlKSA/IFVOSEFORExFRCA6IEhBTkRMRUQ7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB0aHJvdyByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucmVqZWN0aW9uICE9PSBIQU5ETEVEICYmICFzdGF0ZS5wYXJlbnQ7XG59O1xuXG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIGlmIChJU19OT0RFKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChSRUpFQ1RJT05fSEFORExFRCwgcHJvbWlzZSwgc3RhdGUudmFsdWUpO1xuICB9KTtcbn07XG5cbnZhciBiaW5kID0gZnVuY3Rpb24gKGZuLCBzdGF0ZSwgdW53cmFwKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBmbihzdGF0ZSwgdmFsdWUsIHVud3JhcCk7XG4gIH07XG59O1xuXG52YXIgaW50ZXJuYWxSZWplY3QgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICBzdGF0ZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICBub3RpZnkoc3RhdGUsIHRydWUpO1xufTtcblxudmFyIGludGVybmFsUmVzb2x2ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXRlLmZhY2FkZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIHZhciB0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSk7XG4gICAgaWYgKHRoZW4pIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBkb25lOiBmYWxzZSB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSxcbiAgICAgICAgICAgIGJpbmQoaW50ZXJuYWxSZXNvbHZlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kKGludGVybmFsUmVqZWN0LCB3cmFwcGVyLCBzdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGludGVybmFsUmVqZWN0KHdyYXBwZXIsIGVycm9yLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgc3RhdGUuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgICBub3RpZnkoc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW50ZXJuYWxSZWplY3QoeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKEZPUkNFRCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihiaW5kKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpLCBiaW5kKGludGVybmFsUmVqZWN0LCBzdGF0ZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpbnRlcm5hbFJlamVjdChzdGF0ZSwgZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICB0eXBlOiBQUk9NSVNFLFxuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBub3RpZmllZDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGZhbHNlLFxuICAgICAgcmVhY3Rpb25zOiBbXSxcbiAgICAgIHJlamVjdGlvbjogZmFsc2UsXG4gICAgICBzdGF0ZTogUEVORElORyxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICAgIC8vIGBQcm9taXNlLnByb3RvdHlwZS50aGVuYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gSVNfTk9ERSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgc3RhdGUucGFyZW50ID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnJlYWN0aW9ucy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmIChzdGF0ZS5zdGF0ZSAhPSBQRU5ESU5HKSBub3RpZnkoc3RhdGUsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gYFByb21pc2UucHJvdG90eXBlLmNhdGNoYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUocHJvbWlzZSk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBiaW5kKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZChpbnRlcm5hbFJlamVjdCwgc3RhdGUpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSBQcm9taXNlQ29uc3RydWN0b3IgfHwgQyA9PT0gUHJvbWlzZVdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcblxuICBpZiAoIUlTX1BVUkUgJiYgdHlwZW9mIE5hdGl2ZVByb21pc2UgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG5hdGl2ZVRoZW4gPSBOYXRpdmVQcm9taXNlLnByb3RvdHlwZS50aGVuO1xuXG4gICAgLy8gd3JhcCBuYXRpdmUgUHJvbWlzZSN0aGVuIGZvciBuYXRpdmUgYXN5bmMgZnVuY3Rpb25zXG4gICAgcmVkZWZpbmUoTmF0aXZlUHJvbWlzZS5wcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBuYXRpdmVUaGVuLmNhbGwodGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NDBcbiAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcblxuICAgIC8vIHdyYXAgZmV0Y2ggcmVzdWx0XG4gICAgaWYgKHR5cGVvZiAkZmV0Y2ggPT0gJ2Z1bmN0aW9uJykgJCh7IGdsb2JhbDogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gICAgICBmZXRjaDogZnVuY3Rpb24gZmV0Y2goaW5wdXQgLyogLCBpbml0ICovKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShQcm9taXNlQ29uc3RydWN0b3IsICRmZXRjaC5hcHBseShnbG9iYWwsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbiQoeyBnbG9iYWw6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgUHJvbWlzZTogUHJvbWlzZUNvbnN0cnVjdG9yXG59KTtcblxuc2V0VG9TdHJpbmdUYWcoUHJvbWlzZUNvbnN0cnVjdG9yLCBQUk9NSVNFLCBmYWxzZSwgdHJ1ZSk7XG5zZXRTcGVjaWVzKFBST01JU0UpO1xuXG5Qcm9taXNlV3JhcHBlciA9IGdldEJ1aWx0SW4oUFJPTUlTRSk7XG5cbi8vIHN0YXRpY3NcbiQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgLy8gYFByb21pc2UucmVqZWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlamVjdFxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICBjYXBhYmlsaXR5LnJlamVjdC5jYWxsKHVuZGVmaW5lZCwgcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbiQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogSVNfUFVSRSB8fCBGT1JDRUQgfSwge1xuICAvLyBgUHJvbWlzZS5yZXNvbHZlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKElTX1BVUkUgJiYgdGhpcyA9PT0gUHJvbWlzZVdyYXBwZXIgPyBQcm9taXNlQ29uc3RydWN0b3IgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG5cbiQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIC8vIGBQcm9taXNlLmFsbGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5hbGxcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFGdW5jdGlvbihDLnJlc29sdmUpO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICAkcHJvbWlzZVJlc29sdmUuY2FsbChDLCBwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIGBQcm9taXNlLnJhY2VgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucmFjZVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhRnVuY3Rpb24oQy5yZXNvbHZlKTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICRwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2hhckF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUnKS5jaGFyQXQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvcicpO1xuXG52YXIgU1RSSU5HX0lURVJBVE9SID0gJ1N0cmluZyBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuZGVmaW5lSXRlcmF0b3IoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcbiAgICBzdHJpbmc6IFN0cmluZyhpdGVyYXRlZCksXG4gICAgaW5kZXg6IDBcbiAgfSk7XG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICB2YXIgc3RyaW5nID0gc3RhdGUuc3RyaW5nO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleDtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9IGNoYXJBdChzdHJpbmcsIGluZGV4KTtcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgRE9NSXRlcmFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMnKTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHXSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgfVxuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIHJlYWRlciB3aGljaCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgdGhlIGdpdmVuIGlucHV0IHN0cmVhbSwgcmV0dXJuaW5nXHJcbiAqIHN0cmljdGx5IHJlY2VpdmVkIHBhY2tldHMgYXMgYXJyYXkgYnVmZmVycy4gTm90ZSB0aGF0IHRoaXMgb2JqZWN0IHdpbGxcclxuICogb3ZlcndyaXRlIGFueSBpbnN0YWxsZWQgZXZlbnQgaGFuZGxlcnMgb24gdGhlIGdpdmVuIEd1YWNhbW9sZS5JbnB1dFN0cmVhbS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gc3RyZWFtIFRoZSBzdHJlYW0gdGhhdCBkYXRhIHdpbGwgYmUgcmVhZFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20uXHJcbiAqL1xyXG5HdWFjYW1vbGUuQXJyYXlCdWZmZXJSZWFkZXIgPSBmdW5jdGlvbihzdHJlYW0pIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIEd1YWNhbW9sZS5JbnB1dFN0cmVhbS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX3JlYWRlciA9IHRoaXM7XHJcblxyXG4gICAgLy8gUmVjZWl2ZSBibG9icyBhcyBhcnJheSBidWZmZXJzXHJcbiAgICBzdHJlYW0ub25ibG9iID0gZnVuY3Rpb24oZGF0YSkge1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRvIEFycmF5QnVmZmVyXHJcbiAgICAgICAgdmFyIGJpbmFyeSA9IHdpbmRvdy5hdG9iKGRhdGEpO1xyXG4gICAgICAgIHZhciBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihiaW5hcnkubGVuZ3RoKTtcclxuICAgICAgICB2YXIgYnVmZmVyVmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGJpbmFyeS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYnVmZmVyVmlld1tpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpO1xyXG5cclxuICAgICAgICAvLyBDYWxsIGhhbmRsZXIsIGlmIHByZXNlbnRcclxuICAgICAgICBpZiAoZ3VhY19yZWFkZXIub25kYXRhKVxyXG4gICAgICAgICAgICBndWFjX3JlYWRlci5vbmRhdGEoYXJyYXlCdWZmZXIpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gU2ltcGx5IGNhbGwgb25lbmQgd2hlbiBlbmQgcmVjZWl2ZWRcclxuICAgIHN0cmVhbS5vbmVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChndWFjX3JlYWRlci5vbmVuZClcclxuICAgICAgICAgICAgZ3VhY19yZWFkZXIub25lbmQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCBvbmNlIGZvciBldmVyeSBibG9iIG9mIGRhdGEgcmVjZWl2ZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIFRoZSBkYXRhIHBhY2tldCByZWNlaXZlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmRhdGEgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgb25jZSB0aGlzIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgbm8gZnVydGhlciBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cclxuICAgICAqIEBldmVudFxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uZW5kID0gbnVsbDtcclxuXHJcbn07XG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgd3JpdGVyIHdoaWNoIGF1dG9tYXRpY2FsbHkgd3JpdGVzIHRvIHRoZSBnaXZlbiBvdXRwdXQgc3RyZWFtIHdpdGggYXJiaXRyYXJ5XHJcbiAqIGJpbmFyeSBkYXRhLCBzdXBwbGllZCBhcyBBcnJheUJ1ZmZlcnMuXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuT3V0cHV0U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSB0aGF0IGRhdGEgd2lsbCBiZSB3cml0dGVuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkFycmF5QnVmZmVyV3JpdGVyID0gZnVuY3Rpb24oc3RyZWFtKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuU3RyaW5nV3JpdGVyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNfd3JpdGVyID0gdGhpcztcclxuXHJcbiAgICAvLyBTaW1wbHkgY2FsbCBvbmFjayBmb3IgYWNrbm93bGVkZ2VtZW50c1xyXG4gICAgc3RyZWFtLm9uYWNrID0gZnVuY3Rpb24oc3RhdHVzKSB7XHJcbiAgICAgICAgaWYgKGd1YWNfd3JpdGVyLm9uYWNrKVxyXG4gICAgICAgICAgICBndWFjX3dyaXRlci5vbmFjayhzdGF0dXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhlIGdpdmVuIGRhdGEgYXMgYmFzZTY0LCBzZW5kaW5nIGl0IGFzIGEgYmxvYi4gVGhlIGRhdGEgbXVzdFxyXG4gICAgICogYmUgc21hbGwgZW5vdWdoIHRvIGZpdCBpbnRvIGEgc2luZ2xlIGJsb2IgaW5zdHJ1Y3Rpb24uXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzIFRoZSBkYXRhIHRvIHNlbmQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9fc2VuZF9ibG9iKGJ5dGVzKSB7XHJcblxyXG4gICAgICAgIHZhciBiaW5hcnkgPSBcIlwiO1xyXG5cclxuICAgICAgICAvLyBQcm9kdWNlIGJpbmFyeSBzdHJpbmcgZnJvbSBieXRlcyBpbiBidWZmZXJcclxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8Ynl0ZXMuYnl0ZUxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XHJcblxyXG4gICAgICAgIC8vIFNlbmQgYXMgYmFzZTY0XHJcbiAgICAgICAgc3RyZWFtLnNlbmRCbG9iKHdpbmRvdy5idG9hKGJpbmFyeSkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbnkgYmxvYiBzZW50IGJ5IHRoaXMgR3VhY2Ftb2xlLkFycmF5QnVmZmVyV3JpdGVyLFxyXG4gICAgICogaW4gYnl0ZXMuIERhdGEgc2VudCB2aWFcclxuICAgICAqIFtzZW5kRGF0YSgpXXtAbGluayBHdWFjYW1vbGUuQXJyYXlCdWZmZXJXcml0ZXIjc2VuZERhdGF9IHdoaWNoIGV4Y2VlZHNcclxuICAgICAqIHRoaXMgbGVuZ3RoIHdpbGwgYmUgc3BsaXQgaW50byBtdWx0aXBsZSBibG9icy4gQXMgdGhlIEd1YWNhbW9sZSBwcm90b2NvbFxyXG4gICAgICogbGltaXRzIHRoZSBtYXhpbXVtIHNpemUgb2YgYW55IGluc3RydWN0aW9uIG9yIGluc3RydWN0aW9uIGVsZW1lbnQgdG9cclxuICAgICAqIDgxOTIgYnl0ZXMsIGFuZCB0aGUgY29udGVudHMgb2YgYmxvYnMgd2lsbCBiZSBiYXNlNjQtZW5jb2RlZCwgdGhpcyB2YWx1ZVxyXG4gICAgICogc2hvdWxkIG9ubHkgYmUgaW5jcmVhc2VkIHdpdGggZXh0cmVtZSBjYXV0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB7QGxpbmsgR3VhY2Ftb2xlLkFycmF5QnVmZmVyV3JpdGVyLkRFRkFVTFRfQkxPQl9MRU5HVEh9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYmxvYkxlbmd0aCA9IEd1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlci5ERUZBVUxUX0JMT0JfTEVOR1RIO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgdGhlIGdpdmVuIGRhdGEuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8VHlwZWRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byBzZW5kLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xyXG5cclxuICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShkYXRhKTtcclxuXHJcbiAgICAgICAgLy8gSWYgc21hbGwgZW5vdWdoIHRvIGZpdCBpbnRvIHNpbmdsZSBpbnN0cnVjdGlvbiwgc2VuZCBhcy1pc1xyXG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPD0gZ3VhY193cml0ZXIuYmxvYkxlbmd0aClcclxuICAgICAgICAgICAgX19zZW5kX2Jsb2IoYnl0ZXMpO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHNlbmQgYXMgbXVsdGlwbGUgaW5zdHJ1Y3Rpb25zXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG9mZnNldD0wOyBvZmZzZXQ8Ynl0ZXMubGVuZ3RoOyBvZmZzZXQgKz0gZ3VhY193cml0ZXIuYmxvYkxlbmd0aClcclxuICAgICAgICAgICAgICAgIF9fc2VuZF9ibG9iKGJ5dGVzLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgZ3VhY193cml0ZXIuYmxvYkxlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmFscyB0aGF0IG5vIGZ1cnRoZXIgdGV4dCB3aWxsIGJlIHNlbnQsIGVmZmVjdGl2ZWx5IGNsb3NpbmcgdGhlXHJcbiAgICAgKiBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VuZEVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHN0cmVhbS5zZW5kRW5kKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgZm9yIHJlY2VpdmVkIGRhdGEsIGlmIGFja25vd2xlZGdlZCBieSB0aGUgc2VydmVyLlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5TdGF0dXN9IHN0YXR1cyBUaGUgc3RhdHVzIG9mIHRoZSBvcGVyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25hY2sgPSBudWxsO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBtYXhpbXVtIGJsb2IgbGVuZ3RoIGZvciBuZXcgR3VhY2Ftb2xlLkFycmF5QnVmZmVyV3JpdGVyXHJcbiAqIGluc3RhbmNlcy5cclxuICpcclxuICogQGNvbnN0YW50XHJcbiAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAqL1xyXG5HdWFjYW1vbGUuQXJyYXlCdWZmZXJXcml0ZXIuREVGQVVMVF9CTE9CX0xFTkdUSCA9IDYwNDg7XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBNYWludGFpbnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIFdlYiBBdWRpbyBBUEkgQXVkaW9Db250ZXh0IGNsYXNzLFxyXG4gKiBpbnN0YW50aWF0aW5nIHRoZSBBdWRpb0NvbnRleHQgb25seSBpbiByZXNwb25zZSB0byB0aGUgZmlyc3QgY2FsbCB0b1xyXG4gKiBnZXRBdWRpb0NvbnRleHQoKSwgYW5kIG9ubHkgaWYgbm8gZXhpc3RpbmcgQXVkaW9Db250ZXh0IGluc3RhbmNlIGhhcyBiZWVuXHJcbiAqIHByb3ZpZGVkIHZpYSB0aGUgc2luZ2xldG9uIHByb3BlcnR5LiBTdWJzZXF1ZW50IGNhbGxzIHRvIGdldEF1ZGlvQ29udGV4dCgpXHJcbiAqIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5HdWFjYW1vbGUuQXVkaW9Db250ZXh0RmFjdG9yeSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgV2ViIEF1ZGlvIEFQSSBBdWRpb0NvbnRleHQgb2JqZWN0LCBvciBudWxsIGlmXHJcbiAgICAgKiBubyBpbnN0YW5jZSBoYXMgeWVzIGJlZW4gY3JlYXRlZC4gVGhpcyBwcm9wZXJ0eSBtYXkgYmUgbWFudWFsbHkgc2V0IGlmXHJcbiAgICAgKiB5b3Ugd2lzaCB0byBzdXBwbHkgeW91ciBvd24gQXVkaW9Db250ZXh0IGluc3RhbmNlLCBidXQgY2FyZSBtdXN0IGJlXHJcbiAgICAgKiB0YWtlbiB0byBkbyBzbyBhcyBlYXJseSBhcyBwb3NzaWJsZS4gQXNzaWdubWVudHMgdG8gdGhpcyBwcm9wZXJ0eSB3aWxsXHJcbiAgICAgKiBub3QgcmV0cm9hY3RpdmVseSBhZmZlY3QgdGhlIHZhbHVlIHJldHVybmVkIGJ5IHByZXZpb3VzIGNhbGxzIHRvXHJcbiAgICAgKiBnZXRBdWRpb0NvbnRleHQoKS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7QXVkaW9Db250ZXh0fVxyXG4gICAgICovXHJcbiAgICAnc2luZ2xldG9uJyA6IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgV2ViIEF1ZGlvIEFQSSBBdWRpb0NvbnRleHQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0F1ZGlvQ29udGV4dH1cclxuICAgICAqICAgICBBIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIFdlYiBBdWRpbyBBUEkgQXVkaW9Db250ZXh0IG9iamVjdCwgb3IgbnVsbFxyXG4gICAgICogICAgIGlmIHRoZSBXZWIgQXVkaW8gQVBJIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgKi9cclxuICAgICdnZXRBdWRpb0NvbnRleHQnIDogZnVuY3Rpb24gZ2V0QXVkaW9Db250ZXh0KCkge1xyXG5cclxuICAgICAgICAvLyBGYWxsYmFjayB0byBXZWJraXQtc3BlY2lmaWMgQXVkaW9Db250ZXh0IGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgdmFyIEF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcclxuXHJcbiAgICAgICAgLy8gR2V0IG5ldyBBdWRpb0NvbnRleHQgaW5zdGFuY2UgaWYgV2ViIEF1ZGlvIEFQSSBpcyBzdXBwb3J0ZWRcclxuICAgICAgICBpZiAoQXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSBpZiBub25lIHlldCBleGlzdHNcclxuICAgICAgICAgICAgICAgIGlmICghR3VhY2Ftb2xlLkF1ZGlvQ29udGV4dEZhY3Rvcnkuc2luZ2xldG9uKVxyXG4gICAgICAgICAgICAgICAgICAgIEd1YWNhbW9sZS5BdWRpb0NvbnRleHRGYWN0b3J5LnNpbmdsZXRvbiA9IG5ldyBBdWRpb0NvbnRleHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gc2luZ2xldG9uIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gR3VhY2Ftb2xlLkF1ZGlvQ29udGV4dEZhY3Rvcnkuc2luZ2xldG9uO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHVzZSBXZWIgQXVkaW8gQVBJIGlmIG5vdCBhbGxvd2VkIGJ5IGJyb3dzZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2ViIEF1ZGlvIEFQSSBub3Qgc3VwcG9ydGVkXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEFic3RyYWN0IGF1ZGlvIHBsYXllciB3aGljaCBhY2NlcHRzLCBxdWV1ZXMgYW5kIHBsYXlzIGJhY2sgYXJiaXRyYXJ5IGF1ZGlvXHJcbiAqIGRhdGEuIEl0IGlzIHVwIHRvIGltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGNsYXNzIHRvIHByb3ZpZGUgc29tZSBtZWFucyBvZlxyXG4gKiBoYW5kbGluZyBhIHByb3ZpZGVkIEd1YWNhbW9sZS5JbnB1dFN0cmVhbS4gRGF0YSByZWNlaXZlZCBhbG9uZyB0aGUgcHJvdmlkZWRcclxuICogc3RyZWFtIGlzIHRvIGJlIHBsYXllZCBiYWNrIGltbWVkaWF0ZWx5LlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbkd1YWNhbW9sZS5BdWRpb1BsYXllciA9IGZ1bmN0aW9uIEF1ZGlvUGxheWVyKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm90aWZpZXMgdGhpcyBHdWFjYW1vbGUuQXVkaW9QbGF5ZXIgdGhhdCBhbGwgYXVkaW8gdXAgdG8gdGhlIGN1cnJlbnRcclxuICAgICAqIHBvaW50IGluIHRpbWUgaGFzIGJlZW4gZ2l2ZW4gdmlhIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSwgYW5kIHRoYXQgYW55XHJcbiAgICAgKiBkaWZmZXJlbmNlIGluIHRpbWUgYmV0d2VlbiBxdWV1ZWQgYXVkaW8gZGF0YSBhbmQgdGhlIGN1cnJlbnQgdGltZSBjYW4gYmVcclxuICAgICAqIGNvbnNpZGVyZWQgbGF0ZW5jeS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zeW5jID0gZnVuY3Rpb24gc3luYygpIHtcclxuICAgICAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIC0gZG8gbm90aGluZ1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBtaW1ldHlwZSBpcyBzdXBwb3J0ZWQgYnkgYW55IGJ1aWx0LWluXHJcbiAqIGltcGxlbWVudGF0aW9uIG9mIEd1YWNhbW9sZS5BdWRpb1BsYXllciwgYW5kIHRodXMgd2lsbCBiZSBwcm9wZXJseSBoYW5kbGVkXHJcbiAqIGJ5IEd1YWNhbW9sZS5BdWRpb1BsYXllci5nZXRJbnN0YW5jZSgpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICogICAgIFRoZSBtaW1ldHlwZSB0byBjaGVjay5cclxuICpcclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqICAgICB0cnVlIGlmIHRoZSBnaXZlbiBtaW1ldHlwZSBpcyBzdXBwb3J0ZWQgYnkgYW55IGJ1aWx0LWluXHJcbiAqICAgICBHdWFjYW1vbGUuQXVkaW9QbGF5ZXIsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbkd1YWNhbW9sZS5BdWRpb1BsYXllci5pc1N1cHBvcnRlZFR5cGUgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZFR5cGUobWltZXR5cGUpIHtcclxuXHJcbiAgICByZXR1cm4gR3VhY2Ftb2xlLlJhd0F1ZGlvUGxheWVyLmlzU3VwcG9ydGVkVHlwZShtaW1ldHlwZSk7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBtaW1ldHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBidWlsdC1pblxyXG4gKiBHdWFjYW1vbGUuQXVkaW9QbGF5ZXIsIGluIHJvdWdoIG9yZGVyIG9mIHByaW9yaXR5LiBCZXdhcmUgdGhhdCBvbmx5IHRoZSBjb3JlXHJcbiAqIG1pbWV0eXBlcyB0aGVtc2VsdmVzIHdpbGwgYmUgbGlzdGVkLiBBbnkgbWltZXR5cGUgcGFyYW1ldGVycywgZXZlbiByZXF1aXJlZFxyXG4gKiBvbmVzLCB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgbGlzdC4gRm9yIGV4YW1wbGUsIFwiYXVkaW8vTDhcIiBpcyBhXHJcbiAqIHN1cHBvcnRlZCByYXcgYXVkaW8gbWltZXR5cGUgdGhhdCBpcyBzdXBwb3J0ZWQsIGJ1dCBpdCBpcyBpbnZhbGlkIHdpdGhvdXRcclxuICogYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBTb21ldGhpbmcgbGlrZSBcImF1ZGlvL0w4O3JhdGU9NDQxMDBcIiB3b3VsZCBiZSB2YWxpZCxcclxuICogaG93ZXZlciAoc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0ODU2KS5cclxuICpcclxuICogQHJldHVybnMge1N0cmluZ1tdfVxyXG4gKiAgICAgQSBsaXN0IG9mIGFsbCBtaW1ldHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBidWlsdC1pbiBHdWFjYW1vbGUuQXVkaW9QbGF5ZXIsXHJcbiAqICAgICBleGNsdWRpbmcgYW55IHBhcmFtZXRlcnMuXHJcbiAqL1xyXG5HdWFjYW1vbGUuQXVkaW9QbGF5ZXIuZ2V0U3VwcG9ydGVkVHlwZXMgPSBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRUeXBlcygpIHtcclxuXHJcbiAgICByZXR1cm4gR3VhY2Ftb2xlLlJhd0F1ZGlvUGxheWVyLmdldFN1cHBvcnRlZFR5cGVzKCk7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgR3VhY2Ftb2xlLkF1ZGlvUGxheWVyIHByb3ZpZGluZyBzdXBwb3J0IGZvciB0aGUgZ2l2ZW5cclxuICogYXVkaW8gZm9ybWF0LiBJZiBzdXBwb3J0IGZvciB0aGUgZ2l2ZW4gYXVkaW8gZm9ybWF0IGlzIG5vdCBhdmFpbGFibGUsIG51bGxcclxuICogaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLklucHV0U3RyZWFtfSBzdHJlYW1cclxuICogICAgIFRoZSBHdWFjYW1vbGUuSW5wdXRTdHJlYW0gdG8gcmVhZCBhdWRpbyBkYXRhIGZyb20uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gKiAgICAgVGhlIG1pbWV0eXBlIG9mIHRoZSBhdWRpbyBkYXRhIGluIHRoZSBwcm92aWRlZCBzdHJlYW0uXHJcbiAqXHJcbiAqIEByZXR1cm4ge0d1YWNhbW9sZS5BdWRpb1BsYXllcn1cclxuICogICAgIEEgR3VhY2Ftb2xlLkF1ZGlvUGxheWVyIGluc3RhbmNlIHN1cHBvcnRpbmcgdGhlIGdpdmVuIG1pbWV0eXBlIGFuZFxyXG4gKiAgICAgcmVhZGluZyBmcm9tIHRoZSBnaXZlbiBzdHJlYW0sIG9yIG51bGwgaWYgc3VwcG9ydCBmb3IgdGhlIGdpdmVuIG1pbWV0eXBlXHJcbiAqICAgICBpcyBhYnNlbnQuXHJcbiAqL1xyXG5HdWFjYW1vbGUuQXVkaW9QbGF5ZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRJbnN0YW5jZShzdHJlYW0sIG1pbWV0eXBlKSB7XHJcblxyXG4gICAgLy8gVXNlIHJhdyBhdWRpbyBwbGF5ZXIgaWYgcG9zc2libGVcclxuICAgIGlmIChHdWFjYW1vbGUuUmF3QXVkaW9QbGF5ZXIuaXNTdXBwb3J0ZWRUeXBlKG1pbWV0eXBlKSlcclxuICAgICAgICByZXR1cm4gbmV3IEd1YWNhbW9sZS5SYXdBdWRpb1BsYXllcihzdHJlYW0sIG1pbWV0eXBlKTtcclxuXHJcbiAgICAvLyBObyBzdXBwb3J0IGZvciBnaXZlbiBtaW1ldHlwZVxyXG4gICAgcmV0dXJuIG51bGw7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIEd1YWNhbW9sZS5BdWRpb1BsYXllciBwcm92aWRpbmcgc3VwcG9ydCBmb3IgcmF3IFBDTSBmb3JtYXRcclxuICogYXVkaW8uIFRoaXMgcGxheWVyIHJlbGllcyBvbmx5IG9uIHRoZSBXZWIgQXVkaW8gQVBJIGFuZCBkb2VzIG5vdCByZXF1aXJlIGFueVxyXG4gKiBicm93c2VyLWxldmVsIHN1cHBvcnQgZm9yIGl0cyBhdWRpbyBmb3JtYXRzLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1Z21lbnRzIEd1YWNhbW9sZS5BdWRpb1BsYXllclxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gc3RyZWFtXHJcbiAqICAgICBUaGUgR3VhY2Ftb2xlLklucHV0U3RyZWFtIHRvIHJlYWQgYXVkaW8gZGF0YSBmcm9tLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgYXVkaW8gZGF0YSBpbiB0aGUgcHJvdmlkZWQgc3RyZWFtLCB3aGljaCBtdXN0IGJlIGFcclxuICogICAgIFwiYXVkaW8vTDhcIiBvciBcImF1ZGlvL0wxNlwiIG1pbWV0eXBlIHdpdGggbmVjZXNzYXJ5IHBhcmFtZXRlcnMsIHN1Y2ggYXM6XHJcbiAqICAgICBcImF1ZGlvL0wxNjtyYXRlPTQ0MTAwLGNoYW5uZWxzPTJcIi5cclxuICovXHJcbkd1YWNhbW9sZS5SYXdBdWRpb1BsYXllciA9IGZ1bmN0aW9uIFJhd0F1ZGlvUGxheWVyKHN0cmVhbSwgbWltZXR5cGUpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmb3JtYXQgb2YgYXVkaW8gdGhpcyBwbGF5ZXIgd2lsbCBkZWNvZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuUmF3QXVkaW9Gb3JtYXR9XHJcbiAgICAgKi9cclxuICAgIHZhciBmb3JtYXQgPSBHdWFjYW1vbGUuUmF3QXVkaW9Gb3JtYXQucGFyc2UobWltZXR5cGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW5zdGFuY2Ugb2YgYSBXZWIgQXVkaW8gQVBJIEF1ZGlvQ29udGV4dCBvYmplY3QsIG9yIG51bGwgaWYgdGhlXHJcbiAgICAgKiBXZWIgQXVkaW8gQVBJIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtBdWRpb0NvbnRleHR9XHJcbiAgICAgKi9cclxuICAgIHZhciBjb250ZXh0ID0gR3VhY2Ftb2xlLkF1ZGlvQ29udGV4dEZhY3RvcnkuZ2V0QXVkaW9Db250ZXh0KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZWFybGllc3QgcG9zc2libGUgdGltZSB0aGF0IHRoZSBuZXh0IHBhY2tldCBjb3VsZCBwbGF5IHdpdGhvdXRcclxuICAgICAqIG92ZXJsYXBwaW5nIGFuIGFscmVhZHktcGxheWluZyBwYWNrZXQsIGluIHNlY29uZHMuIE5vdGUgdGhhdCB3aGlsZSB0aGlzXHJcbiAgICAgKiB2YWx1ZSBpcyBpbiBzZWNvbmRzLCBpdCBpcyBub3QgYW4gaW50ZWdlciB2YWx1ZSBhbmQgaGFzIG1pY3Jvc2Vjb25kXHJcbiAgICAgKiByZXNvbHV0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgbmV4dFBhY2tldFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR3VhY2Ftb2xlLkFycmF5QnVmZmVyUmVhZGVyIHdyYXBwZWQgYXJvdW5kIHRoZSBhdWRpbyBpbnB1dCBzdHJlYW1cclxuICAgICAqIHByb3ZpZGVkIHdpdGggdGhpcyBHdWFjYW1vbGUuUmF3QXVkaW9QbGF5ZXIgd2FzIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuQXJyYXlCdWZmZXJSZWFkZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciByZWFkZXIgPSBuZXcgR3VhY2Ftb2xlLkFycmF5QnVmZmVyUmVhZGVyKHN0cmVhbSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWluaW11bSBzaXplIG9mIGFuIGF1ZGlvIHBhY2tldCBzcGxpdCBieSBzcGxpdEF1ZGlvUGFja2V0KCksIGluXHJcbiAgICAgKiBzZWNvbmRzLiBBdWRpbyBwYWNrZXRzIHNtYWxsZXIgdGhhbiB0aGlzIHdpbGwgbm90IGJlIHNwbGl0LCBub3Igd2lsbCB0aGVcclxuICAgICAqIHNwbGl0IHJlc3VsdCBvZiBhIGxhcmdlciBwYWNrZXQgZXZlciBiZSBzbWFsbGVyIGluIHNpemUgdGhhbiB0aGlzXHJcbiAgICAgKiBtaW5pbXVtLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBNSU5fU1BMSVRfU0laRSA9IDAuMDI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgbGF0ZW5jeSB0byBhbGxvdyBiZXR3ZWVuIHRoZSBidWZmZXJlZCBkYXRhIHN0cmVhbVxyXG4gICAgICogYW5kIHRoZSBwbGF5YmFjayBwb3NpdGlvbiwgaW4gc2Vjb25kcy4gSW5pdGlhbGx5LCB0aGlzIGlzIHNldCB0b1xyXG4gICAgICogcm91Z2hseSBvbmUgdGhpcmQgb2YgYSBzZWNvbmQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBtYXhMYXRlbmN5ID0gMC4zO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR5cGUgb2YgdHlwZWQgYXJyYXkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVwcmVzZW50IGVhY2ggYXVkaW8gcGFja2V0XHJcbiAgICAgKiBpbnRlcm5hbGx5LiBUaGlzIHdpbGwgYmUgZWl0aGVyIEludDhBcnJheSBvciBJbnQxNkFycmF5LCBkZXBlbmRpbmcgb25cclxuICAgICAqIHdoZXRoZXIgdGhlIHJhdyBhdWRpbyBmb3JtYXQgaXMgOC1iaXQgb3IgMTYtYml0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIFNhbXBsZUFycmF5ID0gKGZvcm1hdC5ieXRlc1BlclNhbXBsZSA9PT0gMSkgPyB3aW5kb3cuSW50OEFycmF5IDogd2luZG93LkludDE2QXJyYXk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBhYnNvbHV0ZSB2YWx1ZSBvZiBhbnkgc2FtcGxlIHdpdGhpbiBhIHJhdyBhdWRpbyBwYWNrZXRcclxuICAgICAqIHJlY2VpdmVkIGJ5IHRoaXMgYXVkaW8gcGxheWVyLiBUaGlzIGRlcGVuZHMgb25seSBvbiB0aGUgc2l6ZSBvZiBlYWNoXHJcbiAgICAgKiBzYW1wbGUsIGFuZCB3aWxsIGJlIDEyOCBmb3IgOC1iaXQgYXVkaW8gYW5kIDMyNzY4IGZvciAxNi1iaXQgYXVkaW8uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBtYXhTYW1wbGVWYWx1ZSA9IChmb3JtYXQuYnl0ZXNQZXJTYW1wbGUgPT09IDEpID8gMTI4IDogMzI3Njg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcXVldWUgb2YgYWxsIHBlbmRpbmcgYXVkaW8gcGFja2V0cywgYXMgYW4gYXJyYXkgb2Ygc2FtcGxlIGFycmF5cy5cclxuICAgICAqIEF1ZGlvIHBhY2tldHMgd2hpY2ggYXJlIHBlbmRpbmcgcGxheWJhY2sgd2lsbCBiZSBhZGRlZCB0byB0aGlzIHF1ZXVlIGZvclxyXG4gICAgICogZnVydGhlciBtYW5pcHVsYXRpb24gcHJpb3IgdG8gc2NoZWR1bGluZyB2aWEgdGhlIFdlYiBBdWRpbyBBUEkuIE9uY2UgYW5cclxuICAgICAqIGF1ZGlvIHBhY2tldCBsZWF2ZXMgdGhpcyBxdWV1ZSBhbmQgaXMgc2NoZWR1bGVkIHZpYSB0aGUgV2ViIEF1ZGlvIEFQSSxcclxuICAgICAqIG5vIGZ1cnRoZXIgbW9kaWZpY2F0aW9ucyBjYW4gYmUgbWFkZSB0byB0aGF0IHBhY2tldC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge1NhbXBsZUFycmF5W119XHJcbiAgICAgKi9cclxuICAgIHZhciBwYWNrZXRRdWV1ZSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2YgYXVkaW8gcGFja2V0cywgcmV0dXJucyBhIHNpbmdsZSBhdWRpbyBwYWNrZXRcclxuICAgICAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhvc2UgcGFja2V0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTYW1wbGVBcnJheVtdfSBwYWNrZXRzXHJcbiAgICAgKiAgICAgVGhlIGFycmF5IG9mIGF1ZGlvIHBhY2tldHMgdG8gY29uY2F0ZW5hdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1NhbXBsZUFycmF5fVxyXG4gICAgICogICAgIEEgc2luZ2xlIGF1ZGlvIHBhY2tldCBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBnaXZlblxyXG4gICAgICogICAgIGF1ZGlvIHBhY2tldHMuIElmIG5vIHBhY2tldHMgYXJlIHByb3ZpZGVkLCB0aGlzIHdpbGwgYmUgdW5kZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICB2YXIgam9pbkF1ZGlvUGFja2V0cyA9IGZ1bmN0aW9uIGpvaW5BdWRpb1BhY2tldHMocGFja2V0cykge1xyXG5cclxuICAgICAgICAvLyBEbyBub3QgYm90aGVyIGpvaW5pbmcgaWYgb25lIG9yIGZld2VyIHBhY2tldHMgYXJlIGluIHRoZSBxdWV1ZVxyXG4gICAgICAgIGlmIChwYWNrZXRzLmxlbmd0aCA8PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gcGFja2V0c1swXTtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRvdGFsIHNhbXBsZSBsZW5ndGggb2YgdGhlIGVudGlyZSBxdWV1ZVxyXG4gICAgICAgIHZhciB0b3RhbExlbmd0aCA9IDA7XHJcbiAgICAgICAgcGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uIGFkZFBhY2tldExlbmd0aHMocGFja2V0KSB7XHJcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IHBhY2tldC5sZW5ndGg7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBlYWNoIHBhY2tldCB3aXRoaW4gcXVldWVcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgam9pbmVkID0gbmV3IFNhbXBsZUFycmF5KHRvdGFsTGVuZ3RoKTtcclxuICAgICAgICBwYWNrZXRzLmZvckVhY2goZnVuY3Rpb24gYXBwZW5kUGFja2V0KHBhY2tldCkge1xyXG4gICAgICAgICAgICBqb2luZWQuc2V0KHBhY2tldCwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHBhY2tldC5sZW5ndGg7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBqb2luZWQ7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgc2luZ2xlIHBhY2tldCBvZiBhdWRpbyBkYXRhLCBzcGxpdHMgb2ZmIGFuIGFyYml0cmFyeSBsZW5ndGggb2ZcclxuICAgICAqIGF1ZGlvIGRhdGEgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoYXQgcGFja2V0LCByZXR1cm5pbmcgdGhlIHNwbGl0IHJlc3VsdFxyXG4gICAgICogYXMgYW4gYXJyYXkgb2YgdHdvIHBhY2tldHMuIFRoZSBzcGxpdCBsb2NhdGlvbiBpcyBkZXRlcm1pbmVkIHRocm91Z2ggYW5cclxuICAgICAqIGFsZ29yaXRobSBpbnRlbmRlZCB0byBtaW5pbWl6ZSB0aGUgbGlrbGlob29kIG9mIGF1ZGlibGUgY2xpY2tpbmcgYmV0d2VlblxyXG4gICAgICogcGFja2V0cy4gSWYgbm8gc3VjaCBzcGxpdCBsb2NhdGlvbiBpcyBwb3NzaWJsZSwgYW4gYXJyYXkgY29udGFpbmluZyBvbmx5XHJcbiAgICAgKiB0aGUgb3JpZ2luYWxseS1wcm92aWRlZCBhdWRpbyBwYWNrZXQgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U2FtcGxlQXJyYXl9IGRhdGFcclxuICAgICAqICAgICBUaGUgYXVkaW8gcGFja2V0IHRvIHNwbGl0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTYW1wbGVBcnJheVtdfVxyXG4gICAgICogICAgIEFuIGFycmF5IG9mIGF1ZGlvIHBhY2tldHMgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIHNwbGl0dGluZyB0aGVcclxuICAgICAqICAgICBwcm92aWRlZCBhdWRpbyBwYWNrZXQuIElmIHNwbGl0dGluZyBpcyBwb3NzaWJsZSwgdGhpcyBhcnJheSB3aWxsXHJcbiAgICAgKiAgICAgY29udGFpbiB0d28gcGFja2V0cy4gSWYgc3BsaXR0aW5nIGlzIG5vdCBwb3NzaWJsZSwgdGhpcyBhcnJheSB3aWxsXHJcbiAgICAgKiAgICAgY29udGFpbiBvbmx5IHRoZSBvcmlnaW5hbGx5LXByb3ZpZGVkIHBhY2tldC5cclxuICAgICAqL1xyXG4gICAgdmFyIHNwbGl0QXVkaW9QYWNrZXQgPSBmdW5jdGlvbiBzcGxpdEF1ZGlvUGFja2V0KGRhdGEpIHtcclxuXHJcbiAgICAgICAgdmFyIG1pblZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB2YXIgb3B0aW1hbFNwbGl0TGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2Ygd2hvbGUgc2FtcGxlcyBpbiB0aGUgcHJvdmlkZWQgYXVkaW8gcGFja2V0IEFORFxyXG4gICAgICAgIC8vIGluIHRoZSBtaW5pbXVtIHBvc3NpYmxlIHNwbGl0IHBhY2tldFxyXG4gICAgICAgIHZhciBzYW1wbGVzID0gTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAvIGZvcm1hdC5jaGFubmVscyk7XHJcbiAgICAgICAgdmFyIG1pblNwbGl0U2FtcGxlcyA9IE1hdGguZmxvb3IoZm9ybWF0LnJhdGUgKiBNSU5fU1BMSVRfU0laRSk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBcImVuZFwiIG9mIHRoZSBhdWRpbyBwYWNrZXRcclxuICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgZm9ybWF0LmNoYW5uZWxzICogbWluU3BsaXRTYW1wbGVzLFxyXG4gICAgICAgICAgICBmb3JtYXQuY2hhbm5lbHMgKiAoc2FtcGxlcyAtIG1pblNwbGl0U2FtcGxlcylcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBGb3IgYWxsIHNhbXBsZXMgYXQgdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gcGFja2V0LCBmaW5kIGEgcG9pbnQgd2hlcmVcclxuICAgICAgICAvLyB0aGUgcGVyY2VwdGlibGUgdm9sdW1lIGFjcm9zcyBhbGwgY2hhbm5lbHMgaXMgbG93ZXN0IChhbmQgdGh1cyBpc1xyXG4gICAgICAgIC8vIHRoZSBvcHRpbWFsIHBvaW50IHRvIHNwbGl0KVxyXG4gICAgICAgIGZvciAodmFyIG9mZnNldCA9IHN0YXJ0OyBvZmZzZXQgPCBkYXRhLmxlbmd0aDsgb2Zmc2V0ICs9IGZvcm1hdC5jaGFubmVscykge1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzdW0gb2YgYWxsIHZhbHVlcyBhY3Jvc3MgYWxsIGNoYW5uZWxzICh0aGUgcmVzdWx0XHJcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgcHJvcG9ydGlvbmFsIHRvIHRoZSBhdmVyYWdlIHZvbHVtZSBvZiBhIHNhbXBsZSlcclxuICAgICAgICAgICAgdmFyIHRvdGFsVmFsdWUgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IGZvcm1hdC5jaGFubmVsczsgY2hhbm5lbCsrKSB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFZhbHVlICs9IE1hdGguYWJzKGRhdGFbb2Zmc2V0ICsgY2hhbm5lbF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBzbWFsbGVzdCBhdmVyYWdlIHZhbHVlIHRodXMgZmFyLCBzZXQgdGhlIHNwbGl0XHJcbiAgICAgICAgICAgIC8vIGxlbmd0aCBzdWNoIHRoYXQgdGhlIGZpcnN0IHBhY2tldCBlbmRzIHdpdGggdGhlIGN1cnJlbnQgc2FtcGxlXHJcbiAgICAgICAgICAgIGlmICh0b3RhbFZhbHVlIDw9IG1pblZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpbWFsU3BsaXRMZW5ndGggPSBvZmZzZXQgKyBmb3JtYXQuY2hhbm5lbHM7XHJcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IHRvdGFsVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBwYWNrZXQgaXMgbm90IHNwbGl0LCByZXR1cm4gdGhlIHN1cHBsaWVkIHBhY2tldCB1bnRvdWNoZWRcclxuICAgICAgICBpZiAob3B0aW1hbFNwbGl0TGVuZ3RoID09PSBkYXRhLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIFtkYXRhXTtcclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgcGFja2V0IGludG8gdHdvIG5ldyBwYWNrZXRzIGFjY29yZGluZyB0byB0aGVcclxuICAgICAgICAvLyBjYWxjdWxhdGVkIG9wdGltYWwgc3BsaXQgbGVuZ3RoXHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbmV3IFNhbXBsZUFycmF5KGRhdGEuYnVmZmVyLnNsaWNlKDAsIG9wdGltYWxTcGxpdExlbmd0aCAqIGZvcm1hdC5ieXRlc1BlclNhbXBsZSkpLFxyXG4gICAgICAgICAgICBuZXcgU2FtcGxlQXJyYXkoZGF0YS5idWZmZXIuc2xpY2Uob3B0aW1hbFNwbGl0TGVuZ3RoICogZm9ybWF0LmJ5dGVzUGVyU2FtcGxlKSlcclxuICAgICAgICBdO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQdXNoZXMgdGhlIGdpdmVuIHBhY2tldCBvZiBhdWRpbyBkYXRhIG9udG8gdGhlIHBsYXliYWNrIHF1ZXVlLiBVbmxpa2VcclxuICAgICAqIG90aGVyIHByaXZhdGUgZnVuY3Rpb25zIHdpdGhpbiBHdWFjYW1vbGUuUmF3QXVkaW9QbGF5ZXIsIHRoZSB0eXBlIG9mIHRoZVxyXG4gICAgICogQXJyYXlCdWZmZXIgcGFja2V0IG9mIGF1ZGlvIGRhdGEgaGVyZSBuZWVkIG5vdCBiZSBzcGVjaWZpYyB0byB0aGUgdHlwZVxyXG4gICAgICogb2YgYXVkaW8gKGFzIHdpdGggU2FtcGxlQXJyYXkpLiBUaGUgQXJyYXlCdWZmZXIgdHlwZSBwcm92aWRlZCBieSBhXHJcbiAgICAgKiBHdWFjYW1vbGUuQXJyYXlCdWZmZXJSZWFkZXIsIGZvciBleGFtcGxlLCBpcyBzdWZmaWNpZW50LiBBbnkgbmVjZXNzYXJ5XHJcbiAgICAgKiBjb252ZXJzaW9ucyB3aWxsIGJlIHBlcmZvcm1lZCBhdXRvbWF0aWNhbGx5IGludGVybmFsbHkuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcclxuICAgICAqICAgICBBIHJhdyBwYWNrZXQgb2YgYXVkaW8gZGF0YSB0aGF0IHNob3VsZCBiZSBwdXNoZWQgb250byB0aGUgYXVkaW9cclxuICAgICAqICAgICBwbGF5YmFjayBxdWV1ZS5cclxuICAgICAqL1xyXG4gICAgdmFyIHB1c2hBdWRpb1BhY2tldCA9IGZ1bmN0aW9uIHB1c2hBdWRpb1BhY2tldChkYXRhKSB7XHJcbiAgICAgICAgcGFja2V0UXVldWUucHVzaChuZXcgU2FtcGxlQXJyYXkoZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNoaWZ0cyBvZmYgYW5kIHJldHVybnMgYSBwYWNrZXQgb2YgYXVkaW8gZGF0YSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlXHJcbiAgICAgKiBwbGF5YmFjayBxdWV1ZS4gVGhlIGxlbmd0aCBvZiB0aGlzIGF1ZGlvIHBhY2tldCBpcyBkZXRlcm1pbmVkXHJcbiAgICAgKiBkeW5hbWljYWxseSBhY2NvcmRpbmcgdG8gdGhlIGNsaWNrLXJlZHVjdGlvbiBhbGdvcml0aG0gaW1wbGVtZW50ZWQgYnlcclxuICAgICAqIHNwbGl0QXVkaW9QYWNrZXQoKS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge1NhbXBsZUFycmF5fVxyXG4gICAgICogICAgIEEgcGFja2V0IG9mIGF1ZGlvIGRhdGEgcHVsbGVkIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgcGxheWJhY2tcclxuICAgICAqICAgICBxdWV1ZS5cclxuICAgICAqL1xyXG4gICAgdmFyIHNoaWZ0QXVkaW9QYWNrZXQgPSBmdW5jdGlvbiBzaGlmdEF1ZGlvUGFja2V0KCkge1xyXG5cclxuICAgICAgICAvLyBGbGF0dGVuIGRhdGEgaW4gcGFja2V0IHF1ZXVlXHJcbiAgICAgICAgdmFyIGRhdGEgPSBqb2luQXVkaW9QYWNrZXRzKHBhY2tldFF1ZXVlKTtcclxuICAgICAgICBpZiAoIWRhdGEpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAvLyBQdWxsIGFuIGFwcHJvcHJpYXRlIGFtb3VudCBvZiBkYXRhIGZyb20gdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxyXG4gICAgICAgIHBhY2tldFF1ZXVlID0gc3BsaXRBdWRpb1BhY2tldChkYXRhKTtcclxuICAgICAgICBkYXRhID0gcGFja2V0UXVldWUuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBnaXZlbiBhdWRpbyBwYWNrZXQgaW50byBhbiBBdWRpb0J1ZmZlciwgcmVhZHkgZm9yIHBsYXliYWNrXHJcbiAgICAgKiBieSB0aGUgV2ViIEF1ZGlvIEFQSS4gVW5saWtlIHRoZSByYXcgYXVkaW8gcGFja2V0cyByZWNlaXZlZCBieSB0aGlzXHJcbiAgICAgKiBhdWRpbyBwbGF5ZXIsIEF1ZGlvQnVmZmVycyByZXF1aXJlIGZsb2F0aW5nIHBvaW50IHNhbXBsZXMgYW5kIGFyZSBzcGxpdFxyXG4gICAgICogaW50byBpc29sYXRlZCBwbGFuZXMgb2YgY2hhbm5lbC1zcGVjaWZpYyBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1NhbXBsZUFycmF5fSBkYXRhXHJcbiAgICAgKiAgICAgVGhlIHJhdyBhdWRpbyBwYWNrZXQgdGhhdCBzaG91bGQgYmUgY29udmVydGVkIGludG8gYSBXZWIgQXVkaW8gQVBJXHJcbiAgICAgKiAgICAgQXVkaW9CdWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0F1ZGlvQnVmZmVyfVxyXG4gICAgICogICAgIEEgbmV3IFdlYiBBdWRpbyBBUEkgQXVkaW9CdWZmZXIgY29udGFpbmluZyB0aGUgcHJvdmlkZWQgYXVkaW8gZGF0YSxcclxuICAgICAqICAgICBjb252ZXJ0ZWQgdG8gdGhlIGZvcm1hdCB1c2VkIGJ5IHRoZSBXZWIgQXVkaW8gQVBJLlxyXG4gICAgICovXHJcbiAgICB2YXIgdG9BdWRpb0J1ZmZlciA9IGZ1bmN0aW9uIHRvQXVkaW9CdWZmZXIoZGF0YSkge1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdG90YWwgbnVtYmVyIG9mIHNhbXBsZXNcclxuICAgICAgICB2YXIgc2FtcGxlcyA9IGRhdGEubGVuZ3RoIC8gZm9ybWF0LmNoYW5uZWxzO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgZXhhY3RseSB3aGVuIHBhY2tldCBDQU4gcGxheVxyXG4gICAgICAgIHZhciBwYWNrZXRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZTtcclxuICAgICAgICBpZiAobmV4dFBhY2tldFRpbWUgPCBwYWNrZXRUaW1lKVxyXG4gICAgICAgICAgICBuZXh0UGFja2V0VGltZSA9IHBhY2tldFRpbWU7XHJcblxyXG4gICAgICAgIC8vIEdldCBhdWRpbyBidWZmZXIgZm9yIHNwZWNpZmllZCBmb3JtYXRcclxuICAgICAgICB2YXIgYXVkaW9CdWZmZXIgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlcihmb3JtYXQuY2hhbm5lbHMsIHNhbXBsZXMsIGZvcm1hdC5yYXRlKTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBlYWNoIGNoYW5uZWxcclxuICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IGZvcm1hdC5jaGFubmVsczsgY2hhbm5lbCsrKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXVkaW9EYXRhID0gYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaWxsIGF1ZGlvIGJ1ZmZlciB3aXRoIGRhdGEgZm9yIGNoYW5uZWxcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGNoYW5uZWw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhdWRpb0RhdGFbaV0gPSBkYXRhW29mZnNldF0gLyBtYXhTYW1wbGVWYWx1ZTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBmb3JtYXQuY2hhbm5lbHM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXVkaW9CdWZmZXI7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBEZWZlciBwbGF5YmFjayBvZiByZWNlaXZlZCBhdWRpbyBwYWNrZXRzIHNsaWdodGx5XHJcbiAgICByZWFkZXIub25kYXRhID0gZnVuY3Rpb24gcGxheVJlY2VpdmVkQXVkaW8oZGF0YSkge1xyXG5cclxuICAgICAgICAvLyBQdXNoIHJlY2VpdmVkIHNhbXBsZXMgb250byBxdWV1ZVxyXG4gICAgICAgIHB1c2hBdWRpb1BhY2tldChuZXcgU2FtcGxlQXJyYXkoZGF0YSkpO1xyXG5cclxuICAgICAgICAvLyBTaGlmdCBvZmYgYW4gYXJiaXRyYXJ5IHBhY2tldCBvZiBhdWRpbyBkYXRhIGZyb20gdGhlIHF1ZXVlICh0aGlzIG1heVxyXG4gICAgICAgIC8vIGJlIGRpZmZlcmVudCBpbiBzaXplIGZyb20gdGhlIHBhY2tldCBqdXN0IHB1c2hlZClcclxuICAgICAgICB2YXIgcGFja2V0ID0gc2hpZnRBdWRpb1BhY2tldCgpO1xyXG4gICAgICAgIGlmICghcGFja2V0KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBleGFjdGx5IHdoZW4gcGFja2V0IENBTiBwbGF5XHJcbiAgICAgICAgdmFyIHBhY2tldFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xyXG4gICAgICAgIGlmIChuZXh0UGFja2V0VGltZSA8IHBhY2tldFRpbWUpXHJcbiAgICAgICAgICAgIG5leHRQYWNrZXRUaW1lID0gcGFja2V0VGltZTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHVwIGJ1ZmZlciBzb3VyY2VcclxuICAgICAgICB2YXIgc291cmNlID0gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICBzb3VyY2UuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gVXNlIG5vdGVPbigpIGluc3RlYWQgb2Ygc3RhcnQoKSBpZiBuZWNlc3NhcnlcclxuICAgICAgICBpZiAoIXNvdXJjZS5zdGFydClcclxuICAgICAgICAgICAgc291cmNlLnN0YXJ0ID0gc291cmNlLm5vdGVPbjtcclxuXHJcbiAgICAgICAgLy8gU2NoZWR1bGUgcGFja2V0XHJcbiAgICAgICAgc291cmNlLmJ1ZmZlciA9IHRvQXVkaW9CdWZmZXIocGFja2V0KTtcclxuICAgICAgICBzb3VyY2Uuc3RhcnQobmV4dFBhY2tldFRpbWUpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGltZWxpbmUgYnkgZHVyYXRpb24gb2Ygc2NoZWR1bGVkIHBhY2tldFxyXG4gICAgICAgIG5leHRQYWNrZXRUaW1lICs9IHBhY2tldC5sZW5ndGggLyBmb3JtYXQuY2hhbm5lbHMgLyBmb3JtYXQucmF0ZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cclxuICAgIHRoaXMuc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBlbGFwc2VkIHRpbWUgc2luY2UgbGFzdCBzeW5jXHJcbiAgICAgICAgdmFyIG5vdyA9IGNvbnRleHQuY3VycmVudFRpbWU7XHJcblxyXG4gICAgICAgIC8vIFJlc2NoZWR1bGUgZnV0dXJlIHBsYXliYWNrIHRpbWUgc3VjaCB0aGF0IHBsYXliYWNrIGxhdGVuY3kgaXNcclxuICAgICAgICAvLyBib3VuZGVkIHdpdGhpbiBhIHJlYXNvbmFibGUgbGF0ZW5jeSB0aHJlc2hvbGRcclxuICAgICAgICBuZXh0UGFja2V0VGltZSA9IE1hdGgubWluKG5leHRQYWNrZXRUaW1lLCBub3cgKyBtYXhMYXRlbmN5KTtcclxuXHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcbkd1YWNhbW9sZS5SYXdBdWRpb1BsYXllci5wcm90b3R5cGUgPSBuZXcgR3VhY2Ftb2xlLkF1ZGlvUGxheWVyKCk7XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBtaW1ldHlwZSBpcyBzdXBwb3J0ZWQgYnlcclxuICogR3VhY2Ftb2xlLlJhd0F1ZGlvUGxheWVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICogICAgIFRoZSBtaW1ldHlwZSB0byBjaGVjay5cclxuICpcclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqICAgICB0cnVlIGlmIHRoZSBnaXZlbiBtaW1ldHlwZSBpcyBzdXBwb3J0ZWQgYnkgR3VhY2Ftb2xlLlJhd0F1ZGlvUGxheWVyLFxyXG4gKiAgICAgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlJhd0F1ZGlvUGxheWVyLmlzU3VwcG9ydGVkVHlwZSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkVHlwZShtaW1ldHlwZSkge1xyXG5cclxuICAgIC8vIE5vIHN1cHBvcnRlZCB0eXBlcyBpZiBubyBXZWIgQXVkaW8gQVBJXHJcbiAgICBpZiAoIUd1YWNhbW9sZS5BdWRpb0NvbnRleHRGYWN0b3J5LmdldEF1ZGlvQ29udGV4dCgpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICByZXR1cm4gR3VhY2Ftb2xlLlJhd0F1ZGlvRm9ybWF0LnBhcnNlKG1pbWV0eXBlKSAhPT0gbnVsbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIG1pbWV0eXBlcyBzdXBwb3J0ZWQgYnkgR3VhY2Ftb2xlLlJhd0F1ZGlvUGxheWVyLiBPbmx5XHJcbiAqIHRoZSBjb3JlIG1pbWV0eXBlcyB0aGVtc2VsdmVzIHdpbGwgYmUgbGlzdGVkLiBBbnkgbWltZXR5cGUgcGFyYW1ldGVycywgZXZlblxyXG4gKiByZXF1aXJlZCBvbmVzLCB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgbGlzdC4gRm9yIGV4YW1wbGUsIFwiYXVkaW8vTDhcIiBpc1xyXG4gKiBhIHJhdyBhdWRpbyBtaW1ldHlwZSB0aGF0IG1heSBiZSBzdXBwb3J0ZWQsIGJ1dCBpdCBpcyBpbnZhbGlkIHdpdGhvdXRcclxuICogYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBTb21ldGhpbmcgbGlrZSBcImF1ZGlvL0w4O3JhdGU9NDQxMDBcIiB3b3VsZCBiZSB2YWxpZCxcclxuICogaG93ZXZlciAoc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0ODU2KS5cclxuICpcclxuICogQHJldHVybnMge1N0cmluZ1tdfVxyXG4gKiAgICAgQSBsaXN0IG9mIGFsbCBtaW1ldHlwZXMgc3VwcG9ydGVkIGJ5IEd1YWNhbW9sZS5SYXdBdWRpb1BsYXllciwgZXhjbHVkaW5nXHJcbiAqICAgICBhbnkgcGFyYW1ldGVycy4gSWYgdGhlIG5lY2Vzc2FyeSBKYXZhU2NyaXB0IEFQSXMgZm9yIHBsYXlpbmcgcmF3IGF1ZGlvXHJcbiAqICAgICBhcmUgYWJzZW50LCB0aGlzIGxpc3Qgd2lsbCBiZSBlbXB0eS5cclxuICovXHJcbkd1YWNhbW9sZS5SYXdBdWRpb1BsYXllci5nZXRTdXBwb3J0ZWRUeXBlcyA9IGZ1bmN0aW9uIGdldFN1cHBvcnRlZFR5cGVzKCkge1xyXG5cclxuICAgIC8vIE5vIHN1cHBvcnRlZCB0eXBlcyBpZiBubyBXZWIgQXVkaW8gQVBJXHJcbiAgICBpZiAoIUd1YWNhbW9sZS5BdWRpb0NvbnRleHRGYWN0b3J5LmdldEF1ZGlvQ29udGV4dCgpKVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuXHJcbiAgICAvLyBXZSBzdXBwb3J0IDgtYml0IGFuZCAxNi1iaXQgcmF3IFBDTVxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICAnYXVkaW8vTDgnLFxyXG4gICAgICAgICdhdWRpby9MMTYnXHJcbiAgICBdO1xyXG5cclxufTtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEFic3RyYWN0IGF1ZGlvIHJlY29yZGVyIHdoaWNoIHN0cmVhbXMgYXJiaXRyYXJ5IGF1ZGlvIGRhdGEgdG8gYW4gdW5kZXJseWluZ1xyXG4gKiBHdWFjYW1vbGUuT3V0cHV0U3RyZWFtLiBJdCBpcyB1cCB0byBpbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBjbGFzcyB0byBwcm92aWRlXHJcbiAqIHNvbWUgbWVhbnMgb2YgaGFuZGxpbmcgdGhpcyBHdWFjYW1vbGUuT3V0cHV0U3RyZWFtLiBEYXRhIHByb2R1Y2VkIGJ5IHRoZVxyXG4gKiByZWNvcmRlciBpcyB0byBiZSBzZW50IGFsb25nIHRoZSBwcm92aWRlZCBzdHJlYW0gaW1tZWRpYXRlbHkuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXIgPSBmdW5jdGlvbiBBdWRpb1JlY29yZGVyKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgd2hpY2ggaXMgaW52b2tlZCB3aGVuIHRoZSBhdWRpbyByZWNvcmRpbmcgcHJvY2VzcyBoYXMgc3RvcHBlZFxyXG4gICAgICogYW5kIHRoZSB1bmRlcmx5aW5nIEd1YWNhbW9sZSBzdHJlYW0gaGFzIGJlZW4gY2xvc2VkIG5vcm1hbGx5LiBBdWRpbyB3aWxsXHJcbiAgICAgKiBvbmx5IHJlc3VtZSByZWNvcmRpbmcgaWYgYSBuZXcgR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXIgaXMgc3RhcnRlZC4gVGhpc1xyXG4gICAgICogR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXIgaW5zdGFuY2UgTUFZIE5PVCBiZSByZXVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHRoaXMub25jbG9zZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayB3aGljaCBpcyBpbnZva2VkIHdoZW4gdGhlIGF1ZGlvIHJlY29yZGluZyBwcm9jZXNzIGNhbm5vdFxyXG4gICAgICogY29udGludWUgZHVlIHRvIGFuIGVycm9yLCBpZiBpdCBoYXMgc3RhcnRlZCBhdCBhbGwuIFRoZSB1bmRlcmx5aW5nXHJcbiAgICAgKiBHdWFjYW1vbGUgc3RyZWFtIGlzIGF1dG9tYXRpY2FsbHkgY2xvc2VkLiBGdXR1cmUgYXR0ZW1wdHMgdG8gcmVjb3JkXHJcbiAgICAgKiBhdWRpbyBzaG91bGQgbm90IGJlIG1hZGUsIGFuZCB0aGlzIEd1YWNhbW9sZS5BdWRpb1JlY29yZGVyIGluc3RhbmNlXHJcbiAgICAgKiBNQVkgTk9UIGJlIHJldXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmVycm9yID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBtaW1ldHlwZSBpcyBzdXBwb3J0ZWQgYnkgYW55IGJ1aWx0LWluXHJcbiAqIGltcGxlbWVudGF0aW9uIG9mIEd1YWNhbW9sZS5BdWRpb1JlY29yZGVyLCBhbmQgdGh1cyB3aWxsIGJlIHByb3Blcmx5IGhhbmRsZWRcclxuICogYnkgR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXIuZ2V0SW5zdGFuY2UoKS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAqICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2suXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKiAgICAgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbWltZXR5cGUgaXMgc3VwcG9ydGVkIGJ5IGFueSBidWlsdC1pblxyXG4gKiAgICAgR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXIsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbkd1YWNhbW9sZS5BdWRpb1JlY29yZGVyLmlzU3VwcG9ydGVkVHlwZSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkVHlwZShtaW1ldHlwZSkge1xyXG5cclxuICAgIHJldHVybiBHdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlci5pc1N1cHBvcnRlZFR5cGUobWltZXR5cGUpO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgbWltZXR5cGVzIHN1cHBvcnRlZCBieSBhbnkgYnVpbHQtaW5cclxuICogR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXIsIGluIHJvdWdoIG9yZGVyIG9mIHByaW9yaXR5LiBCZXdhcmUgdGhhdCBvbmx5IHRoZVxyXG4gKiBjb3JlIG1pbWV0eXBlcyB0aGVtc2VsdmVzIHdpbGwgYmUgbGlzdGVkLiBBbnkgbWltZXR5cGUgcGFyYW1ldGVycywgZXZlblxyXG4gKiByZXF1aXJlZCBvbmVzLCB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgbGlzdC4gRm9yIGV4YW1wbGUsIFwiYXVkaW8vTDhcIiBpc1xyXG4gKiBhIHN1cHBvcnRlZCByYXcgYXVkaW8gbWltZXR5cGUgdGhhdCBpcyBzdXBwb3J0ZWQsIGJ1dCBpdCBpcyBpbnZhbGlkIHdpdGhvdXRcclxuICogYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBTb21ldGhpbmcgbGlrZSBcImF1ZGlvL0w4O3JhdGU9NDQxMDBcIiB3b3VsZCBiZSB2YWxpZCxcclxuICogaG93ZXZlciAoc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0ODU2KS5cclxuICpcclxuICogQHJldHVybnMge1N0cmluZ1tdfVxyXG4gKiAgICAgQSBsaXN0IG9mIGFsbCBtaW1ldHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBidWlsdC1pblxyXG4gKiAgICAgR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXIsIGV4Y2x1ZGluZyBhbnkgcGFyYW1ldGVycy5cclxuICovXHJcbkd1YWNhbW9sZS5BdWRpb1JlY29yZGVyLmdldFN1cHBvcnRlZFR5cGVzID0gZnVuY3Rpb24gZ2V0U3VwcG9ydGVkVHlwZXMoKSB7XHJcblxyXG4gICAgcmV0dXJuIEd1YWNhbW9sZS5SYXdBdWRpb1JlY29yZGVyLmdldFN1cHBvcnRlZFR5cGVzKCk7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXIgcHJvdmlkaW5nIHN1cHBvcnQgZm9yIHRoZVxyXG4gKiBnaXZlbiBhdWRpbyBmb3JtYXQuIElmIHN1cHBvcnQgZm9yIHRoZSBnaXZlbiBhdWRpbyBmb3JtYXQgaXMgbm90IGF2YWlsYWJsZSxcclxuICogbnVsbCBpcyByZXR1cm5lZC5cclxuICpcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuT3V0cHV0U3RyZWFtfSBzdHJlYW1cclxuICogICAgIFRoZSBHdWFjYW1vbGUuT3V0cHV0U3RyZWFtIHRvIHNlbmQgYXVkaW8gZGF0YSB0aHJvdWdoLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgYXVkaW8gZGF0YSB0byBiZSBzZW50IGFsb25nIHRoZSBwcm92aWRlZCBzdHJlYW0uXHJcbiAqXHJcbiAqIEByZXR1cm4ge0d1YWNhbW9sZS5BdWRpb1JlY29yZGVyfVxyXG4gKiAgICAgQSBHdWFjYW1vbGUuQXVkaW9SZWNvcmRlciBpbnN0YW5jZSBzdXBwb3J0aW5nIHRoZSBnaXZlbiBtaW1ldHlwZSBhbmRcclxuICogICAgIHdyaXRpbmcgdG8gdGhlIGdpdmVuIHN0cmVhbSwgb3IgbnVsbCBpZiBzdXBwb3J0IGZvciB0aGUgZ2l2ZW4gbWltZXR5cGVcclxuICogICAgIGlzIGFic2VudC5cclxuICovXHJcbkd1YWNhbW9sZS5BdWRpb1JlY29yZGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0SW5zdGFuY2Uoc3RyZWFtLCBtaW1ldHlwZSkge1xyXG5cclxuICAgIC8vIFVzZSByYXcgYXVkaW8gcmVjb3JkZXIgaWYgcG9zc2libGVcclxuICAgIGlmIChHdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlci5pc1N1cHBvcnRlZFR5cGUobWltZXR5cGUpKVxyXG4gICAgICAgIHJldHVybiBuZXcgR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIoc3RyZWFtLCBtaW1ldHlwZSk7XHJcblxyXG4gICAgLy8gTm8gc3VwcG9ydCBmb3IgZ2l2ZW4gbWltZXR5cGVcclxuICAgIHJldHVybiBudWxsO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBHdWFjYW1vbGUuQXVkaW9SZWNvcmRlciBwcm92aWRpbmcgc3VwcG9ydCBmb3IgcmF3IFBDTVxyXG4gKiBmb3JtYXQgYXVkaW8uIFRoaXMgcmVjb3JkZXIgcmVsaWVzIG9ubHkgb24gdGhlIFdlYiBBdWRpbyBBUEkgYW5kIGRvZXMgbm90XHJcbiAqIHJlcXVpcmUgYW55IGJyb3dzZXItbGV2ZWwgc3VwcG9ydCBmb3IgaXRzIGF1ZGlvIGZvcm1hdHMuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXVnbWVudHMgR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXJcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuT3V0cHV0U3RyZWFtfSBzdHJlYW1cclxuICogICAgIFRoZSBHdWFjYW1vbGUuT3V0cHV0U3RyZWFtIHRvIHdyaXRlIGF1ZGlvIGRhdGEgdG8uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gKiAgICAgVGhlIG1pbWV0eXBlIG9mIHRoZSBhdWRpbyBkYXRhIHRvIHNlbmQgYWxvbmcgdGhlIHByb3ZpZGVkIHN0cmVhbSwgd2hpY2hcclxuICogICAgIG11c3QgYmUgYSBcImF1ZGlvL0w4XCIgb3IgXCJhdWRpby9MMTZcIiBtaW1ldHlwZSB3aXRoIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzLFxyXG4gKiAgICAgc3VjaCBhczogXCJhdWRpby9MMTY7cmF0ZT00NDEwMCxjaGFubmVscz0yXCIuXHJcbiAqL1xyXG5HdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlciA9IGZ1bmN0aW9uIFJhd0F1ZGlvUmVjb3JkZXIoc3RyZWFtLCBtaW1ldHlwZSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgUmF3QXVkaW9SZWNvcmRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5SYXdBdWRpb1JlY29yZGVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgcmVjb3JkZXIgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNpemUgb2YgYXVkaW8gYnVmZmVyIHRvIHJlcXVlc3QgZnJvbSB0aGUgV2ViIEF1ZGlvIEFQSSB3aGVuXHJcbiAgICAgKiByZWNvcmRpbmcgb3IgcHJvY2Vzc2luZyBhdWRpbywgaW4gc2FtcGxlLWZyYW1lcy4gVGhpcyBtdXN0IGJlIGEgcG93ZXIgb2ZcclxuICAgICAqIHR3byBiZXR3ZWVuIDI1NiBhbmQgMTYzODQgaW5jbHVzaXZlLCBhcyByZXF1aXJlZCBieVxyXG4gICAgICogQXVkaW9Db250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcigpLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBCVUZGRVJfU0laRSA9IDIwNDg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2luZG93IHNpemUgdG8gdXNlIHdoZW4gYXBwbHlpbmcgTGFuY3pvcyBpbnRlcnBvbGF0aW9uLCBjb21tb25seVxyXG4gICAgICogZGVub3RlZCBieSB0aGUgdmFyaWFibGUgXCJhXCIuXHJcbiAgICAgKiBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhbmN6b3NfcmVzYW1wbGluZ1xyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29udGFudFxyXG4gICAgICogQHR5cGUgTnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBMQU5DWk9TX1dJTkRPV19TSVpFID0gMztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmb3JtYXQgb2YgYXVkaW8gdGhpcyByZWNvcmRlciB3aWxsIGVuY29kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5SYXdBdWRpb0Zvcm1hdH1cclxuICAgICAqL1xyXG4gICAgdmFyIGZvcm1hdCA9IEd1YWNhbW9sZS5SYXdBdWRpb0Zvcm1hdC5wYXJzZShtaW1ldHlwZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiBhIFdlYiBBdWRpbyBBUEkgQXVkaW9Db250ZXh0IG9iamVjdCwgb3IgbnVsbCBpZiB0aGVcclxuICAgICAqIFdlYiBBdWRpbyBBUEkgaXMgbm90IHN1cHBvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0F1ZGlvQ29udGV4dH1cclxuICAgICAqL1xyXG4gICAgdmFyIGNvbnRleHQgPSBHdWFjYW1vbGUuQXVkaW9Db250ZXh0RmFjdG9yeS5nZXRBdWRpb0NvbnRleHQoKTtcclxuXHJcbiAgICAvLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBpbXBsZW1lbnQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAtIHRoaXNcclxuICAgIC8vIHNoaW1zIGluIHRoaXMgZnVuY3Rpb25hbGl0eSB0byBlbnN1cmUgY29kZSBjb21wYXRpYmlsaXR5LlxyXG4gICAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKVxyXG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMgPSB7fTtcclxuXHJcbiAgICAvLyBCcm93c2VycyB0aGF0IGVpdGhlciBkbyBub3QgaW1wbGVtZW50IG5hdmlnYXRvci5tZWRpYURldmljZXNcclxuICAgIC8vIGF0IGFsbCBvciBkbyBub3QgaW1wbGVtZW50IGl0IGNvbXBsZXRlbHkgbmVlZCB0aGUgZ2V0VXNlck1lZGlhXHJcbiAgICAvLyBtZXRob2QgZGVmaW5lZC4gIFRoaXMgc2hpbXMgaW4gdGhpcyBmdW5jdGlvbiBieSBkZXRlY3RpbmdcclxuICAgIC8vIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGxlZ2FjeSBtZXRob2RzLlxyXG4gICAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSlcclxuICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IChuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhXHJcbiAgICAgICAgICAgICAgICB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhXHJcbiAgICAgICAgICAgICAgICB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhXHJcbiAgICAgICAgICAgICAgICB8fCBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWEpLmJpbmQobmF2aWdhdG9yKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEd1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlciB3cmFwcGVkIGFyb3VuZCB0aGUgYXVkaW8gb3V0cHV0IHN0cmVhbVxyXG4gICAgICogcHJvdmlkZWQgd2hlbiB0aGlzIEd1YWNhbW9sZS5SYXdBdWRpb1JlY29yZGVyIHdhcyBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLkFycmF5QnVmZmVyV3JpdGVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgd3JpdGVyID0gbmV3IEd1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlcihzdHJlYW0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR5cGUgb2YgdHlwZWQgYXJyYXkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVwcmVzZW50IGVhY2ggYXVkaW8gcGFja2V0XHJcbiAgICAgKiBpbnRlcm5hbGx5LiBUaGlzIHdpbGwgYmUgZWl0aGVyIEludDhBcnJheSBvciBJbnQxNkFycmF5LCBkZXBlbmRpbmcgb25cclxuICAgICAqIHdoZXRoZXIgdGhlIHJhdyBhdWRpbyBmb3JtYXQgaXMgOC1iaXQgb3IgMTYtYml0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIFNhbXBsZUFycmF5ID0gKGZvcm1hdC5ieXRlc1BlclNhbXBsZSA9PT0gMSkgPyB3aW5kb3cuSW50OEFycmF5IDogd2luZG93LkludDE2QXJyYXk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBhYnNvbHV0ZSB2YWx1ZSBvZiBhbnkgc2FtcGxlIHdpdGhpbiBhIHJhdyBhdWRpbyBwYWNrZXQgc2VudFxyXG4gICAgICogYnkgdGhpcyBhdWRpbyByZWNvcmRlci4gVGhpcyBkZXBlbmRzIG9ubHkgb24gdGhlIHNpemUgb2YgZWFjaCBzYW1wbGUsXHJcbiAgICAgKiBhbmQgd2lsbCBiZSAxMjggZm9yIDgtYml0IGF1ZGlvIGFuZCAzMjc2OCBmb3IgMTYtYml0IGF1ZGlvLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgbWF4U2FtcGxlVmFsdWUgPSAoZm9ybWF0LmJ5dGVzUGVyU2FtcGxlID09PSAxKSA/IDEyOCA6IDMyNzY4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRvdGFsIG51bWJlciBvZiBhdWRpbyBzYW1wbGVzIHJlYWQgZnJvbSB0aGUgbG9jYWwgYXVkaW8gaW5wdXQgZGV2aWNlXHJcbiAgICAgKiBvdmVyIHRoZSBsaWZlIG9mIHRoaXMgYXVkaW8gcmVjb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciByZWFkU2FtcGxlcyA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGF1ZGlvIHNhbXBsZXMgd3JpdHRlbiB0byB0aGUgdW5kZXJseWluZyBHdWFjYW1vbGVcclxuICAgICAqIGNvbm5lY3Rpb24gb3ZlciB0aGUgbGlmZSBvZiB0aGlzIGF1ZGlvIHJlY29yZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgd3JpdHRlblNhbXBsZXMgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGF1ZGlvIHN0cmVhbSBwcm92aWRlZCBieSB0aGUgYnJvd3NlciwgaWYgYWxsb3dlZC4gSWYgbm8gc3RyZWFtIGhhc1xyXG4gICAgICogeWV0IGJlZW4gcmVjZWl2ZWQsIHRoaXMgd2lsbCBiZSBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIE1lZGlhU3RyZWFtXHJcbiAgICAgKi9cclxuICAgIHZhciBtZWRpYVN0cmVhbSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc291cmNlIG5vZGUgcHJvdmlkaW5nIGFjY2VzcyB0byB0aGUgbG9jYWwgYXVkaW8gaW5wdXQgZGV2aWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGV9XHJcbiAgICAgKi9cclxuICAgIHZhciBzb3VyY2UgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNjcmlwdCBwcm9jZXNzaW5nIG5vZGUgd2hpY2ggcmVjZWl2ZXMgYXVkaW8gaW5wdXQgZnJvbSB0aGUgbWVkaWFcclxuICAgICAqIHN0cmVhbSBzb3VyY2Ugbm9kZSBhcyBpbmRpdmlkdWFsIGF1ZGlvIGJ1ZmZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtTY3JpcHRQcm9jZXNzb3JOb2RlfVxyXG4gICAgICovXHJcbiAgICB2YXIgcHJvY2Vzc29yID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBub3JtYWxpemVkIHNpbmMgZnVuY3Rpb24uIFRoZSBub3JtYWxpemVkIHNpbmMgZnVuY3Rpb24gaXMgZGVmaW5lZCBhc1xyXG4gICAgICogMSBmb3IgeD0wIGFuZCBzaW4oUEkgKiB4KSAvIChQSSAqIHgpIGZvciBhbGwgb3RoZXIgdmFsdWVzIG9mIHguXHJcbiAgICAgKlxyXG4gICAgICogU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW5jX2Z1bmN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiAgICAgVGhlIHBvaW50IGF0IHdoaWNoIHRoZSBub3JtYWxpemVkIHNpbmMgZnVuY3Rpb24gc2hvdWxkIGJlIGNvbXB1dGVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiAgICAgVGhlIHZhbHVlIG9mIHRoZSBub3JtYWxpemVkIHNpbmMgZnVuY3Rpb24gYXQgeC5cclxuICAgICAqL1xyXG4gICAgdmFyIHNpbmMgPSBmdW5jdGlvbiBzaW5jKHgpIHtcclxuXHJcbiAgICAgICAgLy8gVGhlIHZhbHVlIG9mIHNpbmMoMCkgaXMgZGVmaW5lZCBhcyAxXHJcbiAgICAgICAgaWYgKHggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIG5vcm1saXplZCBzaW5jKHgpIGlzIHNpbihQSSAqIHgpIC8gKFBJICogeClcclxuICAgICAgICB2YXIgcGlYID0gTWF0aC5QSSAqIHg7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKHBpWCkgLyBwaVg7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBMYW5jem9zIGtlcm5hbCBhdCBwb2ludCB4IGZvciBhIGdpdmVuIHdpbmRvd1xyXG4gICAgICogc2l6ZS4gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYW5jem9zX3Jlc2FtcGxpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqICAgICBUaGUgcG9pbnQgYXQgd2hpY2ggdGhlIHZhbHVlIG9mIHRoZSBMYW5jem9zIGtlcm5lbCBzaG91bGQgYmVcclxuICAgICAqICAgICBjb21wdXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVxyXG4gICAgICogICAgIFRoZSB3aW5kb3cgc2l6ZSB0byB1c2UgZm9yIHRoZSBMYW5jem9zIGtlcm5lbC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogICAgIFRoZSB2YWx1ZSBvZiB0aGUgTGFuY3pvcyBrZXJuZWwgYXQgdGhlIGdpdmVuIHBvaW50IGZvciB0aGUgZ2l2ZW5cclxuICAgICAqICAgICB3aW5kb3cgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgdmFyIGxhbmN6b3MgPSBmdW5jdGlvbiBsYW5jem9zKHgsIGEpIHtcclxuXHJcbiAgICAgICAgLy8gTGFuY3pvcyBpcyBzaW5jKHgpICogc2luYyh4IC8gYSkgZm9yIC1hIDwgeCA8IGEgLi4uXHJcbiAgICAgICAgaWYgKC1hIDwgeCAmJiB4IDwgYSlcclxuICAgICAgICAgICAgcmV0dXJuIHNpbmMoeCkgKiBzaW5jKHggLyBhKTtcclxuXHJcbiAgICAgICAgLy8gLi4uIGFuZCAwIG90aGVyd2lzZVxyXG4gICAgICAgIHJldHVybiAwO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSB2YWx1ZSBvZiB0aGUgd2F2ZWZvcm0gcmVwcmVzZW50ZWQgYnkgdGhlIGF1ZGlvIGRhdGEgYXRcclxuICAgICAqIHRoZSBnaXZlbiBsb2NhdGlvbi4gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBkZXRlcm1pbmVkIGV4YWN0bHkgYXMgaXQgZG9lc1xyXG4gICAgICogbm90IGNvcnJlc3BvbmQgdG8gYW4gZXhhY3Qgc2FtcGxlIHdpdGhpbiB0aGUgYXVkaW8gZGF0YSwgdGhlIHZhbHVlIHdpbGxcclxuICAgICAqIGJlIGRlcml2ZWQgdGhyb3VnaCBpbnRlcnBvbGF0aW5nIG5lYXJieSBzYW1wbGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYXVkaW9EYXRhXHJcbiAgICAgKiAgICAgQW4gYXJyYXkgb2YgYXVkaW8gZGF0YSwgYXMgcmV0dXJuZWQgYnkgQXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdFxyXG4gICAgICogICAgIFRoZSByZWxhdGl2ZSBsb2NhdGlvbiB3aXRoaW4gdGhlIHdhdmVmb3JtIGZyb20gd2hpY2ggdGhlIHZhbHVlXHJcbiAgICAgKiAgICAgc2hvdWxkIGJlIHJldHJpZXZlZCwgcmVwcmVzZW50ZWQgYXMgYSBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlblxyXG4gICAgICogICAgIDAgYW5kIDEgaW5jbHVzaXZlLCB3aGVyZSAwIHJlcHJlc2VudHMgdGhlIGVhcmxpZXN0IHBvaW50IGluIHRpbWUgYW5kXHJcbiAgICAgKiAgICAgMSByZXByZXNlbnRzIHRoZSBsYXRlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqICAgICBUaGUgdmFsdWUgb2YgdGhlIHdhdmVmb3JtIGF0IHRoZSBnaXZlbiBsb2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgdmFyIGludGVycG9sYXRlU2FtcGxlID0gZnVuY3Rpb24gZ2V0VmFsdWVBdChhdWRpb0RhdGEsIHQpIHtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBbMCwgMV0gcmFuZ2UgdG8gWzAsIGF1ZGlvRGF0YS5sZW5ndGggLSAxXVxyXG4gICAgICAgIHZhciBpbmRleCA9IChhdWRpb0RhdGEubGVuZ3RoIC0gMSkgKiB0O1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGZvciB0aGUgc3VtbWF0aW9uIHVzZWQgYnkgdGhlXHJcbiAgICAgICAgLy8gTGFuY3pvcyBpbnRlcnBvbGF0aW9uIGFsZ29yaXRobSAoc2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYW5jem9zX3Jlc2FtcGxpbmcpXHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5mbG9vcihpbmRleCkgLSBMQU5DWk9TX1dJTkRPV19TSVpFICsgMTtcclxuICAgICAgICB2YXIgZW5kID0gTWF0aC5mbG9vcihpbmRleCkgKyBMQU5DWk9TX1dJTkRPV19TSVpFO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHZhbHVlIG9mIHRoZSBMYW5jem9zIGludGVycG9sYXRpb24gZnVuY3Rpb24gZm9yIHRoZVxyXG4gICAgICAgIC8vIHJlcXVpcmVkIHJhbmdlXHJcbiAgICAgICAgdmFyIHN1bSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSAoYXVkaW9EYXRhW2ldIHx8IDApICogbGFuY3pvcyhpbmRleCAtIGksIExBTkNaT1NfV0lORE9XX1NJWkUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGdpdmVuIEF1ZGlvQnVmZmVyIGludG8gYW4gYXVkaW8gcGFja2V0LCByZWFkeSBmb3Igc3RyZWFtaW5nXHJcbiAgICAgKiBhbG9uZyB0aGUgdW5kZXJseWluZyBvdXRwdXQgc3RyZWFtLiBVbmxpa2UgdGhlIHJhdyBhdWRpbyBwYWNrZXRzIHVzZWQgYnlcclxuICAgICAqIHRoaXMgYXVkaW8gcmVjb3JkZXIsIEF1ZGlvQnVmZmVycyByZXF1aXJlIGZsb2F0aW5nIHBvaW50IHNhbXBsZXMgYW5kIGFyZVxyXG4gICAgICogc3BsaXQgaW50byBpc29sYXRlZCBwbGFuZXMgb2YgY2hhbm5lbC1zcGVjaWZpYyBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBhdWRpb0J1ZmZlclxyXG4gICAgICogICAgIFRoZSBXZWIgQXVkaW8gQVBJIEF1ZGlvQnVmZmVyIHRoYXQgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIHJhd1xyXG4gICAgICogICAgIGF1ZGlvIHBhY2tldC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7U2FtcGxlQXJyYXl9XHJcbiAgICAgKiAgICAgQSBuZXcgcmF3IGF1ZGlvIHBhY2tldCBjb250YWluaW5nIHRoZSBhdWRpbyBkYXRhIGZyb20gdGhlIHByb3ZpZGVkXHJcbiAgICAgKiAgICAgQXVkaW9CdWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHZhciB0b1NhbXBsZUFycmF5ID0gZnVuY3Rpb24gdG9TYW1wbGVBcnJheShhdWRpb0J1ZmZlcikge1xyXG5cclxuICAgICAgICAvLyBUcmFjayBvdmVyYWxsIGFtb3VudCBvZiBkYXRhIHJlYWRcclxuICAgICAgICB2YXIgaW5TYW1wbGVzID0gYXVkaW9CdWZmZXIubGVuZ3RoO1xyXG4gICAgICAgIHJlYWRTYW1wbGVzICs9IGluU2FtcGxlcztcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2FtcGxlcyB0aGF0IHNob3VsZCBiZSB3cml0dGVuIGFzIG9mXHJcbiAgICAgICAgLy8gdGhlIGF1ZGlvIGRhdGEganVzdCByZWNlaXZlZCBhbmQgYWRqdXN0IHRoZSBzaXplIG9mIHRoZSBvdXRwdXRcclxuICAgICAgICAvLyBwYWNrZXQgYWNjb3JkaW5nbHlcclxuICAgICAgICB2YXIgZXhwZWN0ZWRXcml0dGVuU2FtcGxlcyA9IE1hdGgucm91bmQocmVhZFNhbXBsZXMgKiBmb3JtYXQucmF0ZSAvIGF1ZGlvQnVmZmVyLnNhbXBsZVJhdGUpO1xyXG4gICAgICAgIHZhciBvdXRTYW1wbGVzID0gZXhwZWN0ZWRXcml0dGVuU2FtcGxlcyAtIHdyaXR0ZW5TYW1wbGVzO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgbnVtYmVyIG9mIHNhbXBsZXMgd3JpdHRlblxyXG4gICAgICAgIHdyaXR0ZW5TYW1wbGVzICs9IG91dFNhbXBsZXM7XHJcblxyXG4gICAgICAgIC8vIEdldCBhcnJheSBmb3IgcmF3IFBDTSBzdG9yYWdlXHJcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgU2FtcGxlQXJyYXkob3V0U2FtcGxlcyAqIGZvcm1hdC5jaGFubmVscyk7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgZWFjaCBjaGFubmVsXHJcbiAgICAgICAgZm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBmb3JtYXQuY2hhbm5lbHM7IGNoYW5uZWwrKykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGF1ZGlvRGF0YSA9IGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWwpO1xyXG5cclxuICAgICAgICAgICAgLy8gRmlsbCBhcnJheSB3aXRoIGRhdGEgZnJvbSBhdWRpbyBidWZmZXIgY2hhbm5lbFxyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gY2hhbm5lbDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRTYW1wbGVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IGludGVycG9sYXRlU2FtcGxlKGF1ZGlvRGF0YSwgaSAvIChvdXRTYW1wbGVzIC0gMSkpICogbWF4U2FtcGxlVmFsdWU7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZm9ybWF0LmNoYW5uZWxzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldFVzZXJNZWRpYSgpIGNhbGxiYWNrIHdoaWNoIGhhbmRsZXMgc3VjY2Vzc2Z1bCByZXRyaWV2YWwgb2YgYW5cclxuICAgICAqIGF1ZGlvIHN0cmVhbSAoc3VjY2Vzc2Z1bCBzdGFydCBvZiByZWNvcmRpbmcpLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cclxuICAgICAqICAgICBBIE1lZGlhU3RyZWFtIHdoaWNoIHByb3ZpZGVzIGFjY2VzcyB0byBhdWRpbyBkYXRhIHJlYWQgZnJvbSB0aGVcclxuICAgICAqICAgICB1c2VyJ3MgbG9jYWwgYXVkaW8gaW5wdXQgZGV2aWNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgc3RyZWFtUmVjZWl2ZWQgPSBmdW5jdGlvbiBzdHJlYW1SZWNlaXZlZChzdHJlYW0pIHtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHByb2Nlc3Npbmcgbm9kZSB3aGljaCByZWNlaXZlcyBhcHByb3ByaWF0ZWx5LXNpemVkIGF1ZGlvIGJ1ZmZlcnNcclxuICAgICAgICBwcm9jZXNzb3IgPSBjb250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcihCVUZGRVJfU0laRSwgZm9ybWF0LmNoYW5uZWxzLCBmb3JtYXQuY2hhbm5lbHMpO1xyXG4gICAgICAgIHByb2Nlc3Nvci5jb25uZWN0KGNvbnRleHQuZGVzdGluYXRpb24pO1xyXG5cclxuICAgICAgICAvLyBTZW5kIGJsb2JzIHdoZW4gYXVkaW8gYnVmZmVycyBhcmUgcmVjZWl2ZWRcclxuICAgICAgICBwcm9jZXNzb3Iub25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzQXVkaW8oZSkge1xyXG4gICAgICAgICAgICB3cml0ZXIuc2VuZERhdGEodG9TYW1wbGVBcnJheShlLmlucHV0QnVmZmVyKS5idWZmZXIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIENvbm5lY3QgcHJvY2Vzc2luZyBub2RlIHRvIHVzZXIncyBhdWRpbyBpbnB1dCBzb3VyY2VcclxuICAgICAgICBzb3VyY2UgPSBjb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7XHJcbiAgICAgICAgc291cmNlLmNvbm5lY3QocHJvY2Vzc29yKTtcclxuXHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBleHBsaWNpdGx5IHJlc3VtZSBBdWRpb0NvbnRleHQsIGFzIGl0IG1heSBiZSBwYXVzZWRcclxuICAgICAgICAvLyBieSBkZWZhdWx0XHJcbiAgICAgICAgaWYgKGNvbnRleHQuc3RhdGUgPT09ICdzdXNwZW5kZWQnKVxyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3VtZSgpO1xyXG5cclxuICAgICAgICAvLyBTYXZlIHN0cmVhbSBmb3IgbGF0ZXIgY2xlYW51cFxyXG4gICAgICAgIG1lZGlhU3RyZWFtID0gc3RyZWFtO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXRVc2VyTWVkaWEoKSBjYWxsYmFjayB3aGljaCBoYW5kbGVzIGF1ZGlvIHJlY29yZGluZyBkZW5pYWwuIFRoZVxyXG4gICAgICogdW5kZXJseWluZyBHdWFjYW1vbGUgb3V0cHV0IHN0cmVhbSBpcyBjbG9zZWQsIGFuZCB0aGUgZmFpbHVyZSB0b1xyXG4gICAgICogcmVjb3JkIGlzIG5vdGVkIHVzaW5nIG9uZXJyb3IuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHN0cmVhbURlbmllZCA9IGZ1bmN0aW9uIHN0cmVhbURlbmllZCgpIHtcclxuXHJcbiAgICAgICAgLy8gU2ltcGx5IGVuZCBzdHJlYW0gaWYgYXVkaW8gYWNjZXNzIGlzIG5vdCBhbGxvd2VkXHJcbiAgICAgICAgd3JpdGVyLnNlbmRFbmQoKTtcclxuXHJcbiAgICAgICAgLy8gTm90aWZ5IG9mIGNsb3N1cmVcclxuICAgICAgICBpZiAocmVjb3JkZXIub25lcnJvcilcclxuICAgICAgICAgICAgcmVjb3JkZXIub25lcnJvcigpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0cyBhY2Nlc3MgdG8gdGhlIHVzZXIncyBtaWNyb3Bob25lIGFuZCBiZWdpbnMgY2FwdHVyaW5nIGF1ZGlvLiBBbGxcclxuICAgICAqIHJlY2VpdmVkIGF1ZGlvIGRhdGEgaXMgcmVzYW1wbGVkIGFzIG5lY2Vzc2FyeSBhbmQgZm9yd2FyZGVkIHRvIHRoZVxyXG4gICAgICogR3VhY2Ftb2xlIHN0cmVhbSB1bmRlcmx5aW5nIHRoaXMgR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIuIFRoaXNcclxuICAgICAqIGZ1bmN0aW9uIG11c3QgYmUgaW52b2tlZCBPTkxZIE9OQ0UgcGVyIGluc3RhbmNlIG9mXHJcbiAgICAgKiBHdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgYmVnaW5BdWRpb0NhcHR1cmUgPSBmdW5jdGlvbiBiZWdpbkF1ZGlvQ2FwdHVyZSgpIHtcclxuXHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byByZXRyaWV2ZSBhbiBhdWRpbyBpbnB1dCBzdHJlYW0gZnJvbSB0aGUgYnJvd3NlclxyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xyXG4gICAgICAgICAgICAnYXVkaW8nIDogdHJ1ZVxyXG4gICAgICAgIH0sIHN0cmVhbVJlY2VpdmVkLCBzdHJlYW1EZW5pZWQpO1xyXG5cclxuICAgICAgICAvLyBIYW5kbGUgc3RyZWFtIGNyZWF0aW9uL3JlamVjdGlvbiB2aWEgUHJvbWlzZSBmb3IgbmV3ZXIgdmVyc2lvbnMgb2ZcclxuICAgICAgICAvLyBnZXRVc2VyTWVkaWEoKVxyXG4gICAgICAgIGlmIChwcm9taXNlICYmIHByb21pc2UudGhlbilcclxuICAgICAgICAgICAgcHJvbWlzZS50aGVuKHN0cmVhbVJlY2VpdmVkLCBzdHJlYW1EZW5pZWQpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBjYXB0dXJpbmcgYXVkaW8sIGlmIHRoZSBjYXB0dXJlIGhhcyBzdGFydGVkLCBmcmVlaW5nIGFsbCBhc3NvY2lhdGVkXHJcbiAgICAgKiByZXNvdXJjZXMuIElmIHRoZSBjYXB0dXJlIGhhcyBub3Qgc3RhcnRlZCwgdGhpcyBmdW5jdGlvbiBzaW1wbHkgZW5kcyB0aGVcclxuICAgICAqIHVuZGVybHlpbmcgR3VhY2Ftb2xlIHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgc3RvcEF1ZGlvQ2FwdHVyZSA9IGZ1bmN0aW9uIHN0b3BBdWRpb0NhcHR1cmUoKSB7XHJcblxyXG4gICAgICAgIC8vIERpc2Nvbm5lY3QgbWVkaWEgc291cmNlIG5vZGUgZnJvbSBzY3JpcHQgcHJvY2Vzc29yXHJcbiAgICAgICAgaWYgKHNvdXJjZSlcclxuICAgICAgICAgICAgc291cmNlLmRpc2Nvbm5lY3QoKTtcclxuXHJcbiAgICAgICAgLy8gRGlzY29ubmVjdCBhc3NvY2lhdGVkIHNjcmlwdCBwcm9jZXNzb3Igbm9kZVxyXG4gICAgICAgIGlmIChwcm9jZXNzb3IpXHJcbiAgICAgICAgICAgIHByb2Nlc3Nvci5kaXNjb25uZWN0KCk7XHJcblxyXG4gICAgICAgIC8vIFN0b3AgY2FwdHVyZVxyXG4gICAgICAgIGlmIChtZWRpYVN0cmVhbSkge1xyXG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgdHJhY2tzW2ldLnN0b3AoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSByZWZlcmVuY2VzIHRvIG5vdy11bm5lZWRlZCBjb21wb25lbnRzXHJcbiAgICAgICAgcHJvY2Vzc29yID0gbnVsbDtcclxuICAgICAgICBzb3VyY2UgPSBudWxsO1xyXG4gICAgICAgIG1lZGlhU3RyZWFtID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gRW5kIHN0cmVhbVxyXG4gICAgICAgIHdyaXRlci5zZW5kRW5kKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPbmNlIGF1ZGlvIHN0cmVhbSBpcyBzdWNjZXNzZnVsbHkgb3BlbiwgcmVxdWVzdCBhbmQgYmVnaW4gcmVhZGluZyBhdWRpb1xyXG4gICAgd3JpdGVyLm9uYWNrID0gZnVuY3Rpb24gYXVkaW9TdHJlYW1BY2tub3dsZWRnZWQoc3RhdHVzKSB7XHJcblxyXG4gICAgICAgIC8vIEJlZ2luIGNhcHR1cmUgaWYgc3VjY2Vzc2Z1bCByZXNwb25zZSBhbmQgbm90IHlldCBzdGFydGVkXHJcbiAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBHdWFjYW1vbGUuU3RhdHVzLkNvZGUuU1VDQ0VTUyAmJiAhbWVkaWFTdHJlYW0pXHJcbiAgICAgICAgICAgIGJlZ2luQXVkaW9DYXB0dXJlKCk7XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSBzdG9wIGNhcHR1cmUgYW5kIGNlYXNlIGhhbmRsaW5nIGFueSBmdXJ0aGVyIGFja3NcclxuICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0b3AgY2FwdHVyaW5nIGF1ZGlvXHJcbiAgICAgICAgICAgIHN0b3BBdWRpb0NhcHR1cmUoKTtcclxuICAgICAgICAgICAgd3JpdGVyLm9uYWNrID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vdGlmeSBpZiBzdHJlYW0gaGFzIGNsb3NlZCBub3JtYWxseVxyXG4gICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5SRVNPVVJDRV9DTE9TRUQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmRlci5vbmNsb3NlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZGVyLm9uY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIG5vdGlmeSBvZiBjbG9zdXJlIGR1ZSB0byBlcnJvclxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmRlci5vbmVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZGVyLm9uZXJyb3IoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5HdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlci5wcm90b3R5cGUgPSBuZXcgR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXIoKTtcclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIG1pbWV0eXBlIGlzIHN1cHBvcnRlZCBieVxyXG4gKiBHdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlci5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAqICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2suXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKiAgICAgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbWltZXR5cGUgaXMgc3VwcG9ydGVkIGJ5IEd1YWNhbW9sZS5SYXdBdWRpb1JlY29yZGVyLFxyXG4gKiAgICAgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIuaXNTdXBwb3J0ZWRUeXBlID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRUeXBlKG1pbWV0eXBlKSB7XHJcblxyXG4gICAgLy8gTm8gc3VwcG9ydGVkIHR5cGVzIGlmIG5vIFdlYiBBdWRpbyBBUElcclxuICAgIGlmICghR3VhY2Ftb2xlLkF1ZGlvQ29udGV4dEZhY3RvcnkuZ2V0QXVkaW9Db250ZXh0KCkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHJldHVybiBHdWFjYW1vbGUuUmF3QXVkaW9Gb3JtYXQucGFyc2UobWltZXR5cGUpICE9PSBudWxsO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgbWltZXR5cGVzIHN1cHBvcnRlZCBieSBHdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlci4gT25seVxyXG4gKiB0aGUgY29yZSBtaW1ldHlwZXMgdGhlbXNlbHZlcyB3aWxsIGJlIGxpc3RlZC4gQW55IG1pbWV0eXBlIHBhcmFtZXRlcnMsIGV2ZW5cclxuICogcmVxdWlyZWQgb25lcywgd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIGxpc3QuIEZvciBleGFtcGxlLCBcImF1ZGlvL0w4XCIgaXNcclxuICogYSByYXcgYXVkaW8gbWltZXR5cGUgdGhhdCBtYXkgYmUgc3VwcG9ydGVkLCBidXQgaXQgaXMgaW52YWxpZCB3aXRob3V0XHJcbiAqIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gU29tZXRoaW5nIGxpa2UgXCJhdWRpby9MODtyYXRlPTQ0MTAwXCIgd291bGQgYmUgdmFsaWQsXHJcbiAqIGhvd2V2ZXIgKHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDg1NikuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtTdHJpbmdbXX1cclxuICogICAgIEEgbGlzdCBvZiBhbGwgbWltZXR5cGVzIHN1cHBvcnRlZCBieSBHdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlcixcclxuICogICAgIGV4Y2x1ZGluZyBhbnkgcGFyYW1ldGVycy4gSWYgdGhlIG5lY2Vzc2FyeSBKYXZhU2NyaXB0IEFQSXMgZm9yIHJlY29yZGluZ1xyXG4gKiAgICAgcmF3IGF1ZGlvIGFyZSBhYnNlbnQsIHRoaXMgbGlzdCB3aWxsIGJlIGVtcHR5LlxyXG4gKi9cclxuR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIuZ2V0U3VwcG9ydGVkVHlwZXMgPSBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRUeXBlcygpIHtcclxuXHJcbiAgICAvLyBObyBzdXBwb3J0ZWQgdHlwZXMgaWYgbm8gV2ViIEF1ZGlvIEFQSVxyXG4gICAgaWYgKCFHdWFjYW1vbGUuQXVkaW9Db250ZXh0RmFjdG9yeS5nZXRBdWRpb0NvbnRleHQoKSlcclxuICAgICAgICByZXR1cm4gW107XHJcblxyXG4gICAgLy8gV2Ugc3VwcG9ydCA4LWJpdCBhbmQgMTYtYml0IHJhdyBQQ01cclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgJ2F1ZGlvL0w4JyxcclxuICAgICAgICAnYXVkaW8vTDE2J1xyXG4gICAgXTtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIHJlYWRlciB3aGljaCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgdGhlIGdpdmVuIGlucHV0IHN0cmVhbSwgYXNzZW1ibGluZyBhbGxcclxuICogcmVjZWl2ZWQgYmxvYnMgaW50byBhIHNpbmdsZSBibG9iIGJ5IGFwcGVuZGluZyB0aGVtIHRvIGVhY2ggb3RoZXIgaW4gb3JkZXIuXHJcbiAqIE5vdGUgdGhhdCB0aGlzIG9iamVjdCB3aWxsIG92ZXJ3cml0ZSBhbnkgaW5zdGFsbGVkIGV2ZW50IGhhbmRsZXJzIG9uIHRoZVxyXG4gKiBnaXZlbiBHdWFjYW1vbGUuSW5wdXRTdHJlYW0uXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuSW5wdXRTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIHRoYXQgZGF0YSB3aWxsIGJlIHJlYWRcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGUgVGhlIG1pbWV0eXBlIG9mIHRoZSBibG9iIGJlaW5nIGJ1aWx0LlxyXG4gKi9cclxuR3VhY2Ftb2xlLkJsb2JSZWFkZXIgPSBmdW5jdGlvbihzdHJlYW0sIG1pbWV0eXBlKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuSW5wdXRTdHJlYW0uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY19yZWFkZXIgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxlbmd0aCBvZiB0aGlzIEd1YWNhbW9sZS5JbnB1dFN0cmVhbSBpbiBieXRlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBsZW5ndGggPSAwO1xyXG5cclxuICAgIC8vIEdldCBibG9iIGJ1aWxkZXJcclxuICAgIHZhciBibG9iX2J1aWxkZXI7XHJcbiAgICBpZiAgICAgICh3aW5kb3cuQmxvYkJ1aWxkZXIpICAgICAgIGJsb2JfYnVpbGRlciA9IG5ldyBCbG9iQnVpbGRlcigpO1xyXG4gICAgZWxzZSBpZiAod2luZG93LldlYktpdEJsb2JCdWlsZGVyKSBibG9iX2J1aWxkZXIgPSBuZXcgV2ViS2l0QmxvYkJ1aWxkZXIoKTtcclxuICAgIGVsc2UgaWYgKHdpbmRvdy5Nb3pCbG9iQnVpbGRlcikgICAgYmxvYl9idWlsZGVyID0gbmV3IE1vekJsb2JCdWlsZGVyKCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgYmxvYl9idWlsZGVyID0gbmV3IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBibG9icyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLyoqIEBpZ25vcmUgKi9cclxuICAgICAgICAgICAgdGhpcy5hcHBlbmQgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBibG9icy5wdXNoKG5ldyBCbG9iKFtkYXRhXSwge1widHlwZVwiOiBtaW1ldHlwZX0pKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKiBAaWdub3JlICovXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0QmxvYiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKGJsb2JzLCB7XCJ0eXBlXCI6IG1pbWV0eXBlfSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH0pKCk7XHJcblxyXG4gICAgLy8gQXBwZW5kIHJlY2VpdmVkIGJsb2JzXHJcbiAgICBzdHJlYW0ub25ibG9iID0gZnVuY3Rpb24oZGF0YSkge1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRvIEFycmF5QnVmZmVyXHJcbiAgICAgICAgdmFyIGJpbmFyeSA9IHdpbmRvdy5hdG9iKGRhdGEpO1xyXG4gICAgICAgIHZhciBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihiaW5hcnkubGVuZ3RoKTtcclxuICAgICAgICB2YXIgYnVmZmVyVmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGJpbmFyeS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYnVmZmVyVmlld1tpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpO1xyXG5cclxuICAgICAgICBibG9iX2J1aWxkZXIuYXBwZW5kKGFycmF5QnVmZmVyKTtcclxuICAgICAgICBsZW5ndGggKz0gYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gQ2FsbCBoYW5kbGVyLCBpZiBwcmVzZW50XHJcbiAgICAgICAgaWYgKGd1YWNfcmVhZGVyLm9ucHJvZ3Jlc3MpXHJcbiAgICAgICAgICAgIGd1YWNfcmVhZGVyLm9ucHJvZ3Jlc3MoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XHJcblxyXG4gICAgICAgIC8vIFNlbmQgc3VjY2VzcyByZXNwb25zZVxyXG4gICAgICAgIHN0cmVhbS5zZW5kQWNrKFwiT0tcIiwgMHgwMDAwKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFNpbXBseSBjYWxsIG9uZW5kIHdoZW4gZW5kIHJlY2VpdmVkXHJcbiAgICBzdHJlYW0ub25lbmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoZ3VhY19yZWFkZXIub25lbmQpXHJcbiAgICAgICAgICAgIGd1YWNfcmVhZGVyLm9uZW5kKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhpcyBHdWFjYW1vbGUuSW5wdXRTdHJlYW0sIGluIGJ5dGVzLlxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCBsZW5ndGggb2YgdGhpcyBHdWFjYW1vbGUuSW5wdXRTdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGlzIEd1YWNhbW9sZS5CbG9iUmVhZGVyIGFzIGEgQmxvYi5cclxuICAgICAqIEByZXR1cm4ge0Jsb2J9IFRoZSBjb250ZW50cyBvZiB0aGlzIEd1YWNhbW9sZS5CbG9iUmVhZGVyLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldEJsb2IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gYmxvYl9idWlsZGVyLmdldEJsb2IoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCBvbmNlIGZvciBldmVyeSBibG9iIG9mIGRhdGEgcmVjZWl2ZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgb25jZSB0aGlzIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgbm8gZnVydGhlciBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cclxuICAgICAqIEBldmVudFxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uZW5kID0gbnVsbDtcclxuXHJcbn07XG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgd3JpdGVyIHdoaWNoIGF1dG9tYXRpY2FsbHkgd3JpdGVzIHRvIHRoZSBnaXZlbiBvdXRwdXQgc3RyZWFtIHdpdGggdGhlXHJcbiAqIGNvbnRlbnRzIG9mIHByb3ZpZGVkIEJsb2Igb2JqZWN0cy5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLk91dHB1dFN0cmVhbX0gc3RyZWFtXHJcbiAqICAgICBUaGUgc3RyZWFtIHRoYXQgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gdG8uXHJcbiAqL1xyXG5HdWFjYW1vbGUuQmxvYldyaXRlciA9IGZ1bmN0aW9uIEJsb2JXcml0ZXIoc3RyZWFtKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuQmxvYldyaXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5CbG9iV3JpdGVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY1dyaXRlciA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcGVkIEd1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlciB3aGljaCB3aWxsIGJlIHVzZWQgdG8gc2VuZCBhbnlcclxuICAgICAqIHByb3ZpZGVkIGZpbGUgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIGFycmF5QnVmZmVyV3JpdGVyID0gbmV3IEd1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlcihzdHJlYW0pO1xyXG5cclxuICAgIC8vIEluaXRpYWxseSwgc2ltcGx5IGNhbGwgb25hY2sgZm9yIGFja25vd2xlZGdlbWVudHNcclxuICAgIGFycmF5QnVmZmVyV3JpdGVyLm9uYWNrID0gZnVuY3Rpb24oc3RhdHVzKSB7XHJcbiAgICAgICAgaWYgKGd1YWNXcml0ZXIub25hY2spXHJcbiAgICAgICAgICAgIGd1YWNXcml0ZXIub25hY2soc3RhdHVzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCcm93c2VyLWluZGVwZW5kZW50IGltcGxlbWVudGF0aW9uIG9mIEJsb2Iuc2xpY2UoKSB3aGljaCB1c2VzIGFuIGVuZFxyXG4gICAgICogb2Zmc2V0IHRvIGRldGVybWluZSB0aGUgc3BhbiBvZiB0aGUgcmVzdWx0aW5nIHNsaWNlLCByYXRoZXIgdGhhbiBhXHJcbiAgICAgKiBsZW5ndGguXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxyXG4gICAgICogICAgIFRoZSBCbG9iIHRvIHNsaWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxyXG4gICAgICogICAgIFRoZSBzdGFydGluZyBvZmZzZXQgb2YgdGhlIHNsaWNlLCBpbiBieXRlcywgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcclxuICAgICAqICAgICBUaGUgZW5kaW5nIG9mZnNldCBvZiB0aGUgc2xpY2UsIGluIGJ5dGVzLCBleGNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0Jsb2J9XHJcbiAgICAgKiAgICAgQSBCbG9iIGNvbnRhaW5pbmcgdGhlIGRhdGEgd2l0aGluIHRoZSBnaXZlbiBCbG9iIHN0YXJ0aW5nIGF0XHJcbiAgICAgKiAgICAgPGNvZGU+c3RhcnQ8L2NvZGU+IGFuZCBlbmRpbmcgYXQgPGNvZGU+ZW5kIC0gMTwvY29kZT4uXHJcbiAgICAgKi9cclxuICAgIHZhciBzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKGJsb2IsIHN0YXJ0LCBlbmQpIHtcclxuXHJcbiAgICAgICAgLy8gVXNlIHByZWZpeGVkIGltcGxlbWVudGF0aW9ucyBpZiBuZWNlc3NhcnlcclxuICAgICAgICB2YXIgc2xpY2VJbXBsZW1lbnRhdGlvbiA9IChcclxuICAgICAgICAgICAgICAgIGJsb2Iuc2xpY2VcclxuICAgICAgICAgICAgIHx8IGJsb2Iud2Via2l0U2xpY2VcclxuICAgICAgICAgICAgIHx8IGJsb2IubW96U2xpY2VcclxuICAgICAgICApLmJpbmQoYmxvYik7XHJcblxyXG4gICAgICAgIHZhciBsZW5ndGggPSBlbmQgLSBzdGFydDtcclxuXHJcbiAgICAgICAgLy8gVGhlIG9sZCBCbG9iLnNsaWNlKCkgd2FzIGxlbmd0aC1iYXNlZCAobm90IGVuZC1iYXNlZCkuIFRyeSB0aGVcclxuICAgICAgICAvLyBsZW5ndGggdmVyc2lvbiBmaXJzdCwgaWYgdGhlIHR3byBjYWxscyBhcmUgbm90IGVxdWl2YWxlbnQuXHJcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gZW5kKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0IG9mIHRoZSBzbGljZSgpIGNhbGwgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgbGVuZ3RoLFxyXG4gICAgICAgICAgICAvLyB0cnVzdCB0aGF0IHJlc3VsdC4gSXQgbXVzdCBiZSBjb3JyZWN0LlxyXG4gICAgICAgICAgICB2YXIgc2xpY2VSZXN1bHQgPSBzbGljZUltcGxlbWVudGF0aW9uKHN0YXJ0LCBsZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAoc2xpY2VSZXN1bHQuc2l6ZSA9PT0gbGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlUmVzdWx0O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHRoZSBtb3N0LXJlY2VudCBzdGFuZGFyZDogZW5kLWJhc2VkIHNsaWNlKClcclxuICAgICAgICByZXR1cm4gc2xpY2VJbXBsZW1lbnRhdGlvbihzdGFydCwgZW5kKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBnaXZlbiBibG9iIG92ZXIgdGhlIHVuZGVybHlpbmcgc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxyXG4gICAgICogICAgIFRoZSBibG9iIHRvIHNlbmQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VuZEJsb2IgPSBmdW5jdGlvbiBzZW5kQmxvYihibG9iKSB7XHJcblxyXG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyB0aGUgbmV4dCBjaHVuayBvZiB0aGUgYmxvYiBwcm92aWRlZCB0b1xyXG4gICAgICAgICAqIFtzZW5kQmxvYigpXXtAbGluayBHdWFjYW1vbGUuQmxvYldyaXRlciNzZW5kQmxvYn0uIFRoZSBjaHVuayBpdHNlbGZcclxuICAgICAgICAgKiBpcyByZWFkIGFzeW5jaHJvbm91c2x5LCBhbmQgd2lsbCBub3QgYmUgYXZhaWxhYmxlIHVudGlsXHJcbiAgICAgICAgICogcmVhZGVyLm9ubG9hZCBmaXJlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIHJlYWROZXh0Q2h1bmsgPSBmdW5jdGlvbiByZWFkTmV4dENodW5rKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgbm8gZnVydGhlciBjaHVua3MgcmVtYWluLCBpbmZvcm0gb2YgY29tcGxldGlvbiBhbmQgc3RvcFxyXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID49IGJsb2Iuc2l6ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpcmUgY29tcGxldGlvbiBldmVudCBmb3IgY29tcGxldGVkIGJsb2JcclxuICAgICAgICAgICAgICAgIGlmIChndWFjV3JpdGVyLm9uY29tcGxldGUpXHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY1dyaXRlci5vbmNvbXBsZXRlKGJsb2IpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vIGZ1cnRoZXIgY2h1bmtzIHRvIHJlYWRcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9idGFpbiByZWZlcmVuY2UgdG8gbmV4dCBjaHVuayBhcyBhIG5ldyBibG9iXHJcbiAgICAgICAgICAgIHZhciBjaHVuayA9IHNsaWNlKGJsb2IsIG9mZnNldCwgb2Zmc2V0ICsgYXJyYXlCdWZmZXJXcml0ZXIuYmxvYkxlbmd0aCk7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBhcnJheUJ1ZmZlcldyaXRlci5ibG9iTGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byByZWFkIHRoZSBibG9iIGNvbnRlbnRzIHJlcHJlc2VudGVkIGJ5IHRoZSBibG9iIGludG9cclxuICAgICAgICAgICAgLy8gYSBuZXcgYXJyYXkgYnVmZmVyXHJcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihjaHVuayk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFNlbmQgZWFjaCBjaHVuayBvdmVyIHRoZSBzdHJlYW0sIGNvbnRpbnVlIHJlYWRpbmcgdGhlIG5leHQgY2h1bmtcclxuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gY2h1bmtMb2FkQ29tcGxldGUoKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTZW5kIHRoZSBzdWNjZXNzZnVsbHktcmVhZCBjaHVua1xyXG4gICAgICAgICAgICBhcnJheUJ1ZmZlcldyaXRlci5zZW5kRGF0YShyZWFkZXIucmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHNlbmRpbmcgbW9yZSBjaHVua3MgYWZ0ZXIgdGhlIGxhdGVzdCBjaHVuayBpc1xyXG4gICAgICAgICAgICAvLyBhY2tub3dsZWRnZWRcclxuICAgICAgICAgICAgYXJyYXlCdWZmZXJXcml0ZXIub25hY2sgPSBmdW5jdGlvbiBzZW5kTW9yZUNodW5rcyhzdGF0dXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZ3VhY1dyaXRlci5vbmFjaylcclxuICAgICAgICAgICAgICAgICAgICBndWFjV3JpdGVyLm9uYWNrKHN0YXR1cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgdHJhbnNmZXIgaWYgYW4gZXJyb3Igb2NjdXJzXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmlzRXJyb3IoKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5mb3JtIG9mIGJsb2IgdXBsb2FkIHByb2dyZXNzIHZpYSBwcm9ncmVzcyBldmVudHNcclxuICAgICAgICAgICAgICAgIGlmIChndWFjV3JpdGVyLm9ucHJvZ3Jlc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY1dyaXRlci5vbnByb2dyZXNzKGJsb2IsIG9mZnNldCAtIGFycmF5QnVmZmVyV3JpdGVyLmJsb2JMZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFF1ZXVlIHRoZSBuZXh0IGNodW5rIGZvciByZWFkaW5nXHJcbiAgICAgICAgICAgICAgICByZWFkTmV4dENodW5rKCk7XHJcblxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBJZiBhbiBlcnJvciBwcmV2ZW50cyBmdXJ0aGVyIHJlYWRpbmcsIGluZm9ybSBvZiBlcnJvciBhbmQgc3RvcFxyXG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gY2h1bmtMb2FkRmFpbGVkKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gRmlyZSBlcnJvciBldmVudCwgaW5jbHVkaW5nIHRoZSBjb250ZXh0IG9mIHRoZSBlcnJvclxyXG4gICAgICAgICAgICBpZiAoZ3VhY1dyaXRlci5vbmVycm9yKVxyXG4gICAgICAgICAgICAgICAgZ3VhY1dyaXRlci5vbmVycm9yKGJsb2IsIG9mZnNldCwgcmVhZGVyLmVycm9yKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQmVnaW4gcmVhZGluZyB0aGUgZmlyc3QgY2h1bmtcclxuICAgICAgICByZWFkTmV4dENodW5rKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpZ25hbHMgdGhhdCBubyBmdXJ0aGVyIHRleHQgd2lsbCBiZSBzZW50LCBlZmZlY3RpdmVseSBjbG9zaW5nIHRoZVxyXG4gICAgICogc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmRFbmQgPSBmdW5jdGlvbiBzZW5kRW5kKCkge1xyXG4gICAgICAgIGFycmF5QnVmZmVyV3JpdGVyLnNlbmRFbmQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCBmb3IgcmVjZWl2ZWQgZGF0YSwgaWYgYWNrbm93bGVkZ2VkIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5TdGF0dXN9IHN0YXR1c1xyXG4gICAgICogICAgIFRoZSBzdGF0dXMgb2YgdGhlIG9wZXJhdGlvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmFjayA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIGFuIGVycm9yIG9jY3VycyByZWFkaW5nIGEgYmxvYiBwYXNzZWQgdG9cclxuICAgICAqIFtzZW5kQmxvYigpXXtAbGluayBHdWFjYW1vbGUuQmxvYldyaXRlciNzZW5kQmxvYn0uIFRoZSB0cmFuc2ZlciBmb3IgdGhlXHJcbiAgICAgKiB0aGUgZ2l2ZW4gYmxvYiB3aWxsIGNlYXNlLCBidXQgdGhlIHN0cmVhbSB3aWxsIHJlbWFpbiBvcGVuLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtCbG9ifSBibG9iXHJcbiAgICAgKiAgICAgVGhlIGJsb2IgdGhhdCB3YXMgYmVpbmcgcmVhZCB3aGVuIHRoZSBlcnJvciBvY2N1cnJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XHJcbiAgICAgKiAgICAgVGhlIG9mZnNldCBvZiB0aGUgZmFpbGVkIHJlYWQgYXR0ZW1wdCB3aXRoaW4gdGhlIGJsb2IsIGluIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RE9NRXJyb3J9IGVycm9yXHJcbiAgICAgKiAgICAgVGhlIGVycm9yIHRoYXQgb2NjdXJyZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25lcnJvciA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCBmb3IgZWFjaCBzdWNjZXNzZnVsbHktcmVhZCBjaHVuayBvZiBkYXRhIGFzIGEgYmxvYiBpcyBiZWluZyBzZW50XHJcbiAgICAgKiB2aWEgW3NlbmRCbG9iKClde0BsaW5rIEd1YWNhbW9sZS5CbG9iV3JpdGVyI3NlbmRCbG9ifS5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxyXG4gICAgICogICAgIFRoZSBibG9iIHRoYXQgaXMgYmVpbmcgcmVhZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XHJcbiAgICAgKiAgICAgVGhlIG9mZnNldCBvZiB0aGUgcmVhZCB0aGF0IGp1c3Qgc3VjY2VlZGVkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiBhIGJsb2IgcGFzc2VkIHRvXHJcbiAgICAgKiBbc2VuZEJsb2IoKV17QGxpbmsgR3VhY2Ftb2xlLkJsb2JXcml0ZXIjc2VuZEJsb2J9IGhhcyBmaW5pc2hlZCBiZWluZ1xyXG4gICAgICogc2VudC5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxyXG4gICAgICogICAgIFRoZSBibG9iIHRoYXQgd2FzIHNlbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25jb21wbGV0ZSA9IG51bGw7XHJcblxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogR3VhY2Ftb2xlIHByb3RvY29sIGNsaWVudC4gR2l2ZW4gYSB7QGxpbmsgR3VhY2Ftb2xlLlR1bm5lbH0sXHJcbiAqIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBpbmNvbWluZyBhbmQgb3V0Z29pbmcgR3VhY2Ftb2xlIGluc3RydWN0aW9ucyB2aWEgdGhlXHJcbiAqIHByb3ZpZGVkIHR1bm5lbCwgdXBkYXRpbmcgaXRzIGRpc3BsYXkgdXNpbmcgb25lIG9yIG1vcmUgY2FudmFzIGVsZW1lbnRzLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLlR1bm5lbH0gdHVubmVsIFRoZSB0dW5uZWwgdG8gdXNlIHRvIHNlbmQgYW5kIHJlY2VpdmVcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR3VhY2Ftb2xlIGluc3RydWN0aW9ucy5cclxuICovXHJcbkd1YWNhbW9sZS5DbGllbnQgPSBmdW5jdGlvbih0dW5uZWwpIHtcclxuXHJcbiAgICB2YXIgZ3VhY19jbGllbnQgPSB0aGlzO1xyXG5cclxuICAgIHZhciBTVEFURV9JRExFICAgICAgICAgID0gMDtcclxuICAgIHZhciBTVEFURV9DT05ORUNUSU5HICAgID0gMTtcclxuICAgIHZhciBTVEFURV9XQUlUSU5HICAgICAgID0gMjtcclxuICAgIHZhciBTVEFURV9DT05ORUNURUQgICAgID0gMztcclxuICAgIHZhciBTVEFURV9ESVNDT05ORUNUSU5HID0gNDtcclxuICAgIHZhciBTVEFURV9ESVNDT05ORUNURUQgID0gNTtcclxuXHJcbiAgICB2YXIgY3VycmVudFN0YXRlID0gU1RBVEVfSURMRTtcclxuICAgIFxyXG4gICAgdmFyIGN1cnJlbnRUaW1lc3RhbXAgPSAwO1xyXG4gICAgdmFyIHBpbmdJbnRlcnZhbCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGlvbiBmcm9tIEd1YWNhbW9sZSBwcm90b2NvbCBsaW5lIGNhcHMgdG8gTGF5ZXIgbGluZSBjYXBzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGxpbmVDYXAgPSB7XHJcbiAgICAgICAgMDogXCJidXR0XCIsXHJcbiAgICAgICAgMTogXCJyb3VuZFwiLFxyXG4gICAgICAgIDI6IFwic3F1YXJlXCJcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGlvbiBmcm9tIEd1YWNhbW9sZSBwcm90b2NvbCBsaW5lIGNhcHMgdG8gTGF5ZXIgbGluZSBjYXBzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGxpbmVKb2luID0ge1xyXG4gICAgICAgIDA6IFwiYmV2ZWxcIixcclxuICAgICAgICAxOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgMjogXCJyb3VuZFwiXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHVuZGVybHlpbmcgR3VhY2Ftb2xlIGRpc3BsYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuRGlzcGxheX1cclxuICAgICAqL1xyXG4gICAgdmFyIGRpc3BsYXkgPSBuZXcgR3VhY2Ftb2xlLkRpc3BsYXkoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBhdmFpbGFibGUgbGF5ZXJzIGFuZCBidWZmZXJzXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPE51bWJlciwgKEd1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllcnxHdWFjYW1vbGUuTGF5ZXIpPn1cclxuICAgICAqL1xyXG4gICAgdmFyIGxheWVycyA9IHt9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBhdWRpbyBwbGF5ZXJzIGN1cnJlbnRseSBpbiB1c2UgYnkgdGhlIGNsaWVudC4gSW5pdGlhbGx5LCB0aGlzIHdpbGxcclxuICAgICAqIGJlIGVtcHR5LCBidXQgYXVkaW8gcGxheWVycyBtYXkgYmUgYWxsb2NhdGVkIGJ5IHRoZSBzZXJ2ZXIgdXBvbiByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxOdW1iZXIsIEd1YWNhbW9sZS5BdWRpb1BsYXllcj59XHJcbiAgICAgKi9cclxuICAgIHZhciBhdWRpb1BsYXllcnMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCB2aWRlbyBwbGF5ZXJzIGN1cnJlbnRseSBpbiB1c2UgYnkgdGhlIGNsaWVudC4gSW5pdGlhbGx5LCB0aGlzIHdpbGxcclxuICAgICAqIGJlIGVtcHR5LCBidXQgdmlkZW8gcGxheWVycyBtYXkgYmUgYWxsb2NhdGVkIGJ5IHRoZSBzZXJ2ZXIgdXBvbiByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxOdW1iZXIsIEd1YWNhbW9sZS5WaWRlb1BsYXllcj59XHJcbiAgICAgKi9cclxuICAgIHZhciB2aWRlb1BsYXllcnMgPSB7fTtcclxuXHJcbiAgICAvLyBObyBpbml0aWFsIHBhcnNlcnNcclxuICAgIHZhciBwYXJzZXJzID0gW107XHJcblxyXG4gICAgLy8gTm8gaW5pdGlhbCBzdHJlYW1zIFxyXG4gICAgdmFyIHN0cmVhbXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBjdXJyZW50IG9iamVjdHMuIFRoZSBpbmRleCBvZiBlYWNoIG9iamVjdCBpcyBkaWN0YXRlZCBieSB0aGVcclxuICAgICAqIEd1YWNhbW9sZSBzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuT2JqZWN0W119XHJcbiAgICAgKi9cclxuICAgIHZhciBvYmplY3RzID0gW107XHJcblxyXG4gICAgLy8gUG9vbCBvZiBhdmFpbGFibGUgc3RyZWFtIGluZGljZXNcclxuICAgIHZhciBzdHJlYW1faW5kaWNlcyA9IG5ldyBHdWFjYW1vbGUuSW50ZWdlclBvb2woKTtcclxuXHJcbiAgICAvLyBBcnJheSBvZiBhbGxvY2F0ZWQgb3V0cHV0IHN0cmVhbXMgYnkgaW5kZXhcclxuICAgIHZhciBvdXRwdXRfc3RyZWFtcyA9IFtdO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlICE9IGN1cnJlbnRTdGF0ZSkge1xyXG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgaWYgKGd1YWNfY2xpZW50Lm9uc3RhdGVjaGFuZ2UpXHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5vbnN0YXRlY2hhbmdlKGN1cnJlbnRTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzQ29ubmVjdGVkKCkge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50U3RhdGUgPT0gU1RBVEVfQ09OTkVDVEVEXHJcbiAgICAgICAgICAgIHx8IGN1cnJlbnRTdGF0ZSA9PSBTVEFURV9XQUlUSU5HO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvZHVjZXMgYW4gb3BhcXVlIHJlcHJlc2VudGF0aW9uIG9mIEd1YWNhbW9sZS5DbGllbnQgc3RhdGUgd2hpY2ggY2FuIGJlXHJcbiAgICAgKiBsYXRlciBpbXBvcnRlZCB0aHJvdWdoIGEgY2FsbCB0byBpbXBvcnRTdGF0ZSgpLiBUaGlzIG9iamVjdCBpc1xyXG4gICAgICogZWZmZWN0aXZlbHkgYW4gaW5kZXBlbmRlbnQsIGNvbXByZXNzZWQgc25hcHNob3Qgb2YgcHJvdG9jb2wgYW5kIGRpc3BsYXlcclxuICAgICAqIHN0YXRlLiBJbnZva2luZyB0aGlzIGZ1bmN0aW9uIGltcGxpY2l0bHkgZmx1c2hlcyB0aGUgZGlzcGxheS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICogICAgIENhbGxiYWNrIHdoaWNoIHNob3VsZCBiZSBpbnZva2VkIG9uY2UgdGhlIHN0YXRlIG9iamVjdCBpcyByZWFkeS4gVGhlXHJcbiAgICAgKiAgICAgc3RhdGUgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBhcyB0aGUgc29sZSBwYXJhbWV0ZXIuXHJcbiAgICAgKiAgICAgVGhpcyBjYWxsYmFjayBtYXkgYmUgaW52b2tlZCBpbW1lZGlhdGVseSwgb3IgbGF0ZXIgYXMgdGhlIGRpc3BsYXlcclxuICAgICAqICAgICBmaW5pc2hlcyByZW5kZXJpbmcgYW5kIGJlY29tZXMgcmVhZHkuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZXhwb3J0U3RhdGUgPSBmdW5jdGlvbiBleHBvcnRTdGF0ZShjYWxsYmFjaykge1xyXG5cclxuICAgICAgICAvLyBTdGFydCB3aXRoIGVtcHR5IHN0YXRlXHJcbiAgICAgICAgdmFyIHN0YXRlID0ge1xyXG4gICAgICAgICAgICAnY3VycmVudFN0YXRlJyA6IGN1cnJlbnRTdGF0ZSxcclxuICAgICAgICAgICAgJ2N1cnJlbnRUaW1lc3RhbXAnIDogY3VycmVudFRpbWVzdGFtcCxcclxuICAgICAgICAgICAgJ2xheWVycycgOiB7fVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBsYXllcnNTbmFwc2hvdCA9IHt9O1xyXG5cclxuICAgICAgICAvLyBNYWtlIGEgY29weSBvZiBhbGwgY3VycmVudCBsYXllcnMgKHByb3RvY29sIHN0YXRlKVxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBsYXllcnMpIHtcclxuICAgICAgICAgICAgbGF5ZXJzU25hcHNob3Rba2V5XSA9IGxheWVyc1trZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUG9wdWxhdGUgbGF5ZXJzIG9uY2UgZGF0YSBpcyBhdmFpbGFibGUgKGRpc3BsYXkgc3RhdGUsIHJlcXVpcmVzIGZsdXNoKVxyXG4gICAgICAgIGRpc3BsYXkuZmx1c2goZnVuY3Rpb24gcG9wdWxhdGVMYXllcnMoKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBFeHBvcnQgZWFjaCBkZWZpbmVkIGxheWVyL2J1ZmZlclxyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbGF5ZXJzU25hcHNob3QpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChrZXkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzU25hcHNob3Rba2V5XTtcclxuICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBsYXllci50b0NhbnZhcygpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGxheWVyL2J1ZmZlciBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwb3J0TGF5ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJyAgOiBsYXllci53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JyA6IGxheWVyLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBsYXllci9idWZmZXIgaW1hZ2UgZGF0YSwgaWYgaXQgY2FuIGJlIGdlbmVyYXRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLndpZHRoICYmIGxheWVyLmhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICBleHBvcnRMYXllci51cmwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgbGF5ZXIgcHJvcGVydGllcyBpZiBub3QgYSBidWZmZXIgbm9yIHRoZSBkZWZhdWx0IGxheWVyXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0TGF5ZXIueCA9IGxheWVyLng7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0TGF5ZXIueSA9IGxheWVyLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0TGF5ZXIueiA9IGxheWVyLno7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0TGF5ZXIuYWxwaGEgPSBsYXllci5hbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBleHBvcnRMYXllci5tYXRyaXggPSBsYXllci5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0TGF5ZXIucGFyZW50ID0gZ2V0TGF5ZXJJbmRleChsYXllci5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGV4cG9ydGVkIGxheWVyXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5sYXllcnNba2V5XSA9IGV4cG9ydExheWVyO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW52b2tlIGNhbGxiYWNrIG5vdyB0aGF0IHRoZSBzdGF0ZSBpcyByZWFkeVxyXG4gICAgICAgICAgICBjYWxsYmFjayhzdGF0ZSk7XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN0b3JlcyBHdWFjYW1vbGUuQ2xpZW50IHByb3RvY29sIGFuZCBkaXNwbGF5IHN0YXRlIGJhc2VkIG9uIGFuIG9wYXF1ZVxyXG4gICAgICogb2JqZWN0IGZyb20gYSBwcmlvciBjYWxsIHRvIGV4cG9ydFN0YXRlKCkuIFRoZSBHdWFjYW1vbGUuQ2xpZW50IGluc3RhbmNlXHJcbiAgICAgKiB1c2VkIHRvIGV4cG9ydCB0aGF0IHN0YXRlIG5lZWQgbm90IGJlIHRoZSBzYW1lIGFzIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAgICAgKiAgICAgQW4gb3BhcXVlIHJlcHJlc2VudGF0aW9uIG9mIEd1YWNhbW9sZS5DbGllbnQgc3RhdGUgZnJvbSBhIHByaW9yIGNhbGxcclxuICAgICAqICAgICB0byBleHBvcnRTdGF0ZSgpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja11cclxuICAgICAqICAgICBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gc3RhdGUgaGFzIGZpbmlzaGVkIGJlaW5nIGltcG9ydGVkLiBUaGlzXHJcbiAgICAgKiAgICAgbWF5IGhhcHBlbiBpbW1lZGlhdGVseSwgb3IgbGF0ZXIgYXMgaW1hZ2VzIHdpdGhpbiB0aGUgcHJvdmlkZWQgc3RhdGVcclxuICAgICAqICAgICBvYmplY3QgYXJlIGxvYWRlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbXBvcnRTdGF0ZSA9IGZ1bmN0aW9uIGltcG9ydFN0YXRlKHN0YXRlLCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgIHZhciBpbmRleDtcclxuXHJcbiAgICAgICAgY3VycmVudFN0YXRlID0gc3RhdGUuY3VycmVudFN0YXRlO1xyXG4gICAgICAgIGN1cnJlbnRUaW1lc3RhbXAgPSBzdGF0ZS5jdXJyZW50VGltZXN0YW1wO1xyXG5cclxuICAgICAgICAvLyBEaXNwb3NlIG9mIGFsbCBsYXllcnNcclxuICAgICAgICBmb3IgKGtleSBpbiBsYXllcnMpIHtcclxuICAgICAgICAgICAgaW5kZXggPSBwYXJzZUludChrZXkpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKVxyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5kaXNwb3NlKGxheWVyc1trZXldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxheWVycyA9IHt9O1xyXG5cclxuICAgICAgICAvLyBJbXBvcnQgc3RhdGUgb2YgZWFjaCBsYXllci9idWZmZXJcclxuICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZS5sYXllcnMpIHtcclxuXHJcbiAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoa2V5KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbXBvcnRMYXllciA9IHN0YXRlLmxheWVyc1trZXldO1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihpbmRleCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXNldCBsYXllciBzaXplXHJcbiAgICAgICAgICAgIGRpc3BsYXkucmVzaXplKGxheWVyLCBpbXBvcnRMYXllci53aWR0aCwgaW1wb3J0TGF5ZXIuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgbmV3IGxheWVyIGlmIGl0IGhhcyBhc3NvY2lhdGVkIGRhdGFcclxuICAgICAgICAgICAgaWYgKGltcG9ydExheWVyLnVybCkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5zZXRDaGFubmVsTWFzayhsYXllciwgR3VhY2Ftb2xlLkxheWVyLlNSQyk7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmRyYXcobGF5ZXIsIDAsIDAsIGltcG9ydExheWVyLnVybCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBsYXllci1zcGVjaWZpYyBwcm9wZXJ0aWVzIGlmIG5vdCBhIGJ1ZmZlciBub3IgdGhlIGRlZmF1bHQgbGF5ZXJcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiBpbXBvcnRMYXllci5wYXJlbnQgPj0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGxheWVyIHBvc2l0aW9uIGFuZCBzZXQgcGFyZW50XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZ2V0TGF5ZXIoaW1wb3J0TGF5ZXIucGFyZW50KTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkubW92ZShsYXllciwgcGFyZW50LCBpbXBvcnRMYXllci54LCBpbXBvcnRMYXllci55LCBpbXBvcnRMYXllci56KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgbGF5ZXIgdHJhbnNwYXJlbmN5XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LnNoYWRlKGxheWVyLCBpbXBvcnRMYXllci5hbHBoYSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgbWF0cml4IHRyYW5zZm9ybVxyXG4gICAgICAgICAgICAgICAgdmFyIG1hdHJpeCA9IGltcG9ydExheWVyLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkuZGlzdG9ydChsYXllcixcclxuICAgICAgICAgICAgICAgICAgICBtYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzJdLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeFszXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZsdXNoIGNoYW5nZXMgdG8gZGlzcGxheVxyXG4gICAgICAgIGRpc3BsYXkuZmx1c2goY2FsbGJhY2spO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGRpc3BsYXkgb2YgdGhpcyBHdWFjYW1vbGUuQ2xpZW50LiBUaGUgZGlzcGxheVxyXG4gICAgICogY29udGFpbnMgYW4gRWxlbWVudCB3aGljaCBjYW4gYmUgYWRkZWQgdG8gdGhlIERPTSwgY2F1c2luZyB0aGVcclxuICAgICAqIGRpc3BsYXkgdG8gYmVjb21lIHZpc2libGUuXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm4ge0d1YWNhbW9sZS5EaXNwbGF5fSBUaGUgdW5kZXJseWluZyBkaXNwbGF5IG9mIHRoaXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHdWFjYW1vbGUuQ2xpZW50LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldERpc3BsYXkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gZGlzcGxheTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBzY3JlZW4uXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHNjcmVlbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmRTaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3Qgc2VuZCByZXF1ZXN0cyBpZiBub3QgY29ubmVjdGVkXHJcbiAgICAgICAgaWYgKCFpc0Nvbm5lY3RlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcInNpemVcIiwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIGEga2V5IGV2ZW50IGhhdmluZyB0aGUgZ2l2ZW4gcHJvcGVydGllcyBhcyBpZiB0aGUgdXNlclxyXG4gICAgICogcHJlc3NlZCBvciByZWxlYXNlZCBhIGtleS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBwcmVzc2VkIFdoZXRoZXIgdGhlIGtleSBpcyBwcmVzc2VkICh0cnVlKSBvciByZWxlYXNlZFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIChmYWxzZSkuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga2V5c3ltIFRoZSBrZXlzeW0gb2YgdGhlIGtleSBiZWluZyBwcmVzc2VkIG9yIHJlbGVhc2VkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmRLZXlFdmVudCA9IGZ1bmN0aW9uKHByZXNzZWQsIGtleXN5bSkge1xyXG4gICAgICAgIC8vIERvIG5vdCBzZW5kIHJlcXVlc3RzIGlmIG5vdCBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoIWlzQ29ubmVjdGVkKCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwia2V5XCIsIGtleXN5bSwgcHJlc3NlZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgYSBtb3VzZSBldmVudCBoYXZpbmcgdGhlIHByb3BlcnRpZXMgcHJvdmlkZWQgYnkgdGhlIGdpdmVuIG1vdXNlXHJcbiAgICAgKiBzdGF0ZS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTW91c2UuU3RhdGV9IG1vdXNlU3RhdGUgVGhlIHN0YXRlIG9mIHRoZSBtb3VzZSB0byBzZW5kXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgbW91c2UgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VuZE1vdXNlU3RhdGUgPSBmdW5jdGlvbihtb3VzZVN0YXRlKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBzZW5kIHJlcXVlc3RzIGlmIG5vdCBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoIWlzQ29ubmVjdGVkKCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGNsaWVudC1zaWRlIGN1cnNvclxyXG4gICAgICAgIGRpc3BsYXkubW92ZUN1cnNvcihcclxuICAgICAgICAgICAgTWF0aC5mbG9vcihtb3VzZVN0YXRlLngpLFxyXG4gICAgICAgICAgICBNYXRoLmZsb29yKG1vdXNlU3RhdGUueSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBCdWlsZCBtYXNrXHJcbiAgICAgICAgdmFyIGJ1dHRvbk1hc2sgPSAwO1xyXG4gICAgICAgIGlmIChtb3VzZVN0YXRlLmxlZnQpICAgYnV0dG9uTWFzayB8PSAxO1xyXG4gICAgICAgIGlmIChtb3VzZVN0YXRlLm1pZGRsZSkgYnV0dG9uTWFzayB8PSAyO1xyXG4gICAgICAgIGlmIChtb3VzZVN0YXRlLnJpZ2h0KSAgYnV0dG9uTWFzayB8PSA0O1xyXG4gICAgICAgIGlmIChtb3VzZVN0YXRlLnVwKSAgICAgYnV0dG9uTWFzayB8PSA4O1xyXG4gICAgICAgIGlmIChtb3VzZVN0YXRlLmRvd24pICAgYnV0dG9uTWFzayB8PSAxNjtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBtZXNzYWdlXHJcbiAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwibW91c2VcIiwgTWF0aC5mbG9vcihtb3VzZVN0YXRlLngpLCBNYXRoLmZsb29yKG1vdXNlU3RhdGUueSksIGJ1dHRvbk1hc2spO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbG9jYXRlcyBhbiBhdmFpbGFibGUgc3RyZWFtIGluZGV4IGFuZCBjcmVhdGVzIGEgbmV3XHJcbiAgICAgKiBHdWFjYW1vbGUuT3V0cHV0U3RyZWFtIHVzaW5nIHRoYXQgaW5kZXgsIGFzc29jaWF0aW5nIHRoZSByZXN1bHRpbmdcclxuICAgICAqIHN0cmVhbSB3aXRoIHRoaXMgR3VhY2Ftb2xlLkNsaWVudC4gTm90ZSB0aGF0IHRoaXMgc3RyZWFtIHdpbGwgbm90IHlldFxyXG4gICAgICogZXhpc3QgYXMgZmFyIGFzIHRoZSBvdGhlciBlbmQgb2YgdGhlIEd1YWNhbW9sZSBjb25uZWN0aW9uIGlzIGNvbmNlcm5lZC5cclxuICAgICAqIFN0cmVhbXMgZXhpc3Qgd2l0aGluIHRoZSBHdWFjYW1vbGUgcHJvdG9jb2wgb25seSB3aGVuIHJlZmVyZW5jZWQgYnkgYW5cclxuICAgICAqIGluc3RydWN0aW9uIHdoaWNoIGNyZWF0ZXMgdGhlIHN0cmVhbSwgc3VjaCBhcyBhIFwiY2xpcGJvYXJkXCIsIFwiZmlsZVwiLCBvclxyXG4gICAgICogXCJwaXBlXCIgaW5zdHJ1Y3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0d1YWNhbW9sZS5PdXRwdXRTdHJlYW19XHJcbiAgICAgKiAgICAgQSBuZXcgR3VhY2Ftb2xlLk91dHB1dFN0cmVhbSB3aXRoIGEgbmV3bHktYWxsb2NhdGVkIGluZGV4IGFuZFxyXG4gICAgICogICAgIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEd1YWNhbW9sZS5DbGllbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3JlYXRlT3V0cHV0U3RyZWFtID0gZnVuY3Rpb24gY3JlYXRlT3V0cHV0U3RyZWFtKCkge1xyXG5cclxuICAgICAgICAvLyBBbGxvY2F0ZSBpbmRleFxyXG4gICAgICAgIHZhciBpbmRleCA9IHN0cmVhbV9pbmRpY2VzLm5leHQoKTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIG5ldyBzdHJlYW1cclxuICAgICAgICB2YXIgc3RyZWFtID0gb3V0cHV0X3N0cmVhbXNbaW5kZXhdID0gbmV3IEd1YWNhbW9sZS5PdXRwdXRTdHJlYW0oZ3VhY19jbGllbnQsIGluZGV4KTtcclxuICAgICAgICByZXR1cm4gc3RyZWFtO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBhIG5ldyBhdWRpbyBzdHJlYW0gZm9yIHdyaXRpbmcsIHdoZXJlIGF1ZGlvIGRhdGEgaGF2aW5nIHRoZSBnaXZlXHJcbiAgICAgKiBtaW1ldHlwZSB3aWxsIGJlIHNlbnQgYWxvbmcgdGhlIHJldHVybmVkIHN0cmVhbS4gVGhlIGluc3RydWN0aW9uXHJcbiAgICAgKiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoaXMgc3RyZWFtIHdpbGwgYXV0b21hdGljYWxseSBiZSBzZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gICAgICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgYXVkaW8gZGF0YSB0aGF0IHdpbGwgYmUgc2VudCBhbG9uZyB0aGUgcmV0dXJuZWRcclxuICAgICAqICAgICBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7R3VhY2Ftb2xlLk91dHB1dFN0cmVhbX1cclxuICAgICAqICAgICBUaGUgY3JlYXRlZCBhdWRpbyBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3JlYXRlQXVkaW9TdHJlYW0gPSBmdW5jdGlvbihtaW1ldHlwZSkge1xyXG5cclxuICAgICAgICAvLyBBbGxvY2F0ZSBhbmQgYXNzb2NpYXRlIHN0cmVhbSB3aXRoIGF1ZGlvIG1ldGFkYXRhXHJcbiAgICAgICAgdmFyIHN0cmVhbSA9IGd1YWNfY2xpZW50LmNyZWF0ZU91dHB1dFN0cmVhbSgpO1xyXG4gICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcImF1ZGlvXCIsIHN0cmVhbS5pbmRleCwgbWltZXR5cGUpO1xyXG4gICAgICAgIHJldHVybiBzdHJlYW07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW5zIGEgbmV3IGZpbGUgZm9yIHdyaXRpbmcsIGhhdmluZyB0aGUgZ2l2ZW4gaW5kZXgsIG1pbWV0eXBlIGFuZFxyXG4gICAgICogZmlsZW5hbWUuIFRoZSBpbnN0cnVjdGlvbiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoaXMgc3RyZWFtIHdpbGxcclxuICAgICAqIGF1dG9tYXRpY2FsbHkgYmUgc2VudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGUgVGhlIG1pbWV0eXBlIG9mIHRoZSBmaWxlIGJlaW5nIHNlbnQuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIG9mIHRoZSBmaWxlIGJlaW5nIHNlbnQuXHJcbiAgICAgKiBAcmV0dXJuIHtHdWFjYW1vbGUuT3V0cHV0U3RyZWFtfSBUaGUgY3JlYXRlZCBmaWxlIHN0cmVhbS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jcmVhdGVGaWxlU3RyZWFtID0gZnVuY3Rpb24obWltZXR5cGUsIGZpbGVuYW1lKSB7XHJcblxyXG4gICAgICAgIC8vIEFsbG9jYXRlIGFuZCBhc3NvY2lhdGUgc3RyZWFtIHdpdGggZmlsZSBtZXRhZGF0YVxyXG4gICAgICAgIHZhciBzdHJlYW0gPSBndWFjX2NsaWVudC5jcmVhdGVPdXRwdXRTdHJlYW0oKTtcclxuICAgICAgICB0dW5uZWwuc2VuZE1lc3NhZ2UoXCJmaWxlXCIsIHN0cmVhbS5pbmRleCwgbWltZXR5cGUsIGZpbGVuYW1lKTtcclxuICAgICAgICByZXR1cm4gc3RyZWFtO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBhIG5ldyBwaXBlIGZvciB3cml0aW5nLCBoYXZpbmcgdGhlIGdpdmVuIG5hbWUgYW5kIG1pbWV0eXBlLiBUaGVcclxuICAgICAqIGluc3RydWN0aW9uIG5lY2Vzc2FyeSB0byBjcmVhdGUgdGhpcyBzdHJlYW0gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlIFRoZSBtaW1ldHlwZSBvZiB0aGUgZGF0YSBiZWluZyBzZW50LlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBpcGUuXHJcbiAgICAgKiBAcmV0dXJuIHtHdWFjYW1vbGUuT3V0cHV0U3RyZWFtfSBUaGUgY3JlYXRlZCBmaWxlIHN0cmVhbS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jcmVhdGVQaXBlU3RyZWFtID0gZnVuY3Rpb24obWltZXR5cGUsIG5hbWUpIHtcclxuXHJcbiAgICAgICAgLy8gQWxsb2NhdGUgYW5kIGFzc29jaWF0ZSBzdHJlYW0gd2l0aCBwaXBlIG1ldGFkYXRhXHJcbiAgICAgICAgdmFyIHN0cmVhbSA9IGd1YWNfY2xpZW50LmNyZWF0ZU91dHB1dFN0cmVhbSgpO1xyXG4gICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcInBpcGVcIiwgc3RyZWFtLmluZGV4LCBtaW1ldHlwZSwgbmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBuZXcgY2xpcGJvYXJkIG9iamVjdCBmb3Igd3JpdGluZywgaGF2aW5nIHRoZSBnaXZlbiBtaW1ldHlwZS4gVGhlXHJcbiAgICAgKiBpbnN0cnVjdGlvbiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoaXMgc3RyZWFtIHdpbGwgYXV0b21hdGljYWxseSBiZSBzZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZSBUaGUgbWltZXR5cGUgb2YgdGhlIGRhdGEgYmVpbmcgc2VudC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwaXBlLlxyXG4gICAgICogQHJldHVybiB7R3VhY2Ftb2xlLk91dHB1dFN0cmVhbX0gVGhlIGNyZWF0ZWQgZmlsZSBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3JlYXRlQ2xpcGJvYXJkU3RyZWFtID0gZnVuY3Rpb24obWltZXR5cGUpIHtcclxuXHJcbiAgICAgICAgLy8gQWxsb2NhdGUgYW5kIGFzc29jaWF0ZSBzdHJlYW0gd2l0aCBjbGlwYm9hcmQgbWV0YWRhdGFcclxuICAgICAgICB2YXIgc3RyZWFtID0gZ3VhY19jbGllbnQuY3JlYXRlT3V0cHV0U3RyZWFtKCk7XHJcbiAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwiY2xpcGJvYXJkXCIsIHN0cmVhbS5pbmRleCwgbWltZXR5cGUpO1xyXG4gICAgICAgIHJldHVybiBzdHJlYW07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW5zIGEgbmV3IGFyZ3VtZW50IHZhbHVlIHN0cmVhbSBmb3Igd3JpdGluZywgaGF2aW5nIHRoZSBnaXZlblxyXG4gICAgICogcGFyYW1ldGVyIG5hbWUgYW5kIG1pbWV0eXBlLCByZXF1ZXN0aW5nIHRoYXQgdGhlIGNvbm5lY3Rpb24gcGFyYW1ldGVyXHJcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBuYW1lIGJlIHVwZGF0ZWQgdG8gdGhlIHZhbHVlIGRlc2NyaWJlZCBieSB0aGUgY29udGVudHNcclxuICAgICAqIG9mIHRoZSBmb2xsb3dpbmcgc3RyZWFtLiBUaGUgaW5zdHJ1Y3Rpb24gbmVjZXNzYXJ5IHRvIGNyZWF0ZSB0aGlzIHN0cmVhbVxyXG4gICAgICogd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAgICAgKiAgICAgVGhlIG1pbWV0eXBlIG9mIHRoZSBkYXRhIGJlaW5nIHNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUgY29ubmVjdGlvbiBwYXJhbWV0ZXIgdG8gYXR0ZW1wdCB0byB1cGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7R3VhY2Ftb2xlLk91dHB1dFN0cmVhbX1cclxuICAgICAqICAgICBUaGUgY3JlYXRlZCBhcmd1bWVudCB2YWx1ZSBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3JlYXRlQXJndW1lbnRWYWx1ZVN0cmVhbSA9IGZ1bmN0aW9uIGNyZWF0ZUFyZ3VtZW50VmFsdWVTdHJlYW0obWltZXR5cGUsIG5hbWUpIHtcclxuXHJcbiAgICAgICAgLy8gQWxsb2NhdGUgYW5kIGFzc29jaWF0ZSBzdHJlYW0gd2l0aCBhcmd1bWVudCB2YWx1ZSBtZXRhZGF0YVxyXG4gICAgICAgIHZhciBzdHJlYW0gPSBndWFjX2NsaWVudC5jcmVhdGVPdXRwdXRTdHJlYW0oKTtcclxuICAgICAgICB0dW5uZWwuc2VuZE1lc3NhZ2UoXCJhcmd2XCIsIHN0cmVhbS5pbmRleCwgbWltZXR5cGUsIG5hbWUpO1xyXG4gICAgICAgIHJldHVybiBzdHJlYW07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgb3V0cHV0IHN0cmVhbSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIG9iamVjdCBhbmQgaGF2aW5nXHJcbiAgICAgKiB0aGUgZ2l2ZW4gbWltZXR5cGUgYW5kIG5hbWUuIFRoZSBsZWdhbGl0eSBvZiBhIG1pbWV0eXBlIGFuZCBuYW1lIGlzXHJcbiAgICAgKiBkaWN0YXRlZCBieSB0aGUgb2JqZWN0IGl0c2VsZi4gVGhlIGluc3RydWN0aW9uIG5lY2Vzc2FyeSB0byBjcmVhdGUgdGhpc1xyXG4gICAgICogc3RyZWFtIHdpbGwgYXV0b21hdGljYWxseSBiZSBzZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gICAgICogICAgIFRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IGZvciB3aGljaCB0aGUgb3V0cHV0IHN0cmVhbSBpcyBiZWluZ1xyXG4gICAgICogICAgIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAgICAgKiAgICAgVGhlIG1pbWV0eXBlIG9mIHRoZSBkYXRhIHdoaWNoIHdpbGwgYmUgc2VudCB0byB0aGUgb3V0cHV0IHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAgICogICAgIFRoZSBkZWZpbmVkIG5hbWUgb2YgYW4gb3V0cHV0IHN0cmVhbSB3aXRoaW4gdGhlIGdpdmVuIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7R3VhY2Ftb2xlLk91dHB1dFN0cmVhbX1cclxuICAgICAqICAgICBBbiBvdXRwdXQgc3RyZWFtIHdoaWNoIHdpbGwgd3JpdGUgYmxvYnMgdG8gdGhlIG5hbWVkIG91dHB1dCBzdHJlYW1cclxuICAgICAqICAgICBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNyZWF0ZU9iamVjdE91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE91dHB1dFN0cmVhbShpbmRleCwgbWltZXR5cGUsIG5hbWUpIHtcclxuXHJcbiAgICAgICAgLy8gQWxsb2NhdGUgYW5kIHNzb2NpYXRlIHN0cmVhbSB3aXRoIG9iamVjdCBtZXRhZGF0YVxyXG4gICAgICAgIHZhciBzdHJlYW0gPSBndWFjX2NsaWVudC5jcmVhdGVPdXRwdXRTdHJlYW0oKTtcclxuICAgICAgICB0dW5uZWwuc2VuZE1lc3NhZ2UoXCJwdXRcIiwgaW5kZXgsIHN0cmVhbS5pbmRleCwgbWltZXR5cGUsIG5hbWUpO1xyXG4gICAgICAgIHJldHVybiBzdHJlYW07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3RzIHJlYWQgYWNjZXNzIHRvIHRoZSBpbnB1dCBzdHJlYW0gaGF2aW5nIHRoZSBnaXZlbiBuYW1lLiBJZlxyXG4gICAgICogc3VjY2Vzc2Z1bCwgYSBuZXcgaW5wdXQgc3RyZWFtIHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuICAgICAqICAgICBUaGUgaW5kZXggb2YgdGhlIG9iamVjdCBmcm9tIHdoaWNoIHRoZSBpbnB1dCBzdHJlYW0gaXMgYmVpbmdcclxuICAgICAqICAgICByZXF1ZXN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUgaW5wdXQgc3RyZWFtIHRvIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVxdWVzdE9iamVjdElucHV0U3RyZWFtID0gZnVuY3Rpb24gcmVxdWVzdE9iamVjdElucHV0U3RyZWFtKGluZGV4LCBuYW1lKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBzZW5kIHJlcXVlc3RzIGlmIG5vdCBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoIWlzQ29ubmVjdGVkKCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwiZ2V0XCIsIGluZGV4LCBuYW1lKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2tub3dsZWRnZSByZWNlaXB0IG9mIGEgYmxvYiBvbiB0aGUgc3RyZWFtIHdpdGggdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBzdHJlYW0gYXNzb2NpYXRlZCB3aXRoIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkIGJsb2IuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBBIGh1bWFuLXJlYWRhYmxlIG1lc3NhZ2UgZGVzY3JpYmluZyB0aGUgZXJyb3JcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIG9yIHN0YXR1cy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBlcnJvciBjb2RlLCBpZiBhbnksIG9yIDAgZm9yIHN1Y2Nlc3MuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VuZEFjayA9IGZ1bmN0aW9uKGluZGV4LCBtZXNzYWdlLCBjb2RlKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBzZW5kIHJlcXVlc3RzIGlmIG5vdCBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoIWlzQ29ubmVjdGVkKCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwiYWNrXCIsIGluZGV4LCBtZXNzYWdlLCBjb2RlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiB0aGUgaW5kZXggb2YgYSBmaWxlLCB3cml0ZXMgYSBibG9iIG9mIGRhdGEgdG8gdGhhdCBmaWxlLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBmaWxlIHRvIHdyaXRlIHRvLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgQmFzZTY0LWVuY29kZWQgZGF0YSB0byB3cml0ZSB0byB0aGUgZmlsZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5kQmxvYiA9IGZ1bmN0aW9uKGluZGV4LCBkYXRhKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBzZW5kIHJlcXVlc3RzIGlmIG5vdCBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoIWlzQ29ubmVjdGVkKCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwiYmxvYlwiLCBpbmRleCwgZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFya3MgYSBjdXJyZW50bHktb3BlbiBzdHJlYW0gYXMgY29tcGxldGUuIFRoZSBvdGhlciBlbmQgb2YgdGhlXHJcbiAgICAgKiBHdWFjYW1vbGUgY29ubmVjdGlvbiB3aWxsIGJlIG5vdGlmaWVkIHZpYSBhbiBcImVuZFwiIGluc3RydWN0aW9uIHRoYXQgdGhlXHJcbiAgICAgKiBzdHJlYW0gaXMgY2xvc2VkLCBhbmQgdGhlIGluZGV4IHdpbGwgYmUgbWFkZSBhdmFpbGFibGUgZm9yIHJldXNlIGluXHJcbiAgICAgKiBmdXR1cmUgc3RyZWFtcy5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XHJcbiAgICAgKiAgICAgVGhlIGluZGV4IG9mIHRoZSBzdHJlYW0gdG8gZW5kLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmVuZFN0cmVhbSA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBzZW5kIHJlcXVlc3RzIGlmIG5vdCBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoIWlzQ29ubmVjdGVkKCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gRXhwbGljaXRseSBjbG9zZSBzdHJlYW0gYnkgc2VuZGluZyBcImVuZFwiIGluc3RydWN0aW9uXHJcbiAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwiZW5kXCIsIGluZGV4KTtcclxuXHJcbiAgICAgICAgLy8gRnJlZSBhc3NvY2lhdGVkIGluZGV4IGFuZCBzdHJlYW0gaWYgdGhleSBleGlzdFxyXG4gICAgICAgIGlmIChvdXRwdXRfc3RyZWFtc1tpbmRleF0pIHtcclxuICAgICAgICAgICAgc3RyZWFtX2luZGljZXMuZnJlZShpbmRleCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvdXRwdXRfc3RyZWFtc1tpbmRleF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgc3RhdGUgb2YgdGhpcyBHdWFjYW1vbGUuQ2xpZW50IGNoYW5nZXMuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXRlIFRoZSBuZXcgc3RhdGUgb2YgdGhlIGNsaWVudC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbnN0YXRlY2hhbmdlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW4gdGhlIHJlbW90ZSBjbGllbnQgc2VuZHMgYSBuYW1lIHVwZGF0ZS5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmV3IG5hbWUgb2YgdGhpcyBjbGllbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25uYW1lID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW4gYW4gZXJyb3IgaXMgcmVwb3J0ZWQgYnkgdGhlIHJlbW90ZSBjbGllbnQsIGFuZCB0aGUgY29ubmVjdGlvblxyXG4gICAgICogaXMgYmVpbmcgY2xvc2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLlN0YXR1c30gc3RhdHVzIEEgc3RhdHVzIG9iamVjdCB3aGljaCBkZXNjcmliZXMgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmVycm9yID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW4gYSBhdWRpbyBzdHJlYW0gaXMgY3JlYXRlZC4gVGhlIHN0cmVhbSBwcm92aWRlZCB0byB0aGlzIGV2ZW50XHJcbiAgICAgKiBoYW5kbGVyIHdpbGwgY29udGFpbiBpdHMgb3duIGV2ZW50IGhhbmRsZXJzIGZvciByZWNlaXZlZCBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuSW5wdXRTdHJlYW19IHN0cmVhbVxyXG4gICAgICogICAgIFRoZSBzdHJlYW0gdGhhdCB3aWxsIHJlY2VpdmUgYXVkaW8gZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAgICAgKiAgICAgVGhlIG1pbWV0eXBlIG9mIHRoZSBhdWRpbyBkYXRhIHdoaWNoIHdpbGwgYmUgcmVjZWl2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7R3VhY2Ftb2xlLkF1ZGlvUGxheWVyfVxyXG4gICAgICogICAgIEFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZSBHdWFjYW1vbGUuQXVkaW9QbGF5ZXIgaW50ZXJmYWNlIGFuZFxyXG4gICAgICogICAgIGhhcyBiZWVuIGluaXRpYWxpZWQgdG8gcGxheSB0aGUgZGF0YSBpbiB0aGUgcHJvdmlkZWQgc3RyZWFtLCBvciBudWxsXHJcbiAgICAgKiAgICAgaWYgdGhlIGJ1aWx0LWluIGF1ZGlvIHBsYXllcnMgb2YgdGhlIEd1YWNhbW9sZSBjbGllbnQgc2hvdWxkIGJlXHJcbiAgICAgKiAgICAgdXNlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmF1ZGlvID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW4gYSB2aWRlbyBzdHJlYW0gaXMgY3JlYXRlZC4gVGhlIHN0cmVhbSBwcm92aWRlZCB0byB0aGlzIGV2ZW50XHJcbiAgICAgKiBoYW5kbGVyIHdpbGwgY29udGFpbiBpdHMgb3duIGV2ZW50IGhhbmRsZXJzIGZvciByZWNlaXZlZCBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuSW5wdXRTdHJlYW19IHN0cmVhbVxyXG4gICAgICogICAgIFRoZSBzdHJlYW0gdGhhdCB3aWxsIHJlY2VpdmUgdmlkZW8gZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ9IGxheWVyXHJcbiAgICAgKiAgICAgVGhlIGRlc3RpbmF0aW9uIGxheWVyIG9uIHdoaWNoIHRoZSByZWNlaXZlZCB2aWRlbyBkYXRhIHNob3VsZCBiZVxyXG4gICAgICogICAgIHBsYXllZC4gSXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBHdWFjYW1vbGUuVmlkZW9QbGF5ZXJcclxuICAgICAqICAgICBpbXBsZW1lbnRhdGlvbiB0byBwbGF5IHRoZSByZWNlaXZlZCBkYXRhIHdpdGhpbiB0aGlzIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gICAgICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgdmlkZW8gZGF0YSB3aGljaCB3aWxsIGJlIHJlY2VpdmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0d1YWNhbW9sZS5WaWRlb1BsYXllcn1cclxuICAgICAqICAgICBBbiBvYmplY3Qgd2hpY2ggaW1wbGVtZW50cyB0aGUgR3VhY2Ftb2xlLlZpZGVvUGxheWVyIGludGVyZmFjZSBhbmRcclxuICAgICAqICAgICBoYXMgYmVlbiBpbml0aWFsaWVkIHRvIHBsYXkgdGhlIGRhdGEgaW4gdGhlIHByb3ZpZGVkIHN0cmVhbSwgb3IgbnVsbFxyXG4gICAgICogICAgIGlmIHRoZSBidWlsdC1pbiB2aWRlbyBwbGF5ZXJzIG9mIHRoZSBHdWFjYW1vbGUgY2xpZW50IHNob3VsZCBiZVxyXG4gICAgICogICAgIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub252aWRlbyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgY29ubmVjdGlvbiBwYXJhbWV0ZXIgaXMgYmVpbmcgZXhwb3NlZFxyXG4gICAgICogYnkgdGhlIHNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLklucHV0U3RyZWFtfSBzdHJlYW1cclxuICAgICAqICAgICBUaGUgc3RyZWFtIHRoYXQgd2lsbCByZWNlaXZlIGNvbm5lY3Rpb24gcGFyYW1ldGVyIGRhdGEgZnJvbSB0aGVcclxuICAgICAqICAgICBzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAgICAgKiAgICAgVGhlIG1pbWV0eXBlIG9mIHRoZSBkYXRhIHdoaWNoIHdpbGwgYmUgcmVjZWl2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUgY29ubmVjdGlvbiBwYXJhbWV0ZXIgd2hvc2UgdmFsdWUgaXMgYmVpbmcgZXhwb3NlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmFyZ3YgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiB0aGUgY2xpcGJvYXJkIG9mIHRoZSByZW1vdGUgY2xpZW50IGlzIGNoYW5naW5nLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLklucHV0U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSB0aGF0IHdpbGwgcmVjZWl2ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwYm9hcmQgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGUgVGhlIG1pbWV0eXBlIG9mIHRoZSBkYXRhIHdoaWNoIHdpbGwgYmUgcmVjZWl2ZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25jbGlwYm9hcmQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiBhIGZpbGUgc3RyZWFtIGlzIGNyZWF0ZWQuIFRoZSBzdHJlYW0gcHJvdmlkZWQgdG8gdGhpcyBldmVudFxyXG4gICAgICogaGFuZGxlciB3aWxsIGNvbnRhaW4gaXRzIG93biBldmVudCBoYW5kbGVycyBmb3IgcmVjZWl2ZWQgZGF0YS5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gc3RyZWFtIFRoZSBzdHJlYW0gdGhhdCB3aWxsIHJlY2VpdmUgZGF0YVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGUgVGhlIG1pbWV0eXBlIG9mIHRoZSBmaWxlIHJlY2VpdmVkLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHJlY2VpdmVkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uZmlsZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIGEgZmlsZXN5c3RlbSBvYmplY3QgaXMgY3JlYXRlZC4gVGhlIG9iamVjdCBwcm92aWRlZCB0byB0aGlzXHJcbiAgICAgKiBldmVudCBoYW5kbGVyIHdpbGwgY29udGFpbiBpdHMgb3duIGV2ZW50IGhhbmRsZXJzIGFuZCBmdW5jdGlvbnMgZm9yXHJcbiAgICAgKiByZXF1ZXN0aW5nIGFuZCBoYW5kbGluZyBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuT2JqZWN0fSBvYmplY3RcclxuICAgICAqICAgICBUaGUgY3JlYXRlZCBmaWxlc3lzdGVtIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAgICogICAgIFRoZSBuYW1lIG9mIHRoZSBmaWxlc3lzdGVtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uZmlsZXN5c3RlbSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIGEgcGlwZSBzdHJlYW0gaXMgY3JlYXRlZC4gVGhlIHN0cmVhbSBwcm92aWRlZCB0byB0aGlzIGV2ZW50XHJcbiAgICAgKiBoYW5kbGVyIHdpbGwgY29udGFpbiBpdHMgb3duIGV2ZW50IGhhbmRsZXJzIGZvciByZWNlaXZlZCBkYXRhO1xyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLklucHV0U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSB0aGF0IHdpbGwgcmVjZWl2ZSBkYXRhXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZSBUaGUgbWltZXR5cGUgb2YgdGhlIGRhdGEgd2hpY2ggd2lsbCBiZSByZWNlaXZlZC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwaXBlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9ucGlwZSA9IG51bGw7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiBhIFwicmVxdWlyZWRcIiBpbnN0cnVjdGlvbiBpcyByZWNlaXZlZC4gQSByZXF1aXJlZCBpbnN0cnVjdGlvblxyXG4gICAgICogaW5kaWNhdGVzIHRoYXQgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZCBmb3IgdGhlIGNvbm5lY3Rpb24gdG9cclxuICAgICAqIGNvbnRpbnVlLCBzdWNoIGFzIHVzZXIgY3JlZGVudGlhbHMuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGFyYW1ldGVyc1xyXG4gICAgICogICAgICBUaGUgbmFtZXMgb2YgdGhlIGNvbm5lY3Rpb24gcGFyYW1ldGVycyB0aGF0IGFyZSByZXF1aXJlZCB0byBiZVxyXG4gICAgICogICAgICBwcm92aWRlZCBmb3IgdGhlIGNvbm5lY3Rpb24gdG8gY29udGludWUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25yZXF1aXJlZCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciBhIHN5bmMgaW5zdHJ1Y3Rpb24gaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLCBpbmRpY2F0aW5nXHJcbiAgICAgKiB0aGF0IHRoZSBzZXJ2ZXIgaXMgZmluaXNoZWQgcHJvY2Vzc2luZyBhbnkgaW5wdXQgZnJvbSB0aGUgY2xpZW50IGFuZFxyXG4gICAgICogaGFzIHNlbnQgYW55IHJlc3VsdHMuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3luY1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbnN5bmMgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW5kZXgsIGNyZWF0aW5nIGl0IGlmIG5lY2Vzc2FyeS5cclxuICAgICAqIFBvc2l0aXZlIGluZGljZXMgcmVmZXIgdG8gdmlzaWJsZSBsYXllcnMsIGFuIGluZGV4IG9mIHplcm8gcmVmZXJzIHRvXHJcbiAgICAgKiB0aGUgZGVmYXVsdCBsYXllciwgYW5kIG5lZ2F0aXZlIGluZGljZXMgcmVmZXIgdG8gYnVmZmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XHJcbiAgICAgKiAgICAgVGhlIGluZGV4IG9mIHRoZSBsYXllciB0byByZXRyaWV2ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ8R3VhY2Ftb2xlLkxheWVyfVxyXG4gICAgICogICAgIFRoZSBsYXllciBoYXZpbmcgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgICovXHJcbiAgICB2YXIgZ2V0TGF5ZXIgPSBmdW5jdGlvbiBnZXRMYXllcihpbmRleCkge1xyXG5cclxuICAgICAgICAvLyBHZXQgbGF5ZXIsIGNyZWF0ZSBpZiBuZWNlc3NhcnlcclxuICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaW5kZXhdO1xyXG4gICAgICAgIGlmICghbGF5ZXIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBsYXllciBiYXNlZCBvbiBpbmRleFxyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApXHJcbiAgICAgICAgICAgICAgICBsYXllciA9IGRpc3BsYXkuZ2V0RGVmYXVsdExheWVyKCk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID4gMClcclxuICAgICAgICAgICAgICAgIGxheWVyID0gZGlzcGxheS5jcmVhdGVMYXllcigpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBsYXllciA9IGRpc3BsYXkuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQWRkIG5ldyBsYXllclxyXG4gICAgICAgICAgICBsYXllcnNbaW5kZXhdID0gbGF5ZXI7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxheWVyO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBwYXNzZWQgdG8gZ2V0TGF5ZXIoKSB3aGVuIHRoZSBnaXZlbiBsYXllciB3YXMgY3JlYXRlZC5cclxuICAgICAqIFBvc2l0aXZlIGluZGljZXMgcmVmZXIgdG8gdmlzaWJsZSBsYXllcnMsIGFuIGluZGV4IG9mIHplcm8gcmVmZXJzIHRvIHRoZVxyXG4gICAgICogZGVmYXVsdCBsYXllciwgYW5kIG5lZ2F0aXZlIGluZGljZXMgcmVmZXIgdG8gYnVmZmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllcnxHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyXHJcbiAgICAgKiAgICAgVGhlIGxheWVyIHdob3NlIGluZGV4IHNob3VsZCBiZSBkZXRlcm1pbmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiAgICAgVGhlIGluZGV4IG9mIHRoZSBnaXZlbiBsYXllciwgb3IgbnVsbCBpZiBubyBzdWNoIGxheWVyIGlzIGFzc29jaWF0ZWRcclxuICAgICAqICAgICB3aXRoIHRoaXMgY2xpZW50LlxyXG4gICAgICovXHJcbiAgICB2YXIgZ2V0TGF5ZXJJbmRleCA9IGZ1bmN0aW9uIGdldExheWVySW5kZXgobGF5ZXIpIHtcclxuXHJcbiAgICAgICAgLy8gQXZvaWQgc2VhcmNoaW5nIGlmIHRoZXJlIGNsZWFybHkgaXMgbm8gc3VjaCBsYXllclxyXG4gICAgICAgIGlmICghbGF5ZXIpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAvLyBTZWFyY2ggdGhyb3VnaCBlYWNoIGxheWVyLCByZXR1cm5pbmcgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBsYXllclxyXG4gICAgICAgIC8vIG9uY2UgZm91bmRcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXllciA9PT0gbGF5ZXJzW2tleV0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoa2V5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbm8gc3VjaCBpbmRleFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VyKGluZGV4KSB7XHJcblxyXG4gICAgICAgIHZhciBwYXJzZXIgPSBwYXJzZXJzW2luZGV4XTtcclxuXHJcbiAgICAgICAgLy8gSWYgcGFyc2VyIG5vdCB5ZXQgY3JlYXRlZCwgY3JlYXRlIGl0LCBhbmQgdGllIHRvIHRoZVxyXG4gICAgICAgIC8vIG9uaW5zdHJ1Y3Rpb24gaGFuZGxlciBvZiB0aGUgdHVubmVsLlxyXG4gICAgICAgIGlmIChwYXJzZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwYXJzZXIgPSBwYXJzZXJzW2luZGV4XSA9IG5ldyBHdWFjYW1vbGUuUGFyc2VyKCk7XHJcbiAgICAgICAgICAgIHBhcnNlci5vbmluc3RydWN0aW9uID0gdHVubmVsLm9uaW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGFyc2VyO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXJzIGZvciBhbGwgZGVmaW5lZCBsYXllciBwcm9wZXJ0aWVzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGxheWVyUHJvcGVydHlIYW5kbGVycyA9IHtcclxuXHJcbiAgICAgICAgXCJtaXRlci1saW1pdFwiOiBmdW5jdGlvbihsYXllciwgdmFsdWUpIHtcclxuICAgICAgICAgICAgZGlzcGxheS5zZXRNaXRlckxpbWl0KGxheWVyLCBwYXJzZUZsb2F0KHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcnMgZm9yIGFsbCBpbnN0cnVjdGlvbiBvcGNvZGVzIHJlY2VpdmFibGUgYnkgYSBHdWFjYW1vbGUgcHJvdG9jb2xcclxuICAgICAqIGNsaWVudC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBpbnN0cnVjdGlvbkhhbmRsZXJzID0ge1xyXG5cclxuICAgICAgICBcImFja1wiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RyZWFtX2luZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciByZWFzb24gPSBwYXJhbWV0ZXJzWzFdO1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHN0cmVhbVxyXG4gICAgICAgICAgICB2YXIgc3RyZWFtID0gb3V0cHV0X3N0cmVhbXNbc3RyZWFtX2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKHN0cmVhbSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNpZ25hbCBhY2sgaWYgaGFuZGxlciBkZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLm9uYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5vbmFjayhuZXcgR3VhY2Ftb2xlLlN0YXR1cyhjb2RlLCByZWFzb24pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBjb2RlIGlzIGFuIGVycm9yLCBpbnZhbGlkYXRlIHN0cmVhbSBpZiBub3QgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgLy8gaW52YWxpZGF0ZWQgYnkgb25hY2sgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gMHgwMTAwICYmIG91dHB1dF9zdHJlYW1zW3N0cmVhbV9pbmRleF0gPT09IHN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbV9pbmRpY2VzLmZyZWUoc3RyZWFtX2luZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3V0cHV0X3N0cmVhbXNbc3RyZWFtX2luZGV4XTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJhcmNcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1swXSkpO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pO1xyXG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gcGFyc2VJbnQocGFyYW1ldGVyc1szXSk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzWzRdKTtcclxuICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzWzVdKTtcclxuICAgICAgICAgICAgdmFyIG5lZ2F0aXZlID0gcGFyc2VJbnQocGFyYW1ldGVyc1s2XSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LmFyYyhsYXllciwgeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgbmVnYXRpdmUgIT0gMCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiYXJndlwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RyZWFtX2luZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBtaW1ldHlwZSA9IHBhcmFtZXRlcnNbMV07XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGFyYW1ldGVyc1syXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzdHJlYW1cclxuICAgICAgICAgICAgaWYgKGd1YWNfY2xpZW50Lm9uYXJndikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0cmVhbSA9IHN0cmVhbXNbc3RyZWFtX2luZGV4XSA9IG5ldyBHdWFjYW1vbGUuSW5wdXRTdHJlYW0oZ3VhY19jbGllbnQsIHN0cmVhbV9pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5vbmFyZ3Yoc3RyZWFtLCBtaW1ldHlwZSwgbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdW5zdXBwb3J0ZWRcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZ3VhY19jbGllbnQuc2VuZEFjayhzdHJlYW1faW5kZXgsIFwiUmVjZWl2aW5nIGFyZ3VtZW50IHZhbHVlcyB1bnN1cHBvcnRlZFwiLCAweDAxMDApO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImF1ZGlvXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHJlYW1faW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIG1pbWV0eXBlID0gcGFyYW1ldGVyc1sxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gXHJcbiAgICAgICAgICAgIHZhciBzdHJlYW0gPSBzdHJlYW1zW3N0cmVhbV9pbmRleF0gPVxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBHdWFjYW1vbGUuSW5wdXRTdHJlYW0oZ3VhY19jbGllbnQsIHN0cmVhbV9pbmRleCk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgcGxheWVyIGluc3RhbmNlIHZpYSBjYWxsYmFja1xyXG4gICAgICAgICAgICB2YXIgYXVkaW9QbGF5ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZ3VhY19jbGllbnQub25hdWRpbylcclxuICAgICAgICAgICAgICAgIGF1ZGlvUGxheWVyID0gZ3VhY19jbGllbnQub25hdWRpbyhzdHJlYW0sIG1pbWV0eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHVuc3VjY2Vzc2Z1bCwgdHJ5IHRvIHVzZSBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAgICAgaWYgKCFhdWRpb1BsYXllcilcclxuICAgICAgICAgICAgICAgIGF1ZGlvUGxheWVyID0gR3VhY2Ftb2xlLkF1ZGlvUGxheWVyLmdldEluc3RhbmNlKHN0cmVhbSwgbWltZXR5cGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBzdWNjZXNzZnVsbHkgcmV0cmlldmVkIGFuIGF1ZGlvIHBsYXllciwgc2VuZCBzdWNjZXNzIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIGlmIChhdWRpb1BsYXllcikge1xyXG4gICAgICAgICAgICAgICAgYXVkaW9QbGF5ZXJzW3N0cmVhbV9pbmRleF0gPSBhdWRpb1BsYXllcjtcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50LnNlbmRBY2soc3RyZWFtX2luZGV4LCBcIk9LXCIsIDB4MDAwMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgbWltZXR5cGUgbXVzdCBiZSB1bnN1cHBvcnRlZFxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5zZW5kQWNrKHN0cmVhbV9pbmRleCwgXCJCQUQgVFlQRVwiLCAweDAzMEYpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImJsb2JcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHN0cmVhbSBcclxuICAgICAgICAgICAgdmFyIHN0cmVhbV9pbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHBhcmFtZXRlcnNbMV07XHJcbiAgICAgICAgICAgIHZhciBzdHJlYW0gPSBzdHJlYW1zW3N0cmVhbV9pbmRleF07XHJcblxyXG4gICAgICAgICAgICAvLyBXcml0ZSBkYXRhXHJcbiAgICAgICAgICAgIGlmIChzdHJlYW0gJiYgc3RyZWFtLm9uYmxvYilcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5vbmJsb2IoZGF0YSk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiYm9keVwiIDogZnVuY3Rpb24gaGFuZGxlQm9keShwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgb2JqZWN0XHJcbiAgICAgICAgICAgIHZhciBvYmplY3RJbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0c1tvYmplY3RJbmRleF07XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RyZWFtSW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzFdKTtcclxuICAgICAgICAgICAgdmFyIG1pbWV0eXBlID0gcGFyYW1ldGVyc1syXTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBwYXJhbWV0ZXJzWzNdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHN0cmVhbSBpZiBoYW5kbGVyIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3Qub25ib2R5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyZWFtID0gc3RyZWFtc1tzdHJlYW1JbmRleF0gPSBuZXcgR3VhY2Ftb2xlLklucHV0U3RyZWFtKGd1YWNfY2xpZW50LCBzdHJlYW1JbmRleCk7XHJcbiAgICAgICAgICAgICAgICBvYmplY3Qub25ib2R5KHN0cmVhbSwgbWltZXR5cGUsIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHVuc3VwcG9ydGVkXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50LnNlbmRBY2soc3RyZWFtSW5kZXgsIFwiUmVjZWlwdCBvZiBib2R5IHVuc3VwcG9ydGVkXCIsIDB4MDEwMCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiY2ZpbGxcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoYW5uZWxNYXNrID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pKTtcclxuICAgICAgICAgICAgdmFyIHIgPSBwYXJzZUludChwYXJhbWV0ZXJzWzJdKTtcclxuICAgICAgICAgICAgdmFyIGcgPSBwYXJzZUludChwYXJhbWV0ZXJzWzNdKTtcclxuICAgICAgICAgICAgdmFyIGIgPSBwYXJzZUludChwYXJhbWV0ZXJzWzRdKTtcclxuICAgICAgICAgICAgdmFyIGEgPSBwYXJzZUludChwYXJhbWV0ZXJzWzVdKTtcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXkuc2V0Q2hhbm5lbE1hc2sobGF5ZXIsIGNoYW5uZWxNYXNrKTtcclxuICAgICAgICAgICAgZGlzcGxheS5maWxsQ29sb3IobGF5ZXIsIHIsIGcsIGIsIGEpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImNsaXBcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1swXSkpO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS5jbGlwKGxheWVyKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJjbGlwYm9hcmRcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0cmVhbV9pbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgbWltZXR5cGUgPSBwYXJhbWV0ZXJzWzFdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHN0cmVhbSBcclxuICAgICAgICAgICAgaWYgKGd1YWNfY2xpZW50Lm9uY2xpcGJvYXJkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyZWFtID0gc3RyZWFtc1tzdHJlYW1faW5kZXhdID0gbmV3IEd1YWNhbW9sZS5JbnB1dFN0cmVhbShndWFjX2NsaWVudCwgc3RyZWFtX2luZGV4KTtcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50Lm9uY2xpcGJvYXJkKHN0cmVhbSwgbWltZXR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHVuc3VwcG9ydGVkXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50LnNlbmRBY2soc3RyZWFtX2luZGV4LCBcIkNsaXBib2FyZCB1bnN1cHBvcnRlZFwiLCAweDAxMDApO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImNsb3NlXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pKTtcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXkuY2xvc2UobGF5ZXIpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImNvcHlcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHNyY0wgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcbiAgICAgICAgICAgIHZhciBzcmNYID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciBzcmNZID0gcGFyc2VJbnQocGFyYW1ldGVyc1syXSk7XHJcbiAgICAgICAgICAgIHZhciBzcmNXaWR0aCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbM10pO1xyXG4gICAgICAgICAgICB2YXIgc3JjSGVpZ2h0ID0gcGFyc2VJbnQocGFyYW1ldGVyc1s0XSk7XHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsTWFzayA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNV0pO1xyXG4gICAgICAgICAgICB2YXIgZHN0TCA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbNl0pKTtcclxuICAgICAgICAgICAgdmFyIGRzdFggPSBwYXJzZUludChwYXJhbWV0ZXJzWzddKTtcclxuICAgICAgICAgICAgdmFyIGRzdFkgPSBwYXJzZUludChwYXJhbWV0ZXJzWzhdKTtcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXkuc2V0Q2hhbm5lbE1hc2soZHN0TCwgY2hhbm5lbE1hc2spO1xyXG4gICAgICAgICAgICBkaXNwbGF5LmNvcHkoc3JjTCwgc3JjWCwgc3JjWSwgc3JjV2lkdGgsIHNyY0hlaWdodCwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBkc3RMLCBkc3RYLCBkc3RZKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJjc3Ryb2tlXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsTWFzayA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzFdKSk7XHJcbiAgICAgICAgICAgIHZhciBjYXAgPSBsaW5lQ2FwW3BhcnNlSW50KHBhcmFtZXRlcnNbMl0pXTtcclxuICAgICAgICAgICAgdmFyIGpvaW4gPSBsaW5lSm9pbltwYXJzZUludChwYXJhbWV0ZXJzWzNdKV07XHJcbiAgICAgICAgICAgIHZhciB0aGlja25lc3MgPSBwYXJzZUludChwYXJhbWV0ZXJzWzRdKTtcclxuICAgICAgICAgICAgdmFyIHIgPSBwYXJzZUludChwYXJhbWV0ZXJzWzVdKTtcclxuICAgICAgICAgICAgdmFyIGcgPSBwYXJzZUludChwYXJhbWV0ZXJzWzZdKTtcclxuICAgICAgICAgICAgdmFyIGIgPSBwYXJzZUludChwYXJhbWV0ZXJzWzddKTtcclxuICAgICAgICAgICAgdmFyIGEgPSBwYXJzZUludChwYXJhbWV0ZXJzWzhdKTtcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXkuc2V0Q2hhbm5lbE1hc2sobGF5ZXIsIGNoYW5uZWxNYXNrKTtcclxuICAgICAgICAgICAgZGlzcGxheS5zdHJva2VDb2xvcihsYXllciwgY2FwLCBqb2luLCB0aGlja25lc3MsIHIsIGcsIGIsIGEpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImN1cnNvclwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY3Vyc29ySG90c3BvdFggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGN1cnNvckhvdHNwb3RZID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciBzcmNMID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1syXSkpO1xyXG4gICAgICAgICAgICB2YXIgc3JjWCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbM10pO1xyXG4gICAgICAgICAgICB2YXIgc3JjWSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNF0pO1xyXG4gICAgICAgICAgICB2YXIgc3JjV2lkdGggPSBwYXJzZUludChwYXJhbWV0ZXJzWzVdKTtcclxuICAgICAgICAgICAgdmFyIHNyY0hlaWdodCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNl0pO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS5zZXRDdXJzb3IoY3Vyc29ySG90c3BvdFgsIGN1cnNvckhvdHNwb3RZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNMLCBzcmNYLCBzcmNZLCBzcmNXaWR0aCwgc3JjSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJjdXJ2ZVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcbiAgICAgICAgICAgIHZhciBjcDF4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciBjcDF5ID0gcGFyc2VJbnQocGFyYW1ldGVyc1syXSk7XHJcbiAgICAgICAgICAgIHZhciBjcDJ4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1szXSk7XHJcbiAgICAgICAgICAgIHZhciBjcDJ5ID0gcGFyc2VJbnQocGFyYW1ldGVyc1s0XSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1s1XSk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQocGFyYW1ldGVyc1s2XSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LmN1cnZlVG8obGF5ZXIsIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImRpc2Nvbm5lY3RcIiA6IGZ1bmN0aW9uIGhhbmRsZURpc2Nvbm5lY3QocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgLy8gRXhwbGljaXRseSB0ZWFyIGRvd24gY29ubmVjdGlvblxyXG4gICAgICAgICAgICBndWFjX2NsaWVudC5kaXNjb25uZWN0KCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiZGlzcG9zZVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbGF5ZXJfaW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHZpc2libGUgbGF5ZXIsIHJlbW92ZSBmcm9tIHBhcmVudFxyXG4gICAgICAgICAgICBpZiAobGF5ZXJfaW5kZXggPiAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gcGFyZW50XHJcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihsYXllcl9pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmRpc3Bvc2UobGF5ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlbGV0ZSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBsYXllcnNbbGF5ZXJfaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgYnVmZmVyLCBqdXN0IGRlbGV0ZSByZWZlcmVuY2VcclxuICAgICAgICAgICAgZWxzZSBpZiAobGF5ZXJfaW5kZXggPCAwKVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGxheWVyc1tsYXllcl9pbmRleF07XHJcblxyXG4gICAgICAgICAgICAvLyBBdHRlbXB0aW5nIHRvIGRpc3Bvc2UgdGhlIHJvb3QgbGF5ZXIgY3VycmVudGx5IGhhcyBubyBlZmZlY3QuXHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiZGlzdG9ydFwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXJfaW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGEgPSBwYXJzZUZsb2F0KHBhcmFtZXRlcnNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgYiA9IHBhcnNlRmxvYXQocGFyYW1ldGVyc1syXSk7XHJcbiAgICAgICAgICAgIHZhciBjID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzWzNdKTtcclxuICAgICAgICAgICAgdmFyIGQgPSBwYXJzZUZsb2F0KHBhcmFtZXRlcnNbNF0pO1xyXG4gICAgICAgICAgICB2YXIgZSA9IHBhcnNlRmxvYXQocGFyYW1ldGVyc1s1XSk7XHJcbiAgICAgICAgICAgIHZhciBmID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzWzZdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgdmFsaWQgZm9yIHZpc2libGUgbGF5ZXJzIChub3QgYnVmZmVycylcclxuICAgICAgICAgICAgaWYgKGxheWVyX2luZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKGxheWVyX2luZGV4KTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkuZGlzdG9ydChsYXllciwgYSwgYiwgYywgZCwgZSwgZik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuIFxyXG4gICAgICAgIFwiZXJyb3JcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHBhcmFtZXRlcnNbMF07XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxsIGhhbmRsZXIgaWYgZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoZ3VhY19jbGllbnQub25lcnJvcilcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50Lm9uZXJyb3IobmV3IEd1YWNhbW9sZS5TdGF0dXMoY29kZSwgcmVhc29uKSk7XHJcblxyXG4gICAgICAgICAgICBndWFjX2NsaWVudC5kaXNjb25uZWN0KCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiZW5kXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHJlYW1faW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBzdHJlYW1cclxuICAgICAgICAgICAgdmFyIHN0cmVhbSA9IHN0cmVhbXNbc3RyZWFtX2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKHN0cmVhbSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNpZ25hbCBlbmQgb2Ygc3RyZWFtIGlmIGhhbmRsZXIgZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5vbmVuZClcclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub25lbmQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHN0cmVhbVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0cmVhbXNbc3RyZWFtX2luZGV4XTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJmaWxlXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHJlYW1faW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIG1pbWV0eXBlID0gcGFyYW1ldGVyc1sxXTtcclxuICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gcGFyYW1ldGVyc1syXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gXHJcbiAgICAgICAgICAgIGlmIChndWFjX2NsaWVudC5vbmZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBzdHJlYW1zW3N0cmVhbV9pbmRleF0gPSBuZXcgR3VhY2Ftb2xlLklucHV0U3RyZWFtKGd1YWNfY2xpZW50LCBzdHJlYW1faW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZ3VhY19jbGllbnQub25maWxlKHN0cmVhbSwgbWltZXR5cGUsIGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB1bnN1cHBvcnRlZFxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5zZW5kQWNrKHN0cmVhbV9pbmRleCwgXCJGaWxlIHRyYW5zZmVyIHVuc3VwcG9ydGVkXCIsIDB4MDEwMCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiZmlsZXN5c3RlbVwiIDogZnVuY3Rpb24gaGFuZGxlRmlsZXN5c3RlbShwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqZWN0SW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBwYXJhbWV0ZXJzWzFdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIG9iamVjdCwgaWYgc3VwcG9ydGVkXHJcbiAgICAgICAgICAgIGlmIChndWFjX2NsaWVudC5vbmZpbGVzeXN0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBvYmplY3RzW29iamVjdEluZGV4XSA9IG5ldyBHdWFjYW1vbGUuT2JqZWN0KGd1YWNfY2xpZW50LCBvYmplY3RJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5vbmZpbGVzeXN0ZW0ob2JqZWN0LCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdW5zdXBwb3J0ZWQsIHNpbXBseSBpZ25vcmUgdGhlIGF2YWlsYWJpbGl0eSBvZiB0aGUgZmlsZXN5c3RlbVxyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImlkZW50aXR5XCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pKTtcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXkuc2V0VHJhbnNmb3JtKGxheWVyLCAxLCAwLCAwLCAxLCAwLCAwKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJpbWdcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0cmVhbV9pbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbE1hc2sgPSBwYXJzZUludChwYXJhbWV0ZXJzWzFdKTtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1syXSkpO1xyXG4gICAgICAgICAgICB2YXIgbWltZXR5cGUgPSBwYXJhbWV0ZXJzWzNdO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNF0pO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNV0pO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHN0cmVhbVxyXG4gICAgICAgICAgICB2YXIgc3RyZWFtID0gc3RyZWFtc1tzdHJlYW1faW5kZXhdID0gbmV3IEd1YWNhbW9sZS5JbnB1dFN0cmVhbShndWFjX2NsaWVudCwgc3RyZWFtX2luZGV4KTtcclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgcmVjZWl2ZWQgY29udGVudHMgb25jZSBkZWNvZGVkXHJcbiAgICAgICAgICAgIGRpc3BsYXkuc2V0Q2hhbm5lbE1hc2sobGF5ZXIsIGNoYW5uZWxNYXNrKTtcclxuICAgICAgICAgICAgZGlzcGxheS5kcmF3U3RyZWFtKGxheWVyLCB4LCB5LCBzdHJlYW0sIG1pbWV0eXBlKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJqcGVnXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsTWFzayA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzFdKSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1syXSk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQocGFyYW1ldGVyc1szXSk7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gcGFyYW1ldGVyc1s0XTtcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXkuc2V0Q2hhbm5lbE1hc2sobGF5ZXIsIGNoYW5uZWxNYXNrKTtcclxuICAgICAgICAgICAgZGlzcGxheS5kcmF3KGxheWVyLCB4LCB5LCBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsXCIgKyBkYXRhKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJsZmlsbFwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbE1hc2sgPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1sxXSkpO1xyXG4gICAgICAgICAgICB2YXIgc3JjTGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzJdKSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnNldENoYW5uZWxNYXNrKGxheWVyLCBjaGFubmVsTWFzayk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuZmlsbExheWVyKGxheWVyLCBzcmNMYXllcik7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwibGluZVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQocGFyYW1ldGVyc1syXSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyhsYXllciwgeCwgeSk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwibHN0cm9rZVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbE1hc2sgPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1sxXSkpO1xyXG4gICAgICAgICAgICB2YXIgc3JjTGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzJdKSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnNldENoYW5uZWxNYXNrKGxheWVyLCBjaGFubmVsTWFzayk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuc3Ryb2tlTGF5ZXIobGF5ZXIsIHNyY0xheWVyKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJtb3VzZVwiIDogZnVuY3Rpb24gaGFuZGxlTW91c2UocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUludChwYXJhbWV0ZXJzWzFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc3BsYXkgYW5kIG1vdmUgc29mdHdhcmUgY3Vyc29yIHRvIHJlY2VpdmVkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGRpc3BsYXkuc2hvd0N1cnNvcih0cnVlKTtcclxuICAgICAgICAgICAgZGlzcGxheS5tb3ZlQ3Vyc29yKHgsIHkpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIm1vdmVcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGxheWVyX2luZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRfaW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzFdKTtcclxuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludChwYXJhbWV0ZXJzWzJdKTtcclxuICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUludChwYXJhbWV0ZXJzWzNdKTtcclxuICAgICAgICAgICAgdmFyIHogPSBwYXJzZUludChwYXJhbWV0ZXJzWzRdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgdmFsaWQgZm9yIG5vbi1kZWZhdWx0IGxheWVyc1xyXG4gICAgICAgICAgICBpZiAobGF5ZXJfaW5kZXggPiAwICYmIHBhcmVudF9pbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihsYXllcl9pbmRleCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZ2V0TGF5ZXIocGFyZW50X2luZGV4KTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkubW92ZShsYXllciwgcGFyZW50LCB4LCB5LCB6KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIm5hbWVcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICBpZiAoZ3VhY19jbGllbnQub25uYW1lKSBndWFjX2NsaWVudC5vbm5hbWUocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJuZXN0XCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnNlciA9IGdldFBhcnNlcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcbiAgICAgICAgICAgIHBhcnNlci5yZWNlaXZlKHBhcmFtZXRlcnNbMV0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwicGlwZVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RyZWFtX2luZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBtaW1ldHlwZSA9IHBhcmFtZXRlcnNbMV07XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGFyYW1ldGVyc1syXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gXHJcbiAgICAgICAgICAgIGlmIChndWFjX2NsaWVudC5vbnBpcGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBzdHJlYW1zW3N0cmVhbV9pbmRleF0gPSBuZXcgR3VhY2Ftb2xlLklucHV0U3RyZWFtKGd1YWNfY2xpZW50LCBzdHJlYW1faW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZ3VhY19jbGllbnQub25waXBlKHN0cmVhbSwgbWltZXR5cGUsIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHVuc3VwcG9ydGVkXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50LnNlbmRBY2soc3RyZWFtX2luZGV4LCBcIk5hbWVkIHBpcGVzIHVuc3VwcG9ydGVkXCIsIDB4MDEwMCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwicG5nXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsTWFzayA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzFdKSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1syXSk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQocGFyYW1ldGVyc1szXSk7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gcGFyYW1ldGVyc1s0XTtcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXkuc2V0Q2hhbm5lbE1hc2sobGF5ZXIsIGNoYW5uZWxNYXNrKTtcclxuICAgICAgICAgICAgZGlzcGxheS5kcmF3KGxheWVyLCB4LCB5LCBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIiArIGRhdGEpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcInBvcFwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnBvcChsYXllcik7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwicHVzaFwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnB1c2gobGF5ZXIpO1xyXG5cclxuICAgICAgICB9LFxyXG4gXHJcbiAgICAgICAgXCJyZWN0XCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pKTtcclxuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludChwYXJhbWV0ZXJzWzFdKTtcclxuICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUludChwYXJhbWV0ZXJzWzJdKTtcclxuICAgICAgICAgICAgdmFyIHcgPSBwYXJzZUludChwYXJhbWV0ZXJzWzNdKTtcclxuICAgICAgICAgICAgdmFyIGggPSBwYXJzZUludChwYXJhbWV0ZXJzWzRdKTtcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXkucmVjdChsYXllciwgeCwgeSwgdywgaCk7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICBcInJlcXVpcmVkXCI6IGZ1bmN0aW9uIHJlcXVpcmVkKHBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgaWYgKGd1YWNfY2xpZW50Lm9ucmVxdWlyZWQpIGd1YWNfY2xpZW50Lm9ucmVxdWlyZWQocGFyYW1ldGVycyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICBcInJlc2V0XCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pKTtcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXkucmVzZXQobGF5ZXIpO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIFwic2V0XCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pKTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBwYXJhbWV0ZXJzWzFdO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbWV0ZXJzWzJdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbCBwcm9wZXJ0eSBoYW5kbGVyIGlmIGRlZmluZWRcclxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBsYXllclByb3BlcnR5SGFuZGxlcnNbbmFtZV07XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlcihsYXllciwgdmFsdWUpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcInNoYWRlXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBsYXllcl9pbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgYSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pO1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSB2YWxpZCBmb3IgdmlzaWJsZSBsYXllcnMgKG5vdCBidWZmZXJzKVxyXG4gICAgICAgICAgICBpZiAobGF5ZXJfaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIobGF5ZXJfaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5zaGFkZShsYXllciwgYSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJzaXplXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsYXllcl9pbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihsYXllcl9pbmRleCk7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VJbnQocGFyYW1ldGVyc1syXSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnJlc2l6ZShsYXllciwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgXCJzdGFydFwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQocGFyYW1ldGVyc1syXSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbyhsYXllciwgeCwgeSk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwic3luY1wiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGbHVzaCBkaXNwbGF5LCBzZW5kIHN5bmMgd2hlbiBkb25lXHJcbiAgICAgICAgICAgIGRpc3BsYXkuZmx1c2goZnVuY3Rpb24gZGlzcGxheVN5bmNDb21wbGV0ZSgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTeW5jaHJvbml6ZSBhbGwgYXVkaW8gcGxheWVyc1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggaW4gYXVkaW9QbGF5ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF1ZGlvUGxheWVyID0gYXVkaW9QbGF5ZXJzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW9QbGF5ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvUGxheWVyLnN5bmMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHN5bmMgcmVzcG9uc2UgdG8gc2VydmVyXHJcbiAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wICE9PSBjdXJyZW50VGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwic3luY1wiLCB0aW1lc3RhbXApO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHJlY2VpdmVkIGZpcnN0IHVwZGF0ZSwgbm8gbG9uZ2VyIHdhaXRpbmcuXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IFNUQVRFX1dBSVRJTkcpXHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShTVEFURV9DT05ORUNURUQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbCBzeW5jIGhhbmRsZXIgaWYgZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoZ3VhY19jbGllbnQub25zeW5jKVxyXG4gICAgICAgICAgICAgICAgZ3VhY19jbGllbnQub25zeW5jKHRpbWVzdGFtcCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwidHJhbnNmZXJcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHNyY0wgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcbiAgICAgICAgICAgIHZhciBzcmNYID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciBzcmNZID0gcGFyc2VJbnQocGFyYW1ldGVyc1syXSk7XHJcbiAgICAgICAgICAgIHZhciBzcmNXaWR0aCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbM10pO1xyXG4gICAgICAgICAgICB2YXIgc3JjSGVpZ2h0ID0gcGFyc2VJbnQocGFyYW1ldGVyc1s0XSk7XHJcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbl9pbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNV0pO1xyXG4gICAgICAgICAgICB2YXIgZHN0TCA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbNl0pKTtcclxuICAgICAgICAgICAgdmFyIGRzdFggPSBwYXJzZUludChwYXJhbWV0ZXJzWzddKTtcclxuICAgICAgICAgICAgdmFyIGRzdFkgPSBwYXJzZUludChwYXJhbWV0ZXJzWzhdKTtcclxuXHJcbiAgICAgICAgICAgIC8qIFNSQyAqL1xyXG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25faW5kZXggPT09IDB4MylcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkucHV0KHNyY0wsIHNyY1gsIHNyY1ksIHNyY1dpZHRoLCBzcmNIZWlnaHQsIFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdEwsIGRzdFgsIGRzdFkpO1xyXG5cclxuICAgICAgICAgICAgLyogQW55dGhpbmcgZWxzZSB0aGF0IGlzbid0IGEgTk8tT1AgKi9cclxuICAgICAgICAgICAgZWxzZSBpZiAoZnVuY3Rpb25faW5kZXggIT09IDB4NSlcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkudHJhbnNmZXIoc3JjTCwgc3JjWCwgc3JjWSwgc3JjV2lkdGgsIHNyY0hlaWdodCwgXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0TCwgZHN0WCwgZHN0WSwgR3VhY2Ftb2xlLkNsaWVudC5EZWZhdWx0VHJhbnNmZXJGdW5jdGlvbltmdW5jdGlvbl9pbmRleF0pO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcInRyYW5zZm9ybVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcbiAgICAgICAgICAgIHZhciBhID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzWzFdKTtcclxuICAgICAgICAgICAgdmFyIGIgPSBwYXJzZUZsb2F0KHBhcmFtZXRlcnNbMl0pO1xyXG4gICAgICAgICAgICB2YXIgYyA9IHBhcnNlRmxvYXQocGFyYW1ldGVyc1szXSk7XHJcbiAgICAgICAgICAgIHZhciBkID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzWzRdKTtcclxuICAgICAgICAgICAgdmFyIGUgPSBwYXJzZUZsb2F0KHBhcmFtZXRlcnNbNV0pO1xyXG4gICAgICAgICAgICB2YXIgZiA9IHBhcnNlRmxvYXQocGFyYW1ldGVyc1s2XSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnRyYW5zZm9ybShsYXllciwgYSwgYiwgYywgZCwgZSwgZik7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwidW5kZWZpbmVcIiA6IGZ1bmN0aW9uIGhhbmRsZVVuZGVmaW5lKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBvYmplY3RcclxuICAgICAgICAgICAgdmFyIG9iamVjdEluZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBvYmplY3RzW29iamVjdEluZGV4XTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNpZ25hbCBlbmQgb2Ygb2JqZWN0IGRlZmluaXRpb25cclxuICAgICAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3Qub251bmRlZmluZSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5vbnVuZGVmaW5lKCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwidmlkZW9cIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0cmVhbV9pbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzFdKSk7XHJcbiAgICAgICAgICAgIHZhciBtaW1ldHlwZSA9IHBhcmFtZXRlcnNbMl07XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgc3RyZWFtXHJcbiAgICAgICAgICAgIHZhciBzdHJlYW0gPSBzdHJlYW1zW3N0cmVhbV9pbmRleF0gPVxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBHdWFjYW1vbGUuSW5wdXRTdHJlYW0oZ3VhY19jbGllbnQsIHN0cmVhbV9pbmRleCk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgcGxheWVyIGluc3RhbmNlIHZpYSBjYWxsYmFja1xyXG4gICAgICAgICAgICB2YXIgdmlkZW9QbGF5ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZ3VhY19jbGllbnQub252aWRlbylcclxuICAgICAgICAgICAgICAgIHZpZGVvUGxheWVyID0gZ3VhY19jbGllbnQub252aWRlbyhzdHJlYW0sIGxheWVyLCBtaW1ldHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB1bnN1Y2Nlc3NmdWwsIHRyeSB0byB1c2UgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgICAgIGlmICghdmlkZW9QbGF5ZXIpXHJcbiAgICAgICAgICAgICAgICB2aWRlb1BsYXllciA9IEd1YWNhbW9sZS5WaWRlb1BsYXllci5nZXRJbnN0YW5jZShzdHJlYW0sIGxheWVyLCBtaW1ldHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgYW4gdmlkZW8gcGxheWVyLCBzZW5kIHN1Y2Nlc3MgcmVzcG9uc2VcclxuICAgICAgICAgICAgaWYgKHZpZGVvUGxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICB2aWRlb1BsYXllcnNbc3RyZWFtX2luZGV4XSA9IHZpZGVvUGxheWVyO1xyXG4gICAgICAgICAgICAgICAgZ3VhY19jbGllbnQuc2VuZEFjayhzdHJlYW1faW5kZXgsIFwiT0tcIiwgMHgwMDAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBtaW1ldHlwZSBtdXN0IGJlIHVuc3VwcG9ydGVkXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50LnNlbmRBY2soc3RyZWFtX2luZGV4LCBcIkJBRCBUWVBFXCIsIDB4MDMwRik7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHR1bm5lbC5vbmluc3RydWN0aW9uID0gZnVuY3Rpb24ob3Bjb2RlLCBwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgIHZhciBoYW5kbGVyID0gaW5zdHJ1Y3Rpb25IYW5kbGVyc1tvcGNvZGVdO1xyXG4gICAgICAgIGlmIChoYW5kbGVyKVxyXG4gICAgICAgICAgICBoYW5kbGVyKHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyBhIGRpc2Nvbm5lY3QgaW5zdHJ1Y3Rpb24gdG8gdGhlIHNlcnZlciBhbmQgY2xvc2VzIHRoZSB0dW5uZWwuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBPbmx5IGF0dGVtcHQgZGlzY29ubmVjdGlvbiBub3QgZGlzY29ubmVjdGVkLlxyXG4gICAgICAgIGlmIChjdXJyZW50U3RhdGUgIT0gU1RBVEVfRElTQ09OTkVDVEVEXHJcbiAgICAgICAgICAgICAgICAmJiBjdXJyZW50U3RhdGUgIT0gU1RBVEVfRElTQ09OTkVDVElORykge1xyXG5cclxuICAgICAgICAgICAgc2V0U3RhdGUoU1RBVEVfRElTQ09OTkVDVElORyk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdG9wIHBpbmdcclxuICAgICAgICAgICAgaWYgKHBpbmdJbnRlcnZhbClcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHBpbmdJbnRlcnZhbCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZW5kIGRpc2Nvbm5lY3QgbWVzc2FnZSBhbmQgZGlzY29ubmVjdFxyXG4gICAgICAgICAgICB0dW5uZWwuc2VuZE1lc3NhZ2UoXCJkaXNjb25uZWN0XCIpO1xyXG4gICAgICAgICAgICB0dW5uZWwuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShTVEFURV9ESVNDT05ORUNURUQpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0cyB0aGUgdW5kZXJseWluZyB0dW5uZWwgb2YgdGhpcyBHdWFjYW1vbGUuQ2xpZW50LCBwYXNzaW5nIHRoZVxyXG4gICAgICogZ2l2ZW4gYXJiaXRyYXJ5IGRhdGEgdG8gdGhlIHR1bm5lbCBkdXJpbmcgdGhlIGNvbm5lY3Rpb24gcHJvY2Vzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBBcmJpdHJhcnkgY29ubmVjdGlvbiBkYXRhIHRvIGJlIHNlbnQgdG8gdGhlIHVuZGVybHlpbmdcclxuICAgICAqICAgICAgICAgICAgIHR1bm5lbCBkdXJpbmcgdGhlIGNvbm5lY3Rpb24gcHJvY2Vzcy5cclxuICAgICAqIEB0aHJvd3Mge0d1YWNhbW9sZS5TdGF0dXN9IElmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgY29ubmVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24oZGF0YSkge1xyXG5cclxuICAgICAgICBzZXRTdGF0ZShTVEFURV9DT05ORUNUSU5HKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdHVubmVsLmNvbm5lY3QoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChzdGF0dXMpIHtcclxuICAgICAgICAgICAgc2V0U3RhdGUoU1RBVEVfSURMRSk7XHJcbiAgICAgICAgICAgIHRocm93IHN0YXR1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBpbmcgZXZlcnkgNSBzZWNvbmRzIChlbnN1cmUgY29ubmVjdGlvbiBhbGl2ZSlcclxuICAgICAgICBwaW5nSW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcIm5vcFwiKTtcclxuICAgICAgICB9LCA1MDAwKTtcclxuXHJcbiAgICAgICAgc2V0U3RhdGUoU1RBVEVfV0FJVElORyk7XHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXAgb2YgYWxsIEd1YWNhbW9sZSBiaW5hcnkgcmFzdGVyIG9wZXJhdGlvbnMgdG8gdHJhbnNmZXIgZnVuY3Rpb25zLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuR3VhY2Ftb2xlLkNsaWVudC5EZWZhdWx0VHJhbnNmZXJGdW5jdGlvbiA9IHtcclxuXHJcbiAgICAvKiBCTEFDSyAqL1xyXG4gICAgMHgwOiBmdW5jdGlvbiAoc3JjLCBkc3QpIHtcclxuICAgICAgICBkc3QucmVkID0gZHN0LmdyZWVuID0gZHN0LmJsdWUgPSAweDAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiBXSElURSAqL1xyXG4gICAgMHhGOiBmdW5jdGlvbiAoc3JjLCBkc3QpIHtcclxuICAgICAgICBkc3QucmVkID0gZHN0LmdyZWVuID0gZHN0LmJsdWUgPSAweEZGO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiBTUkMgKi9cclxuICAgIDB4MzogZnVuY3Rpb24gKHNyYywgZHN0KSB7XHJcbiAgICAgICAgZHN0LnJlZCAgID0gc3JjLnJlZDtcclxuICAgICAgICBkc3QuZ3JlZW4gPSBzcmMuZ3JlZW47XHJcbiAgICAgICAgZHN0LmJsdWUgID0gc3JjLmJsdWU7XHJcbiAgICAgICAgZHN0LmFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiBERVNUIChuby1vcCkgKi9cclxuICAgIDB4NTogZnVuY3Rpb24gKHNyYywgZHN0KSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZ1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiBJbnZlcnQgU1JDICovXHJcbiAgICAweEM6IGZ1bmN0aW9uIChzcmMsIGRzdCkge1xyXG4gICAgICAgIGRzdC5yZWQgICA9IDB4RkYgJiB+c3JjLnJlZDtcclxuICAgICAgICBkc3QuZ3JlZW4gPSAweEZGICYgfnNyYy5ncmVlbjtcclxuICAgICAgICBkc3QuYmx1ZSAgPSAweEZGICYgfnNyYy5ibHVlO1xyXG4gICAgICAgIGRzdC5hbHBoYSA9ICBzcmMuYWxwaGE7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvKiBJbnZlcnQgREVTVCAqL1xyXG4gICAgMHhBOiBmdW5jdGlvbiAoc3JjLCBkc3QpIHtcclxuICAgICAgICBkc3QucmVkICAgPSAweEZGICYgfmRzdC5yZWQ7XHJcbiAgICAgICAgZHN0LmdyZWVuID0gMHhGRiAmIH5kc3QuZ3JlZW47XHJcbiAgICAgICAgZHN0LmJsdWUgID0gMHhGRiAmIH5kc3QuYmx1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyogQU5EICovXHJcbiAgICAweDE6IGZ1bmN0aW9uIChzcmMsIGRzdCkge1xyXG4gICAgICAgIGRzdC5yZWQgICA9ICAoIHNyYy5yZWQgICAmICBkc3QucmVkKTtcclxuICAgICAgICBkc3QuZ3JlZW4gPSAgKCBzcmMuZ3JlZW4gJiAgZHN0LmdyZWVuKTtcclxuICAgICAgICBkc3QuYmx1ZSAgPSAgKCBzcmMuYmx1ZSAgJiAgZHN0LmJsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiBOQU5EICovXHJcbiAgICAweEU6IGZ1bmN0aW9uIChzcmMsIGRzdCkge1xyXG4gICAgICAgIGRzdC5yZWQgICA9IDB4RkYgJiB+KCBzcmMucmVkICAgJiAgZHN0LnJlZCk7XHJcbiAgICAgICAgZHN0LmdyZWVuID0gMHhGRiAmIH4oIHNyYy5ncmVlbiAmICBkc3QuZ3JlZW4pO1xyXG4gICAgICAgIGRzdC5ibHVlICA9IDB4RkYgJiB+KCBzcmMuYmx1ZSAgJiAgZHN0LmJsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiBPUiAqL1xyXG4gICAgMHg3OiBmdW5jdGlvbiAoc3JjLCBkc3QpIHtcclxuICAgICAgICBkc3QucmVkICAgPSAgKCBzcmMucmVkICAgfCAgZHN0LnJlZCk7XHJcbiAgICAgICAgZHN0LmdyZWVuID0gICggc3JjLmdyZWVuIHwgIGRzdC5ncmVlbik7XHJcbiAgICAgICAgZHN0LmJsdWUgID0gICggc3JjLmJsdWUgIHwgIGRzdC5ibHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyogTk9SICovXHJcbiAgICAweDg6IGZ1bmN0aW9uIChzcmMsIGRzdCkge1xyXG4gICAgICAgIGRzdC5yZWQgICA9IDB4RkYgJiB+KCBzcmMucmVkICAgfCAgZHN0LnJlZCk7XHJcbiAgICAgICAgZHN0LmdyZWVuID0gMHhGRiAmIH4oIHNyYy5ncmVlbiB8ICBkc3QuZ3JlZW4pO1xyXG4gICAgICAgIGRzdC5ibHVlICA9IDB4RkYgJiB+KCBzcmMuYmx1ZSAgfCAgZHN0LmJsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiBYT1IgKi9cclxuICAgIDB4NjogZnVuY3Rpb24gKHNyYywgZHN0KSB7XHJcbiAgICAgICAgZHN0LnJlZCAgID0gICggc3JjLnJlZCAgIF4gIGRzdC5yZWQpO1xyXG4gICAgICAgIGRzdC5ncmVlbiA9ICAoIHNyYy5ncmVlbiBeICBkc3QuZ3JlZW4pO1xyXG4gICAgICAgIGRzdC5ibHVlICA9ICAoIHNyYy5ibHVlICBeICBkc3QuYmx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qIFhOT1IgKi9cclxuICAgIDB4OTogZnVuY3Rpb24gKHNyYywgZHN0KSB7XHJcbiAgICAgICAgZHN0LnJlZCAgID0gMHhGRiAmIH4oIHNyYy5yZWQgICBeICBkc3QucmVkKTtcclxuICAgICAgICBkc3QuZ3JlZW4gPSAweEZGICYgfiggc3JjLmdyZWVuIF4gIGRzdC5ncmVlbik7XHJcbiAgICAgICAgZHN0LmJsdWUgID0gMHhGRiAmIH4oIHNyYy5ibHVlICBeICBkc3QuYmx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qIEFORCBpbnZlcnRlZCBzb3VyY2UgKi9cclxuICAgIDB4NDogZnVuY3Rpb24gKHNyYywgZHN0KSB7XHJcbiAgICAgICAgZHN0LnJlZCAgID0gIDB4RkYgJiAofnNyYy5yZWQgICAmICBkc3QucmVkKTtcclxuICAgICAgICBkc3QuZ3JlZW4gPSAgMHhGRiAmICh+c3JjLmdyZWVuICYgIGRzdC5ncmVlbik7XHJcbiAgICAgICAgZHN0LmJsdWUgID0gIDB4RkYgJiAofnNyYy5ibHVlICAmICBkc3QuYmx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qIE9SIGludmVydGVkIHNvdXJjZSAqL1xyXG4gICAgMHhEOiBmdW5jdGlvbiAoc3JjLCBkc3QpIHtcclxuICAgICAgICBkc3QucmVkICAgPSAgMHhGRiAmICh+c3JjLnJlZCAgIHwgIGRzdC5yZWQpO1xyXG4gICAgICAgIGRzdC5ncmVlbiA9ICAweEZGICYgKH5zcmMuZ3JlZW4gfCAgZHN0LmdyZWVuKTtcclxuICAgICAgICBkc3QuYmx1ZSAgPSAgMHhGRiAmICh+c3JjLmJsdWUgIHwgIGRzdC5ibHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyogQU5EIGludmVydGVkIGRlc3RpbmF0aW9uICovXHJcbiAgICAweDI6IGZ1bmN0aW9uIChzcmMsIGRzdCkge1xyXG4gICAgICAgIGRzdC5yZWQgICA9ICAweEZGICYgKCBzcmMucmVkICAgJiB+ZHN0LnJlZCk7XHJcbiAgICAgICAgZHN0LmdyZWVuID0gIDB4RkYgJiAoIHNyYy5ncmVlbiAmIH5kc3QuZ3JlZW4pO1xyXG4gICAgICAgIGRzdC5ibHVlICA9ICAweEZGICYgKCBzcmMuYmx1ZSAgJiB+ZHN0LmJsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiBPUiBpbnZlcnRlZCBkZXN0aW5hdGlvbiAqL1xyXG4gICAgMHhCOiBmdW5jdGlvbiAoc3JjLCBkc3QpIHtcclxuICAgICAgICBkc3QucmVkICAgPSAgMHhGRiAmICggc3JjLnJlZCAgIHwgfmRzdC5yZWQpO1xyXG4gICAgICAgIGRzdC5ncmVlbiA9ICAweEZGICYgKCBzcmMuZ3JlZW4gfCB+ZHN0LmdyZWVuKTtcclxuICAgICAgICBkc3QuYmx1ZSAgPSAgMHhGRiAmICggc3JjLmJsdWUgIHwgfmRzdC5ibHVlKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIHJlYWRlciB3aGljaCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgdGhlIGdpdmVuIGlucHV0IHN0cmVhbSwgcmV0dXJuaW5nXHJcbiAqIHJlY2VpdmVkIGJsb2JzIGFzIGEgc2luZ2xlIGRhdGEgVVJJIGJ1aWx0IG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgc3RyZWFtLlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBvYmplY3Qgd2lsbCBvdmVyd3JpdGUgYW55IGluc3RhbGxlZCBldmVudCBoYW5kbGVycyBvbiB0aGVcclxuICogZ2l2ZW4gR3VhY2Ftb2xlLklucHV0U3RyZWFtLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLklucHV0U3RyZWFtfSBzdHJlYW1cclxuICogICAgIFRoZSBzdHJlYW0gdGhhdCBkYXRhIHdpbGwgYmUgcmVhZCBmcm9tLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkRhdGFVUklSZWFkZXIgPSBmdW5jdGlvbihzdHJlYW0sIG1pbWV0eXBlKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuRGF0YVVSSVJlYWRlci5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX3JlYWRlciA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGRhdGEgVVJJLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB2YXIgdXJpID0gJ2RhdGE6JyArIG1pbWV0eXBlICsgJztiYXNlNjQsJztcclxuXHJcbiAgICAvLyBSZWNlaXZlIGJsb2JzIGFzIGFycmF5IGJ1ZmZlcnNcclxuICAgIHN0cmVhbS5vbmJsb2IgPSBmdW5jdGlvbiBkYXRhVVJJUmVhZGVyQmxvYihkYXRhKSB7XHJcblxyXG4gICAgICAgIC8vIEN1cnJlbnRseSBhc3N1bWluZyBkYXRhIHdpbGwgQUxXQVlTIGJlIHNhZmUgdG8gc2ltcGx5IGFwcGVuZC4gVGhpc1xyXG4gICAgICAgIC8vIHdpbGwgbm90IGJlIHRydWUgaWYgdGhlIHJlY2VpdmVkIGJhc2U2NCBkYXRhIGVuY29kZXMgYSBudW1iZXIgb2ZcclxuICAgICAgICAvLyBieXRlcyB0aGF0IGlzbid0IGEgbXVsdGlwbGUgb2YgdGhyZWUgKGFzIGJhc2U2NCBleHBhbmRzIGluIGEgcmF0aW9cclxuICAgICAgICAvLyBvZiBleGFjdGx5IDM6NCkuXHJcbiAgICAgICAgdXJpICs9IGRhdGE7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTaW1wbHkgY2FsbCBvbmVuZCB3aGVuIGVuZCByZWNlaXZlZFxyXG4gICAgc3RyZWFtLm9uZW5kID0gZnVuY3Rpb24gZGF0YVVSSVJlYWRlckVuZCgpIHtcclxuICAgICAgICBpZiAoZ3VhY19yZWFkZXIub25lbmQpXHJcbiAgICAgICAgICAgIGd1YWNfcmVhZGVyLm9uZW5kKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGF0YSBVUkkgb2YgYWxsIGRhdGEgcmVjZWl2ZWQgdGhyb3VnaCB0aGUgdW5kZXJseWluZyBzdHJlYW1cclxuICAgICAqIHRodXMgZmFyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgKiAgICAgVGhlIGRhdGEgVVJJIG9mIGFsbCBkYXRhIHJlY2VpdmVkIHRocm91Z2ggdGhlIHVuZGVybHlpbmcgc3RyZWFtIHRodXNcclxuICAgICAqICAgICBmYXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0VVJJID0gZnVuY3Rpb24gZ2V0VVJJKCkge1xyXG4gICAgICAgIHJldHVybiB1cmk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgb25jZSB0aGlzIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgbm8gZnVydGhlciBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmVuZCA9IG51bGw7XHJcblxyXG59O1xuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgR3VhY2Ftb2xlIGRpc3BsYXkuIFRoZSBkaXNwbGF5IGRvZXMgbm90IGRlYWwgd2l0aCB0aGUgR3VhY2Ftb2xlXHJcbiAqIHByb3RvY29sLCBhbmQgaW5zdGVhZCBpbXBsZW1lbnRzIGEgc2V0IG9mIGdyYXBoaWNhbCBvcGVyYXRpb25zIHdoaWNoXHJcbiAqIGVtYm9keSB0aGUgc2V0IG9mIG9wZXJhdGlvbnMgcHJlc2VudCBpbiB0aGUgcHJvdG9jb2wuIFRoZSBvcmRlciBvcGVyYXRpb25zXHJcbiAqIGFyZSBleGVjdXRlZCBpcyBndWFyYW50ZWVkIHRvIGJlIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZWlyIGNvcnJlc3BvbmRpbmdcclxuICogZnVuY3Rpb25zIGFyZSBjYWxsZWQuXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbkd1YWNhbW9sZS5EaXNwbGF5ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuRGlzcGxheS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX2Rpc3BsYXkgPSB0aGlzO1xyXG5cclxuICAgIHZhciBkaXNwbGF5V2lkdGggPSAwO1xyXG4gICAgdmFyIGRpc3BsYXlIZWlnaHQgPSAwO1xyXG4gICAgdmFyIGRpc3BsYXlTY2FsZSA9IDE7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGRpc3BsYXlcclxuICAgIHZhciBkaXNwbGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgIGRpc3BsYXkuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICBkaXNwbGF5LnN0eWxlLndpZHRoID0gZGlzcGxheVdpZHRoICsgXCJweFwiO1xyXG4gICAgZGlzcGxheS5zdHlsZS5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0ICsgXCJweFwiO1xyXG5cclxuICAgIC8vIEVuc3VyZSB0cmFuc2Zvcm1hdGlvbnMgb24gZGlzcGxheSBvcmlnaW5hdGUgYXQgMCwwXHJcbiAgICBkaXNwbGF5LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9XHJcbiAgICBkaXNwbGF5LnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9XHJcbiAgICBkaXNwbGF5LnN0eWxlLk1velRyYW5zZm9ybU9yaWdpbiA9XHJcbiAgICBkaXNwbGF5LnN0eWxlLk9UcmFuc2Zvcm1PcmlnaW4gPVxyXG4gICAgZGlzcGxheS5zdHlsZS5tc1RyYW5zZm9ybU9yaWdpbiA9XHJcbiAgICAgICAgXCIwIDBcIjtcclxuXHJcbiAgICAvLyBDcmVhdGUgZGVmYXVsdCBsYXllclxyXG4gICAgdmFyIGRlZmF1bHRfbGF5ZXIgPSBuZXcgR3VhY2Ftb2xlLkRpc3BsYXkuVmlzaWJsZUxheWVyKGRpc3BsYXlXaWR0aCwgZGlzcGxheUhlaWdodCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGN1cnNvciBsYXllclxyXG4gICAgdmFyIGN1cnNvciA9IG5ldyBHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXIoMCwgMCk7XHJcbiAgICBjdXJzb3Iuc2V0Q2hhbm5lbE1hc2soR3VhY2Ftb2xlLkxheWVyLlNSQyk7XHJcblxyXG4gICAgLy8gQWRkIGRlZmF1bHQgbGF5ZXIgYW5kIGN1cnNvciB0byBkaXNwbGF5XHJcbiAgICBkaXNwbGF5LmFwcGVuZENoaWxkKGRlZmF1bHRfbGF5ZXIuZ2V0RWxlbWVudCgpKTtcclxuICAgIGRpc3BsYXkuYXBwZW5kQ2hpbGQoY3Vyc29yLmdldEVsZW1lbnQoKSk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGJvdW5kaW5nIGRpdiBcclxuICAgIHZhciBib3VuZHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgYm91bmRzLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgYm91bmRzLnN0eWxlLndpZHRoID0gKGRpc3BsYXlXaWR0aCpkaXNwbGF5U2NhbGUpICsgXCJweFwiO1xyXG4gICAgYm91bmRzLnN0eWxlLmhlaWdodCA9IChkaXNwbGF5SGVpZ2h0KmRpc3BsYXlTY2FsZSkgKyBcInB4XCI7XHJcblxyXG4gICAgLy8gQWRkIGRpc3BsYXkgdG8gYm91bmRzXHJcbiAgICBib3VuZHMuYXBwZW5kQ2hpbGQoZGlzcGxheSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBob3RzcG90IG9mIHRoZSBtb3VzZSBjdXJzb3IuIFRoZSBob3RzcG90IGlzXHJcbiAgICAgKiB0aGUgcmVsYXRpdmUgbG9jYXRpb24gd2l0aGluIHRoZSBpbWFnZSBvZiB0aGUgbW91c2UgY3Vyc29yIGF0IHdoaWNoXHJcbiAgICAgKiBlYWNoIGNsaWNrIG9jY3Vycy5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJzb3JIb3RzcG90WCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBob3RzcG90IG9mIHRoZSBtb3VzZSBjdXJzb3IuIFRoZSBob3RzcG90IGlzXHJcbiAgICAgKiB0aGUgcmVsYXRpdmUgbG9jYXRpb24gd2l0aGluIHRoZSBpbWFnZSBvZiB0aGUgbW91c2UgY3Vyc29yIGF0IHdoaWNoXHJcbiAgICAgKiBlYWNoIGNsaWNrIG9jY3Vycy5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJzb3JIb3RzcG90WSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBYIGNvb3JkaW5hdGUgb2YgdGhlIGxvY2FsIG1vdXNlIGN1cnNvci4gVGhpcyBpcyBub3RcclxuICAgICAqIG5lY2Vzc2FyaWx5IHRoZSBsb2NhdGlvbiBvZiB0aGUgYWN0dWFsIG1vdXNlIC0gaXQgcmVmZXJzIG9ubHkgdG9cclxuICAgICAqIHRoZSBsb2NhdGlvbiBvZiB0aGUgY3Vyc29yIGltYWdlIHdpdGhpbiB0aGUgR3VhY2Ftb2xlIGRpc3BsYXksIGFzXHJcbiAgICAgKiBsYXN0IHNldCBieSBtb3ZlQ3Vyc29yKCkuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3Vyc29yWCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBYIGNvb3JkaW5hdGUgb2YgdGhlIGxvY2FsIG1vdXNlIGN1cnNvci4gVGhpcyBpcyBub3RcclxuICAgICAqIG5lY2Vzc2FyaWx5IHRoZSBsb2NhdGlvbiBvZiB0aGUgYWN0dWFsIG1vdXNlIC0gaXQgcmVmZXJzIG9ubHkgdG9cclxuICAgICAqIHRoZSBsb2NhdGlvbiBvZiB0aGUgY3Vyc29yIGltYWdlIHdpdGhpbiB0aGUgR3VhY2Ftb2xlIGRpc3BsYXksIGFzXHJcbiAgICAgKiBsYXN0IHNldCBieSBtb3ZlQ3Vyc29yKCkuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3Vyc29yWSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBkZWZhdWx0IGxheWVyIChhbmQgdGh1cyB0aGUgZW50aXJlIEd1YWNhbW9sZSBkaXNwbGF5KVxyXG4gICAgICogaXMgcmVzaXplZC5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIG5ldyB3aWR0aCBvZiB0aGUgR3VhY2Ftb2xlIGRpc3BsYXkuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBHdWFjYW1vbGUgZGlzcGxheS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbnJlc2l6ZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbG9jYWwgY3Vyc29yIGltYWdlIGlzIGNoYW5nZWQuIFRoaXMgY2FuIGJlIHVzZWQgdG9cclxuICAgICAqIGltcGxlbWVudCBzcGVjaWFsIGhhbmRsaW5nIG9mIHRoZSBjbGllbnQtc2lkZSBjdXJzb3IsIG9yIHRvIG92ZXJyaWRlXHJcbiAgICAgKiB0aGUgZGVmYXVsdCB1c2Ugb2YgYSBzb2Z0d2FyZSBjdXJzb3IgbGF5ZXIuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIFRoZSBjdXJzb3IgaW1hZ2UuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWC1jb29yZGluYXRlIG9mIHRoZSBjdXJzb3IgaG90c3BvdC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZLWNvb3JkaW5hdGUgb2YgdGhlIGN1cnNvciBob3RzcG90LlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uY3Vyc29yID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBxdWV1ZSBvZiBhbGwgcGVuZGluZyBUYXNrcy4gVGFza3Mgd2lsbCBiZSBydW4gaW4gb3JkZXIsIHdpdGggbmV3XHJcbiAgICAgKiB0YXNrcyBhZGRlZCBhdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZSBhbmQgb2xkIHRhc2tzIHJlbW92ZWQgZnJvbSB0aGVcclxuICAgICAqIGZyb250IG9mIHRoZSBxdWV1ZSAoRklGTykuIFRoZXNlIHRhc2tzIHdpbGwgZXZlbnR1YWxseSBiZSBncm91cGVkXHJcbiAgICAgKiBpbnRvIGEgRnJhbWUuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge1Rhc2tbXX1cclxuICAgICAqL1xyXG4gICAgdmFyIHRhc2tzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcXVldWUgb2YgYWxsIGZyYW1lcy4gRWFjaCBmcmFtZSBpcyBhIHBhaXJpbmcgb2YgYW4gYXJyYXkgb2YgdGFza3NcclxuICAgICAqIGFuZCBhIGNhbGxiYWNrIHdoaWNoIG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIGZyYW1lIGlzIHJlbmRlcmVkLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtGcmFtZVtdfVxyXG4gICAgICovXHJcbiAgICB2YXIgZnJhbWVzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGbHVzaGVzIGFsbCBwZW5kaW5nIGZyYW1lcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9fZmx1c2hfZnJhbWVzKCkge1xyXG5cclxuICAgICAgICB2YXIgcmVuZGVyZWRfZnJhbWVzID0gMDtcclxuXHJcbiAgICAgICAgLy8gRHJhdyBhbGwgcGVuZGluZyBmcmFtZXMsIGlmIHJlYWR5XHJcbiAgICAgICAgd2hpbGUgKHJlbmRlcmVkX2ZyYW1lcyA8IGZyYW1lcy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IGZyYW1lc1tyZW5kZXJlZF9mcmFtZXNdO1xyXG4gICAgICAgICAgICBpZiAoIWZyYW1lLmlzUmVhZHkoKSlcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZnJhbWUuZmx1c2goKTtcclxuICAgICAgICAgICAgcmVuZGVyZWRfZnJhbWVzKys7XHJcblxyXG4gICAgICAgIH0gXHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSByZW5kZXJlZCBmcmFtZXMgZnJvbSBhcnJheVxyXG4gICAgICAgIGZyYW1lcy5zcGxpY2UoMCwgcmVuZGVyZWRfZnJhbWVzKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvcmRlcmVkIGxpc3Qgb2YgdGFza3Mgd2hpY2ggbXVzdCBiZSBleGVjdXRlZCBhdG9taWNhbGx5LiBPbmNlXHJcbiAgICAgKiBleGVjdXRlZCwgYW4gYXNzb2NpYXRlZCAoYW5kIG9wdGlvbmFsKSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgZnJhbWUgaXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkLlxyXG4gICAgICogQHBhcmFtIHtUYXNrW119IHRhc2tzIFRoZSBzZXQgb2YgdGFza3Mgd2hpY2ggbXVzdCBiZSBleGVjdXRlZCB0byByZW5kZXJcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBGcmFtZShjYWxsYmFjaywgdGFza3MpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgZnJhbWUgaXMgcmVhZHkgdG8gYmUgcmVuZGVyZWQuIFRoaXMgZnVuY3Rpb25cclxuICAgICAgICAgKiByZXR1cm5zIHRydWUgaWYgYW5kIG9ubHkgaWYgQUxMIHVuZGVybHlpbmcgdGFza3MgYXJlIHVuYmxvY2tlZC5cclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBhbGwgdW5kZXJseWluZyB0YXNrcyBhcmUgdW5ibG9ja2VkLFxyXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTZWFyY2ggZm9yIGJsb2NrZWQgdGFza3NcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgdGFza3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXNrc1tpXS5ibG9ja2VkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgbm8gYmxvY2tlZCB0YXNrcywgdGhlIGZyYW1lIGlzIHJlYWR5XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW5kZXJzIHRoaXMgZnJhbWUsIGNhbGxpbmcgdGhlIGFzc29jaWF0ZWQgY2FsbGJhY2ssIGlmIGFueSwgYWZ0ZXJcclxuICAgICAgICAgKiB0aGUgZnJhbWUgaXMgY29tcGxldGUuIFRoaXMgZnVuY3Rpb24gTVVTVCBvbmx5IGJlIGNhbGxlZCB3aGVuIG5vXHJcbiAgICAgICAgICogYmxvY2tlZCB0YXNrcyBleGlzdC4gQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdpdGggYmxvY2tlZCB0YXNrc1xyXG4gICAgICAgICAqIHdpbGwgcmVzdWx0IGluIHVuZGVmaW5lZCBiZWhhdmlvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IGFsbCBwZW5kaW5nIHRhc2tzLlxyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCB0YXNrcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHRhc2tzW2ldLmV4ZWN1dGUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGwgY2FsbGJhY2tcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY29udGFpbmVyIGZvciBhbiB0YXNrIGhhbmRsZXIuIEVhY2ggb3BlcmF0aW9uIHdoaWNoIG11c3QgYmUgb3JkZXJlZFxyXG4gICAgICogaXMgYXNzb2NpYXRlZCB3aXRoIGEgVGFzayB0aGF0IGdvZXMgaW50byBhIHRhc2sgcXVldWUuIFRhc2tzIGluIHRoaXNcclxuICAgICAqIHF1ZXVlIGFyZSBleGVjdXRlZCBpbiBvcmRlciBvbmNlIHRoZWlyIGhhbmRsZXJzIGFyZSBzZXQsIHdoaWxlIFRhc2tzIFxyXG4gICAgICogd2l0aG91dCBoYW5kbGVycyBibG9jayB0aGVtc2VsdmVzIGFuZCBhbnkgZm9sbG93aW5nIFRhc2tzIGZyb20gcnVubmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0YXNrSGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgdGFzayBcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bnMsIGlmIGFueS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmxvY2tlZCBXaGV0aGVyIHRoaXMgdGFzayBzaG91bGQgc3RhcnQgYmxvY2tlZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVGFzayh0YXNrSGFuZGxlciwgYmxvY2tlZCkge1xyXG4gICAgICAgXHJcbiAgICAgICAgdmFyIHRhc2sgPSB0aGlzO1xyXG4gICAgICAgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0aGlzIFRhc2sgaXMgYmxvY2tlZC5cclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJsb2NrZWQgPSBibG9ja2VkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbmJsb2NrcyB0aGlzIFRhc2ssIGFsbG93aW5nIGl0IHRvIHJ1bi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVuYmxvY2sgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRhc2suYmxvY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfX2ZsdXNoX2ZyYW1lcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbHMgdGhlIGhhbmRsZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGFzayBJTU1FRElBVEVMWS4gVGhpc1xyXG4gICAgICAgICAqIGZ1bmN0aW9uIGRvZXMgbm90IHRyYWNrIHdoZXRoZXIgdGhpcyB0YXNrIGlzIG1hcmtlZCBhcyBibG9ja2VkLlxyXG4gICAgICAgICAqIEVuZm9yY2luZyB0aGUgYmxvY2tlZCBzdGF0dXMgb2YgdGFza3MgaXMgdXAgdG8gdGhlIGNhbGxlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRhc2tIYW5kbGVyKSB0YXNrSGFuZGxlcigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVzIGEgdGFzayBmb3IgZnV0dXJlIGV4ZWN1dGlvbi4gVGhlIGdpdmVuIGhhbmRsZXIgd2lsbCBleGVjdXRlXHJcbiAgICAgKiBpbW1lZGlhdGVseSBhZnRlciBhbGwgcHJldmlvdXMgdGFza3MgdXBvbiBmcmFtZSBmbHVzaCwgdW5sZXNzIHRoaXNcclxuICAgICAqIHRhc2sgaXMgYmxvY2tlZC4gSWYgYW55IHRhc2tzIGlzIGJsb2NrZWQsIHRoZSBlbnRpcmUgZnJhbWUgd2lsbCBub3RcclxuICAgICAqIHJlbmRlciAoYW5kIG5vIHRhc2tzIHdpdGhpbiB3aWxsIGV4ZWN1dGUpIHVudGlsIGFsbCB0YXNrcyBhcmUgdW5ibG9ja2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHBvc3NpYmxlLCBpZiBhbnkuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJsb2NrZWQgV2hldGhlciB0aGUgdGFzayBzaG91bGQgc3RhcnQgYmxvY2tlZC5cclxuICAgICAqIEByZXR1cm5zIHtUYXNrfSBUaGUgVGFzayBjcmVhdGVkIGFuZCBhZGRlZCB0byB0aGUgcXVldWUgZm9yIGZ1dHVyZVxyXG4gICAgICogICAgICAgICAgICAgICAgIHJ1bm5pbmcuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVGFzayhoYW5kbGVyLCBibG9ja2VkKSB7XHJcbiAgICAgICAgdmFyIHRhc2sgPSBuZXcgVGFzayhoYW5kbGVyLCBibG9ja2VkKTtcclxuICAgICAgICB0YXNrcy5wdXNoKHRhc2spO1xyXG4gICAgICAgIHJldHVybiB0YXNrO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudCB3aGljaCBjb250YWlucyB0aGUgR3VhY2Ftb2xlIGRpc3BsYXkuXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIEd1YWNhbW9sZSBkaXNwbGF5LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gYm91bmRzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoaXMgZGlzcGxheS5cclxuICAgICAqIFxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggb2YgdGhpcyBkaXNwbGF5O1xyXG4gICAgICovXHJcbiAgICB0aGlzLmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlXaWR0aDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhpcyBkaXNwbGF5LlxyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhpcyBkaXNwbGF5O1xyXG4gICAgICovXHJcbiAgICB0aGlzLmdldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBkaXNwbGF5SGVpZ2h0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgbGF5ZXIgb2YgdGhpcyBkaXNwbGF5LiBFYWNoIEd1YWNhbW9sZSBkaXNwbGF5IGFsd2F5c1xyXG4gICAgICogaGFzIGF0IGxlYXN0IG9uZSBsYXllci4gT3RoZXIgbGF5ZXJzIGNhbiBvcHRpb25hbGx5IGJlIGNyZWF0ZWQgd2l0aGluXHJcbiAgICAgKiB0aGlzIGxheWVyLCBidXQgdGhlIGRlZmF1bHQgbGF5ZXIgY2Fubm90IGJlIHJlbW92ZWQgYW5kIGlzIHRoZSBhYnNvbHV0ZVxyXG4gICAgICogYW5jZXN0b3Igb2YgYWxsIG90aGVyIGxheWVycy5cclxuICAgICAqIFxyXG4gICAgICogQHJldHVybiB7R3VhY2Ftb2xlLkRpc3BsYXkuVmlzaWJsZUxheWVyfSBUaGUgZGVmYXVsdCBsYXllci5cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXREZWZhdWx0TGF5ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdF9sYXllcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJzb3IgbGF5ZXIgb2YgdGhpcyBkaXNwbGF5LiBFYWNoIEd1YWNhbW9sZSBkaXNwbGF5IGNvbnRhaW5zXHJcbiAgICAgKiBhIGxheWVyIGZvciB0aGUgaW1hZ2Ugb2YgdGhlIG1vdXNlIGN1cnNvci4gVGhpcyBsYXllciBpcyBhIHNwZWNpYWwgY2FzZVxyXG4gICAgICogYW5kIGV4aXN0cyBhYm92ZSBhbGwgb3RoZXIgbGF5ZXJzLCBzaW1pbGFyIHRvIHRoZSBoYXJkd2FyZSBtb3VzZSBjdXJzb3IuXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm4ge0d1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllcn0gVGhlIGN1cnNvciBsYXllci5cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRDdXJzb3JMYXllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBjdXJzb3I7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBsYXllci4gVGhlIG5ldyBsYXllciB3aWxsIGJlIGEgZGlyZWN0IGNoaWxkIG9mIHRoZSBkZWZhdWx0XHJcbiAgICAgKiBsYXllciwgYnV0IGNhbiBiZSBtb3ZlZCB0byBiZSBhIGNoaWxkIG9mIGFueSBvdGhlciBsYXllci4gTGF5ZXJzIHJldHVybmVkXHJcbiAgICAgKiBieSB0aGlzIGZ1bmN0aW9uIGFyZSB2aXNpYmxlLlxyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJuIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ9IFRoZSBuZXdseS1jcmVhdGVkIGxheWVyLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNyZWF0ZUxheWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGxheWVyID0gbmV3IEd1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllcihkaXNwbGF5V2lkdGgsIGRpc3BsYXlIZWlnaHQpO1xyXG4gICAgICAgIGxheWVyLm1vdmUoZGVmYXVsdF9sYXllciwgMCwgMCwgMCk7XHJcbiAgICAgICAgcmV0dXJuIGxheWVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYnVmZmVyLiBCdWZmZXJzIGFyZSBpbnZpc2libGUsIG9mZi1zY3JlZW4gc3VyZmFjZXMuIFRoZXlcclxuICAgICAqIGFyZSBpbXBsZW1lbnRlZCBpbiB0aGUgc2FtZSBtYW5uZXIgYXMgbGF5ZXJzLCBidXQgZG8gbm90IHByb3ZpZGUgdGhlXHJcbiAgICAgKiBzYW1lIG5lc3Rpbmcgc2VtYW50aWNzLlxyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJuIHtHdWFjYW1vbGUuTGF5ZXJ9IFRoZSBuZXdseS1jcmVhdGVkIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEd1YWNhbW9sZS5MYXllcigwLCAwKTtcclxuICAgICAgICBidWZmZXIuYXV0b3NpemUgPSAxO1xyXG4gICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmx1c2ggYWxsIHBlbmRpbmcgZHJhdyB0YXNrcywgaWYgcG9zc2libGUsIGFzIGEgbmV3IGZyYW1lLiBJZiB0aGUgZW50aXJlXHJcbiAgICAgKiBmcmFtZSBpcyBub3QgcmVhZHksIHRoZSBmbHVzaCB3aWxsIHdhaXQgdW50aWwgYWxsIHJlcXVpcmVkIHRhc2tzIGFyZVxyXG4gICAgICogdW5ibG9ja2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgZnJhbWUgaXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoZWQuIFRoaXMgbWF5IGhhcHBlbiBpbW1lZGlhdGVseSwgb3JcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdGVyIHdoZW4gYmxvY2tlZCB0YXNrcyBiZWNvbWUgdW5ibG9ja2VkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgLy8gQWRkIGZyYW1lLCByZXNldCB0YXNrc1xyXG4gICAgICAgIGZyYW1lcy5wdXNoKG5ldyBGcmFtZShjYWxsYmFjaywgdGFza3MpKTtcclxuICAgICAgICB0YXNrcyA9IFtdO1xyXG5cclxuICAgICAgICAvLyBBdHRlbXB0IGZsdXNoXHJcbiAgICAgICAgX19mbHVzaF9mcmFtZXMoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaG90c3BvdCBhbmQgaW1hZ2Ugb2YgdGhlIG1vdXNlIGN1cnNvciBkaXNwbGF5ZWQgd2l0aGluIHRoZVxyXG4gICAgICogR3VhY2Ftb2xlIGRpc3BsYXkuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3RzcG90WCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJzb3IgaG90c3BvdC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3RzcG90WSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJzb3IgaG90c3BvdC5cclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgc291cmNlIGxheWVyIGNvbnRhaW5pbmcgdGhlIGRhdGEgd2hpY2hcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGQgYmUgdXNlZCBhcyB0aGUgbW91c2UgY3Vyc29yIGltYWdlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3ggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgbGF5ZXIncyBjb29yZGluYXRlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIGxheWVyJ3MgY29vcmRpbmF0ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjdyBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBsYXllcidzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY2ggVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBsYXllcidzIGNvb3JkaW5hdGUgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcblxyXG4gICAgICovXHJcbiAgICB0aGlzLnNldEN1cnNvciA9IGZ1bmN0aW9uKGhvdHNwb3RYLCBob3RzcG90WSwgbGF5ZXIsIHNyY3gsIHNyY3ksIHNyY3csIHNyY2gpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X3NldF9jdXJzb3IoKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgaG90c3BvdFxyXG4gICAgICAgICAgICBndWFjX2Rpc3BsYXkuY3Vyc29ySG90c3BvdFggPSBob3RzcG90WDtcclxuICAgICAgICAgICAgZ3VhY19kaXNwbGF5LmN1cnNvckhvdHNwb3RZID0gaG90c3BvdFk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXNldCBjdXJzb3Igc2l6ZVxyXG4gICAgICAgICAgICBjdXJzb3IucmVzaXplKHNyY3csIHNyY2gpO1xyXG5cclxuICAgICAgICAgICAgLy8gRHJhdyBjdXJzb3IgdG8gY3Vyc29yIGxheWVyXHJcbiAgICAgICAgICAgIGN1cnNvci5jb3B5KGxheWVyLCBzcmN4LCBzcmN5LCBzcmN3LCBzcmNoLCAwLCAwKTtcclxuICAgICAgICAgICAgZ3VhY19kaXNwbGF5Lm1vdmVDdXJzb3IoZ3VhY19kaXNwbGF5LmN1cnNvclgsIGd1YWNfZGlzcGxheS5jdXJzb3JZKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpcmUgY3Vyc29yIGNoYW5nZSBldmVudFxyXG4gICAgICAgICAgICBpZiAoZ3VhY19kaXNwbGF5Lm9uY3Vyc29yKVxyXG4gICAgICAgICAgICAgICAgZ3VhY19kaXNwbGF5Lm9uY3Vyc29yKGN1cnNvci50b0NhbnZhcygpLCBob3RzcG90WCwgaG90c3BvdFkpO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHNvZnR3YXJlLXJlbmRlcmVkIGN1cnNvciBpcyBzaG93bi4gVGhpcyBjdXJzb3IgZGlmZmVyc1xyXG4gICAgICogZnJvbSB0aGUgaGFyZHdhcmUgY3Vyc29yIGluIHRoYXQgaXQgaXMgYnVpbHQgaW50byB0aGUgR3VhY2Ftb2xlLkRpc3BsYXksXHJcbiAgICAgKiBhbmQgcmVsaWVzIG9uIGl0cyBvd24gR3VhY2Ftb2xlIGxheWVyIHRvIHJlbmRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaG93bj10cnVlXSBXaGV0aGVyIHRvIHNob3cgdGhlIHNvZnR3YXJlIGN1cnNvci5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaG93Q3Vyc29yID0gZnVuY3Rpb24oc2hvd24pIHtcclxuXHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjdXJzb3IuZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIERPTSBpZiBoaWRkZW5cclxuICAgICAgICBpZiAoc2hvd24gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQpXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGVuc3VyZSBjdXJzb3IgaXMgY2hpbGQgb2YgZGlzcGxheVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmVudCAhPT0gZGlzcGxheSlcclxuICAgICAgICAgICAgZGlzcGxheS5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbG9jYXRpb24gb2YgdGhlIGxvY2FsIGN1cnNvciB0byB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuIEZvciB0aGVcclxuICAgICAqIHNha2Ugb2YgcmVzcG9uc2l2ZW5lc3MsIHRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgaXRzIGFjdGlvbiBpbW1lZGlhdGVseS5cclxuICAgICAqIEN1cnNvciBtb3Rpb24gaXMgbm90IG1haW50YWluZWQgd2l0aGluIGF0b21pYyBmcmFtZXMuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgdG8gbW92ZSB0aGUgY3Vyc29yIHRvLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSB0byBtb3ZlIHRoZSBjdXJzb3IgdG8uXHJcbiAgICAgKi9cclxuICAgIHRoaXMubW92ZUN1cnNvciA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHJcbiAgICAgICAgLy8gTW92ZSBjdXJzb3IgbGF5ZXJcclxuICAgICAgICBjdXJzb3IudHJhbnNsYXRlKHggLSBndWFjX2Rpc3BsYXkuY3Vyc29ySG90c3BvdFgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB5IC0gZ3VhY19kaXNwbGF5LmN1cnNvckhvdHNwb3RZKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHN0b3JlZCBwb3NpdGlvblxyXG4gICAgICAgIGd1YWNfZGlzcGxheS5jdXJzb3JYID0geDtcclxuICAgICAgICBndWFjX2Rpc3BsYXkuY3Vyc29yWSA9IHk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIExheWVyIHRvIHRoZSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0LlxyXG4gICAgICogUmVzaXppbmcgaXMgb25seSBhdHRlbXB0ZWQgaWYgdGhlIG5ldyBzaXplIHByb3ZpZGVkIGlzIGFjdHVhbGx5IGRpZmZlcmVudFxyXG4gICAgICogZnJvbSB0aGUgY3VycmVudCBzaXplLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIHJlc2l6ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgbmV3IHdpZHRoLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgbmV3IGhlaWdodC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNpemUgPSBmdW5jdGlvbihsYXllciwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfcmVzaXplKCkge1xyXG5cclxuICAgICAgICAgICAgbGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzaXplIGRpc3BsYXkgaWYgZGVmYXVsdCBsYXllciBpcyByZXNpemVkXHJcbiAgICAgICAgICAgIGlmIChsYXllciA9PT0gZGVmYXVsdF9sYXllcikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSAoc2V0KSBkaXNwbGF5IHNpemVcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheUhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkuc3R5bGUud2lkdGggPSBkaXNwbGF5V2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LnN0eWxlLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQgKyBcInB4XCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGJvdW5kcyBzaXplXHJcbiAgICAgICAgICAgICAgICBib3VuZHMuc3R5bGUud2lkdGggPSAoZGlzcGxheVdpZHRoKmRpc3BsYXlTY2FsZSkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBib3VuZHMuc3R5bGUuaGVpZ2h0ID0gKGRpc3BsYXlIZWlnaHQqZGlzcGxheVNjYWxlKSArIFwicHhcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RpZnkgb2YgcmVzaXplXHJcbiAgICAgICAgICAgICAgICBpZiAoZ3VhY19kaXNwbGF5Lm9ucmVzaXplKVxyXG4gICAgICAgICAgICAgICAgICAgIGd1YWNfZGlzcGxheS5vbnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIHNwZWNpZmllZCBpbWFnZSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuIFRoZSBpbWFnZSBzcGVjaWZpZWRcclxuICAgICAqIG11c3QgYWxyZWFkeSBiZSBsb2FkZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllclxyXG4gICAgICogICAgIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqICAgICBUaGUgZGVzdGluYXRpb24gWCBjb29yZGluYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFxyXG4gICAgICogICAgIFRoZSBkZXN0aW5hdGlvbiBZIGNvb3JkaW5hdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtDYW52YXNJbWFnZVNvdXJjZX0gaW1hZ2VcclxuICAgICAqICAgICBUaGUgaW1hZ2UgdG8gZHJhdy4gTm90ZSB0aGF0IHRoaXMgbm90IGEgVVJMLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYXdJbWFnZSA9IGZ1bmN0aW9uKGxheWVyLCB4LCB5LCBpbWFnZSkge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfZHJhd0ltYWdlKCkge1xyXG4gICAgICAgICAgICBsYXllci5kcmF3SW1hZ2UoeCwgeSwgaW1hZ2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBpbWFnZSBjb250YWluZWQgd2l0aGluIHRoZSBzcGVjaWZpZWQgQmxvYiBhdCB0aGUgZ2l2ZW5cclxuICAgICAqIGNvb3JkaW5hdGVzLiBUaGUgQmxvYiBzcGVjaWZpZWQgbXVzdCBhbHJlYWR5IGJlIHBvcHVsYXRlZCB3aXRoIGltYWdlXHJcbiAgICAgKiBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllclxyXG4gICAgICogICAgIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqICAgICBUaGUgZGVzdGluYXRpb24gWCBjb29yZGluYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiAgICAgVGhlIGRlc3RpbmF0aW9uIFkgY29vcmRpbmF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2JcclxuICAgICAqICAgICBUaGUgQmxvYiBjb250YWluaW5nIHRoZSBpbWFnZSBkYXRhIHRvIGRyYXcuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhd0Jsb2IgPSBmdW5jdGlvbihsYXllciwgeCwgeSwgYmxvYikge1xyXG5cclxuICAgICAgICB2YXIgdGFzaztcclxuXHJcbiAgICAgICAgLy8gUHJlZmVyIGNyZWF0ZUltYWdlQml0bWFwKCkgb3ZlciBibG9iIFVSTHMgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgaWYgKHdpbmRvdy5jcmVhdGVJbWFnZUJpdG1hcCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJpdG1hcDtcclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgaW1hZ2Ugb25jZSBsb2FkZWRcclxuICAgICAgICAgICAgdGFzayA9IHNjaGVkdWxlVGFzayhmdW5jdGlvbiBkcmF3SW1hZ2VCaXRtYXAoKSB7XHJcbiAgICAgICAgICAgICAgICBsYXllci5kcmF3SW1hZ2UoeCwgeSwgYml0bWFwKTtcclxuICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBMb2FkIGltYWdlIGZyb20gcHJvdmlkZWQgYmxvYlxyXG4gICAgICAgICAgICB3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYikudGhlbihmdW5jdGlvbiBiaXRtYXBMb2FkZWQoZGVjb2RlZCkge1xyXG4gICAgICAgICAgICAgICAgYml0bWFwID0gZGVjb2RlZDtcclxuICAgICAgICAgICAgICAgIHRhc2sudW5ibG9jaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgYmxvYiBVUkxzIGFuZCB0aGUgSW1hZ2Ugb2JqZWN0IGlmIGNyZWF0ZUltYWdlQml0bWFwKCkgaXNcclxuICAgICAgICAvLyB1bmF2YWlsYWJsZVxyXG4gICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIFVSTCBmb3IgYmxvYlxyXG4gICAgICAgICAgICB2YXIgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgYW5kIGZyZWUgYmxvYiBVUkwgd2hlbiByZWFkeVxyXG4gICAgICAgICAgICB0YXNrID0gc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9kcmF3QmxvYigpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBpbWFnZSBvbmx5IGlmIGl0IGxvYWRlZCB3aXRob3V0IGVycm9yc1xyXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5kcmF3SW1hZ2UoeCwgeSwgaW1hZ2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEJsb2IgVVJMIG5vIGxvbmdlciBuZWVkZWRcclxuICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcclxuXHJcbiAgICAgICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gTG9hZCBpbWFnZSBmcm9tIFVSTFxyXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gdGFzay51bmJsb2NrO1xyXG4gICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gdGFzay51bmJsb2NrO1xyXG4gICAgICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIGltYWdlIHdpdGhpbiB0aGUgZ2l2ZW4gc3RyZWFtIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy4gVGhlXHJcbiAgICAgKiBpbWFnZSB3aWxsIGJlIGxvYWRlZCBhdXRvbWF0aWNhbGx5LCBhbmQgdGhpcyBhbmQgYW55IGZ1dHVyZSBvcGVyYXRpb25zXHJcbiAgICAgKiB3aWxsIHdhaXQgZm9yIHRoZSBpbWFnZSB0byBmaW5pc2ggbG9hZGluZy4gVGhpcyBmdW5jdGlvbiB3aWxsXHJcbiAgICAgKiBhdXRvbWF0aWNhbGx5IGNob29zZSBhbiBhcHByb3JpYXRlIG1ldGhvZCBmb3IgcmVhZGluZyBhbmQgZGVjb2RpbmcgdGhlXHJcbiAgICAgKiBnaXZlbiBpbWFnZSBzdHJlYW0sIGFuZCBzaG91bGQgYmUgcHJlZmVycmVkIGZvciByZWNlaXZlZCBzdHJlYW1zIGV4Y2VwdFxyXG4gICAgICogd2hlcmUgbWFudWFsIGRlY29kaW5nIG9mIHRoZSBzdHJlYW0gaXMgdW5hdm9pZGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyXHJcbiAgICAgKiAgICAgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogICAgIFRoZSBkZXN0aW5hdGlvbiBYIGNvb3JkaW5hdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqICAgICBUaGUgZGVzdGluYXRpb24gWSBjb29yZGluYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLklucHV0U3RyZWFtfSBzdHJlYW1cclxuICAgICAqICAgICBUaGUgc3RyZWFtIGFsb25nIHdoaWNoIGltYWdlIGRhdGEgd2lsbCBiZSByZWNlaXZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICAgICAqICAgICBUaGUgbWltZXR5cGUgb2YgdGhlIGltYWdlIHdpdGhpbiB0aGUgc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYXdTdHJlYW0gPSBmdW5jdGlvbiBkcmF3U3RyZWFtKGxheWVyLCB4LCB5LCBzdHJlYW0sIG1pbWV0eXBlKSB7XHJcblxyXG4gICAgICAgIC8vIElmIGNyZWF0ZUltYWdlQml0bWFwKCkgaXMgYXZhaWxhYmxlLCBsb2FkIHRoZSBpbWFnZSBhcyBhIGJsb2Igc29cclxuICAgICAgICAvLyB0aGF0IGZ1bmN0aW9uIGNhbiBiZSB1c2VkXHJcbiAgICAgICAgaWYgKHdpbmRvdy5jcmVhdGVJbWFnZUJpdG1hcCkge1xyXG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEd1YWNhbW9sZS5CbG9iUmVhZGVyKHN0cmVhbSwgbWltZXR5cGUpO1xyXG4gICAgICAgICAgICByZWFkZXIub25lbmQgPSBmdW5jdGlvbiBkcmF3SW1hZ2VCbG9iKCkge1xyXG4gICAgICAgICAgICAgICAgZ3VhY19kaXNwbGF5LmRyYXdCbG9iKGxheWVyLCB4LCB5LCByZWFkZXIuZ2V0QmxvYigpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExhY2tpbmcgY3JlYXRlSW1hZ2VCaXRtYXAoKSwgZmFsbCBiYWNrIHRvIGRhdGEgVVJJcyBhbmQgdGhlIEltYWdlXHJcbiAgICAgICAgLy8gb2JqZWN0XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgR3VhY2Ftb2xlLkRhdGFVUklSZWFkZXIoc3RyZWFtLCBtaW1ldHlwZSk7XHJcbiAgICAgICAgICAgIHJlYWRlci5vbmVuZCA9IGZ1bmN0aW9uIGRyYXdJbWFnZURhdGFVUkkoKSB7XHJcbiAgICAgICAgICAgICAgICBndWFjX2Rpc3BsYXkuZHJhdyhsYXllciwgeCwgeSwgcmVhZGVyLmdldFVSSSgpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBpbWFnZSBhdCB0aGUgc3BlY2lmaWVkIFVSTCBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuIFRoZSBpbWFnZVxyXG4gICAgICogd2lsbCBiZSBsb2FkZWQgYXV0b21hdGljYWxseSwgYW5kIHRoaXMgYW5kIGFueSBmdXR1cmUgb3BlcmF0aW9ucyB3aWxsXHJcbiAgICAgKiB3YWl0IGZvciB0aGUgaW1hZ2UgdG8gZmluaXNoIGxvYWRpbmcuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGRlc3RpbmF0aW9uIFggY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBkZXN0aW5hdGlvbiBZIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgb2YgdGhlIGltYWdlIHRvIGRyYXcuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhdyA9IGZ1bmN0aW9uKGxheWVyLCB4LCB5LCB1cmwpIHtcclxuXHJcbiAgICAgICAgdmFyIHRhc2sgPSBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X2RyYXcoKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBpbWFnZSBvbmx5IGlmIGl0IGxvYWRlZCB3aXRob3V0IGVycm9yc1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2Uud2lkdGggJiYgaW1hZ2UuaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgbGF5ZXIuZHJhd0ltYWdlKHgsIHksIGltYWdlKTtcclxuXHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltYWdlLm9ubG9hZCA9IHRhc2sudW5ibG9jaztcclxuICAgICAgICBpbWFnZS5vbmVycm9yID0gdGFzay51bmJsb2NrO1xyXG4gICAgICAgIGltYWdlLnNyYyA9IHVybDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGxheXMgdGhlIHZpZGVvIGF0IHRoZSBzcGVjaWZpZWQgVVJMIHdpdGhpbiB0aGlzIGxheWVyLiBUaGUgdmlkZW9cclxuICAgICAqIHdpbGwgYmUgbG9hZGVkIGF1dG9tYXRpY2FsbHksIGFuZCB0aGlzIGFuZCBhbnkgZnV0dXJlIG9wZXJhdGlvbnMgd2lsbFxyXG4gICAgICogd2FpdCBmb3IgdGhlIHZpZGVvIHRvIGZpbmlzaCBsb2FkaW5nLiBGdXR1cmUgb3BlcmF0aW9ucyB3aWxsIG5vdCBiZVxyXG4gICAgICogZXhlY3V0ZWQgdW50aWwgdGhlIHZpZGVvIGZpbmlzaGVzIHBsYXlpbmcuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlIFRoZSBtaW1ldHlwZSBvZiB0aGUgdmlkZW8gdG8gcGxheS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgdmlkZW8gdG8gcGxheS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5wbGF5ID0gZnVuY3Rpb24obGF5ZXIsIG1pbWV0eXBlLCBkdXJhdGlvbiwgdXJsKSB7XHJcblxyXG4gICAgICAgIC8vIFN0YXJ0IGxvYWRpbmcgdGhlIHZpZGVvXHJcbiAgICAgICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xyXG4gICAgICAgIHZpZGVvLnR5cGUgPSBtaW1ldHlwZTtcclxuICAgICAgICB2aWRlby5zcmMgPSB1cmw7XHJcblxyXG4gICAgICAgIC8vIFN0YXJ0IGNvcHlpbmcgZnJhbWVzIHdoZW4gcGxheWluZ1xyXG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5XCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVuZGVyX2NhbGxiYWNrKCkge1xyXG4gICAgICAgICAgICAgICAgbGF5ZXIuZHJhd0ltYWdlKDAsIDAsIHZpZGVvKTtcclxuICAgICAgICAgICAgICAgIGlmICghdmlkZW8uZW5kZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQocmVuZGVyX2NhbGxiYWNrLCAyMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJlbmRlcl9jYWxsYmFjaygpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHNjaGVkdWxlVGFzayh2aWRlby5wbGF5KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmZXIgYSByZWN0YW5nbGUgb2YgaW1hZ2UgZGF0YSBmcm9tIG9uZSBMYXllciB0byB0aGlzIExheWVyIHVzaW5nIHRoZVxyXG4gICAgICogc3BlY2lmaWVkIHRyYW5zZmVyIGZ1bmN0aW9uLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gc3JjTGF5ZXIgVGhlIExheWVyIHRvIGNvcHkgaW1hZ2UgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3ggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXIncyBjb29yZGluYXRlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3MgY29vcmRpbmF0ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjdyBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY2ggVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBMYXllcidzIGNvb3JkaW5hdGUgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gZHN0TGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBkZXN0aW5hdGlvbiBYIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgZGVzdGluYXRpb24gWSBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmZXJGdW5jdGlvbiBUaGUgdHJhbnNmZXIgZnVuY3Rpb24gdG8gdXNlIHRvXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyIGRhdGEgZnJvbSBzb3VyY2UgdG9cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJhbnNmZXIgPSBmdW5jdGlvbihzcmNMYXllciwgc3JjeCwgc3JjeSwgc3Jjdywgc3JjaCwgZHN0TGF5ZXIsIHgsIHksIHRyYW5zZmVyRnVuY3Rpb24pIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X3RyYW5zZmVyKCkge1xyXG4gICAgICAgICAgICBkc3RMYXllci50cmFuc2ZlcihzcmNMYXllciwgc3JjeCwgc3JjeSwgc3Jjdywgc3JjaCwgeCwgeSwgdHJhbnNmZXJGdW5jdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHV0IGEgcmVjdGFuZ2xlIG9mIGltYWdlIGRhdGEgZnJvbSBvbmUgTGF5ZXIgdG8gdGhpcyBMYXllciBkaXJlY3RseVxyXG4gICAgICogd2l0aG91dCBwZXJmb3JtaW5nIGFueSBhbHBoYSBibGVuZGluZy4gU2ltcGx5IGNvcHkgdGhlIGRhdGEuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBzcmNMYXllciBUaGUgTGF5ZXIgdG8gY29weSBpbWFnZSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzIGNvb3JkaW5hdGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3kgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXIncyBjb29yZGluYXRlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN3IFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3NcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjaCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2VcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIExheWVyJ3MgY29vcmRpbmF0ZSBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBkc3RMYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGRlc3RpbmF0aW9uIFggY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBkZXN0aW5hdGlvbiBZIGNvb3JkaW5hdGUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucHV0ID0gZnVuY3Rpb24oc3JjTGF5ZXIsIHNyY3gsIHNyY3ksIHNyY3csIHNyY2gsIGRzdExheWVyLCB4LCB5KSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9wdXQoKSB7XHJcbiAgICAgICAgICAgIGRzdExheWVyLnB1dChzcmNMYXllciwgc3JjeCwgc3JjeSwgc3Jjdywgc3JjaCwgeCwgeSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weSBhIHJlY3RhbmdsZSBvZiBpbWFnZSBkYXRhIGZyb20gb25lIExheWVyIHRvIHRoaXMgTGF5ZXIuIFRoaXNcclxuICAgICAqIG9wZXJhdGlvbiB3aWxsIGNvcHkgZXhhY3RseSB0aGUgaW1hZ2UgZGF0YSB0aGF0IHdpbGwgYmUgZHJhd24gb25jZSBhbGxcclxuICAgICAqIG9wZXJhdGlvbnMgb2YgdGhlIHNvdXJjZSBMYXllciB0aGF0IHdlcmUgcGVuZGluZyBhdCB0aGUgdGltZSB0aGlzXHJcbiAgICAgKiBmdW5jdGlvbiB3YXMgY2FsbGVkIGFyZSBjb21wbGV0ZS4gVGhpcyBvcGVyYXRpb24gd2lsbCBub3QgYWx0ZXIgdGhlXHJcbiAgICAgKiBzaXplIG9mIHRoZSBzb3VyY2UgTGF5ZXIgZXZlbiBpZiBpdHMgYXV0b3NpemUgcHJvcGVydHkgaXMgc2V0IHRvIHRydWUuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBzcmNMYXllciBUaGUgTGF5ZXIgdG8gY29weSBpbWFnZSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzIGNvb3JkaW5hdGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3kgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXIncyBjb29yZGluYXRlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN3IFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3NcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjaCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2VcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIExheWVyJ3MgY29vcmRpbmF0ZSBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBkc3RMYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGRlc3RpbmF0aW9uIFggY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBkZXN0aW5hdGlvbiBZIGNvb3JkaW5hdGUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29weSA9IGZ1bmN0aW9uKHNyY0xheWVyLCBzcmN4LCBzcmN5LCBzcmN3LCBzcmNoLCBkc3RMYXllciwgeCwgeSkge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfY29weSgpIHtcclxuICAgICAgICAgICAgZHN0TGF5ZXIuY29weShzcmNMYXllciwgc3JjeCwgc3JjeSwgc3Jjdywgc3JjaCwgeCwgeSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIGEgbmV3IHBhdGggYXQgdGhlIHNwZWNpZmllZCBwb2ludC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBkcmF3LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gZHJhdy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb3ZlVG8gPSBmdW5jdGlvbihsYXllciwgeCwgeSkge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfbW92ZVRvKCkge1xyXG4gICAgICAgICAgICBsYXllci5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRoZSBzcGVjaWZpZWQgbGluZSB0byB0aGUgY3VycmVudCBwYXRoLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSB0byBkcmF3LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmxpbmVUbyA9IGZ1bmN0aW9uKGxheWVyLCB4LCB5KSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9saW5lVG8oKSB7XHJcbiAgICAgICAgICAgIGxheWVyLmxpbmVUbyh4LCB5KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIHNwZWNpZmllZCBhcmMgdG8gdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSB3aGljaFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgd2lsbCBjb250YWluIHRoZSBhcmMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSB3aGljaFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgd2lsbCBjb250YWluIHRoZSBhcmMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEFuZ2xlIFRoZSBzdGFydGluZyBhbmdsZSBvZiB0aGUgYXJjLCBpbiByYWRpYW5zLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlIFRoZSBlbmRpbmcgYW5nbGUgb2YgdGhlIGFyYywgaW4gcmFkaWFucy5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVnYXRpdmUgV2hldGhlciB0aGUgYXJjIHNob3VsZCBiZSBkcmF3biBpbiBvcmRlciBvZlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNyZWFzaW5nIGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmFyYyA9IGZ1bmN0aW9uKGxheWVyLCB4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBuZWdhdGl2ZSkge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfYXJjKCkge1xyXG4gICAgICAgICAgICBsYXllci5hcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgbmVnYXRpdmUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIG5ldyBwYXRoIGF0IHRoZSBzcGVjaWZpZWQgcG9pbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNwMXggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjcDF5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3AyeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kcG9pbnQgb2YgdGhlIGN1cnZlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kcG9pbnQgb2YgdGhlIGN1cnZlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnZlVG8gPSBmdW5jdGlvbihsYXllciwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfY3VydmVUbygpIHtcclxuICAgICAgICAgICAgbGF5ZXIuY3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aCBieSBjb25uZWN0aW5nIHRoZSBlbmQgcG9pbnQgd2l0aCB0aGUgc3RhcnRcclxuICAgICAqIHBvaW50IChpZiBhbnkpIHdpdGggYSBzdHJhaWdodCBsaW5lLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uKGxheWVyKSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9jbG9zZSgpIHtcclxuICAgICAgICAgICAgbGF5ZXIuY2xvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIHNwZWNpZmllZCByZWN0YW5nbGUgdG8gdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB0byBkcmF3LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgdG8gZHJhdy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUgdG8gZHJhdy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWN0ID0gZnVuY3Rpb24obGF5ZXIsIHgsIHksIHcsIGgpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X3JlY3QoKSB7XHJcbiAgICAgICAgICAgIGxheWVyLnJlY3QoeCwgeSwgdywgaCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xpcCBhbGwgZnV0dXJlIGRyYXdpbmcgb3BlcmF0aW9ucyBieSB0aGUgY3VycmVudCBwYXRoLiBUaGUgY3VycmVudCBwYXRoXHJcbiAgICAgKiBpcyBpbXBsaWNpdGx5IGNsb3NlZC4gVGhlIGN1cnJlbnQgcGF0aCBjYW4gY29udGludWUgdG8gYmUgcmV1c2VkXHJcbiAgICAgKiBmb3Igb3RoZXIgb3BlcmF0aW9ucyAoc3VjaCBhcyBmaWxsQ29sb3IoKSkgYnV0IGEgbmV3IHBhdGggd2lsbCBiZSBzdGFydGVkXHJcbiAgICAgKiBvbmNlIGEgcGF0aCBkcmF3aW5nIG9wZXJhdGlvbiAocGF0aCgpIG9yIHJlY3QoKSkgaXMgdXNlZC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byBhZmZlY3QuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xpcCA9IGZ1bmN0aW9uKGxheWVyKSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9jbGlwKCkge1xyXG4gICAgICAgICAgICBsYXllci5jbGlwKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Ryb2tlIHRoZSBjdXJyZW50IHBhdGggd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG9yLiBUaGUgY3VycmVudCBwYXRoXHJcbiAgICAgKiBpcyBpbXBsaWNpdGx5IGNsb3NlZC4gVGhlIGN1cnJlbnQgcGF0aCBjYW4gY29udGludWUgdG8gYmUgcmV1c2VkXHJcbiAgICAgKiBmb3Igb3RoZXIgb3BlcmF0aW9ucyAoc3VjaCBhcyBjbGlwKCkpIGJ1dCBhIG5ldyBwYXRoIHdpbGwgYmUgc3RhcnRlZFxyXG4gICAgICogb25jZSBhIHBhdGggZHJhd2luZyBvcGVyYXRpb24gKHBhdGgoKSBvciByZWN0KCkpIGlzIHVzZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNhcCBUaGUgbGluZSBjYXAgc3R5bGUuIENhbiBiZSBcInJvdW5kXCIsIFwic3F1YXJlXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIG9yIFwiYnV0dFwiLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGpvaW4gVGhlIGxpbmUgam9pbiBzdHlsZS4gQ2FuIGJlIFwicm91bmRcIiwgXCJiZXZlbFwiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgb3IgXCJtaXRlclwiLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzcyBUaGUgbGluZSB0aGlja25lc3MgaW4gcGl4ZWxzLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgVGhlIHJlZCBjb21wb25lbnQgb2YgdGhlIGNvbG9yIHRvIGZpbGwuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZyBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIHRoZSBjb2xvciB0byBmaWxsLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIGJsdWUgY29tcG9uZW50IG9mIHRoZSBjb2xvciB0byBmaWxsLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGFscGhhIGNvbXBvbmVudCBvZiB0aGUgY29sb3IgdG8gZmlsbC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdHJva2VDb2xvciA9IGZ1bmN0aW9uKGxheWVyLCBjYXAsIGpvaW4sIHRoaWNrbmVzcywgciwgZywgYiwgYSkge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfc3Ryb2tlQ29sb3IoKSB7XHJcbiAgICAgICAgICAgIGxheWVyLnN0cm9rZUNvbG9yKGNhcCwgam9pbiwgdGhpY2tuZXNzLCByLCBnLCBiLCBhKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxscyB0aGUgY3VycmVudCBwYXRoIHdpdGggdGhlIHNwZWNpZmllZCBjb2xvci4gVGhlIGN1cnJlbnQgcGF0aFxyXG4gICAgICogaXMgaW1wbGljaXRseSBjbG9zZWQuIFRoZSBjdXJyZW50IHBhdGggY2FuIGNvbnRpbnVlIHRvIGJlIHJldXNlZFxyXG4gICAgICogZm9yIG90aGVyIG9wZXJhdGlvbnMgKHN1Y2ggYXMgY2xpcCgpKSBidXQgYSBuZXcgcGF0aCB3aWxsIGJlIHN0YXJ0ZWRcclxuICAgICAqIG9uY2UgYSBwYXRoIGRyYXdpbmcgb3BlcmF0aW9uIChwYXRoKCkgb3IgcmVjdCgpKSBpcyB1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIFRoZSByZWQgY29tcG9uZW50IG9mIHRoZSBjb2xvciB0byBmaWxsLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGcgVGhlIGdyZWVuIGNvbXBvbmVudCBvZiB0aGUgY29sb3IgdG8gZmlsbC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBibHVlIGNvbXBvbmVudCBvZiB0aGUgY29sb3IgdG8gZmlsbC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBhbHBoYSBjb21wb25lbnQgb2YgdGhlIGNvbG9yIHRvIGZpbGwuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmlsbENvbG9yID0gZnVuY3Rpb24obGF5ZXIsIHIsIGcsIGIsIGEpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X2ZpbGxDb2xvcigpIHtcclxuICAgICAgICAgICAgbGF5ZXIuZmlsbENvbG9yKHIsIGcsIGIsIGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cm9rZSB0aGUgY3VycmVudCBwYXRoIHdpdGggdGhlIGltYWdlIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGxheWVyLiBUaGVcclxuICAgICAqIGltYWdlIGRhdGEgd2lsbCBiZSB0aWxlZCBpbmZpbml0ZWx5IHdpdGhpbiB0aGUgc3Ryb2tlLiBUaGUgY3VycmVudCBwYXRoXHJcbiAgICAgKiBpcyBpbXBsaWNpdGx5IGNsb3NlZC4gVGhlIGN1cnJlbnQgcGF0aCBjYW4gY29udGludWUgdG8gYmUgcmV1c2VkXHJcbiAgICAgKiBmb3Igb3RoZXIgb3BlcmF0aW9ucyAoc3VjaCBhcyBjbGlwKCkpIGJ1dCBhIG5ldyBwYXRoIHdpbGwgYmUgc3RhcnRlZFxyXG4gICAgICogb25jZSBhIHBhdGggZHJhd2luZyBvcGVyYXRpb24gKHBhdGgoKSBvciByZWN0KCkpIGlzIHVzZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNhcCBUaGUgbGluZSBjYXAgc3R5bGUuIENhbiBiZSBcInJvdW5kXCIsIFwic3F1YXJlXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIG9yIFwiYnV0dFwiLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGpvaW4gVGhlIGxpbmUgam9pbiBzdHlsZS4gQ2FuIGJlIFwicm91bmRcIiwgXCJiZXZlbFwiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgb3IgXCJtaXRlclwiLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzcyBUaGUgbGluZSB0aGlja25lc3MgaW4gcGl4ZWxzLlxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IHNyY0xheWVyIFRoZSBsYXllciB0byB1c2UgYXMgYSByZXBlYXRpbmcgcGF0dGVyblxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhpbiB0aGUgc3Ryb2tlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0cm9rZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGNhcCwgam9pbiwgdGhpY2tuZXNzLCBzcmNMYXllcikge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfc3Ryb2tlTGF5ZXIoKSB7XHJcbiAgICAgICAgICAgIGxheWVyLnN0cm9rZUxheWVyKGNhcCwgam9pbiwgdGhpY2tuZXNzLCBzcmNMYXllcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsbHMgdGhlIGN1cnJlbnQgcGF0aCB3aXRoIHRoZSBpbWFnZSB3aXRoaW4gdGhlIHNwZWNpZmllZCBsYXllci4gVGhlXHJcbiAgICAgKiBpbWFnZSBkYXRhIHdpbGwgYmUgdGlsZWQgaW5maW5pdGVseSB3aXRoaW4gdGhlIHN0cm9rZS4gVGhlIGN1cnJlbnQgcGF0aFxyXG4gICAgICogaXMgaW1wbGljaXRseSBjbG9zZWQuIFRoZSBjdXJyZW50IHBhdGggY2FuIGNvbnRpbnVlIHRvIGJlIHJldXNlZFxyXG4gICAgICogZm9yIG90aGVyIG9wZXJhdGlvbnMgKHN1Y2ggYXMgY2xpcCgpKSBidXQgYSBuZXcgcGF0aCB3aWxsIGJlIHN0YXJ0ZWRcclxuICAgICAqIG9uY2UgYSBwYXRoIGRyYXdpbmcgb3BlcmF0aW9uIChwYXRoKCkgb3IgcmVjdCgpKSBpcyB1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBzcmNMYXllciBUaGUgbGF5ZXIgdG8gdXNlIGFzIGEgcmVwZWF0aW5nIHBhdHRlcm5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoaW4gdGhlIGZpbGwuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmlsbExheWVyID0gZnVuY3Rpb24obGF5ZXIsIHNyY0xheWVyKSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9maWxsTGF5ZXIoKSB7XHJcbiAgICAgICAgICAgIGxheWVyLmZpbGxMYXllcihzcmNMYXllcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHVzaCBjdXJyZW50IGxheWVyIHN0YXRlIG9udG8gc3RhY2suXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbihsYXllcikge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfcHVzaCgpIHtcclxuICAgICAgICAgICAgbGF5ZXIucHVzaCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvcCBsYXllciBzdGF0ZSBvZmYgc3RhY2suXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvcCA9IGZ1bmN0aW9uKGxheWVyKSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9wb3AoKSB7XHJcbiAgICAgICAgICAgIGxheWVyLnBvcCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBsYXllciwgY2xlYXJpbmcgdGhlIHN0YWNrLCB0aGUgY3VycmVudCBwYXRoLCBhbmQgYW55IHRyYW5zZm9ybVxyXG4gICAgICogbWF0cml4LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKGxheWVyKSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9yZXNldCgpIHtcclxuICAgICAgICAgICAgbGF5ZXIucmVzZXQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiBhZmZpbmUgdHJhbnNmb3JtIChkZWZpbmVkIHdpdGggc2l4IHZhbHVlcyBmcm9tIHRoZVxyXG4gICAgICogdHJhbnNmb3JtJ3MgbWF0cml4KS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byBtb2RpZnkuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIHRoaXJkIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVGhlIGZvdXJ0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlIFRoZSBmaWZ0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmIFRoZSBzaXh0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbihsYXllciwgYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfc2V0VHJhbnNmb3JtKCkge1xyXG4gICAgICAgICAgICBsYXllci5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gYWZmaW5lIHRyYW5zZm9ybSAoZGVmaW5lZCB3aXRoIHNpeCB2YWx1ZXMgZnJvbSB0aGVcclxuICAgICAqIHRyYW5zZm9ybSdzIG1hdHJpeCkuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSB0aGlyZCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkIFRoZSBmb3VydGggdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZSBUaGUgZmlmdGggdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZiBUaGUgc2l4dGggdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJhbnNmb3JtID0gZnVuY3Rpb24obGF5ZXIsIGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X3RyYW5zZm9ybSgpIHtcclxuICAgICAgICAgICAgbGF5ZXIudHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNoYW5uZWwgbWFzayBmb3IgZnV0dXJlIG9wZXJhdGlvbnMgb24gdGhpcyBMYXllci5cclxuICAgICAqIFxyXG4gICAgICogVGhlIGNoYW5uZWwgbWFzayBpcyBhIEd1YWNhbW9sZS1zcGVjaWZpYyBjb21wb3NpdGluZyBvcGVyYXRpb24gaWRlbnRpZmllclxyXG4gICAgICogd2l0aCBhIHNpbmdsZSBiaXQgcmVwcmVzZW50aW5nIGVhY2ggb2YgZm91ciBjaGFubmVscyAoaW4gb3JkZXIpOiBzb3VyY2VcclxuICAgICAqIGltYWdlIHdoZXJlIGRlc3RpbmF0aW9uIHRyYW5zcGFyZW50LCBzb3VyY2Ugd2hlcmUgZGVzdGluYXRpb24gb3BhcXVlLFxyXG4gICAgICogZGVzdGluYXRpb24gd2hlcmUgc291cmNlIHRyYW5zcGFyZW50LCBhbmQgZGVzdGluYXRpb24gd2hlcmUgc291cmNlXHJcbiAgICAgKiBvcGFxdWUuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1hc2sgVGhlIGNoYW5uZWwgbWFzayBmb3IgZnV0dXJlIG9wZXJhdGlvbnMgb24gdGhpc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgTGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2V0Q2hhbm5lbE1hc2sgPSBmdW5jdGlvbihsYXllciwgbWFzaykge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfc2V0Q2hhbm5lbE1hc2soKSB7XHJcbiAgICAgICAgICAgIGxheWVyLnNldENoYW5uZWxNYXNrKG1hc2spO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1pdGVyIGxpbWl0IGZvciBzdHJva2Ugb3BlcmF0aW9ucyB1c2luZyB0aGUgbWl0ZXIgam9pbi4gVGhpc1xyXG4gICAgICogbGltaXQgaXMgdGhlIG1heGltdW0gcmF0aW8gb2YgdGhlIHNpemUgb2YgdGhlIG1pdGVyIGpvaW4gdG8gdGhlIHN0cm9rZVxyXG4gICAgICogd2lkdGguIElmIHRoaXMgcmF0aW8gaXMgZXhjZWVkZWQsIHRoZSBtaXRlciB3aWxsIG5vdCBiZSBkcmF3biBmb3IgdGhhdFxyXG4gICAgICogam9pbnQgb2YgdGhlIHBhdGguXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0IFRoZSBtaXRlciBsaW1pdCBmb3Igc3Ryb2tlIG9wZXJhdGlvbnMgdXNpbmcgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgbWl0ZXIgam9pbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXRNaXRlckxpbWl0ID0gZnVuY3Rpb24obGF5ZXIsIGxpbWl0KSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9zZXRNaXRlckxpbWl0KCkge1xyXG4gICAgICAgICAgICBsYXllci5zZXRNaXRlckxpbWl0KGxpbWl0KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBjb250YWluZXIgZW50aXJlbHksIHN1Y2ggdGhhdCBpdCBpcyBubyBsb25nZXJcclxuICAgICAqIGNvbnRhaW5lZCB3aXRoaW4gaXRzIHBhcmVudCBsYXllciwgaWYgYW55LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkRpc3BsYXkuVmlzaWJsZUxheWVyfSBsYXllclxyXG4gICAgICogICAgIFRoZSBsYXllciBiZWluZyByZW1vdmVkIGZyb20gaXRzIHBhcmVudC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZShsYXllcikge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBkaXNwb3NlTGF5ZXIoKSB7XHJcbiAgICAgICAgICAgIGxheWVyLmRpc3Bvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBhZmZpbmUgdHJhbnNmb3JtIChkZWZpbmVkIHdpdGggc2l4IHZhbHVlcyBmcm9tIHRoZVxyXG4gICAgICogdHJhbnNmb3JtJ3MgbWF0cml4KSB0byB0aGUgZ2l2ZW4gbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ9IGxheWVyXHJcbiAgICAgKiAgICAgVGhlIGxheWVyIGJlaW5nIGRpc3RvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVxyXG4gICAgICogICAgIFRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYlxyXG4gICAgICogICAgIFRoZSBzZWNvbmQgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNcclxuICAgICAqICAgICBUaGUgdGhpcmQgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRcclxuICAgICAqICAgICBUaGUgZm91cnRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlXHJcbiAgICAgKiAgICAgVGhlIGZpZnRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmXHJcbiAgICAgKiAgICAgVGhlIHNpeHRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRpc3RvcnQgPSBmdW5jdGlvbiBkaXN0b3J0KGxheWVyLCBhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIGRpc3RvcnRMYXllcigpIHtcclxuICAgICAgICAgICAgbGF5ZXIuZGlzdG9ydChhLCBiLCBjLCBkLCBlLCBmKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBnaXZlbiBYIGFuZCBZXHJcbiAgICAgKiBjb29yZGluYXRlLCBzZXRzIHRoZSBaIHN0YWNraW5nIG9yZGVyLCBhbmQgcmVwYXJlbnRzIHRoZSBsYXllclxyXG4gICAgICogdG8gdGhlIGdpdmVuIHBhcmVudCBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllcn0gbGF5ZXJcclxuICAgICAqICAgICBUaGUgbGF5ZXIgYmVpbmcgbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ9IHBhcmVudFxyXG4gICAgICogICAgIFRoZSBwYXJlbnQgdG8gc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiAgICAgVGhlIFggY29vcmRpbmF0ZSB0byBtb3ZlIHRvLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiAgICAgVGhlIFkgY29vcmRpbmF0ZSB0byBtb3ZlIHRvLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB6XHJcbiAgICAgKiAgICAgVGhlIFogY29vcmRpbmF0ZSB0byBtb3ZlIHRvLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vdmUgPSBmdW5jdGlvbiBtb3ZlKGxheWVyLCBwYXJlbnQsIHgsIHksIHopIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gbW92ZUxheWVyKCkge1xyXG4gICAgICAgICAgICBsYXllci5tb3ZlKHBhcmVudCwgeCwgeSwgeik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdpdmVuIHZhbHVlLCB3aGVyZSAyNTUgaXNcclxuICAgICAqIGZ1bGx5IG9wYXF1ZSBhbmQgMCBpcyBmdWxseSB0cmFuc3BhcmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllcn0gbGF5ZXJcclxuICAgICAqICAgICBUaGUgbGF5ZXIgd2hvc2Ugb3BhY2l0eSBzaG91bGQgYmUgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYVxyXG4gICAgICogICAgIFRoZSBvcGFjaXR5IHRvIHNldC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaGFkZSA9IGZ1bmN0aW9uIHNoYWRlKGxheWVyLCBhbHBoYSkge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBzaGFkZUxheWVyKCkge1xyXG4gICAgICAgICAgICBsYXllci5zaGFkZShhbHBoYSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2NhbGUgb2YgdGhlIGNsaWVudCBkaXNwbGF5IGVsZW1lbnQgc3VjaCB0aGF0IGl0IHJlbmRlcnMgYXRcclxuICAgICAqIGEgcmVsYXRpdmVseSBzbWFsbGVyIG9yIGxhcmdlciBzaXplLCB3aXRob3V0IGFmZmVjdGluZyB0aGUgdHJ1ZVxyXG4gICAgICogcmVzb2x1dGlvbiBvZiB0aGUgZGlzcGxheS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgVGhlIHNjYWxlIHRvIHJlc2l6ZSB0bywgd2hlcmUgMS4wIGlzIG5vcm1hbFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHNpemUgKDE6MSBzY2FsZSkuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2NhbGUgPSBmdW5jdGlvbihzY2FsZSkge1xyXG5cclxuICAgICAgICBkaXNwbGF5LnN0eWxlLnRyYW5zZm9ybSA9XHJcbiAgICAgICAgZGlzcGxheS5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPVxyXG4gICAgICAgIGRpc3BsYXkuc3R5bGUuTW96VHJhbnNmb3JtID1cclxuICAgICAgICBkaXNwbGF5LnN0eWxlLk9UcmFuc2Zvcm0gPVxyXG4gICAgICAgIGRpc3BsYXkuc3R5bGUubXNUcmFuc2Zvcm0gPVxyXG5cclxuICAgICAgICAgICAgXCJzY2FsZShcIiArIHNjYWxlICsgXCIsXCIgKyBzY2FsZSArIFwiKVwiO1xyXG5cclxuICAgICAgICBkaXNwbGF5U2NhbGUgPSBzY2FsZTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGJvdW5kcyBzaXplXHJcbiAgICAgICAgYm91bmRzLnN0eWxlLndpZHRoID0gKGRpc3BsYXlXaWR0aCpkaXNwbGF5U2NhbGUpICsgXCJweFwiO1xyXG4gICAgICAgIGJvdW5kcy5zdHlsZS5oZWlnaHQgPSAoZGlzcGxheUhlaWdodCpkaXNwbGF5U2NhbGUpICsgXCJweFwiO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzY2FsZSBvZiB0aGUgZGlzcGxheS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzY2FsZSBvZiB0aGUgZGlzcGxheS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRTY2FsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBkaXNwbGF5U2NhbGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNhbnZhcyBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGVudGlyZSBkaXNwbGF5LCB3aXRoIGFsbCBjaGlsZFxyXG4gICAgICogbGF5ZXJzIGNvbXBvc2l0ZWQgd2l0aGluLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBBIG5ldyBjYW52YXMgZWxlbWVudCBjb250YWluaW5nIGEgY29weSBvZlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBkaXNwbGF5LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmZsYXR0ZW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgIFxyXG4gICAgICAgIC8vIEdldCBkZXN0aW5hdGlvbiBjYW52YXNcclxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSBkZWZhdWx0X2xheWVyLndpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkZWZhdWx0X2xheWVyLmhlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIHNvcnRlZCBhcnJheSBvZiBjaGlsZHJlblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldF9jaGlsZHJlbihsYXllcikge1xyXG5cclxuICAgICAgICAgICAgLy8gQnVpbGQgYXJyYXkgb2YgY2hpbGRyZW5cclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4IGluIGxheWVyLmNoaWxkcmVuKVxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChsYXllci5jaGlsZHJlbltpbmRleF0pO1xyXG5cclxuICAgICAgICAgICAgLy8gU29ydFxyXG4gICAgICAgICAgICBjaGlsZHJlbi5zb3J0KGZ1bmN0aW9uIGNoaWxkcmVuX2NvbXBhcmF0b3IoYSwgYikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgYmFzZWQgb24gWiBvcmRlclxyXG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBhLnogLSBiLno7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiAhPT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBaIG9yZGVyIGlkZW50aWNhbCwgdXNlIGRvY3VtZW50IG9yZGVyXHJcbiAgICAgICAgICAgICAgICB2YXIgYV9lbGVtZW50ID0gYS5nZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYl9lbGVtZW50ID0gYi5nZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBiX2VsZW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYV9lbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORykgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcpIHJldHVybiAgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBzYW1lXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gRG9uZVxyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhd3MgdGhlIGNvbnRlbnRzIG9mIHRoZSBnaXZlbiBsYXllciBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXNcclxuICAgICAgICBmdW5jdGlvbiBkcmF3X2xheWVyKGxheWVyLCB4LCB5KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IGxheWVyXHJcbiAgICAgICAgICAgIGlmIChsYXllci53aWR0aCA+IDAgJiYgbGF5ZXIuaGVpZ2h0ID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNhdmUgYW5kIHVwZGF0ZSBhbHBoYVxyXG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxfYWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSAqPSBsYXllci5hbHBoYSAvIDI1NS4wO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvcHkgZGF0YVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UobGF5ZXIuZ2V0Q2FudmFzKCksIHgsIHkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERyYXcgYWxsIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBnZXRfY2hpbGRyZW4obGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd19sYXllcihjaGlsZCwgeCArIGNoaWxkLngsIHkgKyBjaGlsZC55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIGFscGhhXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gaW5pdGlhbF9hbHBoYTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEcmF3IGRlZmF1bHQgbGF5ZXIgYW5kIGFsbCBjaGlsZHJlblxyXG4gICAgICAgIGRyYXdfbGF5ZXIoZGVmYXVsdF9sYXllciwgMCwgMCk7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBuZXcgY2FudmFzIGNvcHlcclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgICAgIFxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogU2ltcGxlIGNvbnRhaW5lciBmb3IgR3VhY2Ftb2xlLkxheWVyLCBhbGxvd2luZyBsYXllcnMgdG8gYmUgZWFzaWx5XHJcbiAqIHJlcG9zaXRpb25lZCBhbmQgbmVzdGVkLiBUaGlzIGFsbG93cyBjZXJ0YWluIG9wZXJhdGlvbnMgdG8gYmUgYWNjZWxlcmF0ZWRcclxuICogdGhyb3VnaCBET00gbWFuaXB1bGF0aW9uLCByYXRoZXIgdGhhbiByYXN0ZXIgb3BlcmF0aW9ucy5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXVnbWVudHMgR3VhY2Ftb2xlLkxheWVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIExheWVyLCBpbiBwaXhlbHMuIFRoZSBjYW52YXMgZWxlbWVudFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYmFja2luZyB0aGlzIExheWVyIHdpbGwgYmUgZ2l2ZW4gdGhpcyB3aWR0aC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBMYXllciwgaW4gcGl4ZWxzLiBUaGUgY2FudmFzIGVsZW1lbnRcclxuICogICAgICAgICAgICAgICAgICAgICAgICBiYWNraW5nIHRoaXMgTGF5ZXIgd2lsbCBiZSBnaXZlbiB0aGlzIGhlaWdodC5cclxuICovXHJcbkd1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllciA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcbiAgICBHdWFjYW1vbGUuTGF5ZXIuYXBwbHkodGhpcywgW3dpZHRoLCBoZWlnaHRdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIGxheWVyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGxheWVyID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIElkZW50aWZpZXIgd2hpY2ggdW5pcXVlbHkgaWRlbnRpZmllcyB0aGlzIGxheWVyLiBUaGlzIGlzIENPTVBMRVRFTFlcclxuICAgICAqIFVOUkVMQVRFRCB0byB0aGUgaW5kZXggb2YgdGhlIHVuZGVybHlpbmcgbGF5ZXIsIHdoaWNoIGlzIHNwZWNpZmljXHJcbiAgICAgKiB0byB0aGUgR3VhY2Ftb2xlIHByb3RvY29sLCBhbmQgbm90IHJlbGV2YW50IGF0IHRoaXMgbGV2ZWwuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9fdW5pcXVlX2lkID0gR3VhY2Ftb2xlLkRpc3BsYXkuVmlzaWJsZUxheWVyLl9fbmV4dF9pZCsrO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyIGNvbnRhaW5lciwgd2hlcmUgMjU1IGlzIGZ1bGx5IG9wYXF1ZSBhbmQgMCBpc1xyXG4gICAgICogZnVsbHkgdHJhbnNwYXJlbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWxwaGEgPSAweEZGO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGlzIGxheWVyIGNvbnRhaW5lciB3aXRoaW5cclxuICAgICAqIGl0cyBwYXJlbnQsIGluIHBpeGVscy5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMueCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoaXMgbGF5ZXIgY29udGFpbmVyIHdpdGhpblxyXG4gICAgICogaXRzIHBhcmVudCwgaW4gcGl4ZWxzLlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy55ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFogc3RhY2tpbmcgb3JkZXIgb2YgdGhpcyBsYXllciByZWxhdGl2ZSB0byBvdGhlciBzaWJsaW5nIGxheWVycy5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMueiA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQgdG8gdGhpcyBsYXllciBjb250YWluZXIuIEVhY2ggZWxlbWVudFxyXG4gICAgICogY29ycmVzcG9uZHMgdG8gYSB2YWx1ZSBmcm9tIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXgsIHdpdGggdGhlIGZpcnN0XHJcbiAgICAgKiB0aHJlZSB2YWx1ZXMgYmVpbmcgdGhlIGZpcnN0IHJvdywgYW5kIHRoZSBsYXN0IHRocmVlIHZhbHVlcyBiZWluZyB0aGVcclxuICAgICAqIHNlY29uZCByb3cuIFRoZXJlIGFyZSBzaXggdmFsdWVzIHRvdGFsLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhcmVudCBsYXllciBjb250YWluZXIgb2YgdGhpcyBsYXllciwgaWYgYW55LlxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9mIGFsbCBjaGlsZHJlbiBvZiB0aGlzIGxheWVyLCBpbmRleGVkIGJ5IGxheWVyIGluZGV4LiBUaGlzIG9iamVjdFxyXG4gICAgICogd2lsbCBoYXZlIG9uZSBwcm9wZXJ0eSBwZXIgY2hpbGQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2hpbGRyZW4gPSB7fTtcclxuXHJcbiAgICAvLyBTZXQgbGF5ZXIgcG9zaXRpb25cclxuICAgIHZhciBjYW52YXMgPSBsYXllci5nZXRDYW52YXMoKTtcclxuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcclxuICAgIGNhbnZhcy5zdHlsZS50b3AgPSBcIjBweFwiO1xyXG5cclxuICAgIC8vIENyZWF0ZSBkaXYgd2l0aCBnaXZlbiBzaXplXHJcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgIGRpdi5hcHBlbmRDaGlsZChjYW52YXMpO1xyXG4gICAgZGl2LnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XHJcbiAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgZGl2LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xyXG4gICAgZGl2LnN0eWxlLnRvcCA9IFwiMHB4XCI7XHJcbiAgICBkaXYuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VwZXJjbGFzcyByZXNpemUoKSBmdW5jdGlvbi5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBfX3N1cGVyX3Jlc2l6ZSA9IHRoaXMucmVzaXplO1xyXG5cclxuICAgIHRoaXMucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG5cclxuICAgICAgICAvLyBSZXNpemUgY29udGFpbmluZyBkaXZcclxuICAgICAgICBkaXYuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcclxuICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xyXG5cclxuICAgICAgICBfX3N1cGVyX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICB9O1xyXG4gIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGNhbnZhcyBhbmQgYW55IG90aGVyIGVsZW1lbnRzXHJcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXllci5cclxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSBUaGUgZWxlbWVudCBjb250YWluaW5nIHRoaXMgbGF5ZXIncyBjYW52YXMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBkaXY7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiB0aGlzIGxheWVyJ3MgdHJhbnNmb3JtLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKDBweCwgMHB4KVwiOyAvLyAoMCwgMClcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhcmJpdHJhcnkgbWF0cml4IGNvbXBvbmVudCBvZiB0aGlzIGxheWVyJ3MgdHJhbnNmb3JtLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIG1hdHJpeCA9IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCI7IC8vIElkZW50aXR5XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhpcyBsYXllciB0byB0aGUgZ2l2ZW4gWCBhbmQgWVxyXG4gICAgICogY29vcmRpbmF0ZS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSB0byBtb3ZlIHRvLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSB0byBtb3ZlIHRvLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHJcbiAgICAgICAgbGF5ZXIueCA9IHg7XHJcbiAgICAgICAgbGF5ZXIueSA9IHk7XHJcblxyXG4gICAgICAgIC8vIEdlbmVyYXRlIHRyYW5zbGF0aW9uXHJcbiAgICAgICAgdHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUoXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyB4ICsgXCJweCxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICArIHkgKyBcInB4KVwiO1xyXG5cclxuICAgICAgICAvLyBTZXQgbGF5ZXIgdHJhbnNmb3JtIFxyXG4gICAgICAgIGRpdi5zdHlsZS50cmFuc2Zvcm0gPVxyXG4gICAgICAgIGRpdi5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPVxyXG4gICAgICAgIGRpdi5zdHlsZS5Nb3pUcmFuc2Zvcm0gPVxyXG4gICAgICAgIGRpdi5zdHlsZS5PVHJhbnNmb3JtID1cclxuICAgICAgICBkaXYuc3R5bGUubXNUcmFuc2Zvcm0gPVxyXG5cclxuICAgICAgICAgICAgdHJhbnNsYXRlICsgXCIgXCIgKyBtYXRyaXg7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGlzIFZpc2libGVMYXllciB0byB0aGUgZ2l2ZW4gWCBhbmQgWVxyXG4gICAgICogY29vcmRpbmF0ZSwgc2V0cyB0aGUgWiBzdGFja2luZyBvcmRlciwgYW5kIHJlcGFyZW50cyB0aGlzIFZpc2libGVMYXllclxyXG4gICAgICogdG8gdGhlIGdpdmVuIFZpc2libGVMYXllci5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ9IHBhcmVudCBUaGUgcGFyZW50IHRvIHNldC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgdG8gbW92ZSB0by5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgdG8gbW92ZSB0by5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSBaIGNvb3JkaW5hdGUgdG8gbW92ZSB0by5cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb3ZlID0gZnVuY3Rpb24ocGFyZW50LCB4LCB5LCB6KSB7XHJcblxyXG4gICAgICAgIC8vIFNldCBwYXJlbnQgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgaWYgKGxheWVyLnBhcmVudCAhPT0gcGFyZW50KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWludGFpbiByZWxhdGlvbnNoaXBcclxuICAgICAgICAgICAgaWYgKGxheWVyLnBhcmVudClcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBsYXllci5wYXJlbnQuY2hpbGRyZW5bbGF5ZXIuX191bmlxdWVfaWRdO1xyXG4gICAgICAgICAgICBsYXllci5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbltsYXllci5fX3VuaXF1ZV9pZF0gPSBsYXllcjtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlcGFyZW50IGVsZW1lbnRcclxuICAgICAgICAgICAgdmFyIHBhcmVudF9lbGVtZW50ID0gcGFyZW50LmdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgcGFyZW50X2VsZW1lbnQuYXBwZW5kQ2hpbGQoZGl2KTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgbG9jYXRpb25cclxuICAgICAgICBsYXllci50cmFuc2xhdGUoeCwgeSk7XHJcbiAgICAgICAgbGF5ZXIueiA9IHo7XHJcbiAgICAgICAgZGl2LnN0eWxlLnpJbmRleCA9IHo7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhpcyBsYXllciB0byB0aGUgZ2l2ZW4gdmFsdWUsIHdoZXJlIDI1NSBpcyBmdWxseVxyXG4gICAgICogb3BhcXVlIGFuZCAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgb3BhY2l0eSB0byBzZXQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2hhZGUgPSBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgbGF5ZXIuYWxwaGEgPSBhO1xyXG4gICAgICAgIGRpdi5zdHlsZS5vcGFjaXR5ID0gYS8yNTUuMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoaXMgbGF5ZXIgY29udGFpbmVyIGVudGlyZWx5LCBzdWNoIHRoYXQgaXQgaXMgbm8gbG9uZ2VyXHJcbiAgICAgKiBjb250YWluZWQgd2l0aGluIGl0cyBwYXJlbnQgbGF5ZXIsIGlmIGFueS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHBhcmVudCBjb250YWluZXJcclxuICAgICAgICBpZiAobGF5ZXIucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBsYXllci5wYXJlbnQuY2hpbGRyZW5bbGF5ZXIuX191bmlxdWVfaWRdO1xyXG4gICAgICAgICAgICBsYXllci5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gcGFyZW50IGVsZW1lbnRcclxuICAgICAgICBpZiAoZGl2LnBhcmVudE5vZGUpXHJcbiAgICAgICAgICAgIGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpdik7XHJcbiAgICAgICAgXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gYWZmaW5lIHRyYW5zZm9ybSAoZGVmaW5lZCB3aXRoIHNpeCB2YWx1ZXMgZnJvbSB0aGVcclxuICAgICAqIHRyYW5zZm9ybSdzIG1hdHJpeCkuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgdGhpcmQgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZCBUaGUgZm91cnRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGUgVGhlIGZpZnRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGYgVGhlIHNpeHRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRpc3RvcnQgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XHJcblxyXG4gICAgICAgIC8vIFN0b3JlIG1hdHJpeFxyXG4gICAgICAgIGxheWVyLm1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcclxuXHJcbiAgICAgICAgLy8gR2VuZXJhdGUgbWF0cml4IHRyYW5zZm9ybWF0aW9uXHJcbiAgICAgICAgbWF0cml4ID1cclxuXHJcbiAgICAgICAgICAgIC8qIGEgYyBlXHJcbiAgICAgICAgICAgICAqIGIgZCBmXHJcbiAgICAgICAgICAgICAqIDAgMCAxXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgXHJcbiAgICAgICAgICAgIFwibWF0cml4KFwiICsgYSArIFwiLFwiICsgYiArIFwiLFwiICsgYyArIFwiLFwiICsgZCArIFwiLFwiICsgZSArIFwiLFwiICsgZiArIFwiKVwiO1xyXG5cclxuICAgICAgICAvLyBTZXQgbGF5ZXIgdHJhbnNmb3JtIFxyXG4gICAgICAgIGRpdi5zdHlsZS50cmFuc2Zvcm0gPVxyXG4gICAgICAgIGRpdi5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPVxyXG4gICAgICAgIGRpdi5zdHlsZS5Nb3pUcmFuc2Zvcm0gPVxyXG4gICAgICAgIGRpdi5zdHlsZS5PVHJhbnNmb3JtID1cclxuICAgICAgICBkaXYuc3R5bGUubXNUcmFuc2Zvcm0gPVxyXG5cclxuICAgICAgICAgICAgdHJhbnNsYXRlICsgXCIgXCIgKyBtYXRyaXg7XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIG5leHQgaWRlbnRpZmllciB0byBiZSBhc3NpZ25lZCB0byB0aGUgbGF5ZXIgY29udGFpbmVyLiBUaGlzIGlkZW50aWZpZXJcclxuICogdW5pcXVlbHkgaWRlbnRpZmllcyBlYWNoIFZpc2libGVMYXllciwgYnV0IGlzIHVucmVsYXRlZCB0byB0aGUgaW5kZXggb2ZcclxuICogdGhlIGxheWVyLCB3aGljaCBleGlzdHMgYXQgdGhlIHByb3RvY29sL2NsaWVudCBsZXZlbCBvbmx5LlxyXG4gKiBcclxuICogQHByaXZhdGVcclxuICogQHR5cGUge051bWJlcn1cclxuICovXHJcbkd1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllci5fX25leHRfaWQgPSAwO1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQSBoaWRkZW4gaW5wdXQgZmllbGQgd2hpY2ggYXR0ZW1wdHMgdG8ga2VlcCBpdHNlbGYgZm9jdXNlZCBhdCBhbGwgdGltZXMsXHJcbiAqIGV4Y2VwdCB3aGVuIGFub3RoZXIgaW5wdXQgZmllbGQgaGFzIGJlZW4gaW50ZW50aW9uYWxseSBmb2N1c2VkLCB3aGV0aGVyXHJcbiAqIHByb2dyYW1hdGljYWxseSBvciBieSB0aGUgdXNlci4gVGhlIGFjdHVhbCB1bmRlcmx5aW5nIGlucHV0IGZpZWxkLCByZXR1cm5lZFxyXG4gKiBieSBnZXRFbGVtZW50KCksIG1heSBiZSB1c2VkIGFzIGEgcmVsaWFibGUgc291cmNlIG9mIGtleWJvYXJkLXJlbGF0ZWQgZXZlbnRzLFxyXG4gKiBwYXJ0aWN1bGFybHkgY29tcG9zaXRpb24gYW5kIGlucHV0IGV2ZW50cyB3aGljaCBtYXkgcmVxdWlyZSBhIGZvY3VzZWQgaW5wdXRcclxuICogZmllbGQgdG8gYmUgZGlzcGF0Y2hlZCBhdCBhbGwuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuR3VhY2Ftb2xlLklucHV0U2luayA9IGZ1bmN0aW9uIElucHV0U2luaygpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlIG9mIEd1YWNhbW9sZS5JbnB1dFNpbmsuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuSW5wdXRTaW5rfVxyXG4gICAgICovXHJcbiAgICB2YXIgc2luayA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdW5kZXJseWluZyBpbnB1dCBmaWVsZCwgc3R5bGVkIHRvIGJlIGludmlzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHZhciBmaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XHJcbiAgICBmaWVsZC5zdHlsZS5wb3NpdGlvbiAgID0gJ2ZpeGVkJztcclxuICAgIGZpZWxkLnN0eWxlLm91dGxpbmUgICAgPSAnbm9uZSc7XHJcbiAgICBmaWVsZC5zdHlsZS5ib3JkZXIgICAgID0gJ25vbmUnO1xyXG4gICAgZmllbGQuc3R5bGUubWFyZ2luICAgICA9ICcwJztcclxuICAgIGZpZWxkLnN0eWxlLnBhZGRpbmcgICAgPSAnMCc7XHJcbiAgICBmaWVsZC5zdHlsZS5oZWlnaHQgICAgID0gJzAnO1xyXG4gICAgZmllbGQuc3R5bGUud2lkdGggICAgICA9ICcwJztcclxuICAgIGZpZWxkLnN0eWxlLmxlZnQgICAgICAgPSAnMCc7XHJcbiAgICBmaWVsZC5zdHlsZS5ib3R0b20gICAgID0gJzAnO1xyXG4gICAgZmllbGQuc3R5bGUucmVzaXplICAgICA9ICdub25lJztcclxuICAgIGZpZWxkLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xyXG4gICAgZmllbGQuc3R5bGUuY29sb3IgICAgICA9ICd0cmFuc3BhcmVudCc7XHJcblxyXG4gICAgLy8gS2VlcCBmaWVsZCBjbGVhciB3aGVuIG1vZGlmaWVkIHZpYSBub3JtYWwga2V5cHJlc3Nlc1xyXG4gICAgZmllbGQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXByZXNzXCIsIGZ1bmN0aW9uIGNsZWFyS2V5cHJlc3MoZSkge1xyXG4gICAgICAgIGZpZWxkLnZhbHVlID0gJyc7XHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgLy8gS2VlcCBmaWVsZCBjbGVhciB3aGVuIG1vZG9maWVkIHZpYSBjb21wb3NpdGlvbiBldmVudHNcclxuICAgIGZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoXCJjb21wb3NpdGlvbmVuZFwiLCBmdW5jdGlvbiBjbGVhckNvbXBsZXRlZENvbXBvc2l0aW9uKGUpIHtcclxuICAgICAgICBpZiAoZS5kYXRhKVxyXG4gICAgICAgICAgICBmaWVsZC52YWx1ZSA9ICcnO1xyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIC8vIEtlZXAgZmllbGQgY2xlYXIgd2hlbiBtb2RvZmllZCB2aWEgaW5wdXQgZXZlbnRzXHJcbiAgICBmaWVsZC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZnVuY3Rpb24gY2xlYXJDb21wbGV0ZWRJbnB1dChlKSB7XHJcbiAgICAgICAgaWYgKGUuZGF0YSAmJiAhZS5pc0NvbXBvc2luZylcclxuICAgICAgICAgICAgZmllbGQudmFsdWUgPSAnJztcclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAvLyBXaGVuZXZlciBmb2N1cyBpcyBnYWluZWQsIGF1dG9tYXRpY2FsbHkgY2xpY2sgdG8gZW5zdXJlIGN1cnNvciBpc1xyXG4gICAgLy8gYWN0dWFsbHkgcGxhY2VkIHdpdGhpbiB0aGUgZmllbGQgKHRoZSBmaWVsZCBtYXkgc2ltcGx5IGJlIGhpZ2hsaWdodGVkIG9yXHJcbiAgICAvLyBvdXRsaW5lZCBvdGhlcndpc2UpXHJcbiAgICBmaWVsZC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZnVuY3Rpb24gZm9jdXNSZWNlaXZlZCgpIHtcclxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiBkZWZlclJlZm9jdXMoKSB7XHJcbiAgICAgICAgICAgIGZpZWxkLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIGZpZWxkLnNlbGVjdCgpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRlbXB0cyB0byBmb2N1cyB0aGUgdW5kZXJseWluZyBpbnB1dCBmaWVsZC4gVGhlIGZvY3VzIGF0dGVtcHQgb2NjdXJzXHJcbiAgICAgKiBhc3luY2hyb25vdXNseSwgYW5kIG1heSBzaWxlbnRseSBmYWlsIGRlcGVuZGluZyBvbiBicm93c2VyIHJlc3RyaWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xyXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uIGRlZmVyUmVmb2N1cygpIHtcclxuICAgICAgICAgICAgZmllbGQuZm9jdXMoKTsgLy8gRm9jdXMgbXVzdCBiZSBkZWZlcnJlZCB0byB3b3JrIHJlbGlhYmx5IGFjcm9zcyBicm93c2Vyc1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgaW5wdXQgZmllbGQuIFRoaXMgaW5wdXQgZmllbGQgTVVTVCBiZSBtYW51YWxseVxyXG4gICAgICogYWRkZWQgdG8gdGhlIERPTSBmb3IgdGhlIEd1YWNhbW9sZS5JbnB1dFNpbmsgdG8gaGF2ZSBhbnkgZWZmZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldEVsZW1lbnQgPSBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiBmaWVsZDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gQXV0b21hdGljYWxseSByZWZvY3VzIGlucHV0IHNpbmsgaWYgcGFydCBvZiBET01cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uIHJlZm9jdXNTaW5rKGUpIHtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IHJlZm9jdXMgaWYgZm9jdXMgaXMgb24gYW4gaW5wdXQgZmllbGRcclxuICAgICAgICB2YXIgZm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGZvY3VzZWQgJiYgZm9jdXNlZCAhPT0gZG9jdW1lbnQuYm9keSkge1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBjb25zaWRlciBmb2N1c2VkIGlucHV0IGZpZWxkcyB3aGljaCBhcmUgYWN0dWFsbHkgdmlzaWJsZVxyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IGZvY3VzZWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgKyByZWN0LndpZHRoID4gMCAmJiByZWN0LnRvcCArIHJlY3QuaGVpZ2h0ID4gMClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWZvY3VzIGlucHV0IHNpbmsgaW5zdGVhZCBvZiBoYW5kbGluZyBjbGlja1xyXG4gICAgICAgIHNpbmsuZm9jdXMoKTtcclxuXHJcbiAgICB9LCB0cnVlKTtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbnB1dCBzdHJlYW0gYWJzdHJhY3Rpb24gdXNlZCBieSB0aGUgR3VhY2Ftb2xlIGNsaWVudCB0byBmYWNpbGl0YXRlXHJcbiAqIHRyYW5zZmVyIG9mIGZpbGVzIG9yIG90aGVyIGJpbmFyeSBkYXRhLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLkNsaWVudH0gY2xpZW50IFRoZSBjbGllbnQgb3duaW5nIHRoaXMgc3RyZWFtLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoaXMgc3RyZWFtLlxyXG4gKi9cclxuR3VhY2Ftb2xlLklucHV0U3RyZWFtID0gZnVuY3Rpb24oY2xpZW50LCBpbmRleCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgc3RyZWFtLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNfc3RyZWFtID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGlzIHN0cmVhbS5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIGEgYmxvYiBvZiBkYXRhIGlzIHJlY2VpdmVkLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIFRoZSByZWNlaXZlZCBiYXNlNjQgZGF0YS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmJsb2IgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhpcyBzdHJlYW0gaXMgY2xvc2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmVuZCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2tub3dsZWRnZXMgdGhlIHJlY2VpcHQgb2YgYSBibG9iLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBBIGh1bWFuLXJlYWRhYmxlIG1lc3NhZ2UgZGVzY3JpYmluZyB0aGUgZXJyb3JcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIG9yIHN0YXR1cy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBlcnJvciBjb2RlLCBpZiBhbnksIG9yIDAgZm9yIHN1Y2Nlc3MuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VuZEFjayA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNvZGUpIHtcclxuICAgICAgICBjbGllbnQuc2VuZEFjayhndWFjX3N0cmVhbS5pbmRleCwgbWVzc2FnZSwgY29kZSk7XHJcbiAgICB9O1xyXG5cclxufTtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEludGVnZXIgcG9vbCB3aGljaCByZXR1cm5zIGNvbnNpc3RlbnRseSBpbmNyZWFzaW5nIGludGVnZXJzIHdoaWxlIGludGVnZXJzXHJcbiAqIGFyZSBpbiB1c2UsIGFuZCBwcmV2aW91c2x5LXVzZWQgaW50ZWdlcnMgd2hlbiBwb3NzaWJsZS5cclxuICogQGNvbnN0cnVjdG9yIFxyXG4gKi9cclxuR3VhY2Ftb2xlLkludGVnZXJQb29sID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBpbnRlZ2VyIHBvb2wuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNfcG9vbCA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBhdmFpbGFibGUgaW50ZWdlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cclxuICAgICAqL1xyXG4gICAgdmFyIHBvb2wgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuZXh0IGludGVnZXIgdG8gcmV0dXJuIGlmIG5vIG1vcmUgaW50ZWdlcnMgcmVtYWluLlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5uZXh0X2ludCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IGF2YWlsYWJsZSBpbnRlZ2VyIGluIHRoZSBwb29sLiBJZiBwb3NzaWJsZSwgYSBwcmV2aW91c2x5XHJcbiAgICAgKiB1c2VkIGludGVnZXIgd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAqIFxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbmV4dCBhdmFpbGFibGUgaW50ZWdlci5cclxuICAgICAqL1xyXG4gICAgdGhpcy5uZXh0ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8vIElmIGZyZWUnZCBpbnRlZ2VycyBleGlzdCwgcmV0dXJuIG9uZSBvZiB0aG9zZVxyXG4gICAgICAgIGlmIChwb29sLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHJldHVybiBwb29sLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgbmV3IGludGVnZXJcclxuICAgICAgICByZXR1cm4gZ3VhY19wb29sLm5leHRfaW50Kys7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZyZWVzIHRoZSBnaXZlbiBpbnRlZ2VyLCBhbGxvd2luZyBpdCB0byBiZSByZXVzZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlZ2VyIFRoZSBpbnRlZ2VyIHRvIGZyZWUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJlZSA9IGZ1bmN0aW9uKGludGVnZXIpIHtcclxuICAgICAgICBwb29sLnB1c2goaW50ZWdlcik7XHJcbiAgICB9O1xyXG5cclxufTtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgcmVhZGVyIHdoaWNoIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyB0aGUgZ2l2ZW4gaW5wdXQgc3RyZWFtLCBhc3NlbWJsaW5nIGFsbFxyXG4gKiByZWNlaXZlZCBibG9icyBpbnRvIGEgSmF2YVNjcmlwdCBvYmplY3QgYnkgYXBwZW5kaW5nIHRoZW0gdG8gZWFjaCBvdGhlciwgaW5cclxuICogb3JkZXIsIGFuZCBkZWNvZGluZyB0aGUgcmVzdWx0IGFzIEpTT04uIE5vdGUgdGhhdCB0aGlzIG9iamVjdCB3aWxsIG92ZXJ3cml0ZVxyXG4gKiBhbnkgaW5zdGFsbGVkIGV2ZW50IGhhbmRsZXJzIG9uIHRoZSBnaXZlbiBHdWFjYW1vbGUuSW5wdXRTdHJlYW0uXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuSW5wdXRTdHJlYW19IHN0cmVhbVxyXG4gKiAgICAgVGhlIHN0cmVhbSB0aGF0IEpTT04gd2lsbCBiZSByZWFkIGZyb20uXHJcbiAqL1xyXG5HdWFjYW1vbGUuSlNPTlJlYWRlciA9IGZ1bmN0aW9uIGd1YWNhbW9sZUpTT05SZWFkZXIoc3RyZWFtKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuSlNPTlJlYWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5KU09OUmVhZGVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY1JlYWRlciA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcGVkIEd1YWNhbW9sZS5TdHJpbmdSZWFkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuU3RyaW5nUmVhZGVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgc3RyaW5nUmVhZGVyID0gbmV3IEd1YWNhbW9sZS5TdHJpbmdSZWFkZXIoc3RyZWFtKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBKU09OIHJlYWQgdGh1cyBmYXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHZhciBqc29uID0gJyc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGlzIEd1YWNhbW9sZS5KU09OUmVhZGVyLCBpbiBjaGFyYWN0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqICAgICBUaGUgY3VycmVudCBsZW5ndGggb2YgdGhpcyBHdWFjYW1vbGUuSlNPTlJlYWRlci5cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIGpzb24ubGVuZ3RoO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNvbnRlbnRzIG9mIHRoaXMgR3VhY2Ftb2xlLkpTT05SZWFkZXIgYXMgYSBKYXZhU2NyaXB0XHJcbiAgICAgKiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICogICAgIFRoZSBjb250ZW50cyBvZiB0aGlzIEd1YWNhbW9sZS5KU09OUmVhZGVyLCBhcyBwYXJzZWQgZnJvbSB0aGUgSlNPTlxyXG4gICAgICogICAgIGNvbnRlbnRzIG9mIHRoZSBpbnB1dCBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0SlNPTiA9IGZ1bmN0aW9uIGdldEpTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFwcGVuZCBhbGwgcmVjZWl2ZWQgdGV4dFxyXG4gICAgc3RyaW5nUmVhZGVyLm9udGV4dCA9IGZ1bmN0aW9uIG9udGV4dCh0ZXh0KSB7XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCByZWNlaXZlZCB0ZXh0XHJcbiAgICAgICAganNvbiArPSB0ZXh0O1xyXG5cclxuICAgICAgICAvLyBDYWxsIGhhbmRsZXIsIGlmIHByZXNlbnRcclxuICAgICAgICBpZiAoZ3VhY1JlYWRlci5vbnByb2dyZXNzKVxyXG4gICAgICAgICAgICBndWFjUmVhZGVyLm9ucHJvZ3Jlc3ModGV4dC5sZW5ndGgpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gU2ltcGx5IGNhbGwgb25lbmQgd2hlbiBlbmQgcmVjZWl2ZWRcclxuICAgIHN0cmluZ1JlYWRlci5vbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xyXG4gICAgICAgIGlmIChndWFjUmVhZGVyLm9uZW5kKVxyXG4gICAgICAgICAgICBndWFjUmVhZGVyLm9uZW5kKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgb25jZSBmb3IgZXZlcnkgYmxvYiBvZiBkYXRhIHJlY2VpdmVkLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcclxuICAgICAqICAgICBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgcmVjZWl2ZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25wcm9ncmVzcyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCBvbmNlIHRoaXMgc3RyZWFtIGlzIGZpbmlzaGVkIGFuZCBubyBmdXJ0aGVyIGRhdGEgd2lsbCBiZSB3cml0dGVuLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uZW5kID0gbnVsbDtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBjcm9zcy1icm93c2VyIGFuZCBjcm9zcy1rZXlib2FyZCBrZXlib2FyZCBmb3IgYSBzcGVjaWZpYyBlbGVtZW50LlxyXG4gKiBCcm93c2VyIGFuZCBrZXlib2FyZCBsYXlvdXQgdmFyaWF0aW9uIGlzIGFic3RyYWN0ZWQgYXdheSwgcHJvdmlkaW5nIGV2ZW50c1xyXG4gKiB3aGljaCByZXByZXNlbnQga2V5cyBhcyB0aGVpciBjb3JyZXNwb25kaW5nIFgxMSBrZXlzeW0uXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50fSBbZWxlbWVudF1cclxuICogICAgVGhlIEVsZW1lbnQgdG8gdXNlIHRvIHByb3ZpZGUga2V5Ym9hcmQgZXZlbnRzLiBJZiBvbWl0dGVkLCBhdCBsZWFzdCBvbmVcclxuICogICAgRWxlbWVudCBtdXN0IGJlIG1hbnVhbGx5IHByb3ZpZGVkIHRocm91Z2ggdGhlIGxpc3RlblRvKCkgZnVuY3Rpb24gZm9yXHJcbiAqICAgIHRoZSBHdWFjYW1vbGUuS2V5Ym9hcmQgaW5zdGFuY2UgdG8gaGF2ZSBhbnkgZWZmZWN0LlxyXG4gKi9cclxuR3VhY2Ftb2xlLktleWJvYXJkID0gZnVuY3Rpb24gS2V5Ym9hcmQoZWxlbWVudCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLktleWJvYXJkLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNfa2V5Ym9hcmQgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW50ZWdlciB2YWx1ZSB3aGljaCB1bmlxdWVseSBpZGVudGlmaWVzIHRoaXMgR3VhY2Ftb2xlLktleWJvYXJkXHJcbiAgICAgKiBpbnN0YW5jZSB3aXRoIHJlc3BlY3QgdG8gb3RoZXIgR3VhY2Ftb2xlLktleWJvYXJkIGluc3RhbmNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNLZXlib2FyZElEID0gR3VhY2Ftb2xlLktleWJvYXJkLl9uZXh0SUQrKztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3aGljaCBpcyBhZGRlZCB0byBldmVudCBvYmplY3RzIHZpYSBtYXJrRXZlbnQoKVxyXG4gICAgICogdG8gbm90ZSB0aGF0IHRoZXkgaGF2ZSBhbHJlYWR5IGJlZW4gaGFuZGxlZCBieSB0aGlzIEd1YWNhbW9sZS5LZXlib2FyZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB2YXIgRVZFTlRfTUFSS0VSID0gJ19HVUFDX0tFWUJPQVJEX0hBTkRMRURfQllfJyArIGd1YWNLZXlib2FyZElEO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHVzZXIgcHJlc3NlcyBhIGtleSB3aXRoIHRoZSBlbGVtZW50IGFzc29jaWF0ZWRcclxuICAgICAqIHdpdGggdGhpcyBHdWFjYW1vbGUuS2V5Ym9hcmQgaW4gZm9jdXMuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtleXN5bSBUaGUga2V5c3ltIG9mIHRoZSBrZXkgYmVpbmcgcHJlc3NlZC5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGtleSBldmVudCBzaG91bGQgYmUgYWxsb3dlZCB0aHJvdWdoIHRvIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgYnJvd3NlciwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9ua2V5ZG93biA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgdXNlciByZWxlYXNlcyBhIGtleSB3aXRoIHRoZSBlbGVtZW50IGFzc29jaWF0ZWRcclxuICAgICAqIHdpdGggdGhpcyBHdWFjYW1vbGUuS2V5Ym9hcmQgaW4gZm9jdXMuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtleXN5bSBUaGUga2V5c3ltIG9mIHRoZSBrZXkgYmVpbmcgcmVsZWFzZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25rZXl1cCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb2Yga25vd24gcGxhdGZvcm0tc3BlY2lmaWMgb3IgYnJvd3Nlci1zcGVjaWZpYyBxdWlya3Mgd2hpY2ggbXVzdCBiZVxyXG4gICAgICogYWNjb3VudGVkIGZvciB0byBwcm9wZXJseSBpbnRlcnByZXQga2V5IGV2ZW50cywgZXZlbiBpZiB0aGUgb25seSB3YXkgdG9cclxuICAgICAqIHJlbGlhYmx5IGRldGVjdCB0aGF0IHF1aXJrIGlzIHRvIHBsYXRmb3JtL2Jyb3dzZXItc25pZmYuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgQm9vbGVhbj59XHJcbiAgICAgKi9cclxuICAgIHZhciBxdWlya3MgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIga2V5dXAgZXZlbnRzIGFyZSB1bml2ZXJzYWxseSB1bnJlbGlhYmxlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAga2V5dXBVbnJlbGlhYmxlOiBmYWxzZSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0aGUgQWx0IGtleSBpcyBhY3R1YWxseSBhIG1vZGlmaWVyIGZvciB0eXBhYmxlIGtleXMgYW5kIGlzXHJcbiAgICAgICAgICogdGh1cyBuZXZlciB1c2VkIGZvciBrZXlib2FyZCBzaG9ydGN1dHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBhbHRJc1R5cGFibGVPbmx5OiBmYWxzZSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB3ZSBjYW4gcmVseSBvbiByZWNlaXZpbmcgYSBrZXl1cCBldmVudCBmb3IgdGhlIENhcHMgTG9ja1xyXG4gICAgICAgICAqIGtleS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNhcHNMb2NrS2V5dXBVbnJlbGlhYmxlOiBmYWxzZVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gU2V0IHF1aXJrIGZsYWdzIGRlcGVuZGluZyBvbiBwbGF0Zm9ybS9icm93c2VyLCBpZiBzdWNoIGluZm9ybWF0aW9uIGlzXHJcbiAgICAvLyBhdmFpbGFibGVcclxuICAgIGlmIChuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnBsYXRmb3JtKSB7XHJcblxyXG4gICAgICAgIC8vIEFsbCBrZXl1cCBldmVudHMgYXJlIHVucmVsaWFibGUgb24gaU9TIChzYWRseSlcclxuICAgICAgICBpZiAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKC9pcGFkfGlwaG9uZXxpcG9kL2kpKVxyXG4gICAgICAgICAgICBxdWlya3Mua2V5dXBVbnJlbGlhYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gVGhlIEFsdCBrZXkgb24gTWFjIGlzIG5ldmVyIHVzZWQgZm9yIGtleWJvYXJkIHNob3J0Y3V0cywgYW5kIHRoZVxyXG4gICAgICAgIC8vIENhcHMgTG9jayBrZXkgbmV2ZXIgZGlzcGF0Y2hlcyBrZXl1cCBldmVudHNcclxuICAgICAgICBlbHNlIGlmIChuYXZpZ2F0b3IucGxhdGZvcm0ubWF0Y2goL15tYWMvaSkpIHtcclxuICAgICAgICAgICAgcXVpcmtzLmFsdElzVHlwYWJsZU9ubHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBxdWlya3MuY2Fwc0xvY2tLZXl1cFVucmVsaWFibGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGtleSBldmVudCBoYXZpbmcgYSBjb3JyZXNwb25kaW5nIHRpbWVzdGFtcC4gVGhpcyBldmVudCBpcyBub24tc3BlY2lmaWMuXHJcbiAgICAgKiBJdHMgc3ViY2xhc3NlcyBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIHdoZW4gcmVjb3JkaW5nIHNwZWNpZmljIGtleVxyXG4gICAgICogZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIEtleUV2ZW50ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIGtleSBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIga2V5X2V2ZW50ID0gdGhpcztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYXJiaXRyYXJ5IHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHMsIGluZGljYXRpbmcgdGhpcyBldmVudCdzXHJcbiAgICAgICAgICogcG9zaXRpb24gaW4gdGltZSByZWxhdGl2ZSB0byBvdGhlciBldmVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoaXMga2V5IGV2ZW50IHNob3VsZCBiZSBwcmV2ZW50ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGtleXN5bSBvZiB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSBldmVudCwgYXMgZGV0ZXJtaW5lZFxyXG4gICAgICAgICAqIGJ5IGEgYmVzdC1lZmZvcnQgZ3Vlc3MgdXNpbmcgYXZhaWxhYmxlIGV2ZW50IHByb3BlcnRpZXMgYW5kIGtleWJvYXJkXHJcbiAgICAgICAgICogc3RhdGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMua2V5c3ltID0gbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0aGUga2V5c3ltIHZhbHVlIG9mIHRoaXMga2V5IGV2ZW50IGlzIGtub3duIHRvIGJlIHJlbGlhYmxlLlxyXG4gICAgICAgICAqIElmIGZhbHNlLCB0aGUga2V5c3ltIG1heSBzdGlsbCBiZSB2YWxpZCwgYnV0IGl0J3Mgb25seSBhIGJlc3QgZ3Vlc3MsXHJcbiAgICAgICAgICogYW5kIGZ1dHVyZSBrZXkgZXZlbnRzIG1heSBiZSBhIGJldHRlciBzb3VyY2Ugb2YgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlbGlhYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGlzIGV2ZW50IHdhc1xyXG4gICAgICAgICAqIHJlY2VpdmVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHNpbmNlIHRoaXNcclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIGV2ZW50IHdhcyByZWNlaXZlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdldEFnZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBrZXlfZXZlbnQudGltZXN0YW1wO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIHByZXNzaW5nIG9mIGEga2V5LCB3aGljaCBuZWVkIG5vdCBiZSBhIGtleVxyXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIGEgcHJpbnRhYmxlIGNoYXJhY3Rlci4gVGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgYW55XHJcbiAgICAgKiBpbmZvcm1hdGlvbiB3aXRoaW4gdGhpcyBvYmplY3QgaXMgYnJvd3Nlci1kZXBlbmRlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1Z21lbnRzIEd1YWNhbW9sZS5LZXlib2FyZC5LZXlFdmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtleUNvZGUgVGhlIEphdmFTY3JpcHQga2V5IGNvZGUgb2YgdGhlIGtleSBwcmVzc2VkLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleUlkZW50aWZpZXIgVGhlIGxlZ2FjeSBET00zIFwia2V5SWRlbnRpZmllclwiIG9mIHRoZSBrZXlcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNzZWQsIGFzIGRlZmluZWQgYXQ6XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDA5MDkwOC8jZXZlbnRzLUV2ZW50cy1LZXlib2FyZEV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBzdGFuZGFyZCBuYW1lIG9mIHRoZSBrZXkgcHJlc3NlZCwgYXMgZGVmaW5lZCBhdDpcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uIFRoZSBsb2NhdGlvbiBvbiB0aGUga2V5Ym9hcmQgY29ycmVzcG9uZGluZyB0b1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBrZXkgcHJlc3NlZCwgYXMgZGVmaW5lZCBhdDpcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1LZXlib2FyZEV2ZW50XHJcbiAgICAgKi9cclxuICAgIHZhciBLZXlkb3duRXZlbnQgPSBmdW5jdGlvbihrZXlDb2RlLCBrZXlJZGVudGlmaWVyLCBrZXksIGxvY2F0aW9uKSB7XHJcblxyXG4gICAgICAgIC8vIFdlIGV4dGVuZCBLZXlFdmVudFxyXG4gICAgICAgIEtleUV2ZW50LmFwcGx5KHRoaXMpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgSmF2YVNjcmlwdCBrZXkgY29kZSBvZiB0aGUga2V5IHByZXNzZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMua2V5Q29kZSA9IGtleUNvZGU7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsZWdhY3kgRE9NMyBcImtleUlkZW50aWZpZXJcIiBvZiB0aGUga2V5IHByZXNzZWQsIGFzIGRlZmluZWQgYXQ6XHJcbiAgICAgICAgICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwOTA5MDgvI2V2ZW50cy1FdmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmtleUlkZW50aWZpZXIgPSBrZXlJZGVudGlmaWVyO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc3RhbmRhcmQgbmFtZSBvZiB0aGUga2V5IHByZXNzZWQsIGFzIGRlZmluZWQgYXQ6XHJcbiAgICAgICAgICogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsb2NhdGlvbiBvbiB0aGUga2V5Ym9hcmQgY29ycmVzcG9uZGluZyB0byB0aGUga2V5IHByZXNzZWQsIGFzXHJcbiAgICAgICAgICogZGVmaW5lZCBhdDpcclxuICAgICAgICAgKiBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1LZXlib2FyZEV2ZW50XHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XHJcblxyXG4gICAgICAgIC8vIElmIGtleSBpcyBrbm93biBmcm9tIGtleUNvZGUgb3IgRE9NMyBhbG9uZSwgdXNlIHRoYXRcclxuICAgICAgICB0aGlzLmtleXN5bSA9ICBrZXlzeW1fZnJvbV9rZXlfaWRlbnRpZmllcihrZXksIGxvY2F0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHx8IGtleXN5bV9mcm9tX2tleWNvZGUoa2V5Q29kZSwgbG9jYXRpb24pO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBrZXl1cCBmb2xsb3dpbmcgdGhpcyBrZXlkb3duIGV2ZW50IGlzIGtub3duIHRvIGJlXHJcbiAgICAgICAgICogcmVsaWFibGUuIElmIGZhbHNlLCB3ZSBjYW5ub3QgcmVseSBvbiB0aGUga2V5dXAgZXZlbnQgdG8gb2NjdXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmtleXVwUmVsaWFibGUgPSAhcXVpcmtzLmtleXVwVW5yZWxpYWJsZTtcclxuXHJcbiAgICAgICAgLy8gRE9NMyBhbmQga2V5Q29kZSBhcmUgcmVsaWFibGUgc291cmNlcyBpZiB0aGUgY29ycmVzcG9uZGluZyBrZXkgaXNcclxuICAgICAgICAvLyBub3QgYSBwcmludGFibGUga2V5XHJcbiAgICAgICAgaWYgKHRoaXMua2V5c3ltICYmICFpc1ByaW50YWJsZSh0aGlzLmtleXN5bSkpXHJcbiAgICAgICAgICAgIHRoaXMucmVsaWFibGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBVc2UgbGVnYWN5IGtleUlkZW50aWZpZXIgYXMgYSBsYXN0IHJlc29ydCwgaWYgaXQgbG9va3Mgc2FuZVxyXG4gICAgICAgIGlmICghdGhpcy5rZXlzeW0gJiYga2V5X2lkZW50aWZpZXJfc2FuZShrZXlDb2RlLCBrZXlJZGVudGlmaWVyKSlcclxuICAgICAgICAgICAgdGhpcy5rZXlzeW0gPSBrZXlzeW1fZnJvbV9rZXlfaWRlbnRpZmllcihrZXlJZGVudGlmaWVyLCBsb2NhdGlvbiwgZ3VhY19rZXlib2FyZC5tb2RpZmllcnMuc2hpZnQpO1xyXG5cclxuICAgICAgICAvLyBJZiBhIGtleSBpcyBwcmVzc2VkIHdoaWxlIG1ldGEgaXMgaGVsZCBkb3duLCB0aGUga2V5dXAgd2lsbFxyXG4gICAgICAgIC8vIG5ldmVyIGJlIHNlbnQgaW4gQ2hyb21lIChidWcgIzEwODQwNClcclxuICAgICAgICBpZiAoZ3VhY19rZXlib2FyZC5tb2RpZmllcnMubWV0YSAmJiB0aGlzLmtleXN5bSAhPT0gMHhGRkU3ICYmIHRoaXMua2V5c3ltICE9PSAweEZGRTgpXHJcbiAgICAgICAgICAgIHRoaXMua2V5dXBSZWxpYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBXZSBjYW5ub3QgcmVseSBvbiByZWNlaXZpbmcga2V5dXAgZm9yIENhcHMgTG9jayBvbiBjZXJ0YWluIHBsYXRmb3Jtc1xyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMua2V5c3ltID09PSAweEZGRTUgJiYgcXVpcmtzLmNhcHNMb2NrS2V5dXBVbnJlbGlhYmxlKVxyXG4gICAgICAgICAgICB0aGlzLmtleXVwUmVsaWFibGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgZGVmYXVsdCBhY3Rpb24gZm9yIEFsdCtjb21iaW5hdGlvbnMgbXVzdCBiZSBwcmV2ZW50ZWRcclxuICAgICAgICB2YXIgcHJldmVudF9hbHQgPSAhZ3VhY19rZXlib2FyZC5tb2RpZmllcnMuY3RybCAmJiAhcXVpcmtzLmFsdElzVHlwYWJsZU9ubHk7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIGRlZmF1bHQgYWN0aW9uIGZvciBDdHJsK2NvbWJpbmF0aW9ucyBtdXN0IGJlIHByZXZlbnRlZFxyXG4gICAgICAgIHZhciBwcmV2ZW50X2N0cmwgPSAhZ3VhY19rZXlib2FyZC5tb2RpZmllcnMuYWx0O1xyXG5cclxuICAgICAgICAvLyBXZSBtdXN0IHJlbHkgb24gdGhlIChwb3RlbnRpYWxseSBidWdneSkga2V5SWRlbnRpZmllciBpZiBwcmV2ZW50aW5nXHJcbiAgICAgICAgLy8gdGhlIGRlZmF1bHQgYWN0aW9uIGlzIGltcG9ydGFudFxyXG4gICAgICAgIGlmICgocHJldmVudF9jdHJsICYmIGd1YWNfa2V5Ym9hcmQubW9kaWZpZXJzLmN0cmwpXHJcbiAgICAgICAgIHx8IChwcmV2ZW50X2FsdCAgJiYgZ3VhY19rZXlib2FyZC5tb2RpZmllcnMuYWx0KVxyXG4gICAgICAgICB8fCBndWFjX2tleWJvYXJkLm1vZGlmaWVycy5tZXRhXHJcbiAgICAgICAgIHx8IGd1YWNfa2V5Ym9hcmQubW9kaWZpZXJzLmh5cGVyKVxyXG4gICAgICAgICAgICB0aGlzLnJlbGlhYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gUmVjb3JkIG1vc3QgcmVjZW50bHkga25vd24ga2V5c3ltIGJ5IGFzc29jaWF0ZWQga2V5IGNvZGVcclxuICAgICAgICByZWNlbnRLZXlzeW1ba2V5Q29kZV0gPSB0aGlzLmtleXN5bTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEtleWRvd25FdmVudC5wcm90b3R5cGUgPSBuZXcgS2V5RXZlbnQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIHByZXNzaW5nIG9mIGEga2V5LCB3aGljaCBNVVNUIGJlXHJcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggYSBwcmludGFibGUgY2hhcmFjdGVyLiBUaGUgcHJlc2VuY2Ugb3IgYWJzZW5jZSBvZiBhbnlcclxuICAgICAqIGluZm9ybWF0aW9uIHdpdGhpbiB0aGlzIG9iamVjdCBpcyBicm93c2VyLWRlcGVuZGVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAYXVnbWVudHMgR3VhY2Ftb2xlLktleWJvYXJkLktleUV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckNvZGUgVGhlIFVuaWNvZGUgY29kZXBvaW50IG9mIHRoZSBjaGFyYWN0ZXIgdGhhdFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHdvdWxkIGJlIHR5cGVkIGJ5IHRoZSBrZXkgcHJlc3NlZC5cclxuICAgICAqL1xyXG4gICAgdmFyIEtleXByZXNzRXZlbnQgPSBmdW5jdGlvbihjaGFyQ29kZSkge1xyXG5cclxuICAgICAgICAvLyBXZSBleHRlbmQgS2V5RXZlbnRcclxuICAgICAgICBLZXlFdmVudC5hcHBseSh0aGlzKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFVuaWNvZGUgY29kZXBvaW50IG9mIHRoZSBjaGFyYWN0ZXIgdGhhdCB3b3VsZCBiZSB0eXBlZCBieSB0aGVcclxuICAgICAgICAgKiBrZXkgcHJlc3NlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGFyQ29kZSA9IGNoYXJDb2RlO1xyXG5cclxuICAgICAgICAvLyBQdWxsIGtleXN5bSBmcm9tIGNoYXIgY29kZVxyXG4gICAgICAgIHRoaXMua2V5c3ltID0ga2V5c3ltX2Zyb21fY2hhcmNvZGUoY2hhckNvZGUpO1xyXG5cclxuICAgICAgICAvLyBLZXlwcmVzcyBpcyBhbHdheXMgcmVsaWFibGVcclxuICAgICAgICB0aGlzLnJlbGlhYmxlID0gdHJ1ZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEtleXByZXNzRXZlbnQucHJvdG90eXBlID0gbmV3IEtleUV2ZW50KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoZSBwcmVzc2luZyBvZiBhIGtleSwgd2hpY2ggbmVlZCBub3QgYmUgYSBrZXlcclxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCBhIHByaW50YWJsZSBjaGFyYWN0ZXIuIFRoZSBwcmVzZW5jZSBvciBhYnNlbmNlIG9mIGFueVxyXG4gICAgICogaW5mb3JtYXRpb24gd2l0aGluIHRoaXMgb2JqZWN0IGlzIGJyb3dzZXItZGVwZW5kZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBhdWdtZW50cyBHdWFjYW1vbGUuS2V5Ym9hcmQuS2V5RXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrZXlDb2RlIFRoZSBKYXZhU2NyaXB0IGtleSBjb2RlIG9mIHRoZSBrZXkgcmVsZWFzZWQuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5SWRlbnRpZmllciBUaGUgbGVnYWN5IERPTTMgXCJrZXlJZGVudGlmaWVyXCIgb2YgdGhlIGtleVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZWQsIGFzIGRlZmluZWQgYXQ6XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDA5MDkwOC8jZXZlbnRzLUV2ZW50cy1LZXlib2FyZEV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBzdGFuZGFyZCBuYW1lIG9mIHRoZSBrZXkgcmVsZWFzZWQsIGFzIGRlZmluZWQgYXQ6XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLUtleWJvYXJkRXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhdGlvbiBUaGUgbG9jYXRpb24gb24gdGhlIGtleWJvYXJkIGNvcnJlc3BvbmRpbmcgdG9cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUga2V5IHJlbGVhc2VkLCBhcyBkZWZpbmVkIGF0OlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLUtleWJvYXJkRXZlbnRcclxuICAgICAqL1xyXG4gICAgdmFyIEtleXVwRXZlbnQgPSBmdW5jdGlvbihrZXlDb2RlLCBrZXlJZGVudGlmaWVyLCBrZXksIGxvY2F0aW9uKSB7XHJcblxyXG4gICAgICAgIC8vIFdlIGV4dGVuZCBLZXlFdmVudFxyXG4gICAgICAgIEtleUV2ZW50LmFwcGx5KHRoaXMpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgSmF2YVNjcmlwdCBrZXkgY29kZSBvZiB0aGUga2V5IHJlbGVhc2VkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmtleUNvZGUgPSBrZXlDb2RlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGVnYWN5IERPTTMgXCJrZXlJZGVudGlmaWVyXCIgb2YgdGhlIGtleSByZWxlYXNlZCwgYXMgZGVmaW5lZCBhdDpcclxuICAgICAgICAgKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDA5MDkwOC8jZXZlbnRzLUV2ZW50cy1LZXlib2FyZEV2ZW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMua2V5SWRlbnRpZmllciA9IGtleUlkZW50aWZpZXI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzdGFuZGFyZCBuYW1lIG9mIHRoZSBrZXkgcmVsZWFzZWQsIGFzIGRlZmluZWQgYXQ6XHJcbiAgICAgICAgICogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsb2NhdGlvbiBvbiB0aGUga2V5Ym9hcmQgY29ycmVzcG9uZGluZyB0byB0aGUga2V5IHJlbGVhc2VkLCBhc1xyXG4gICAgICAgICAqIGRlZmluZWQgYXQ6XHJcbiAgICAgICAgICogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG5cclxuICAgICAgICAvLyBJZiBrZXkgaXMga25vd24gZnJvbSBrZXlDb2RlIG9yIERPTTMgYWxvbmUsIHVzZSB0aGF0XHJcbiAgICAgICAgdGhpcy5rZXlzeW0gPSAga2V5c3ltX2Zyb21fa2V5Y29kZShrZXlDb2RlLCBsb2NhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB8fCBrZXlzeW1fZnJvbV9rZXlfaWRlbnRpZmllcihrZXksIGxvY2F0aW9uKTsgLy8ga2V5Q29kZSBpcyBzdGlsbCBtb3JlIHJlbGlhYmxlIGZvciBrZXl1cCB3aGVuIGRlYWQga2V5cyBhcmUgaW4gdXNlXHJcblxyXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgbW9zdCByZWNlbnRseSBwcmVzc2VkIGtleXN5bSBhc3NvY2lhdGVkIHdpdGggdGhlXHJcbiAgICAgICAgLy8ga2V5Q29kZSBpZiB0aGUgaW5mZXJyZWQga2V5IGRvZXNuJ3Qgc2VlbSB0byBhY3R1YWxseSBiZSBwcmVzc2VkXHJcbiAgICAgICAgaWYgKCFndWFjX2tleWJvYXJkLnByZXNzZWRbdGhpcy5rZXlzeW1dKVxyXG4gICAgICAgICAgICB0aGlzLmtleXN5bSA9IHJlY2VudEtleXN5bVtrZXlDb2RlXSB8fCB0aGlzLmtleXN5bTtcclxuXHJcbiAgICAgICAgLy8gS2V5dXAgaXMgYXMgcmVsaWFibGUgYXMgaXQgd2lsbCBldmVyIGJlXHJcbiAgICAgICAgdGhpcy5yZWxpYWJsZSA9IHRydWU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBLZXl1cEV2ZW50LnByb3RvdHlwZSA9IG5ldyBLZXlFdmVudCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgcmVjb3JkZWQgZXZlbnRzLCB3aGljaCBjYW4gYmUgaW5zdGFuY2VzIG9mIHRoZSBwcml2YXRlXHJcbiAgICAgKiBLZXlkb3duRXZlbnQsIEtleXByZXNzRXZlbnQsIGFuZCBLZXl1cEV2ZW50IGNsYXNzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtLZXlFdmVudFtdfVxyXG4gICAgICovXHJcbiAgICB2YXIgZXZlbnRMb2cgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBvZiBrbm93biBKYXZhU2NyaXB0IGtleWNvZGVzIHdoaWNoIGRvIG5vdCBtYXAgdG8gdHlwYWJsZSBjaGFyYWN0ZXJzXHJcbiAgICAgKiB0byB0aGVpciBYMTEga2V5c3ltIGVxdWl2YWxlbnRzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGtleWNvZGVLZXlzeW1zID0ge1xyXG4gICAgICAgIDg6ICAgWzB4RkYwOF0sIC8vIGJhY2tzcGFjZVxyXG4gICAgICAgIDk6ICAgWzB4RkYwOV0sIC8vIHRhYlxyXG4gICAgICAgIDEyOiAgWzB4RkYwQiwgMHhGRjBCLCAweEZGMEIsIDB4RkZCNV0sIC8vIGNsZWFyICAgICAgIC8gS1AgNVxyXG4gICAgICAgIDEzOiAgWzB4RkYwRF0sIC8vIGVudGVyXHJcbiAgICAgICAgMTY6ICBbMHhGRkUxLCAweEZGRTEsIDB4RkZFMl0sIC8vIHNoaWZ0XHJcbiAgICAgICAgMTc6ICBbMHhGRkUzLCAweEZGRTMsIDB4RkZFNF0sIC8vIGN0cmxcclxuICAgICAgICAxODogIFsweEZGRTksIDB4RkZFOSwgMHhGRTAzXSwgLy8gYWx0XHJcbiAgICAgICAgMTk6ICBbMHhGRjEzXSwgLy8gcGF1c2UvYnJlYWtcclxuICAgICAgICAyMDogIFsweEZGRTVdLCAvLyBjYXBzIGxvY2tcclxuICAgICAgICAyNzogIFsweEZGMUJdLCAvLyBlc2NhcGVcclxuICAgICAgICAzMjogIFsweDAwMjBdLCAvLyBzcGFjZVxyXG4gICAgICAgIDMzOiAgWzB4RkY1NSwgMHhGRjU1LCAweEZGNTUsIDB4RkZCOV0sIC8vIHBhZ2UgdXAgICAgIC8gS1AgOVxyXG4gICAgICAgIDM0OiAgWzB4RkY1NiwgMHhGRjU2LCAweEZGNTYsIDB4RkZCM10sIC8vIHBhZ2UgZG93biAgIC8gS1AgM1xyXG4gICAgICAgIDM1OiAgWzB4RkY1NywgMHhGRjU3LCAweEZGNTcsIDB4RkZCMV0sIC8vIGVuZCAgICAgICAgIC8gS1AgMVxyXG4gICAgICAgIDM2OiAgWzB4RkY1MCwgMHhGRjUwLCAweEZGNTAsIDB4RkZCN10sIC8vIGhvbWUgICAgICAgIC8gS1AgN1xyXG4gICAgICAgIDM3OiAgWzB4RkY1MSwgMHhGRjUxLCAweEZGNTEsIDB4RkZCNF0sIC8vIGxlZnQgYXJyb3cgIC8gS1AgNFxyXG4gICAgICAgIDM4OiAgWzB4RkY1MiwgMHhGRjUyLCAweEZGNTIsIDB4RkZCOF0sIC8vIHVwIGFycm93ICAgIC8gS1AgOFxyXG4gICAgICAgIDM5OiAgWzB4RkY1MywgMHhGRjUzLCAweEZGNTMsIDB4RkZCNl0sIC8vIHJpZ2h0IGFycm93IC8gS1AgNlxyXG4gICAgICAgIDQwOiAgWzB4RkY1NCwgMHhGRjU0LCAweEZGNTQsIDB4RkZCMl0sIC8vIGRvd24gYXJyb3cgIC8gS1AgMlxyXG4gICAgICAgIDQ1OiAgWzB4RkY2MywgMHhGRjYzLCAweEZGNjMsIDB4RkZCMF0sIC8vIGluc2VydCAgICAgIC8gS1AgMFxyXG4gICAgICAgIDQ2OiAgWzB4RkZGRiwgMHhGRkZGLCAweEZGRkYsIDB4RkZBRV0sIC8vIGRlbGV0ZSAgICAgIC8gS1AgZGVjaW1hbFxyXG4gICAgICAgIDkxOiAgWzB4RkZFQl0sIC8vIGxlZnQgd2luZG93IGtleSAoaHlwZXJfbClcclxuICAgICAgICA5MjogIFsweEZGNjddLCAvLyByaWdodCB3aW5kb3cga2V5IChtZW51IGtleT8pXHJcbiAgICAgICAgOTM6ICBudWxsLCAgICAgLy8gc2VsZWN0IGtleVxyXG4gICAgICAgIDk2OiAgWzB4RkZCMF0sIC8vIEtQIDBcclxuICAgICAgICA5NzogIFsweEZGQjFdLCAvLyBLUCAxXHJcbiAgICAgICAgOTg6ICBbMHhGRkIyXSwgLy8gS1AgMlxyXG4gICAgICAgIDk5OiAgWzB4RkZCM10sIC8vIEtQIDNcclxuICAgICAgICAxMDA6IFsweEZGQjRdLCAvLyBLUCA0XHJcbiAgICAgICAgMTAxOiBbMHhGRkI1XSwgLy8gS1AgNVxyXG4gICAgICAgIDEwMjogWzB4RkZCNl0sIC8vIEtQIDZcclxuICAgICAgICAxMDM6IFsweEZGQjddLCAvLyBLUCA3XHJcbiAgICAgICAgMTA0OiBbMHhGRkI4XSwgLy8gS1AgOFxyXG4gICAgICAgIDEwNTogWzB4RkZCOV0sIC8vIEtQIDlcclxuICAgICAgICAxMDY6IFsweEZGQUFdLCAvLyBLUCBtdWx0aXBseVxyXG4gICAgICAgIDEwNzogWzB4RkZBQl0sIC8vIEtQIGFkZFxyXG4gICAgICAgIDEwOTogWzB4RkZBRF0sIC8vIEtQIHN1YnRyYWN0XHJcbiAgICAgICAgMTEwOiBbMHhGRkFFXSwgLy8gS1AgZGVjaW1hbFxyXG4gICAgICAgIDExMTogWzB4RkZBRl0sIC8vIEtQIGRpdmlkZVxyXG4gICAgICAgIDExMjogWzB4RkZCRV0sIC8vIGYxXHJcbiAgICAgICAgMTEzOiBbMHhGRkJGXSwgLy8gZjJcclxuICAgICAgICAxMTQ6IFsweEZGQzBdLCAvLyBmM1xyXG4gICAgICAgIDExNTogWzB4RkZDMV0sIC8vIGY0XHJcbiAgICAgICAgMTE2OiBbMHhGRkMyXSwgLy8gZjVcclxuICAgICAgICAxMTc6IFsweEZGQzNdLCAvLyBmNlxyXG4gICAgICAgIDExODogWzB4RkZDNF0sIC8vIGY3XHJcbiAgICAgICAgMTE5OiBbMHhGRkM1XSwgLy8gZjhcclxuICAgICAgICAxMjA6IFsweEZGQzZdLCAvLyBmOVxyXG4gICAgICAgIDEyMTogWzB4RkZDN10sIC8vIGYxMFxyXG4gICAgICAgIDEyMjogWzB4RkZDOF0sIC8vIGYxMVxyXG4gICAgICAgIDEyMzogWzB4RkZDOV0sIC8vIGYxMlxyXG4gICAgICAgIDE0NDogWzB4RkY3Rl0sIC8vIG51bSBsb2NrXHJcbiAgICAgICAgMTQ1OiBbMHhGRjE0XSwgLy8gc2Nyb2xsIGxvY2tcclxuICAgICAgICAyMjU6IFsweEZFMDNdICAvLyBhbHRncmFwaCAoaXNvX2xldmVsM19zaGlmdClcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2Yga25vd24gSmF2YVNjcmlwdCBrZXlpZGVudGlmaWVycyB3aGljaCBkbyBub3QgbWFwIHRvIHR5cGFibGVcclxuICAgICAqIGNoYXJhY3RlcnMgdG8gdGhlaXIgdW5zaGlmdGVkIFgxMSBrZXlzeW0gZXF1aXZhbGVudHMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIga2V5aWRlbnRpZmllcl9rZXlzeW0gPSB7XHJcbiAgICAgICAgXCJBZ2FpblwiOiBbMHhGRjY2XSxcclxuICAgICAgICBcIkFsbENhbmRpZGF0ZXNcIjogWzB4RkYzRF0sXHJcbiAgICAgICAgXCJBbHBoYW51bWVyaWNcIjogWzB4RkYzMF0sXHJcbiAgICAgICAgXCJBbHRcIjogWzB4RkZFOSwgMHhGRkU5LCAweEZFMDNdLFxyXG4gICAgICAgIFwiQXR0blwiOiBbMHhGRDBFXSxcclxuICAgICAgICBcIkFsdEdyYXBoXCI6IFsweEZFMDNdLFxyXG4gICAgICAgIFwiQXJyb3dEb3duXCI6IFsweEZGNTRdLFxyXG4gICAgICAgIFwiQXJyb3dMZWZ0XCI6IFsweEZGNTFdLFxyXG4gICAgICAgIFwiQXJyb3dSaWdodFwiOiBbMHhGRjUzXSxcclxuICAgICAgICBcIkFycm93VXBcIjogWzB4RkY1Ml0sXHJcbiAgICAgICAgXCJCYWNrc3BhY2VcIjogWzB4RkYwOF0sXHJcbiAgICAgICAgXCJDYXBzTG9ja1wiOiBbMHhGRkU1XSxcclxuICAgICAgICBcIkNhbmNlbFwiOiBbMHhGRjY5XSxcclxuICAgICAgICBcIkNsZWFyXCI6IFsweEZGMEJdLFxyXG4gICAgICAgIFwiQ29udmVydFwiOiBbMHhGRjIxXSxcclxuICAgICAgICBcIkNvcHlcIjogWzB4RkQxNV0sXHJcbiAgICAgICAgXCJDcnNlbFwiOiBbMHhGRDFDXSxcclxuICAgICAgICBcIkNyU2VsXCI6IFsweEZEMUNdLFxyXG4gICAgICAgIFwiQ29kZUlucHV0XCI6IFsweEZGMzddLFxyXG4gICAgICAgIFwiQ29tcG9zZVwiOiBbMHhGRjIwXSxcclxuICAgICAgICBcIkNvbnRyb2xcIjogWzB4RkZFMywgMHhGRkUzLCAweEZGRTRdLFxyXG4gICAgICAgIFwiQ29udGV4dE1lbnVcIjogWzB4RkY2N10sXHJcbiAgICAgICAgXCJEZWxldGVcIjogWzB4RkZGRl0sXHJcbiAgICAgICAgXCJEb3duXCI6IFsweEZGNTRdLFxyXG4gICAgICAgIFwiRW5kXCI6IFsweEZGNTddLFxyXG4gICAgICAgIFwiRW50ZXJcIjogWzB4RkYwRF0sXHJcbiAgICAgICAgXCJFcmFzZUVvZlwiOiBbMHhGRDA2XSxcclxuICAgICAgICBcIkVzY2FwZVwiOiBbMHhGRjFCXSxcclxuICAgICAgICBcIkV4ZWN1dGVcIjogWzB4RkY2Ml0sXHJcbiAgICAgICAgXCJFeHNlbFwiOiBbMHhGRDFEXSxcclxuICAgICAgICBcIkV4U2VsXCI6IFsweEZEMURdLFxyXG4gICAgICAgIFwiRjFcIjogWzB4RkZCRV0sXHJcbiAgICAgICAgXCJGMlwiOiBbMHhGRkJGXSxcclxuICAgICAgICBcIkYzXCI6IFsweEZGQzBdLFxyXG4gICAgICAgIFwiRjRcIjogWzB4RkZDMV0sXHJcbiAgICAgICAgXCJGNVwiOiBbMHhGRkMyXSxcclxuICAgICAgICBcIkY2XCI6IFsweEZGQzNdLFxyXG4gICAgICAgIFwiRjdcIjogWzB4RkZDNF0sXHJcbiAgICAgICAgXCJGOFwiOiBbMHhGRkM1XSxcclxuICAgICAgICBcIkY5XCI6IFsweEZGQzZdLFxyXG4gICAgICAgIFwiRjEwXCI6IFsweEZGQzddLFxyXG4gICAgICAgIFwiRjExXCI6IFsweEZGQzhdLFxyXG4gICAgICAgIFwiRjEyXCI6IFsweEZGQzldLFxyXG4gICAgICAgIFwiRjEzXCI6IFsweEZGQ0FdLFxyXG4gICAgICAgIFwiRjE0XCI6IFsweEZGQ0JdLFxyXG4gICAgICAgIFwiRjE1XCI6IFsweEZGQ0NdLFxyXG4gICAgICAgIFwiRjE2XCI6IFsweEZGQ0RdLFxyXG4gICAgICAgIFwiRjE3XCI6IFsweEZGQ0VdLFxyXG4gICAgICAgIFwiRjE4XCI6IFsweEZGQ0ZdLFxyXG4gICAgICAgIFwiRjE5XCI6IFsweEZGRDBdLFxyXG4gICAgICAgIFwiRjIwXCI6IFsweEZGRDFdLFxyXG4gICAgICAgIFwiRjIxXCI6IFsweEZGRDJdLFxyXG4gICAgICAgIFwiRjIyXCI6IFsweEZGRDNdLFxyXG4gICAgICAgIFwiRjIzXCI6IFsweEZGRDRdLFxyXG4gICAgICAgIFwiRjI0XCI6IFsweEZGRDVdLFxyXG4gICAgICAgIFwiRmluZFwiOiBbMHhGRjY4XSxcclxuICAgICAgICBcIkdyb3VwRmlyc3RcIjogWzB4RkUwQ10sXHJcbiAgICAgICAgXCJHcm91cExhc3RcIjogWzB4RkUwRV0sXHJcbiAgICAgICAgXCJHcm91cE5leHRcIjogWzB4RkUwOF0sXHJcbiAgICAgICAgXCJHcm91cFByZXZpb3VzXCI6IFsweEZFMEFdLFxyXG4gICAgICAgIFwiRnVsbFdpZHRoXCI6IG51bGwsXHJcbiAgICAgICAgXCJIYWxmV2lkdGhcIjogbnVsbCxcclxuICAgICAgICBcIkhhbmd1bE1vZGVcIjogWzB4RkYzMV0sXHJcbiAgICAgICAgXCJIYW5rYWt1XCI6IFsweEZGMjldLFxyXG4gICAgICAgIFwiSGFuamFNb2RlXCI6IFsweEZGMzRdLFxyXG4gICAgICAgIFwiSGVscFwiOiBbMHhGRjZBXSxcclxuICAgICAgICBcIkhpcmFnYW5hXCI6IFsweEZGMjVdLFxyXG4gICAgICAgIFwiSGlyYWdhbmFLYXRha2FuYVwiOiBbMHhGRjI3XSxcclxuICAgICAgICBcIkhvbWVcIjogWzB4RkY1MF0sXHJcbiAgICAgICAgXCJIeXBlclwiOiBbMHhGRkVELCAweEZGRUQsIDB4RkZFRV0sXHJcbiAgICAgICAgXCJJbnNlcnRcIjogWzB4RkY2M10sXHJcbiAgICAgICAgXCJKYXBhbmVzZUhpcmFnYW5hXCI6IFsweEZGMjVdLFxyXG4gICAgICAgIFwiSmFwYW5lc2VLYXRha2FuYVwiOiBbMHhGRjI2XSxcclxuICAgICAgICBcIkphcGFuZXNlUm9tYWppXCI6IFsweEZGMjRdLFxyXG4gICAgICAgIFwiSnVuamFNb2RlXCI6IFsweEZGMzhdLFxyXG4gICAgICAgIFwiS2FuYU1vZGVcIjogWzB4RkYyRF0sXHJcbiAgICAgICAgXCJLYW5qaU1vZGVcIjogWzB4RkYyMV0sXHJcbiAgICAgICAgXCJLYXRha2FuYVwiOiBbMHhGRjI2XSxcclxuICAgICAgICBcIkxlZnRcIjogWzB4RkY1MV0sXHJcbiAgICAgICAgXCJNZXRhXCI6IFsweEZGRTcsIDB4RkZFNywgMHhGRkU4XSxcclxuICAgICAgICBcIk1vZGVDaGFuZ2VcIjogWzB4RkY3RV0sXHJcbiAgICAgICAgXCJOdW1Mb2NrXCI6IFsweEZGN0ZdLFxyXG4gICAgICAgIFwiUGFnZURvd25cIjogWzB4RkY1Nl0sXHJcbiAgICAgICAgXCJQYWdlVXBcIjogWzB4RkY1NV0sXHJcbiAgICAgICAgXCJQYXVzZVwiOiBbMHhGRjEzXSxcclxuICAgICAgICBcIlBsYXlcIjogWzB4RkQxNl0sXHJcbiAgICAgICAgXCJQcmV2aW91c0NhbmRpZGF0ZVwiOiBbMHhGRjNFXSxcclxuICAgICAgICBcIlByaW50U2NyZWVuXCI6IFsweEZGNjFdLFxyXG4gICAgICAgIFwiUmVkb1wiOiBbMHhGRjY2XSxcclxuICAgICAgICBcIlJpZ2h0XCI6IFsweEZGNTNdLFxyXG4gICAgICAgIFwiUm9tYW5DaGFyYWN0ZXJzXCI6IG51bGwsXHJcbiAgICAgICAgXCJTY3JvbGxcIjogWzB4RkYxNF0sXHJcbiAgICAgICAgXCJTZWxlY3RcIjogWzB4RkY2MF0sXHJcbiAgICAgICAgXCJTZXBhcmF0b3JcIjogWzB4RkZBQ10sXHJcbiAgICAgICAgXCJTaGlmdFwiOiBbMHhGRkUxLCAweEZGRTEsIDB4RkZFMl0sXHJcbiAgICAgICAgXCJTaW5nbGVDYW5kaWRhdGVcIjogWzB4RkYzQ10sXHJcbiAgICAgICAgXCJTdXBlclwiOiBbMHhGRkVCLCAweEZGRUIsIDB4RkZFQ10sXHJcbiAgICAgICAgXCJUYWJcIjogWzB4RkYwOV0sXHJcbiAgICAgICAgXCJVSUtleUlucHV0RG93bkFycm93XCI6IFsweEZGNTRdLFxyXG4gICAgICAgIFwiVUlLZXlJbnB1dEVzY2FwZVwiOiBbMHhGRjFCXSxcclxuICAgICAgICBcIlVJS2V5SW5wdXRMZWZ0QXJyb3dcIjogWzB4RkY1MV0sXHJcbiAgICAgICAgXCJVSUtleUlucHV0UmlnaHRBcnJvd1wiOiBbMHhGRjUzXSxcclxuICAgICAgICBcIlVJS2V5SW5wdXRVcEFycm93XCI6IFsweEZGNTJdLFxyXG4gICAgICAgIFwiVXBcIjogWzB4RkY1Ml0sXHJcbiAgICAgICAgXCJVbmRvXCI6IFsweEZGNjVdLFxyXG4gICAgICAgIFwiV2luXCI6IFsweEZGRUJdLFxyXG4gICAgICAgIFwiWmVua2FrdVwiOiBbMHhGRjI4XSxcclxuICAgICAgICBcIlplbmtha3VIYW5rYWt1XCI6IFsweEZGMkFdXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsIGtleXN5bXMgd2hpY2ggc2hvdWxkIG5vdCByZXBlYXQgd2hlbiBoZWxkIGRvd24uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgbm9fcmVwZWF0ID0ge1xyXG4gICAgICAgIDB4RkUwMzogdHJ1ZSwgLy8gSVNPIExldmVsIDMgU2hpZnQgKEFsdEdyKVxyXG4gICAgICAgIDB4RkZFMTogdHJ1ZSwgLy8gTGVmdCBzaGlmdFxyXG4gICAgICAgIDB4RkZFMjogdHJ1ZSwgLy8gUmlnaHQgc2hpZnRcclxuICAgICAgICAweEZGRTM6IHRydWUsIC8vIExlZnQgY3RybCBcclxuICAgICAgICAweEZGRTQ6IHRydWUsIC8vIFJpZ2h0IGN0cmwgXHJcbiAgICAgICAgMHhGRkU1OiB0cnVlLCAvLyBDYXBzIExvY2tcclxuICAgICAgICAweEZGRTc6IHRydWUsIC8vIExlZnQgbWV0YSBcclxuICAgICAgICAweEZGRTg6IHRydWUsIC8vIFJpZ2h0IG1ldGEgXHJcbiAgICAgICAgMHhGRkU5OiB0cnVlLCAvLyBMZWZ0IGFsdFxyXG4gICAgICAgIDB4RkZFQTogdHJ1ZSwgLy8gUmlnaHQgYWx0XHJcbiAgICAgICAgMHhGRkVCOiB0cnVlLCAvLyBMZWZ0IGh5cGVyXHJcbiAgICAgICAgMHhGRkVDOiB0cnVlICAvLyBSaWdodCBoeXBlclxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBtb2RpZmllcnMgYW5kIHRoZWlyIHN0YXRlcy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb2RpZmllcnMgPSBuZXcgR3VhY2Ftb2xlLktleWJvYXJkLk1vZGlmaWVyU3RhdGUoKTtcclxuICAgICAgICBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0YXRlIG9mIGV2ZXJ5IGtleSwgaW5kZXhlZCBieSBrZXlzeW0uIElmIGEgcGFydGljdWxhciBrZXkgaXNcclxuICAgICAqIHByZXNzZWQsIHRoZSB2YWx1ZSBvZiBwcmVzc2VkIGZvciB0aGF0IGtleXN5bSB3aWxsIGJlIHRydWUuIElmIGEga2V5XHJcbiAgICAgKiBpcyBub3QgY3VycmVudGx5IHByZXNzZWQsIGl0IHdpbGwgbm90IGJlIGRlZmluZWQuIFxyXG4gICAgICovXHJcbiAgICB0aGlzLnByZXNzZWQgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdGF0ZSBvZiBldmVyeSBrZXksIGluZGV4ZWQgYnkga2V5c3ltLCBmb3Igc3RyaWN0bHkgdGhvc2Uga2V5cyB3aG9zZVxyXG4gICAgICogc3RhdHVzIGhhcyBiZWVuIGluZGlyZWN0bHkgZGV0ZXJtaW5lZCB0aG9ydWdoIG9ic2VydmF0aW9uIG9mIG90aGVyIGtleVxyXG4gICAgICogZXZlbnRzLiBJZiBhIHBhcnRpY3VsYXIga2V5IGlzIGltcGxpY2l0bHkgcHJlc3NlZCwgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBpbXBsaWNpdGx5UHJlc3NlZCBmb3IgdGhhdCBrZXlzeW0gd2lsbCBiZSB0cnVlLiBJZiBhIGtleVxyXG4gICAgICogaXMgbm90IGN1cnJlbnRseSBpbXBsaWNpdGx5IHByZXNzZWQgKHRoZSBrZXkgaXMgbm90IHByZXNzZWQgT1IgdGhlIHN0YXRlXHJcbiAgICAgKiBvZiB0aGUga2V5IGlzIGV4cGxpY2l0bHkga25vd24pLCBpdCB3aWxsIG5vdCBiZSBkZWZpbmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlsZSB7T2JqZWN0LjxOdW1iZXIsIEJvb2xlYW4+fVxyXG4gICAgICovXHJcbiAgICB2YXIgaW1wbGljaXRseVByZXNzZWQgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsYXN0IHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBvbmtleWRvd24gaGFuZGxlciBmb3IgZWFjaCBrZXksIGluZGV4ZWRcclxuICAgICAqIGJ5IGtleXN5bS4gVGhpcyBpcyB1c2VkIHRvIHByZXZlbnQvYWxsb3cgZGVmYXVsdCBhY3Rpb25zIGZvciBrZXkgZXZlbnRzLFxyXG4gICAgICogZXZlbiB3aGVuIHRoZSBvbmtleWRvd24gaGFuZGxlciBjYW5ub3QgYmUgY2FsbGVkIGFnYWluIGJlY2F1c2UgdGhlIGtleVxyXG4gICAgICogaXMgKHRoZW9yZXRpY2FsbHkpIHN0aWxsIHByZXNzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGxhc3Rfa2V5ZG93bl9yZXN1bHQgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBrZXlzeW0gbW9zdCByZWNlbnRseSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBrZXljb2RlIHdoZW4ga2V5ZG93blxyXG4gICAgICogZmlyZWQuIFRoaXMgb2JqZWN0IG1hcHMga2V5Y29kZXMgdG8ga2V5c3ltcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge09iamVjdC48TnVtYmVyLCBOdW1iZXI+fVxyXG4gICAgICovXHJcbiAgICB2YXIgcmVjZW50S2V5c3ltID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaW1lb3V0IGJlZm9yZSBrZXkgcmVwZWF0IHN0YXJ0cy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBrZXlfcmVwZWF0X3RpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJ2YWwgd2hpY2ggcHJlc3NlcyBhbmQgcmVsZWFzZXMgdGhlIGxhc3Qga2V5IHByZXNzZWQgd2hpbGUgdGhhdFxyXG4gICAgICoga2V5IGlzIHN0aWxsIGJlaW5nIGhlbGQgZG93bi5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBrZXlfcmVwZWF0X2ludGVydmFsID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIGtleXN5bXMgaW5kZXhlZCBieSBsb2NhdGlvbiwgcmV0dXJucyB0aGUga2V5c3ltXHJcbiAgICAgKiBmb3IgdGhlIGdpdmVuIGxvY2F0aW9uLCBvciB0aGUga2V5c3ltIGZvciB0aGUgc3RhbmRhcmQgbG9jYXRpb24gaWZcclxuICAgICAqIHVuZGVmaW5lZC5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGtleXN5bXNcclxuICAgICAqICAgICBBbiBhcnJheSBvZiBrZXlzeW1zLCB3aGVyZSB0aGUgaW5kZXggb2YgdGhlIGtleXN5bSBpbiB0aGUgYXJyYXkgaXNcclxuICAgICAqICAgICB0aGUgbG9jYXRpb24gdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uXHJcbiAgICAgKiAgICAgVGhlIGxvY2F0aW9uIG9uIHRoZSBrZXlib2FyZCBjb3JyZXNwb25kaW5nIHRvIHRoZSBrZXkgcHJlc3NlZCwgYXNcclxuICAgICAqICAgICBkZWZpbmVkIGF0OiBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1LZXlib2FyZEV2ZW50XHJcbiAgICAgKi9cclxuICAgIHZhciBnZXRfa2V5c3ltID0gZnVuY3Rpb24gZ2V0X2tleXN5bShrZXlzeW1zLCBsb2NhdGlvbikge1xyXG5cclxuICAgICAgICBpZiAoIWtleXN5bXMpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4ga2V5c3ltc1tsb2NhdGlvbl0gfHwga2V5c3ltc1swXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGtleXN5bSBjb3JyZXNwb25kcyB0byBhIHByaW50YWJsZSBjaGFyYWN0ZXIsXHJcbiAgICAgKiBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtleXN5bVxyXG4gICAgICogICAgIFRoZSBrZXlzeW0gdG8gY2hlY2suXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKiAgICAgdHJ1ZSBpZiB0aGUgZ2l2ZW4ga2V5c3ltIGNvcnJlc3BvbmRzIHRvIGEgcHJpbnRhYmxlIGNoYXJhY3RlcixcclxuICAgICAqICAgICBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBpc1ByaW50YWJsZSA9IGZ1bmN0aW9uIGlzUHJpbnRhYmxlKGtleXN5bSkge1xyXG5cclxuICAgICAgICAvLyBLZXlzeW1zIHdpdGggVW5pY29kZSBlcXVpdmFsZW50cyBhcmUgcHJpbnRhYmxlXHJcbiAgICAgICAgcmV0dXJuIChrZXlzeW0gPj0gMHgwMCAmJiBrZXlzeW0gPD0gMHhGRilcclxuICAgICAgICAgICAgfHwgKGtleXN5bSAmIDB4RkZGRjAwMDApID09PSAweDAxMDAwMDAwO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24ga2V5c3ltX2Zyb21fa2V5X2lkZW50aWZpZXIoaWRlbnRpZmllciwgbG9jYXRpb24sIHNoaWZ0ZWQpIHtcclxuXHJcbiAgICAgICAgaWYgKCFpZGVudGlmaWVyKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIHR5cGVkQ2hhcmFjdGVyO1xyXG5cclxuICAgICAgICAvLyBJZiBpZGVudGlmaWVyIGlzIFUreHh4eCwgZGVjb2RlIFVuaWNvZGUgY2hhcmFjdGVyIFxyXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4TG9jYXRpb24gPSBpZGVudGlmaWVyLmluZGV4T2YoXCJVK1wiKTtcclxuICAgICAgICBpZiAodW5pY29kZVByZWZpeExvY2F0aW9uID49IDApIHtcclxuICAgICAgICAgICAgdmFyIGhleCA9IGlkZW50aWZpZXIuc3Vic3RyaW5nKHVuaWNvZGVQcmVmaXhMb2NhdGlvbisyKTtcclxuICAgICAgICAgICAgdHlwZWRDaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHNpbmdsZSBjaGFyYWN0ZXIgYW5kIG5vdCBrZXlwYWQsIHVzZSB0aGF0IGFzIHR5cGVkIGNoYXJhY3RlclxyXG4gICAgICAgIGVsc2UgaWYgKGlkZW50aWZpZXIubGVuZ3RoID09PSAxICYmIGxvY2F0aW9uICE9PSAzKVxyXG4gICAgICAgICAgICB0eXBlZENoYXJhY3RlciA9IGlkZW50aWZpZXI7XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbG9vayB1cCBjb3JyZXNwb25kaW5nIGtleXN5bVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGdldF9rZXlzeW0oa2V5aWRlbnRpZmllcl9rZXlzeW1baWRlbnRpZmllcl0sIGxvY2F0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gQWx0ZXIgY2FzZSBpZiBuZWNlc3NhcnlcclxuICAgICAgICBpZiAoc2hpZnRlZCA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgdHlwZWRDaGFyYWN0ZXIgPSB0eXBlZENoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGVsc2UgaWYgKHNoaWZ0ZWQgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICB0eXBlZENoYXJhY3RlciA9IHR5cGVkQ2hhcmFjdGVyLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIC8vIEdldCBjb2RlcG9pbnRcclxuICAgICAgICB2YXIgY29kZXBvaW50ID0gdHlwZWRDaGFyYWN0ZXIuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICByZXR1cm4ga2V5c3ltX2Zyb21fY2hhcmNvZGUoY29kZXBvaW50KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNDb250cm9sQ2hhcmFjdGVyKGNvZGVwb2ludCkge1xyXG4gICAgICAgIHJldHVybiBjb2RlcG9pbnQgPD0gMHgxRiB8fCAoY29kZXBvaW50ID49IDB4N0YgJiYgY29kZXBvaW50IDw9IDB4OUYpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGtleXN5bV9mcm9tX2NoYXJjb2RlKGNvZGVwb2ludCkge1xyXG5cclxuICAgICAgICAvLyBLZXlzeW1zIGZvciBjb250cm9sIGNoYXJhY3RlcnNcclxuICAgICAgICBpZiAoaXNDb250cm9sQ2hhcmFjdGVyKGNvZGVwb2ludCkpIHJldHVybiAweEZGMDAgfCBjb2RlcG9pbnQ7XHJcblxyXG4gICAgICAgIC8vIEtleXN5bXMgZm9yIEFTQ0lJIGNoYXJzXHJcbiAgICAgICAgaWYgKGNvZGVwb2ludCA+PSAweDAwMDAgJiYgY29kZXBvaW50IDw9IDB4MDBGRilcclxuICAgICAgICAgICAgcmV0dXJuIGNvZGVwb2ludDtcclxuXHJcbiAgICAgICAgLy8gS2V5c3ltcyBmb3IgVW5pY29kZVxyXG4gICAgICAgIGlmIChjb2RlcG9pbnQgPj0gMHgwMTAwICYmIGNvZGVwb2ludCA8PSAweDEwRkZGRilcclxuICAgICAgICAgICAgcmV0dXJuIDB4MDEwMDAwMDAgfCBjb2RlcG9pbnQ7XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrZXlzeW1fZnJvbV9rZXljb2RlKGtleUNvZGUsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldF9rZXlzeW0oa2V5Y29kZUtleXN5bXNba2V5Q29kZV0sIGxvY2F0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhldXJpc3RpY2FsbHkgZGV0ZWN0cyBpZiB0aGUgbGVnYWN5IGtleUlkZW50aWZpZXIgcHJvcGVydHkgb2ZcclxuICAgICAqIGEga2V5ZG93bi9rZXl1cCBldmVudCBsb29rcyBpbmNvcnJlY3RseSBkZXJpdmVkLiBDaHJvbWUsIGFuZFxyXG4gICAgICogcHJlc3VtYWJseSBvdGhlcnMsIHdpbGwgcHJvZHVjZSB0aGUga2V5SWRlbnRpZmllciBieSBhc3N1bWluZ1xyXG4gICAgICogdGhlIGtleUNvZGUgaXMgdGhlIFVuaWNvZGUgY29kZXBvaW50IGZvciB0aGF0IGtleS4gVGhpcyBpcyBub3RcclxuICAgICAqIGNvcnJlY3QgaW4gYWxsIGNhc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga2V5Q29kZVxyXG4gICAgICogICAgIFRoZSBrZXlDb2RlIGZyb20gYSBicm93c2VyIGtleWRvd24va2V5dXAgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleUlkZW50aWZpZXJcclxuICAgICAqICAgICBUaGUgbGVnYWN5IGtleUlkZW50aWZpZXIgZnJvbSBhIGJyb3dzZXIga2V5ZG93bi9rZXl1cCBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqICAgICB0cnVlIGlmIHRoZSBrZXlJZGVudGlmaWVyIGxvb2tzIHNhbmUsIGZhbHNlIGlmIHRoZSBrZXlJZGVudGlmaWVyXHJcbiAgICAgKiAgICAgYXBwZWFycyBpbmNvcnJlY3RseSBkZXJpdmVkIG9yIGlzIG1pc3NpbmcgZW50aXJlbHkuXHJcbiAgICAgKi9cclxuICAgIHZhciBrZXlfaWRlbnRpZmllcl9zYW5lID0gZnVuY3Rpb24ga2V5X2lkZW50aWZpZXJfc2FuZShrZXlDb2RlLCBrZXlJZGVudGlmaWVyKSB7XHJcblxyXG4gICAgICAgIC8vIE1pc3NpbmcgaWRlbnRpZmllciBpcyBub3Qgc2FuZVxyXG4gICAgICAgIGlmICgha2V5SWRlbnRpZmllcilcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBBc3N1bWUgbm9uLVVuaWNvZGUga2V5SWRlbnRpZmllciB2YWx1ZXMgYXJlIHNhbmVcclxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeExvY2F0aW9uID0ga2V5SWRlbnRpZmllci5pbmRleE9mKFwiVStcIik7XHJcbiAgICAgICAgaWYgKHVuaWNvZGVQcmVmaXhMb2NhdGlvbiA9PT0gLTEpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgVW5pY29kZSBjb2RlcG9pbnQgaXNuJ3QgaWRlbnRpY2FsIHRvIHRoZSBrZXlDb2RlLFxyXG4gICAgICAgIC8vIHRoZW4gdGhlIGlkZW50aWZpZXIgaXMgbGlrZWx5IGNvcnJlY3RcclxuICAgICAgICB2YXIgY29kZXBvaW50ID0gcGFyc2VJbnQoa2V5SWRlbnRpZmllci5zdWJzdHJpbmcodW5pY29kZVByZWZpeExvY2F0aW9uKzIpLCAxNik7XHJcbiAgICAgICAgaWYgKGtleUNvZGUgIT09IGNvZGVwb2ludClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIC8vIFRoZSBrZXlDb2RlcyBmb3IgQS1aIGFuZCAwLTkgYXJlIGFjdHVhbGx5IGlkZW50aWNhbCB0byB0aGVpclxyXG4gICAgICAgIC8vIFVuaWNvZGUgY29kZXBvaW50c1xyXG4gICAgICAgIGlmICgoa2V5Q29kZSA+PSA2NSAmJiBrZXlDb2RlIDw9IDkwKSB8fCAoa2V5Q29kZSA+PSA0OCAmJiBrZXlDb2RlIDw9IDU3KSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIC8vIFRoZSBrZXlJZGVudGlmaWVyIGRvZXMgTk9UIGFwcGVhciBzYW5lXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXJrcyBhIGtleSBhcyBwcmVzc2VkLCBmaXJpbmcgdGhlIGtleWRvd24gZXZlbnQgaWYgcmVnaXN0ZXJlZC4gS2V5XHJcbiAgICAgKiByZXBlYXQgZm9yIHRoZSBwcmVzc2VkIGtleSB3aWxsIHN0YXJ0IGFmdGVyIGEgZGVsYXkgaWYgdGhhdCBrZXkgaXNcclxuICAgICAqIG5vdCBhIG1vZGlmaWVyLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gZGVwZW5kcyBvbiB0aGVcclxuICAgICAqIHJldHVybiB2YWx1ZSBvZiB0aGUga2V5ZG93biBldmVudCBoYW5kbGVyLCBpZiBhbnkuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrZXlzeW0gVGhlIGtleXN5bSBvZiB0aGUga2V5IHRvIHByZXNzLlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBldmVudCBzaG91bGQgTk9UIGJlIGNhbmNlbGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucHJlc3MgPSBmdW5jdGlvbihrZXlzeW0pIHtcclxuXHJcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIHdpdGggcHJlc3NpbmcgdGhlIGtleSBpZiB0aGUga2V5IGlzIHVua25vd25cclxuICAgICAgICBpZiAoa2V5c3ltID09PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIE9ubHkgcHJlc3MgaWYgcmVsZWFzZWRcclxuICAgICAgICBpZiAoIWd1YWNfa2V5Ym9hcmQucHJlc3NlZFtrZXlzeW1dKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBNYXJrIGtleSBhcyBwcmVzc2VkXHJcbiAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQucHJlc3NlZFtrZXlzeW1dID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlbmQga2V5IGV2ZW50XHJcbiAgICAgICAgICAgIGlmIChndWFjX2tleWJvYXJkLm9ua2V5ZG93bikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGd1YWNfa2V5Ym9hcmQub25rZXlkb3duKGtleXN5bSk7XHJcbiAgICAgICAgICAgICAgICBsYXN0X2tleWRvd25fcmVzdWx0W2tleXN5bV0gPSByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcCBhbnkgY3VycmVudCByZXBlYXRcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoa2V5X3JlcGVhdF90aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGtleV9yZXBlYXRfaW50ZXJ2YWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlcGVhdCBhZnRlciBhIGRlbGF5IGFzIGxvbmcgYXMgcHJlc3NlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFub19yZXBlYXRba2V5c3ltXSlcclxuICAgICAgICAgICAgICAgICAgICBrZXlfcmVwZWF0X3RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5X3JlcGVhdF9pbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQub25rZXl1cChrZXlzeW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5vbmtleWRvd24oa2V5c3ltKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIDUwMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBsYXN0IGtleWRvd24gcmVzdWx0IGJ5IGRlZmF1bHQsIHJlc29ydCB0byBmYWxzZSBpZiB1bmtub3duXHJcbiAgICAgICAgcmV0dXJuIGxhc3Rfa2V5ZG93bl9yZXN1bHRba2V5c3ltXSB8fCBmYWxzZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFya3MgYSBrZXkgYXMgcmVsZWFzZWQsIGZpcmluZyB0aGUga2V5dXAgZXZlbnQgaWYgcmVnaXN0ZXJlZC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtleXN5bSBUaGUga2V5c3ltIG9mIHRoZSBrZXkgdG8gcmVsZWFzZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWxlYXNlID0gZnVuY3Rpb24oa2V5c3ltKSB7XHJcblxyXG4gICAgICAgIC8vIE9ubHkgcmVsZWFzZSBpZiBwcmVzc2VkXHJcbiAgICAgICAgaWYgKGd1YWNfa2V5Ym9hcmQucHJlc3NlZFtrZXlzeW1dKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBNYXJrIGtleSBhcyByZWxlYXNlZFxyXG4gICAgICAgICAgICBkZWxldGUgZ3VhY19rZXlib2FyZC5wcmVzc2VkW2tleXN5bV07XHJcbiAgICAgICAgICAgIGRlbGV0ZSBpbXBsaWNpdGx5UHJlc3NlZFtrZXlzeW1dO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RvcCByZXBlYXRcclxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChrZXlfcmVwZWF0X3RpbWVvdXQpO1xyXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChrZXlfcmVwZWF0X2ludGVydmFsKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlbmQga2V5IGV2ZW50XHJcbiAgICAgICAgICAgIGlmIChrZXlzeW0gIT09IG51bGwgJiYgZ3VhY19rZXlib2FyZC5vbmtleXVwKVxyXG4gICAgICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5vbmtleXVwKGtleXN5bSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJlc3NlcyBhbmQgcmVsZWFzZXMgdGhlIGtleXMgbmVjZXNzYXJ5IHRvIHR5cGUgdGhlIGdpdmVuIHN0cmluZyBvZlxyXG4gICAgICogdGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAgICAgKiAgICAgVGhlIHN0cmluZyB0byB0eXBlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGUgPSBmdW5jdGlvbiB0eXBlKHN0cikge1xyXG5cclxuICAgICAgICAvLyBQcmVzcy9yZWxlYXNlIHRoZSBrZXkgY29ycmVzcG9uZGluZyB0byBlYWNoIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBrZXlzeW0gb2YgY3VycmVudCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgdmFyIGNvZGVwb2ludCA9IHN0ci5jb2RlUG9pbnRBdCA/IHN0ci5jb2RlUG9pbnRBdChpKSA6IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICB2YXIga2V5c3ltID0ga2V5c3ltX2Zyb21fY2hhcmNvZGUoY29kZXBvaW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZXNzIGFuZCByZWxlYXNlIGtleSBmb3IgY3VycmVudCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5wcmVzcyhrZXlzeW0pO1xyXG4gICAgICAgICAgICBndWFjX2tleWJvYXJkLnJlbGVhc2Uoa2V5c3ltKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIHN0YXRlIG9mIHRoaXMga2V5Ym9hcmQsIHJlbGVhc2luZyBhbGwga2V5cywgYW5kIGZpcmluZyBrZXl1cFxyXG4gICAgICogZXZlbnRzIGZvciBlYWNoIHJlbGVhc2VkIGtleS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBSZWxlYXNlIGFsbCBwcmVzc2VkIGtleXNcclxuICAgICAgICBmb3IgKHZhciBrZXlzeW0gaW4gZ3VhY19rZXlib2FyZC5wcmVzc2VkKVxyXG4gICAgICAgICAgICBndWFjX2tleWJvYXJkLnJlbGVhc2UocGFyc2VJbnQoa2V5c3ltKSk7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGV2ZW50IGxvZ1xyXG4gICAgICAgIGV2ZW50TG9nID0gW107XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIHRoZSByZW1vdGUgYW5kIGxvY2FsIHN0YXRlIG9mIGEgcGFydGljdWxhciBrZXksIHJlc3luY2hyb25pemVzIHRoZVxyXG4gICAgICogcmVtb3RlIHN0YXRlIG9mIHRoYXQga2V5IHdpdGggdGhlIGxvY2FsIHN0YXRlIHRocm91Z2ggcHJlc3Npbmcgb3JcclxuICAgICAqIHJlbGVhc2luZyBrZXlzeW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW90ZVN0YXRlXHJcbiAgICAgKiAgICAgV2hldGhlciB0aGUga2V5IGlzIGN1cnJlbnRseSBwcmVzc2VkIHJlbW90ZWx5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9jYWxTdGF0ZVxyXG4gICAgICogICAgIFdoZXRoZXIgdGhlIGtleSBpcyBjdXJyZW50bHkgcHJlc3NlZCByZW1vdGVseSBsb2NhbGx5LiBJZiB0aGUgc3RhdGVcclxuICAgICAqICAgICBvZiB0aGUga2V5IGlzIG5vdCBrbm93biwgdGhpcyBtYXkgYmUgdW5kZWZpbmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGtleXN5bXNcclxuICAgICAqICAgICBUaGUga2V5c3ltcyB3aGljaCByZXByZXNlbnQgdGhlIGtleSBiZWluZyB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7S2V5RXZlbnR9IGtleUV2ZW50XHJcbiAgICAgKiAgICAgR3VhY2Ftb2xlJ3MgY3VycmVudCBiZXN0IGludGVycHJldGF0aW9uIG9mIHRoZSBrZXkgZXZlbnQgYmVpbmdcclxuICAgICAqICAgICBwcm9jZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciB1cGRhdGVNb2RpZmllclN0YXRlID0gZnVuY3Rpb24gdXBkYXRlTW9kaWZpZXJTdGF0ZShyZW1vdGVTdGF0ZSxcclxuICAgICAgICBsb2NhbFN0YXRlLCBrZXlzeW1zLCBrZXlFdmVudCkge1xyXG5cclxuICAgICAgICB2YXIgaTtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IHRydXN0IGNoYW5nZXMgaW4gbW9kaWZpZXIgc3RhdGUgZm9yIGV2ZW50cyBkaXJlY3RseSBpbnZvbHZpbmdcclxuICAgICAgICAvLyB0aGF0IG1vZGlmaWVyOiAoMSkgdGhlIGZsYWcgbWF5IGVycm9uZW91c2x5IGJlIGNsZWFyZWQgZGVzcGl0ZVxyXG4gICAgICAgIC8vIGFub3RoZXIgdmVyc2lvbiBvZiB0aGUgc2FtZSBrZXkgc3RpbGwgYmVpbmcgaGVsZCBhbmQgKDIpIHRoZSBjaGFuZ2VcclxuICAgICAgICAvLyBpbiBmbGFnIG1heSBiZSBkdWUgdG8gdGhlIGN1cnJlbnQgZXZlbnQgYmVpbmcgcHJvY2Vzc2VkLCB0aHVzXHJcbiAgICAgICAgLy8gdXBkYXRpbmcgdGhpbmdzIGhlcmUgaXMgYXQgYmVzdCByZWR1bmRhbnQgYW5kIGF0IHdvcnN0IGluY29ycmVjdFxyXG4gICAgICAgIGlmIChrZXlzeW1zLmluZGV4T2Yoa2V5RXZlbnQua2V5c3ltKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gUmVsZWFzZSBhbGwgcmVsYXRlZCBrZXlzIGlmIG1vZGlmaWVyIGlzIGltcGxpY2l0bHkgcmVsZWFzZWRcclxuICAgICAgICBpZiAocmVtb3RlU3RhdGUgJiYgbG9jYWxTdGF0ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXN5bXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQucmVsZWFzZShrZXlzeW1zW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJlc3MgaWYgbW9kaWZpZXIgaXMgaW1wbGljaXRseSBwcmVzc2VkXHJcbiAgICAgICAgZWxzZSBpZiAoIXJlbW90ZVN0YXRlICYmIGxvY2FsU3RhdGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IG1vZGlmaWVyIGZsYWcgaXNuJ3QgYWxyZWFkeSBwcmVzc2VkIG9yIGFscmVhZHkgc2V0XHJcbiAgICAgICAgICAgIC8vIGR1ZSB0byBhbm90aGVyIHZlcnNpb24gb2YgdGhlIHNhbWUga2V5IGJlaW5nIGhlbGQgZG93blxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5c3ltcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGd1YWNfa2V5Ym9hcmQucHJlc3NlZFtrZXlzeW1zW2ldXSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1hcmsgYXMgaW1wbGljaXRseSBwcmVzc2VkIG9ubHkgaWYgdGhlcmUgaXMgb3RoZXIgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgLy8gd2l0aGluIHRoZSBrZXkgZXZlbnQgcmVsYXRpbmcgdG8gYSBkaWZmZXJlbnQga2V5LiBTb21lXHJcbiAgICAgICAgICAgIC8vIHBsYXRmb3Jtcywgc3VjaCBhcyBpT1MsIHdpbGwgc2VuZCBlc3NlbnRpYWxseSBlbXB0eSBrZXkgZXZlbnRzXHJcbiAgICAgICAgICAgIC8vIGZvciBtb2RpZmllciBrZXlzLCB1c2luZyBvbmx5IHRoZSBtb2RpZmllciBmbGFncyB0byBzaWduYWwgdGhlXHJcbiAgICAgICAgICAgIC8vIGlkZW50aXR5IG9mIHRoZSBrZXkuXHJcbiAgICAgICAgICAgIHZhciBrZXlzeW0gPSBrZXlzeW1zWzBdO1xyXG4gICAgICAgICAgICBpZiAoa2V5RXZlbnQua2V5c3ltKVxyXG4gICAgICAgICAgICAgICAgaW1wbGljaXRseVByZXNzZWRba2V5c3ltXSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBndWFjX2tleWJvYXJkLnByZXNzKGtleXN5bSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBrZXlib2FyZCBldmVudCwgdXBkYXRlcyB0aGUgbG9jYWwgbW9kaWZpZXIgc3RhdGUgYW5kIHJlbW90ZVxyXG4gICAgICoga2V5IHN0YXRlIGJhc2VkIG9uIHRoZSBtb2RpZmllciBmbGFncyB3aXRoaW4gdGhlIGV2ZW50LiBUaGlzIGZ1bmN0aW9uXHJcbiAgICAgKiBwYXlzIG5vIGF0dGVudGlvbiB0byBrZXljb2Rlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXHJcbiAgICAgKiAgICAgVGhlIGtleWJvYXJkIGV2ZW50IGNvbnRhaW5pbmcgdGhlIGZsYWdzIHRvIHVwZGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0tleUV2ZW50fSBrZXlFdmVudFxyXG4gICAgICogICAgIEd1YWNhbW9sZSdzIGN1cnJlbnQgYmVzdCBpbnRlcnByZXRhdGlvbiBvZiB0aGUga2V5IGV2ZW50IGJlaW5nXHJcbiAgICAgKiAgICAgcHJvY2Vzc2VkLlxyXG4gICAgICovXHJcbiAgICB2YXIgc3luY01vZGlmaWVyU3RhdGVzID0gZnVuY3Rpb24gc3luY01vZGlmaWVyU3RhdGVzKGUsIGtleUV2ZW50KSB7XHJcblxyXG4gICAgICAgIC8vIEdldCBzdGF0ZVxyXG4gICAgICAgIHZhciBzdGF0ZSA9IEd1YWNhbW9sZS5LZXlib2FyZC5Nb2RpZmllclN0YXRlLmZyb21LZXlib2FyZEV2ZW50KGUpO1xyXG5cclxuICAgICAgICAvLyBSZXN5bmMgc3RhdGUgb2YgYWx0XHJcbiAgICAgICAgdXBkYXRlTW9kaWZpZXJTdGF0ZShndWFjX2tleWJvYXJkLm1vZGlmaWVycy5hbHQsIHN0YXRlLmFsdCwgW1xyXG4gICAgICAgICAgICAweEZGRTksIC8vIExlZnQgYWx0XHJcbiAgICAgICAgICAgIDB4RkZFQSwgLy8gUmlnaHQgYWx0XHJcbiAgICAgICAgICAgIDB4RkUwMyAgLy8gQWx0R3JcclxuICAgICAgICBdLCBrZXlFdmVudCk7XHJcblxyXG4gICAgICAgIC8vIFJlc3luYyBzdGF0ZSBvZiBzaGlmdFxyXG4gICAgICAgIHVwZGF0ZU1vZGlmaWVyU3RhdGUoZ3VhY19rZXlib2FyZC5tb2RpZmllcnMuc2hpZnQsIHN0YXRlLnNoaWZ0LCBbXHJcbiAgICAgICAgICAgIDB4RkZFMSwgLy8gTGVmdCBzaGlmdFxyXG4gICAgICAgICAgICAweEZGRTIgIC8vIFJpZ2h0IHNoaWZ0XHJcbiAgICAgICAgXSwga2V5RXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBSZXN5bmMgc3RhdGUgb2YgY3RybFxyXG4gICAgICAgIHVwZGF0ZU1vZGlmaWVyU3RhdGUoZ3VhY19rZXlib2FyZC5tb2RpZmllcnMuY3RybCwgc3RhdGUuY3RybCwgW1xyXG4gICAgICAgICAgICAweEZGRTMsIC8vIExlZnQgY3RybFxyXG4gICAgICAgICAgICAweEZGRTQgIC8vIFJpZ2h0IGN0cmxcclxuICAgICAgICBdLCBrZXlFdmVudCk7XHJcblxyXG4gICAgICAgIC8vIFJlc3luYyBzdGF0ZSBvZiBtZXRhXHJcbiAgICAgICAgdXBkYXRlTW9kaWZpZXJTdGF0ZShndWFjX2tleWJvYXJkLm1vZGlmaWVycy5tZXRhLCBzdGF0ZS5tZXRhLCBbXHJcbiAgICAgICAgICAgIDB4RkZFNywgLy8gTGVmdCBtZXRhXHJcbiAgICAgICAgICAgIDB4RkZFOCAgLy8gUmlnaHQgbWV0YVxyXG4gICAgICAgIF0sIGtleUV2ZW50KTtcclxuXHJcbiAgICAgICAgLy8gUmVzeW5jIHN0YXRlIG9mIGh5cGVyXHJcbiAgICAgICAgdXBkYXRlTW9kaWZpZXJTdGF0ZShndWFjX2tleWJvYXJkLm1vZGlmaWVycy5oeXBlciwgc3RhdGUuaHlwZXIsIFtcclxuICAgICAgICAgICAgMHhGRkVCLCAvLyBMZWZ0IGh5cGVyXHJcbiAgICAgICAgICAgIDB4RkZFQyAgLy8gUmlnaHQgaHlwZXJcclxuICAgICAgICBdLCBrZXlFdmVudCk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxyXG4gICAgICAgIGd1YWNfa2V5Ym9hcmQubW9kaWZpZXJzID0gc3RhdGU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBhbGwgY3VycmVudGx5IHByZXNzZWQga2V5cyB3ZXJlIGltcGxpY2l0bHkgcHJlc3NlZC4gQVxyXG4gICAgICoga2V5IGlzIGltcGxpY2l0bHkgcHJlc3NlZCBpZiBpdHMgc3RhdHVzIHdhcyBpbmZlcnJlZCBpbmRpcmVjdGx5IGZyb21cclxuICAgICAqIGluc3BlY3Rpb24gb2Ygb3RoZXIga2V5IGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKiAgICAgdHJ1ZSBpZiBhbGwgY3VycmVudGx5IHByZXNzZWQga2V5cyB3ZXJlIGltcGxpY2l0bHkgcHJlc3NlZCwgZmFsc2VcclxuICAgICAqICAgICBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBpc1N0YXRlSW1wbGljaXQgPSBmdW5jdGlvbiBpc1N0YXRlSW1wbGljaXQoKSB7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleXN5bSBpbiBndWFjX2tleWJvYXJkLnByZXNzZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFpbXBsaWNpdGx5UHJlc3NlZFtrZXlzeW1dKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIHRocm91Z2ggdGhlIGV2ZW50IGxvZywgcmVtb3ZpbmcgZXZlbnRzIGZyb20gdGhlIGhlYWQgb2YgdGhlIGxvZ1xyXG4gICAgICogd2hlbiB0aGUgY29ycmVzcG9uZGluZyB0cnVlIGtleSBwcmVzc2VzIGFyZSBrbm93biAob3IgYXMga25vd24gYXMgdGhleVxyXG4gICAgICogY2FuIGJlKS5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBsYXRlc3QgZXZlbnQgc2hvdWxkXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICBiZSBwcmV2ZW50ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGludGVycHJldF9ldmVudHMoKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBwcmV2ZW50IGRlZmF1bHQgaWYgbm8gZXZlbnQgY291bGQgYmUgaW50ZXJwcmV0ZWRcclxuICAgICAgICB2YXIgaGFuZGxlZF9ldmVudCA9IGludGVycHJldF9ldmVudCgpO1xyXG4gICAgICAgIGlmICghaGFuZGxlZF9ldmVudClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBJbnRlcnByZXQgYXMgbXVjaCBhcyBwb3NzaWJsZVxyXG4gICAgICAgIHZhciBsYXN0X2V2ZW50O1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbGFzdF9ldmVudCA9IGhhbmRsZWRfZXZlbnQ7XHJcbiAgICAgICAgICAgIGhhbmRsZWRfZXZlbnQgPSBpbnRlcnByZXRfZXZlbnQoKTtcclxuICAgICAgICB9IHdoaWxlIChoYW5kbGVkX2V2ZW50ICE9PSBudWxsKTtcclxuXHJcbiAgICAgICAgLy8gUmVzZXQga2V5Ym9hcmQgc3RhdGUgaWYgd2UgY2Fubm90IGV4cGVjdCB0byByZWNlaXZlIGFueSBmdXJ0aGVyXHJcbiAgICAgICAgLy8ga2V5dXAgZXZlbnRzXHJcbiAgICAgICAgaWYgKGlzU3RhdGVJbXBsaWNpdCgpKVxyXG4gICAgICAgICAgICBndWFjX2tleWJvYXJkLnJlc2V0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBsYXN0X2V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVsZWFzZXMgQ3RybCtBbHQsIGlmIGJvdGggYXJlIGN1cnJlbnRseSBwcmVzc2VkIGFuZCB0aGUgZ2l2ZW4ga2V5c3ltXHJcbiAgICAgKiBsb29rcyBsaWtlIGEga2V5IHRoYXQgbWF5IHJlcXVpcmUgQWx0R3IuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrZXlzeW0gVGhlIGtleSB0aGF0IHdhcyBqdXN0IHByZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciByZWxlYXNlX3NpbXVsYXRlZF9hbHRnciA9IGZ1bmN0aW9uIHJlbGVhc2Vfc2ltdWxhdGVkX2FsdGdyKGtleXN5bSkge1xyXG5cclxuICAgICAgICAvLyBCb3RoIEN0cmwrQWx0IG11c3QgYmUgcHJlc3NlZCBpZiBzaW11bGF0ZWQgQWx0R3IgaXMgaW4gdXNlXHJcbiAgICAgICAgaWYgKCFndWFjX2tleWJvYXJkLm1vZGlmaWVycy5jdHJsIHx8ICFndWFjX2tleWJvYXJkLm1vZGlmaWVycy5hbHQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gQXNzdW1lIFtBLVpdIG5ldmVyIHJlcXVpcmUgQWx0R3JcclxuICAgICAgICBpZiAoa2V5c3ltID49IDB4MDA0MSAmJiBrZXlzeW0gPD0gMHgwMDVBKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIEFzc3VtZSBbYS16XSBuZXZlciByZXF1aXJlIEFsdEdyXHJcbiAgICAgICAgaWYgKGtleXN5bSA+PSAweDAwNjEgJiYga2V5c3ltIDw9IDB4MDA3QSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBSZWxlYXNlIEN0cmwrQWx0IGlmIHRoZSBrZXlzeW0gaXMgcHJpbnRhYmxlXHJcbiAgICAgICAgaWYgKGtleXN5bSA8PSAweEZGIHx8IChrZXlzeW0gJiAweEZGMDAwMDAwKSA9PT0gMHgwMTAwMDAwMCkge1xyXG4gICAgICAgICAgICBndWFjX2tleWJvYXJkLnJlbGVhc2UoMHhGRkUzKTsgLy8gTGVmdCBjdHJsIFxyXG4gICAgICAgICAgICBndWFjX2tleWJvYXJkLnJlbGVhc2UoMHhGRkU0KTsgLy8gUmlnaHQgY3RybCBcclxuICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5yZWxlYXNlKDB4RkZFOSk7IC8vIExlZnQgYWx0XHJcbiAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQucmVsZWFzZSgweEZGRUEpOyAvLyBSaWdodCBhbHRcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIHRocm91Z2ggdGhlIGV2ZW50IGxvZywgaW50ZXJwcmV0aW5nIHRoZSBmaXJzdCBldmVudCwgaWYgcG9zc2libGUsXHJcbiAgICAgKiBhbmQgcmV0dXJuaW5nIHRoYXQgZXZlbnQuIElmIG5vIGV2ZW50cyBjYW4gYmUgaW50ZXJwcmV0ZWQsIGR1ZSB0byBhXHJcbiAgICAgKiB0b3RhbCBsYWNrIG9mIGV2ZW50cyBvciB0aGUgbmVlZCBmb3IgbW9yZSBldmVudHMsIG51bGwgaXMgcmV0dXJuZWQuIEFueVxyXG4gICAgICogaW50ZXJwcmV0ZWQgZXZlbnRzIGFyZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgZnJvbSB0aGUgbG9nLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7S2V5RXZlbnR9XHJcbiAgICAgKiAgICAgVGhlIGZpcnN0IGtleSBldmVudCBpbiB0aGUgbG9nLCBpZiBpdCBjYW4gYmUgaW50ZXJwcmV0ZWQsIG9yIG51bGxcclxuICAgICAqICAgICBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBpbnRlcnByZXRfZXZlbnQgPSBmdW5jdGlvbiBpbnRlcnByZXRfZXZlbnQoKSB7XHJcblxyXG4gICAgICAgIC8vIFBlZWsgYXQgZmlyc3QgZXZlbnQgaW4gbG9nXHJcbiAgICAgICAgdmFyIGZpcnN0ID0gZXZlbnRMb2dbMF07XHJcbiAgICAgICAgaWYgKCFmaXJzdClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIC8vIEtleWRvd24gZXZlbnRcclxuICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBLZXlkb3duRXZlbnQpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBrZXlzeW0gPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgYWNjZXB0ZWRfZXZlbnRzID0gW107XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBldmVudCBpdHNlbGYgaXMgcmVsaWFibGUsIG5vIG5lZWQgdG8gd2FpdCBmb3Igb3RoZXIgZXZlbnRzXHJcbiAgICAgICAgICAgIGlmIChmaXJzdC5yZWxpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAga2V5c3ltID0gZmlyc3Qua2V5c3ltO1xyXG4gICAgICAgICAgICAgICAgYWNjZXB0ZWRfZXZlbnRzID0gZXZlbnRMb2cuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBrZXlkb3duIGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEga2V5cHJlc3MsIHVzZSB0aGUgaW5kaWNhdGVkIGNoYXJhY3RlclxyXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudExvZ1sxXSBpbnN0YW5jZW9mIEtleXByZXNzRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGtleXN5bSA9IGV2ZW50TG9nWzFdLmtleXN5bTtcclxuICAgICAgICAgICAgICAgIGFjY2VwdGVkX2V2ZW50cyA9IGV2ZW50TG9nLnNwbGljZSgwLCAyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYga2V5ZG93biBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbnl0aGluZyBlbHNlLCB0aGVuIG5vXHJcbiAgICAgICAgICAgIC8vIGtleXByZXNzIGNhbiBwb3NzaWJseSBvY2N1ciB0byBjbGFyaWZ5IHRoaXMgZXZlbnQsIGFuZCB3ZSBtdXN0XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBpdCBub3dcclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRMb2dbMV0pIHtcclxuICAgICAgICAgICAgICAgIGtleXN5bSA9IGZpcnN0LmtleXN5bTtcclxuICAgICAgICAgICAgICAgIGFjY2VwdGVkX2V2ZW50cyA9IGV2ZW50TG9nLnNwbGljZSgwLCAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmlyZSBhIGtleSBwcmVzcyBpZiB2YWxpZCBldmVudHMgd2VyZSBmb3VuZFxyXG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRfZXZlbnRzLmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5c3ltKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICByZWxlYXNlX3NpbXVsYXRlZF9hbHRncihrZXlzeW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gIWd1YWNfa2V5Ym9hcmQucHJlc3Moa2V5c3ltKTtcclxuICAgICAgICAgICAgICAgICAgICByZWNlbnRLZXlzeW1bZmlyc3Qua2V5Q29kZV0gPSBrZXlzeW07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbGVhc2UgdGhlIGtleSBub3cgaWYgd2UgY2Fubm90IHJlbHkgb24gdGhlIGFzc29jaWF0ZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBrZXl1cCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlyc3Qua2V5dXBSZWxpYWJsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5yZWxlYXNlKGtleXN5bSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCB3aGV0aGVyIGRlZmF1bHQgd2FzIHByZXZlbnRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxhY2NlcHRlZF9ldmVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdGVkX2V2ZW50c1tpXS5kZWZhdWx0UHJldmVudGVkID0gZGVmYXVsdFByZXZlbnRlZDtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IC8vIGVuZCBpZiBrZXlkb3duXHJcblxyXG4gICAgICAgIC8vIEtleXVwIGV2ZW50XHJcbiAgICAgICAgZWxzZSBpZiAoZmlyc3QgaW5zdGFuY2VvZiBLZXl1cEV2ZW50ICYmICFxdWlya3Mua2V5dXBVbnJlbGlhYmxlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWxlYXNlIHNwZWNpZmljIGtleSBpZiBrbm93blxyXG4gICAgICAgICAgICB2YXIga2V5c3ltID0gZmlyc3Qua2V5c3ltO1xyXG4gICAgICAgICAgICBpZiAoa2V5c3ltKSB7XHJcbiAgICAgICAgICAgICAgICBndWFjX2tleWJvYXJkLnJlbGVhc2Uoa2V5c3ltKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSByZWNlbnRLZXlzeW1bZmlyc3Qua2V5Q29kZV07XHJcbiAgICAgICAgICAgICAgICBmaXJzdC5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBmYWxsIGJhY2sgdG8gcmVsZWFzaW5nIGFsbCBrZXlzXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRMb2cuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgfSAvLyBlbmQgaWYga2V5dXBcclxuXHJcbiAgICAgICAgLy8gSWdub3JlIGFueSBvdGhlciB0eXBlIG9mIGV2ZW50IChrZXlwcmVzcyBieSBpdHNlbGYgaXMgaW52YWxpZCwgYW5kXHJcbiAgICAgICAgLy8gdW5yZWxpYWJsZSBrZXl1cCBldmVudHMgc2hvdWxkIHNpbXBseSBiZSBkdW1wZWQpXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRMb2cuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgLy8gTm8gZXZlbnQgaW50ZXJwcmV0ZWRcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUga2V5Ym9hcmQgbG9jYXRpb24gb2YgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuXHJcbiAgICAgKiBrZXlib2FyZCBldmVudC4gVGhlIGxvY2F0aW9uIGRpZmZlcmVudGlhdGVzIGtleSBldmVudHMgd2hpY2ggb3RoZXJ3aXNlXHJcbiAgICAgKiBoYXZlIHRoZSBzYW1lIGtleWNvZGUsIHN1Y2ggYXMgbGVmdCBzaGlmdCB2cy4gcmlnaHQgc2hpZnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxyXG4gICAgICogICAgIEEgSmF2YVNjcmlwdCBrZXlib2FyZCBldmVudCwgYXMgcmVjZWl2ZWQgdGhyb3VnaCB0aGUgRE9NIHZpYSBhXHJcbiAgICAgKiAgICAgXCJrZXlkb3duXCIsIFwia2V5dXBcIiwgb3IgXCJrZXlwcmVzc1wiIGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqICAgICBUaGUgbG9jYXRpb24gb2YgdGhlIGtleSBldmVudCBvbiB0aGUga2V5Ym9hcmQsIGFzIGRlZmluZWQgYXQ6XHJcbiAgICAgKiAgICAgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICovXHJcbiAgICB2YXIgZ2V0RXZlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEV2ZW50TG9jYXRpb24oZSkge1xyXG5cclxuICAgICAgICAvLyBVc2Ugc3RhbmRhcmQgbG9jYXRpb24sIGlmIHBvc3NpYmxlXHJcbiAgICAgICAgaWYgKCdsb2NhdGlvbicgaW4gZSlcclxuICAgICAgICAgICAgcmV0dXJuIGUubG9jYXRpb247XHJcblxyXG4gICAgICAgIC8vIEZhaWxpbmcgdGhhdCwgYXR0ZW1wdCB0byB1c2UgZGVwcmVjYXRlZCBrZXlMb2NhdGlvblxyXG4gICAgICAgIGlmICgna2V5TG9jYXRpb24nIGluIGUpXHJcbiAgICAgICAgICAgIHJldHVybiBlLmtleUxvY2F0aW9uO1xyXG5cclxuICAgICAgICAvLyBJZiBubyBsb2NhdGlvbiBpcyBhdmFpbGFibGUsIGFzc3VtZSBsZWZ0IHNpZGVcclxuICAgICAgICByZXR1cm4gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gbWFyayB0aGUgZ2l2ZW4gRXZlbnQgYXMgaGF2aW5nIGJlZW4gaGFuZGxlZCBieSB0aGlzXHJcbiAgICAgKiBHdWFjYW1vbGUuS2V5Ym9hcmQuIElmIHRoZSBFdmVudCBoYXMgYWxyZWFkeSBiZWVuIG1hcmtlZCBhcyBoYW5kbGVkLFxyXG4gICAgICogZmFsc2UgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAgICogICAgIFRoZSBFdmVudCB0byBtYXJrLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogICAgIHRydWUgaWYgdGhlIGdpdmVuIEV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgbWFya2VkLCBmYWxzZSBpZiB0aGUgZ2l2ZW5cclxuICAgICAqICAgICBFdmVudCB3YXMgYWxyZWFkeSBtYXJrZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciBtYXJrRXZlbnQgPSBmdW5jdGlvbiBtYXJrRXZlbnQoZSkge1xyXG5cclxuICAgICAgICAvLyBGYWlsIGlmIGV2ZW50IGlzIGFscmVhZHkgbWFya2VkXHJcbiAgICAgICAgaWYgKGVbRVZFTlRfTUFSS0VSXSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBNYXJrIGV2ZW50IG90aGVyd2lzZVxyXG4gICAgICAgIGVbRVZFTlRfTUFSS0VSXSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgZ2l2ZW4gRWxlbWVudCwgYXV0b21hdGljYWxseSB0cmFuc2xhdGluZ1xyXG4gICAgICogcmVjZWl2ZWQga2V5LCBpbnB1dCwgYW5kIGNvbXBvc2l0aW9uIGV2ZW50cyBpbnRvIHNpbXBsZSBrZXlkb3duL2tleXVwXHJcbiAgICAgKiBldmVudHMgc2lnbmFsbGVkIHRocm91Z2ggdGhpcyBHdWFjYW1vbGUuS2V5Ym9hcmQncyBvbmtleWRvd24gYW5kXHJcbiAgICAgKiBvbmtleXVwIGhhbmRsZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudH0gZWxlbWVudFxyXG4gICAgICogICAgIFRoZSBFbGVtZW50IHRvIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG8gZm9yIHRoZSBzYWtlIG9mIGhhbmRsaW5nXHJcbiAgICAgKiAgICAga2V5IG9yIGlucHV0IGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5saXN0ZW5UbyA9IGZ1bmN0aW9uIGxpc3RlblRvKGVsZW1lbnQpIHtcclxuXHJcbiAgICAgICAgLy8gV2hlbiBrZXkgcHJlc3NlZFxyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBpbnRlcmNlcHQgaWYgaGFuZGxlciBzZXRcclxuICAgICAgICAgICAgaWYgKCFndWFjX2tleWJvYXJkLm9ua2V5ZG93bikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gSWdub3JlIGV2ZW50cyB3aGljaCBoYXZlIGFscmVhZHkgYmVlbiBoYW5kbGVkXHJcbiAgICAgICAgICAgIGlmICghbWFya0V2ZW50KGUpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB2YXIga2V5Q29kZTtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5ldmVudCkga2V5Q29kZSA9IHdpbmRvdy5ldmVudC5rZXlDb2RlO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChlLndoaWNoKSBrZXlDb2RlID0gZS53aGljaDtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpeCBtb2RpZmllciBzdGF0ZXNcclxuICAgICAgICAgICAgdmFyIGtleWRvd25FdmVudCA9IG5ldyBLZXlkb3duRXZlbnQoa2V5Q29kZSwgZS5rZXlJZGVudGlmaWVyLCBlLmtleSwgZ2V0RXZlbnRMb2NhdGlvbihlKSk7XHJcbiAgICAgICAgICAgIHN5bmNNb2RpZmllclN0YXRlcyhlLCBrZXlkb3duRXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWdub3JlIChidXQgZG8gbm90IHByZXZlbnQpIHRoZSBcImNvbXBvc2l0aW9uXCIga2V5Y29kZSBzZW50IGJ5IHNvbWVcclxuICAgICAgICAgICAgLy8gYnJvd3NlcnMgd2hlbiBhbiBJTUUgaXMgaW4gdXNlIChzZWU6IGh0dHA6Ly9saXN0cy53My5vcmcvQXJjaGl2ZXMvUHVibGljL3d3dy1kb20vMjAxMEp1bFNlcC9hdHQtMDE4Mi9rZXlDb2RlLXNwZWMuaHRtbClcclxuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IDIyOSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIExvZyBldmVudFxyXG4gICAgICAgICAgICBldmVudExvZy5wdXNoKGtleWRvd25FdmVudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnRlcnByZXQgYXMgbWFueSBldmVudHMgYXMgcG9zc2libGUsIHByZXZlbnQgZGVmYXVsdCBpZiBpbmRpY2F0ZWRcclxuICAgICAgICAgICAgaWYgKGludGVycHJldF9ldmVudHMoKSlcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIFdoZW4ga2V5IHByZXNzZWRcclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IGludGVyY2VwdCBpZiBoYW5kbGVyIHNldFxyXG4gICAgICAgICAgICBpZiAoIWd1YWNfa2V5Ym9hcmQub25rZXlkb3duICYmICFndWFjX2tleWJvYXJkLm9ua2V5dXApIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIElnbm9yZSBldmVudHMgd2hpY2ggaGF2ZSBhbHJlYWR5IGJlZW4gaGFuZGxlZFxyXG4gICAgICAgICAgICBpZiAoIW1hcmtFdmVudChlKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoYXJDb2RlO1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmV2ZW50KSBjaGFyQ29kZSA9IHdpbmRvdy5ldmVudC5rZXlDb2RlO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChlLndoaWNoKSBjaGFyQ29kZSA9IGUud2hpY2g7XHJcblxyXG4gICAgICAgICAgICAvLyBGaXggbW9kaWZpZXIgc3RhdGVzXHJcbiAgICAgICAgICAgIHZhciBrZXlwcmVzc0V2ZW50ID0gbmV3IEtleXByZXNzRXZlbnQoY2hhckNvZGUpO1xyXG4gICAgICAgICAgICBzeW5jTW9kaWZpZXJTdGF0ZXMoZSwga2V5cHJlc3NFdmVudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBMb2cgZXZlbnRcclxuICAgICAgICAgICAgZXZlbnRMb2cucHVzaChrZXlwcmVzc0V2ZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEludGVycHJldCBhcyBtYW55IGV2ZW50cyBhcyBwb3NzaWJsZSwgcHJldmVudCBkZWZhdWx0IGlmIGluZGljYXRlZFxyXG4gICAgICAgICAgICBpZiAoaW50ZXJwcmV0X2V2ZW50cygpKVxyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICB9LCB0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gV2hlbiBrZXkgcmVsZWFzZWRcclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IGludGVyY2VwdCBpZiBoYW5kbGVyIHNldFxyXG4gICAgICAgICAgICBpZiAoIWd1YWNfa2V5Ym9hcmQub25rZXl1cCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gSWdub3JlIGV2ZW50cyB3aGljaCBoYXZlIGFscmVhZHkgYmVlbiBoYW5kbGVkXHJcbiAgICAgICAgICAgIGlmICghbWFya0V2ZW50KGUpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICB2YXIga2V5Q29kZTtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5ldmVudCkga2V5Q29kZSA9IHdpbmRvdy5ldmVudC5rZXlDb2RlO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChlLndoaWNoKSBrZXlDb2RlID0gZS53aGljaDtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpeCBtb2RpZmllciBzdGF0ZXNcclxuICAgICAgICAgICAgdmFyIGtleXVwRXZlbnQgPSBuZXcgS2V5dXBFdmVudChrZXlDb2RlLCBlLmtleUlkZW50aWZpZXIsIGUua2V5LCBnZXRFdmVudExvY2F0aW9uKGUpKTtcclxuICAgICAgICAgICAgc3luY01vZGlmaWVyU3RhdGVzKGUsIGtleXVwRXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gTG9nIGV2ZW50LCBjYWxsIGZvciBpbnRlcnByZXRhdGlvblxyXG4gICAgICAgICAgICBldmVudExvZy5wdXNoKGtleXVwRXZlbnQpO1xyXG4gICAgICAgICAgICBpbnRlcnByZXRfZXZlbnRzKCk7XHJcblxyXG4gICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIHRoZSBnaXZlbiBcImlucHV0XCIgZXZlbnQsIHR5cGluZyB0aGUgZGF0YSB3aXRoaW4gdGhlIGlucHV0IHRleHQuXHJcbiAgICAgICAgICogSWYgdGhlIGV2ZW50IGlzIGNvbXBsZXRlICh0ZXh0IGlzIHByb3ZpZGVkKSwgaGFuZGxpbmcgb2YgXCJjb21wb3NpdGlvbmVuZFwiXHJcbiAgICAgICAgICogZXZlbnRzIGlzIHN1c3BlbmRlZCwgYXMgc3VjaCBldmVudHMgbWF5IGNvbmZsaWN0IHdpdGggaW5wdXQgZXZlbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge0lucHV0RXZlbnR9IGVcclxuICAgICAgICAgKiAgICAgVGhlIFwiaW5wdXRcIiBldmVudCB0byBoYW5kbGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGhhbmRsZUlucHV0ID0gZnVuY3Rpb24gaGFuZGxlSW5wdXQoZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBpbnRlcmNlcHQgaWYgaGFuZGxlciBzZXRcclxuICAgICAgICAgICAgaWYgKCFndWFjX2tleWJvYXJkLm9ua2V5ZG93biAmJiAhZ3VhY19rZXlib2FyZC5vbmtleXVwKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBJZ25vcmUgZXZlbnRzIHdoaWNoIGhhdmUgYWxyZWFkeSBiZWVuIGhhbmRsZWRcclxuICAgICAgICAgICAgaWYgKCFtYXJrRXZlbnQoZSkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIFR5cGUgYWxsIGNvbnRlbnQgd3JpdHRlblxyXG4gICAgICAgICAgICBpZiAoZS5kYXRhICYmICFlLmlzQ29tcG9zaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb21wb3NpdGlvbmVuZFwiLCBoYW5kbGVDb21wb3NpdGlvbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgZ3VhY19rZXlib2FyZC50eXBlKGUuZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlcyB0aGUgZ2l2ZW4gXCJjb21wb3NpdGlvbmVuZFwiIGV2ZW50LCB0eXBpbmcgdGhlIGRhdGEgd2l0aGluIHRoZVxyXG4gICAgICAgICAqIGNvbXBvc2VkIHRleHQuIElmIHRoZSBldmVudCBpcyBjb21wbGV0ZSAoY29tcG9zZWQgdGV4dCBpcyBwcm92aWRlZCksXHJcbiAgICAgICAgICogaGFuZGxpbmcgb2YgXCJpbnB1dFwiIGV2ZW50cyBpcyBzdXNwZW5kZWQsIGFzIHN1Y2ggZXZlbnRzIG1heSBjb25mbGljdFxyXG4gICAgICAgICAqIHdpdGggY29tcG9zaXRpb24gZXZlbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge0NvbXBvc2l0aW9uRXZlbnR9IGVcclxuICAgICAgICAgKiAgICAgVGhlIFwiY29tcG9zaXRpb25lbmRcIiBldmVudCB0byBoYW5kbGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGhhbmRsZUNvbXBvc2l0aW9uID0gZnVuY3Rpb24gaGFuZGxlQ29tcG9zaXRpb24oZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBpbnRlcmNlcHQgaWYgaGFuZGxlciBzZXRcclxuICAgICAgICAgICAgaWYgKCFndWFjX2tleWJvYXJkLm9ua2V5ZG93biAmJiAhZ3VhY19rZXlib2FyZC5vbmtleXVwKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBJZ25vcmUgZXZlbnRzIHdoaWNoIGhhdmUgYWxyZWFkeSBiZWVuIGhhbmRsZWRcclxuICAgICAgICAgICAgaWYgKCFtYXJrRXZlbnQoZSkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIFR5cGUgYWxsIGNvbnRlbnQgd3JpdHRlblxyXG4gICAgICAgICAgICBpZiAoZS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBoYW5kbGVJbnB1dCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgZ3VhY19rZXlib2FyZC50eXBlKGUuZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQXV0b21hdGljYWxseSB0eXBlIHRleHQgZW50ZXJlZCBpbnRvIHRoZSB3cmFwcGVkIGZpZWxkXHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgaGFuZGxlSW5wdXQsIGZhbHNlKTtcclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb21wb3NpdGlvbmVuZFwiLCBoYW5kbGVDb21wb3NpdGlvbiwgZmFsc2UpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gTGlzdGVuIHRvIGdpdmVuIGVsZW1lbnQsIGlmIGFueVxyXG4gICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgZ3VhY19rZXlib2FyZC5saXN0ZW5UbyhlbGVtZW50KTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIHVuaXF1ZSBudW1lcmljYWwgaWRlbnRpZmllciB0byBhc3NpZ24gdG8gdGhlIG5leHQgR3VhY2Ftb2xlLktleWJvYXJkXHJcbiAqIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZSB7TnVtYmVyfVxyXG4gKi9cclxuR3VhY2Ftb2xlLktleWJvYXJkLl9uZXh0SUQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBzdGF0ZSBvZiBhbGwgc3VwcG9ydGVkIGtleWJvYXJkIG1vZGlmaWVycy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5HdWFjYW1vbGUuS2V5Ym9hcmQuTW9kaWZpZXJTdGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgc2hpZnQgaXMgY3VycmVudGx5IHByZXNzZWQuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaGlmdCA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgY3RybCBpcyBjdXJyZW50bHkgcHJlc3NlZC5cclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN0cmwgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIGFsdCBpcyBjdXJyZW50bHkgcHJlc3NlZC5cclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFsdCA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgbWV0YSAoYXBwbGUga2V5KSBpcyBjdXJyZW50bHkgcHJlc3NlZC5cclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1ldGEgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgaHlwZXIgKHdpbmRvd3Mga2V5KSBpcyBjdXJyZW50bHkgcHJlc3NlZC5cclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmh5cGVyID0gZmFsc2U7XHJcbiAgICBcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtb2RpZmllciBzdGF0ZSBhcHBsaWNhYmxlIHRvIHRoZSBrZXlib2FyZCBldmVudCBnaXZlbi5cclxuICogXHJcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZSBUaGUga2V5Ym9hcmQgZXZlbnQgdG8gcmVhZC5cclxuICogQHJldHVybnMge0d1YWNhbW9sZS5LZXlib2FyZC5Nb2RpZmllclN0YXRlfSBUaGUgY3VycmVudCBzdGF0ZSBvZiBrZXlib2FyZFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVycy5cclxuICovXHJcbkd1YWNhbW9sZS5LZXlib2FyZC5Nb2RpZmllclN0YXRlLmZyb21LZXlib2FyZEV2ZW50ID0gZnVuY3Rpb24oZSkge1xyXG4gICAgXHJcbiAgICB2YXIgc3RhdGUgPSBuZXcgR3VhY2Ftb2xlLktleWJvYXJkLk1vZGlmaWVyU3RhdGUoKTtcclxuXHJcbiAgICAvLyBBc3NpZ24gc3RhdGVzIGZyb20gb2xkIGZsYWdzXHJcbiAgICBzdGF0ZS5zaGlmdCA9IGUuc2hpZnRLZXk7XHJcbiAgICBzdGF0ZS5jdHJsICA9IGUuY3RybEtleTtcclxuICAgIHN0YXRlLmFsdCAgID0gZS5hbHRLZXk7XHJcbiAgICBzdGF0ZS5tZXRhICA9IGUubWV0YUtleTtcclxuXHJcbiAgICAvLyBVc2UgRE9NMyBnZXRNb2RpZmllclN0YXRlKCkgZm9yIG90aGVyc1xyXG4gICAgaWYgKGUuZ2V0TW9kaWZpZXJTdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlLmh5cGVyID0gZS5nZXRNb2RpZmllclN0YXRlKFwiT1NcIilcclxuICAgICAgICAgICAgICAgICAgIHx8IGUuZ2V0TW9kaWZpZXJTdGF0ZShcIlN1cGVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICB8fCBlLmdldE1vZGlmaWVyU3RhdGUoXCJIeXBlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgfHwgZS5nZXRNb2RpZmllclN0YXRlKFwiV2luXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdGF0ZTtcclxuICAgIFxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQWJzdHJhY3Qgb3JkZXJlZCBkcmF3aW5nIHN1cmZhY2UuIEVhY2ggTGF5ZXIgY29udGFpbnMgYSBjYW52YXMgZWxlbWVudCBhbmRcclxuICogcHJvdmlkZXMgc2ltcGxlIGRyYXdpbmcgaW5zdHJ1Y3Rpb25zIGZvciBkcmF3aW5nIHRvIHRoYXQgY2FudmFzIGVsZW1lbnQsXHJcbiAqIGhvd2V2ZXIgdW5saWtlIHRoZSBjYW52YXMgZWxlbWVudCBpdHNlbGYsIGRyYXdpbmcgb3BlcmF0aW9ucyBvbiBhIExheWVyIGFyZVxyXG4gKiBndWFyYW50ZWVkIHRvIHJ1biBpbiBvcmRlciwgZXZlbiBpZiBzdWNoIGFuIG9wZXJhdGlvbiBtdXN0IHdhaXQgZm9yIGFuIGltYWdlXHJcbiAqIHRvIGxvYWQgYmVmb3JlIGNvbXBsZXRpbmcuXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIExheWVyLCBpbiBwaXhlbHMuIFRoZSBjYW52YXMgZWxlbWVudFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYmFja2luZyB0aGlzIExheWVyIHdpbGwgYmUgZ2l2ZW4gdGhpcyB3aWR0aC5cclxuICogICAgICAgICAgICAgICAgICAgICAgIFxyXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIExheWVyLCBpbiBwaXhlbHMuIFRoZSBjYW52YXMgZWxlbWVudFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tpbmcgdGhpcyBMYXllciB3aWxsIGJlIGdpdmVuIHRoaXMgaGVpZ2h0LlxyXG4gKi9cclxuR3VhY2Ftb2xlLkxheWVyID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgTGF5ZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgbGF5ZXIgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBwaXhlbHMgdGhlIHdpZHRoIG9yIGhlaWdodCBvZiBhIGxheWVyIG11c3QgY2hhbmdlIGJlZm9yZVxyXG4gICAgICogdGhlIHVuZGVybHlpbmcgY2FudmFzIGlzIHJlc2l6ZWQuIFRoZSB1bmRlcmx5aW5nIGNhbnZhcyB3aWxsIGJlIGtlcHQgYXRcclxuICAgICAqIGRpbWVuc2lvbnMgd2hpY2ggYXJlIGludGVnZXIgbXVsdGlwbGVzIG9mIHRoaXMgZmFjdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEB0eXBlIE51bWJlclxyXG4gICAgICovXHJcbiAgICB2YXIgQ0FOVkFTX1NJWkVfRkFDVE9SID0gNjQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FudmFzIGVsZW1lbnQgYmFja2luZyB0aGlzIExheWVyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgMkQgZGlzcGxheSBjb250ZXh0IG9mIHRoZSBjYW52YXMgZWxlbWVudCBiYWNraW5nIHRoaXMgTGF5ZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICBjb250ZXh0LnNhdmUoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGxheWVyIGhhcyBub3QgeWV0IGJlZW4gZHJhd24gdG8uIE9uY2UgYW55IGRyYXcgb3BlcmF0aW9uXHJcbiAgICAgKiB3aGljaCBhZmZlY3RzIHRoZSB1bmRlcmx5aW5nIGNhbnZhcyBpcyBpbnZva2VkLCB0aGlzIGZsYWcgd2lsbCBiZSBzZXQgdG9cclxuICAgICAqIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSBCb29sZWFuXHJcbiAgICAgKi9cclxuICAgIHZhciBlbXB0eSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIGEgbmV3IHBhdGggc2hvdWxkIGJlIHN0YXJ0ZWQgd2l0aCB0aGUgbmV4dCBwYXRoIGRyYXdpbmdcclxuICAgICAqIG9wZXJhdGlvbnMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgcGF0aENsb3NlZCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHN0YXRlcyBvbiB0aGUgc3RhdGUgc3RhY2suXHJcbiAgICAgKiBcclxuICAgICAqIE5vdGUgdGhhdCB0aGVyZSB3aWxsIEFMV0FZUyBiZSBvbmUgZWxlbWVudCBvbiB0aGUgc3RhY2ssIGJ1dCB0aGF0XHJcbiAgICAgKiBlbGVtZW50IGlzIG5vdCBleHBvc2VkLiBJdCBpcyBvbmx5IHVzZWQgdG8gcmVzZXQgdGhlIGxheWVyIHRvIGl0c1xyXG4gICAgICogaW5pdGlhbCBzdGF0ZS5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHN0YWNrU2l6ZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2YgYWxsIEd1YWNhbW9sZSBjaGFubmVsIG1hc2tzIHRvIEhUTUw1IGNhbnZhcyBjb21wb3NpdGUgb3BlcmF0aW9uXHJcbiAgICAgKiBuYW1lcy4gTm90IGFsbCBjaGFubmVsIG1hc2sgY29tYmluYXRpb25zIGFyZSBjdXJyZW50bHkgaW1wbGVtZW50ZWQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgY29tcG9zaXRlT3BlcmF0aW9uID0ge1xyXG4gICAgIC8qIDB4MCBOT1QgSU1QTEVNRU5URUQgKi9cclxuICAgICAgICAweDE6IFwiZGVzdGluYXRpb24taW5cIixcclxuICAgICAgICAweDI6IFwiZGVzdGluYXRpb24tb3V0XCIsXHJcbiAgICAgLyogMHgzIE5PVCBJTVBMRU1FTlRFRCAqL1xyXG4gICAgICAgIDB4NDogXCJzb3VyY2UtaW5cIixcclxuICAgICAvKiAweDUgTk9UIElNUExFTUVOVEVEICovXHJcbiAgICAgICAgMHg2OiBcInNvdXJjZS1hdG9wXCIsXHJcbiAgICAgLyogMHg3IE5PVCBJTVBMRU1FTlRFRCAqL1xyXG4gICAgICAgIDB4ODogXCJzb3VyY2Utb3V0XCIsXHJcbiAgICAgICAgMHg5OiBcImRlc3RpbmF0aW9uLWF0b3BcIixcclxuICAgICAgICAweEE6IFwieG9yXCIsXHJcbiAgICAgICAgMHhCOiBcImRlc3RpbmF0aW9uLW92ZXJcIixcclxuICAgICAgICAweEM6IFwiY29weVwiLFxyXG4gICAgIC8qIDB4RCBOT1QgSU1QTEVNRU5URUQgKi9cclxuICAgICAgICAweEU6IFwic291cmNlLW92ZXJcIixcclxuICAgICAgICAweEY6IFwibGlnaHRlclwiXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyB0aGUgY2FudmFzIGVsZW1lbnQgYmFja2luZyB0aGlzIExheWVyLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5XHJcbiAgICAgKiBiZSB1c2VkIGludGVybmFsbHkuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW25ld1dpZHRoPTBdXHJcbiAgICAgKiAgICAgVGhlIG5ldyB3aWR0aCB0byBhc3NpZ24gdG8gdGhpcyBMYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW25ld0hlaWdodD0wXVxyXG4gICAgICogICAgIFRoZSBuZXcgaGVpZ2h0IHRvIGFzc2lnbiB0byB0aGlzIExheWVyLlxyXG4gICAgICovXHJcbiAgICB2YXIgcmVzaXplID0gZnVuY3Rpb24gcmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcclxuXHJcbiAgICAgICAgLy8gRGVmYXVsdCBzaXplIHRvIHplcm9cclxuICAgICAgICBuZXdXaWR0aCA9IG5ld1dpZHRoIHx8IDA7XHJcbiAgICAgICAgbmV3SGVpZ2h0ID0gbmV3SGVpZ2h0IHx8IDA7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgZGltZW5zaW9ucyBvZiBpbnRlcm5hbCBjYW52YXNcclxuICAgICAgICB2YXIgY2FudmFzV2lkdGggID0gTWF0aC5jZWlsKG5ld1dpZHRoICAvIENBTlZBU19TSVpFX0ZBQ1RPUikgKiBDQU5WQVNfU0laRV9GQUNUT1I7XHJcbiAgICAgICAgdmFyIGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChuZXdIZWlnaHQgLyBDQU5WQVNfU0laRV9GQUNUT1IpICogQ0FOVkFTX1NJWkVfRkFDVE9SO1xyXG5cclxuICAgICAgICAvLyBSZXNpemUgb25seSBpZiBjYW52YXMgZGltZW5zaW9ucyBhcmUgYWN0dWFsbHkgY2hhbmdpbmdcclxuICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENvcHkgb2xkIGRhdGEgb25seSBpZiByZWxldmFudCBhbmQgbm9uLWVtcHR5XHJcbiAgICAgICAgICAgIHZhciBvbGREYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFlbXB0eSAmJiBjYW52YXMud2lkdGggIT09IDAgJiYgY2FudmFzLmhlaWdodCAhPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBjYW52YXMgYW5kIGNvbnRleHQgZm9yIGhvbGRpbmcgb2xkIGRhdGFcclxuICAgICAgICAgICAgICAgIG9sZERhdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgICAgICAgICAgb2xkRGF0YS53aWR0aCA9IE1hdGgubWluKGxheWVyLndpZHRoLCBuZXdXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICBvbGREYXRhLmhlaWdodCA9IE1hdGgubWluKGxheWVyLmhlaWdodCwgbmV3SGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkRGF0YUNvbnRleHQgPSBvbGREYXRhLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IGltYWdlIGRhdGEgZnJvbSBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICBvbGREYXRhQ29udGV4dC5kcmF3SW1hZ2UoY2FudmFzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCBvbGREYXRhLndpZHRoLCBvbGREYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgb2xkRGF0YS53aWR0aCwgb2xkRGF0YS5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUHJlc2VydmUgY29tcG9zaXRlIG9wZXJhdGlvblxyXG4gICAgICAgICAgICB2YXIgb2xkQ29tcG9zaXRlT3BlcmF0aW9uID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XHJcblxyXG4gICAgICAgICAgICAvLyBSZXNpemUgY2FudmFzXHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgLy8gUmVkcmF3IG9sZCBkYXRhLCBpZiBhbnlcclxuICAgICAgICAgICAgaWYgKG9sZERhdGEpXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShvbGREYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsIDAsIG9sZERhdGEud2lkdGgsIG9sZERhdGEuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIDAsIDAsIG9sZERhdGEud2lkdGgsIG9sZERhdGEuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgY29tcG9zaXRlIG9wZXJhdGlvblxyXG4gICAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG9sZENvbXBvc2l0ZU9wZXJhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIC8vIEFja25vd2xlZGdlIHJlc2V0IG9mIHN0YWNrIChoYXBwZW5zIG9uIHJlc2l6ZSBvZiBjYW52YXMpXHJcbiAgICAgICAgICAgIHN0YWNrU2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBjYW52YXMgc2l6ZSBpcyBub3QgY2hhbmdpbmcsIG1hbnVhbGx5IGZvcmNlIHN0YXRlIHJlc2V0XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBsYXllci5yZXNldCgpO1xyXG5cclxuICAgICAgICAvLyBBc3NpZ24gbmV3IGxheWVyIGRpbWVuc2lvbnNcclxuICAgICAgICBsYXllci53aWR0aCA9IG5ld1dpZHRoO1xyXG4gICAgICAgIGxheWVyLmhlaWdodCA9IG5ld0hlaWdodDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gdGhlIFggYW5kIFkgY29vcmRpbmF0ZXMgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIGEgcmVjdGFuZ2xlXHJcbiAgICAgKiBhbmQgdGhlIHJlY3RhbmdsZSdzIHdpZHRoIGFuZCBoZWlnaHQsIHJlc2l6ZSB0aGUgYmFja2luZyBjYW52YXMgZWxlbWVudFxyXG4gICAgICogYXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IHRoZSByZWN0YW5nbGUgZml0cyB3aXRoaW4gdGhlIGNhbnZhc1xyXG4gICAgICogZWxlbWVudCdzIGNvb3JkaW5hdGUgc3BhY2UuIFRoaXMgZnVuY3Rpb24gd2lsbCBvbmx5IG1ha2UgdGhlIGNhbnZhc1xyXG4gICAgICogbGFyZ2VyLiBJZiB0aGUgcmVjdGFuZ2xlIGFscmVhZHkgZml0cyB3aXRoaW4gdGhlIGNhbnZhcyBlbGVtZW50J3NcclxuICAgICAqIGNvb3JkaW5hdGUgc3BhY2UsIHRoZSBjYW52YXMgaXMgbGVmdCB1bmNoYW5nZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB0byBmaXQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB0byBmaXQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIHRoZSByZWN0YW5nbGUgdG8gZml0LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIGhlaWdodCBvZiB0aGUgdGhlIHJlY3RhbmdsZSB0byBmaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZpdFJlY3QoeCwgeSwgdywgaCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBib3VuZHNcclxuICAgICAgICB2YXIgb3BCb3VuZFggPSB3ICsgeDtcclxuICAgICAgICB2YXIgb3BCb3VuZFkgPSBoICsgeTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBEZXRlcm1pbmUgbWF4IHdpZHRoXHJcbiAgICAgICAgdmFyIHJlc2l6ZVdpZHRoO1xyXG4gICAgICAgIGlmIChvcEJvdW5kWCA+IGxheWVyLndpZHRoKVxyXG4gICAgICAgICAgICByZXNpemVXaWR0aCA9IG9wQm91bmRYO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmVzaXplV2lkdGggPSBsYXllci53aWR0aDtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIG1heCBoZWlnaHRcclxuICAgICAgICB2YXIgcmVzaXplSGVpZ2h0O1xyXG4gICAgICAgIGlmIChvcEJvdW5kWSA+IGxheWVyLmhlaWdodClcclxuICAgICAgICAgICAgcmVzaXplSGVpZ2h0ID0gb3BCb3VuZFk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXNpemVIZWlnaHQgPSBsYXllci5oZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIFJlc2l6ZSBpZiBuZWNlc3NhcnlcclxuICAgICAgICBsYXllci5yZXNpemUocmVzaXplV2lkdGgsIHJlc2l6ZUhlaWdodCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRvIHRydWUgaWYgdGhpcyBMYXllciBzaG91bGQgcmVzaXplIGl0c2VsZiB0byBhY2NvbW9kYXRlIHRoZVxyXG4gICAgICogZGltZW5zaW9ucyBvZiBhbnkgZHJhd2luZyBvcGVyYXRpb24sIGFuZCBmYWxzZSAodGhlIGRlZmF1bHQpIG90aGVyd2lzZS5cclxuICAgICAqIFxyXG4gICAgICogTm90ZSB0aGF0IHNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0YWtlcyBlZmZlY3QgaW1tZWRpYXRlbHksIGFuZCB0aHVzIG1heVxyXG4gICAgICogdGFrZSBlZmZlY3Qgb24gb3BlcmF0aW9ucyB0aGF0IHdlcmUgc3RhcnRlZCBpbiB0aGUgcGFzdCBidXQgaGF2ZSBub3RcclxuICAgICAqIHlldCBjb21wbGV0ZWQuIElmIHlvdSB3aXNoIHRoZSBzZXR0aW5nIG9mIHRoaXMgZmxhZyB0byBvbmx5IG1vZGlmeVxyXG4gICAgICogZnV0dXJlIG9wZXJhdGlvbnMsIHlvdSB3aWxsIG5lZWQgdG8gbWFrZSB0aGUgc2V0dGluZyBvZiB0aGlzIGZsYWcgYW5cclxuICAgICAqIG9wZXJhdGlvbiB3aXRoIHN5bmMoKS5cclxuICAgICAqIFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIFNldCBhdXRvc2l6ZSB0byB0cnVlIGZvciBhbGwgZnV0dXJlIG9wZXJhdGlvbnNcclxuICAgICAqIGxheWVyLnN5bmMoZnVuY3Rpb24oKSB7XHJcbiAgICAgKiAgICAgbGF5ZXIuYXV0b3NpemUgPSB0cnVlO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdXRvc2l6ZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgd2lkdGggb2YgdGhpcyBsYXllci5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGlzIGxheWVyLlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjYW52YXMgZWxlbWVudCBiYWNraW5nIHRoaXMgTGF5ZXIuIE5vdGUgdGhhdCB0aGUgZGltZW5zaW9uc1xyXG4gICAgICogb2YgdGhlIGNhbnZhcyBtYXkgbm90IGV4YWN0bHkgbWF0Y2ggdGhvc2Ugb2YgdGhlIExheWVyLCBhcyByZXNpemluZyBhXHJcbiAgICAgKiBjYW52YXMgd2hpbGUgbWFpbnRhaW5pbmcgaXRzIHN0YXRlIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fVxyXG4gICAgICogICAgIFRoZSBjYW52YXMgZWxlbWVudCBiYWNraW5nIHRoaXMgTGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0Q2FudmFzID0gZnVuY3Rpb24gZ2V0Q2FudmFzKCkge1xyXG4gICAgICAgIHJldHVybiBjYW52YXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBjYW52YXMgZWxlbWVudCBjb250YWluaW5nIHRoZSBzYW1lIGltYWdlIGFzIHRoaXMgTGF5ZXIuXHJcbiAgICAgKiBVbmxpa2UgZ2V0Q2FudmFzKCksIHRoZSBjYW52YXMgZWxlbWVudCByZXR1cm5lZCBpcyBndWFyYW50ZWVkIHRvIGhhdmVcclxuICAgICAqIHRoZSBleGFjdCBzYW1lIGRpbWVuc2lvbnMgYXMgdGhlIExheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH1cclxuICAgICAqICAgICBBIG5ldyBjYW52YXMgZWxlbWVudCBjb250YWluaW5nIGEgY29weSBvZiB0aGUgaW1hZ2UgY29udGVudCB0aGlzXHJcbiAgICAgKiAgICAgTGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMudG9DYW52YXMgPSBmdW5jdGlvbiB0b0NhbnZhcygpIHtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBjYW52YXMgaGF2aW5nIHNhbWUgZGltZW5zaW9uc1xyXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSBsYXllci53aWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbGF5ZXIuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBDb3B5IGltYWdlIGNvbnRlbnRzIHRvIG5ldyBjYW52YXNcclxuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGxheWVyLmdldENhbnZhcygpLCAwLCAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGlzIExheWVyIHRvIHRoZSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXNpemluZ1xyXG4gICAgICogaXMgb25seSBhdHRlbXB0ZWQgaWYgdGhlIG5ldyBzaXplIHByb3ZpZGVkIGlzIGFjdHVhbGx5IGRpZmZlcmVudCBmcm9tXHJcbiAgICAgKiB0aGUgY3VycmVudCBzaXplLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbmV3V2lkdGggVGhlIG5ldyB3aWR0aCB0byBhc3NpZ24gdG8gdGhpcyBMYXllci5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuZXdIZWlnaHQgVGhlIG5ldyBoZWlnaHQgdG8gYXNzaWduIHRvIHRoaXMgTGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzaXplID0gZnVuY3Rpb24obmV3V2lkdGgsIG5ld0hlaWdodCkge1xyXG4gICAgICAgIGlmIChuZXdXaWR0aCAhPT0gbGF5ZXIud2lkdGggfHwgbmV3SGVpZ2h0ICE9PSBsYXllci5oZWlnaHQpXHJcbiAgICAgICAgICAgIHJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgc3BlY2lmaWVkIGltYWdlIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy4gVGhlIGltYWdlIHNwZWNpZmllZFxyXG4gICAgICogbXVzdCBhbHJlYWR5IGJlIGxvYWRlZC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqICAgICBUaGUgZGVzdGluYXRpb24gWCBjb29yZGluYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiAgICAgVGhlIGRlc3RpbmF0aW9uIFkgY29vcmRpbmF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0ltYWdlU291cmNlfSBpbWFnZVxyXG4gICAgICogICAgIFRoZSBpbWFnZSB0byBkcmF3LiBOb3RlIHRoYXQgdGhpcyBpcyBub3QgYSBVUkwuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhd0ltYWdlID0gZnVuY3Rpb24oeCwgeSwgaW1hZ2UpIHtcclxuICAgICAgICBpZiAobGF5ZXIuYXV0b3NpemUpIGZpdFJlY3QoeCwgeSwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XHJcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHkpO1xyXG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmZXIgYSByZWN0YW5nbGUgb2YgaW1hZ2UgZGF0YSBmcm9tIG9uZSBMYXllciB0byB0aGlzIExheWVyIHVzaW5nIHRoZVxyXG4gICAgICogc3BlY2lmaWVkIHRyYW5zZmVyIGZ1bmN0aW9uLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gc3JjTGF5ZXIgVGhlIExheWVyIHRvIGNvcHkgaW1hZ2UgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3ggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXIncyBjb29yZGluYXRlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3MgY29vcmRpbmF0ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjdyBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY2ggVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBMYXllcidzIGNvb3JkaW5hdGUgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgZGVzdGluYXRpb24gWCBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIGRlc3RpbmF0aW9uIFkgY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZmVyRnVuY3Rpb24gVGhlIHRyYW5zZmVyIGZ1bmN0aW9uIHRvIHVzZSB0b1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2ZlciBkYXRhIGZyb20gc291cmNlIHRvXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyYW5zZmVyID0gZnVuY3Rpb24oc3JjTGF5ZXIsIHNyY3gsIHNyY3ksIHNyY3csIHNyY2gsIHgsIHksIHRyYW5zZmVyRnVuY3Rpb24pIHtcclxuXHJcbiAgICAgICAgdmFyIHNyY0NhbnZhcyA9IHNyY0xheWVyLmdldENhbnZhcygpO1xyXG5cclxuICAgICAgICAvLyBJZiBlbnRpcmUgcmVjdGFuZ2xlIG91dHNpZGUgc291cmNlIGNhbnZhcywgc3RvcFxyXG4gICAgICAgIGlmIChzcmN4ID49IHNyY0NhbnZhcy53aWR0aCB8fCBzcmN5ID49IHNyY0NhbnZhcy5oZWlnaHQpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBjbGlwIHJlY3RhbmdsZSB0byBhcmVhXHJcbiAgICAgICAgaWYgKHNyY3ggKyBzcmN3ID4gc3JjQ2FudmFzLndpZHRoKVxyXG4gICAgICAgICAgICBzcmN3ID0gc3JjQ2FudmFzLndpZHRoIC0gc3JjeDtcclxuXHJcbiAgICAgICAgaWYgKHNyY3kgKyBzcmNoID4gc3JjQ2FudmFzLmhlaWdodClcclxuICAgICAgICAgICAgc3JjaCA9IHNyY0NhbnZhcy5oZWlnaHQgLSBzcmN5O1xyXG5cclxuICAgICAgICAvLyBTdG9wIGlmIG5vdGhpbmcgdG8gZHJhdy5cclxuICAgICAgICBpZiAoc3JjdyA9PT0gMCB8fCBzcmNoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChsYXllci5hdXRvc2l6ZSkgZml0UmVjdCh4LCB5LCBzcmN3LCBzcmNoKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IGltYWdlIGRhdGEgZnJvbSBzcmMgYW5kIGRzdFxyXG4gICAgICAgIHZhciBzcmMgPSBzcmNMYXllci5nZXRDYW52YXMoKS5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKHNyY3gsIHNyY3ksIHNyY3csIHNyY2gpO1xyXG4gICAgICAgIHZhciBkc3QgPSBjb250ZXh0LmdldEltYWdlRGF0YSh4ICwgeSwgc3Jjdywgc3JjaCk7XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IHRyYW5zZmVyIGZvciBlYWNoIHBpeGVsXHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNyY3cqc3JjaCo0OyBpKz00KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgc291cmNlIHBpeGVsIGVudmlyb25tZW50XHJcbiAgICAgICAgICAgIHZhciBzcmNfcGl4ZWwgPSBuZXcgR3VhY2Ftb2xlLkxheWVyLlBpeGVsKFxyXG4gICAgICAgICAgICAgICAgc3JjLmRhdGFbaV0sXHJcbiAgICAgICAgICAgICAgICBzcmMuZGF0YVtpKzFdLFxyXG4gICAgICAgICAgICAgICAgc3JjLmRhdGFbaSsyXSxcclxuICAgICAgICAgICAgICAgIHNyYy5kYXRhW2krM11cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBHZXQgZGVzdGluYXRpb24gcGl4ZWwgZW52aXJvbm1lbnRcclxuICAgICAgICAgICAgdmFyIGRzdF9waXhlbCA9IG5ldyBHdWFjYW1vbGUuTGF5ZXIuUGl4ZWwoXHJcbiAgICAgICAgICAgICAgICBkc3QuZGF0YVtpXSxcclxuICAgICAgICAgICAgICAgIGRzdC5kYXRhW2krMV0sXHJcbiAgICAgICAgICAgICAgICBkc3QuZGF0YVtpKzJdLFxyXG4gICAgICAgICAgICAgICAgZHN0LmRhdGFbaSszXVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgdHJhbnNmZXIgZnVuY3Rpb25cclxuICAgICAgICAgICAgdHJhbnNmZXJGdW5jdGlvbihzcmNfcGl4ZWwsIGRzdF9waXhlbCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTYXZlIHBpeGVsIGRhdGFcclxuICAgICAgICAgICAgZHN0LmRhdGFbaSAgXSA9IGRzdF9waXhlbC5yZWQ7XHJcbiAgICAgICAgICAgIGRzdC5kYXRhW2krMV0gPSBkc3RfcGl4ZWwuZ3JlZW47XHJcbiAgICAgICAgICAgIGRzdC5kYXRhW2krMl0gPSBkc3RfcGl4ZWwuYmx1ZTtcclxuICAgICAgICAgICAgZHN0LmRhdGFbaSszXSA9IGRzdF9waXhlbC5hbHBoYTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEcmF3IGltYWdlIGRhdGFcclxuICAgICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShkc3QsIHgsIHkpO1xyXG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFB1dCBhIHJlY3RhbmdsZSBvZiBpbWFnZSBkYXRhIGZyb20gb25lIExheWVyIHRvIHRoaXMgTGF5ZXIgZGlyZWN0bHlcclxuICAgICAqIHdpdGhvdXQgcGVyZm9ybWluZyBhbnkgYWxwaGEgYmxlbmRpbmcuIFNpbXBseSBjb3B5IHRoZSBkYXRhLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gc3JjTGF5ZXIgVGhlIExheWVyIHRvIGNvcHkgaW1hZ2UgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3ggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXIncyBjb29yZGluYXRlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3MgY29vcmRpbmF0ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjdyBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY2ggVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBMYXllcidzIGNvb3JkaW5hdGUgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgZGVzdGluYXRpb24gWCBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIGRlc3RpbmF0aW9uIFkgY29vcmRpbmF0ZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5wdXQgPSBmdW5jdGlvbihzcmNMYXllciwgc3JjeCwgc3JjeSwgc3Jjdywgc3JjaCwgeCwgeSkge1xyXG5cclxuICAgICAgICB2YXIgc3JjQ2FudmFzID0gc3JjTGF5ZXIuZ2V0Q2FudmFzKCk7XHJcblxyXG4gICAgICAgIC8vIElmIGVudGlyZSByZWN0YW5nbGUgb3V0c2lkZSBzb3VyY2UgY2FudmFzLCBzdG9wXHJcbiAgICAgICAgaWYgKHNyY3ggPj0gc3JjQ2FudmFzLndpZHRoIHx8IHNyY3kgPj0gc3JjQ2FudmFzLmhlaWdodCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGNsaXAgcmVjdGFuZ2xlIHRvIGFyZWFcclxuICAgICAgICBpZiAoc3JjeCArIHNyY3cgPiBzcmNDYW52YXMud2lkdGgpXHJcbiAgICAgICAgICAgIHNyY3cgPSBzcmNDYW52YXMud2lkdGggLSBzcmN4O1xyXG5cclxuICAgICAgICBpZiAoc3JjeSArIHNyY2ggPiBzcmNDYW52YXMuaGVpZ2h0KVxyXG4gICAgICAgICAgICBzcmNoID0gc3JjQ2FudmFzLmhlaWdodCAtIHNyY3k7XHJcblxyXG4gICAgICAgIC8vIFN0b3AgaWYgbm90aGluZyB0byBkcmF3LlxyXG4gICAgICAgIGlmIChzcmN3ID09PSAwIHx8IHNyY2ggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKGxheWVyLmF1dG9zaXplKSBmaXRSZWN0KHgsIHksIHNyY3csIHNyY2gpO1xyXG5cclxuICAgICAgICAvLyBHZXQgaW1hZ2UgZGF0YSBmcm9tIHNyYyBhbmQgZHN0XHJcbiAgICAgICAgdmFyIHNyYyA9IHNyY0xheWVyLmdldENhbnZhcygpLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoc3JjeCwgc3JjeSwgc3Jjdywgc3JjaCk7XHJcbiAgICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoc3JjLCB4LCB5KTtcclxuICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IGEgcmVjdGFuZ2xlIG9mIGltYWdlIGRhdGEgZnJvbSBvbmUgTGF5ZXIgdG8gdGhpcyBMYXllci4gVGhpc1xyXG4gICAgICogb3BlcmF0aW9uIHdpbGwgY29weSBleGFjdGx5IHRoZSBpbWFnZSBkYXRhIHRoYXQgd2lsbCBiZSBkcmF3biBvbmNlIGFsbFxyXG4gICAgICogb3BlcmF0aW9ucyBvZiB0aGUgc291cmNlIExheWVyIHRoYXQgd2VyZSBwZW5kaW5nIGF0IHRoZSB0aW1lIHRoaXNcclxuICAgICAqIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYXJlIGNvbXBsZXRlLiBUaGlzIG9wZXJhdGlvbiB3aWxsIG5vdCBhbHRlciB0aGVcclxuICAgICAqIHNpemUgb2YgdGhlIHNvdXJjZSBMYXllciBldmVuIGlmIGl0cyBhdXRvc2l6ZSBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IHNyY0xheWVyIFRoZSBMYXllciB0byBjb3B5IGltYWdlIGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3MgY29vcmRpbmF0ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzIGNvb3JkaW5hdGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3cgVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXInc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZSBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmNoIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgTGF5ZXIncyBjb29yZGluYXRlIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGRlc3RpbmF0aW9uIFggY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBkZXN0aW5hdGlvbiBZIGNvb3JkaW5hdGUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29weSA9IGZ1bmN0aW9uKHNyY0xheWVyLCBzcmN4LCBzcmN5LCBzcmN3LCBzcmNoLCB4LCB5KSB7XHJcblxyXG4gICAgICAgIHZhciBzcmNDYW52YXMgPSBzcmNMYXllci5nZXRDYW52YXMoKTtcclxuXHJcbiAgICAgICAgLy8gSWYgZW50aXJlIHJlY3RhbmdsZSBvdXRzaWRlIHNvdXJjZSBjYW52YXMsIHN0b3BcclxuICAgICAgICBpZiAoc3JjeCA+PSBzcmNDYW52YXMud2lkdGggfHwgc3JjeSA+PSBzcmNDYW52YXMuaGVpZ2h0KSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgY2xpcCByZWN0YW5nbGUgdG8gYXJlYVxyXG4gICAgICAgIGlmIChzcmN4ICsgc3JjdyA+IHNyY0NhbnZhcy53aWR0aClcclxuICAgICAgICAgICAgc3JjdyA9IHNyY0NhbnZhcy53aWR0aCAtIHNyY3g7XHJcblxyXG4gICAgICAgIGlmIChzcmN5ICsgc3JjaCA+IHNyY0NhbnZhcy5oZWlnaHQpXHJcbiAgICAgICAgICAgIHNyY2ggPSBzcmNDYW52YXMuaGVpZ2h0IC0gc3JjeTtcclxuXHJcbiAgICAgICAgLy8gU3RvcCBpZiBub3RoaW5nIHRvIGRyYXcuXHJcbiAgICAgICAgaWYgKHNyY3cgPT09IDAgfHwgc3JjaCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAobGF5ZXIuYXV0b3NpemUpIGZpdFJlY3QoeCwgeSwgc3Jjdywgc3JjaCk7XHJcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2Uoc3JjQ2FudmFzLCBzcmN4LCBzcmN5LCBzcmN3LCBzcmNoLCB4LCB5LCBzcmN3LCBzcmNoKTtcclxuICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBuZXcgcGF0aCBhdCB0aGUgc3BlY2lmaWVkIHBvaW50LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBkcmF3LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gZHJhdy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU3RhcnQgYSBuZXcgcGF0aCBpZiBjdXJyZW50IHBhdGggaXMgY2xvc2VkXHJcbiAgICAgICAgaWYgKHBhdGhDbG9zZWQpIHtcclxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgcGF0aENsb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAobGF5ZXIuYXV0b3NpemUpIGZpdFJlY3QoeCwgeSwgMCwgMCk7XHJcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0aGUgc3BlY2lmaWVkIGxpbmUgdG8gdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgdG8gZHJhdy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIHRvIGRyYXcuXHJcbiAgICAgKi9cclxuICAgIHRoaXMubGluZVRvID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IHBhdGggaWYgY3VycmVudCBwYXRoIGlzIGNsb3NlZFxyXG4gICAgICAgIGlmIChwYXRoQ2xvc2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIHBhdGhDbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGxheWVyLmF1dG9zaXplKSBmaXRSZWN0KHgsIHksIDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xyXG4gICAgICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0aGUgc3BlY2lmaWVkIGFyYyB0byB0aGUgY3VycmVudCBwYXRoLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSB3aGljaFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgd2lsbCBjb250YWluIHRoZSBhcmMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSB3aGljaFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgd2lsbCBjb250YWluIHRoZSBhcmMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEFuZ2xlIFRoZSBzdGFydGluZyBhbmdsZSBvZiB0aGUgYXJjLCBpbiByYWRpYW5zLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlIFRoZSBlbmRpbmcgYW5nbGUgb2YgdGhlIGFyYywgaW4gcmFkaWFucy5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVnYXRpdmUgV2hldGhlciB0aGUgYXJjIHNob3VsZCBiZSBkcmF3biBpbiBvcmRlciBvZlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNyZWFzaW5nIGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmFyYyA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIG5lZ2F0aXZlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU3RhcnQgYSBuZXcgcGF0aCBpZiBjdXJyZW50IHBhdGggaXMgY2xvc2VkXHJcbiAgICAgICAgaWYgKHBhdGhDbG9zZWQpIHtcclxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgcGF0aENsb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAobGF5ZXIuYXV0b3NpemUpIGZpdFJlY3QoeCwgeSwgMCwgMCk7XHJcbiAgICAgICAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgbmVnYXRpdmUpO1xyXG4gICAgICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIG5ldyBwYXRoIGF0IHRoZSBzcGVjaWZpZWQgcG9pbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjcDF4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3AxeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNwMnggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3AyeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZHBvaW50IG9mIHRoZSBjdXJ2ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGVuZHBvaW50IG9mIHRoZSBjdXJ2ZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJ2ZVRvID0gZnVuY3Rpb24oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IHBhdGggaWYgY3VycmVudCBwYXRoIGlzIGNsb3NlZFxyXG4gICAgICAgIGlmIChwYXRoQ2xvc2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIHBhdGhDbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGxheWVyLmF1dG9zaXplKSBmaXRSZWN0KHgsIHksIDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcclxuICAgICAgICBcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aCBieSBjb25uZWN0aW5nIHRoZSBlbmQgcG9pbnQgd2l0aCB0aGUgc3RhcnRcclxuICAgICAqIHBvaW50IChpZiBhbnkpIHdpdGggYSBzdHJhaWdodCBsaW5lLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBwYXRoQ2xvc2VkID0gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIHNwZWNpZmllZCByZWN0YW5nbGUgdG8gdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgdG8gZHJhdy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSB0byBkcmF3LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGRyYXcuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgLy8gU3RhcnQgYSBuZXcgcGF0aCBpZiBjdXJyZW50IHBhdGggaXMgY2xvc2VkXHJcbiAgICAgICAgaWYgKHBhdGhDbG9zZWQpIHtcclxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgcGF0aENsb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAobGF5ZXIuYXV0b3NpemUpIGZpdFJlY3QoeCwgeSwgdywgaCk7XHJcbiAgICAgICAgY29udGV4dC5yZWN0KHgsIHksIHcsIGgpO1xyXG4gICAgICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsaXAgYWxsIGZ1dHVyZSBkcmF3aW5nIG9wZXJhdGlvbnMgYnkgdGhlIGN1cnJlbnQgcGF0aC4gVGhlIGN1cnJlbnQgcGF0aFxyXG4gICAgICogaXMgaW1wbGljaXRseSBjbG9zZWQuIFRoZSBjdXJyZW50IHBhdGggY2FuIGNvbnRpbnVlIHRvIGJlIHJldXNlZFxyXG4gICAgICogZm9yIG90aGVyIG9wZXJhdGlvbnMgKHN1Y2ggYXMgZmlsbENvbG9yKCkpIGJ1dCBhIG5ldyBwYXRoIHdpbGwgYmUgc3RhcnRlZFxyXG4gICAgICogb25jZSBhIHBhdGggZHJhd2luZyBvcGVyYXRpb24gKHBhdGgoKSBvciByZWN0KCkpIGlzIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xpcCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBTZXQgbmV3IGNsaXBwaW5nIHJlZ2lvblxyXG4gICAgICAgIGNvbnRleHQuY2xpcCgpO1xyXG5cclxuICAgICAgICAvLyBQYXRoIG5vdyBpbXBsaWNpdGx5IGNsb3NlZFxyXG4gICAgICAgIHBhdGhDbG9zZWQgPSB0cnVlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJva2UgdGhlIGN1cnJlbnQgcGF0aCB3aXRoIHRoZSBzcGVjaWZpZWQgY29sb3IuIFRoZSBjdXJyZW50IHBhdGhcclxuICAgICAqIGlzIGltcGxpY2l0bHkgY2xvc2VkLiBUaGUgY3VycmVudCBwYXRoIGNhbiBjb250aW51ZSB0byBiZSByZXVzZWRcclxuICAgICAqIGZvciBvdGhlciBvcGVyYXRpb25zIChzdWNoIGFzIGNsaXAoKSkgYnV0IGEgbmV3IHBhdGggd2lsbCBiZSBzdGFydGVkXHJcbiAgICAgKiBvbmNlIGEgcGF0aCBkcmF3aW5nIG9wZXJhdGlvbiAocGF0aCgpIG9yIHJlY3QoKSkgaXMgdXNlZC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNhcCBUaGUgbGluZSBjYXAgc3R5bGUuIENhbiBiZSBcInJvdW5kXCIsIFwic3F1YXJlXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIG9yIFwiYnV0dFwiLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGpvaW4gVGhlIGxpbmUgam9pbiBzdHlsZS4gQ2FuIGJlIFwicm91bmRcIiwgXCJiZXZlbFwiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgb3IgXCJtaXRlclwiLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzcyBUaGUgbGluZSB0aGlja25lc3MgaW4gcGl4ZWxzLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgVGhlIHJlZCBjb21wb25lbnQgb2YgdGhlIGNvbG9yIHRvIGZpbGwuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZyBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIHRoZSBjb2xvciB0byBmaWxsLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIGJsdWUgY29tcG9uZW50IG9mIHRoZSBjb2xvciB0byBmaWxsLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGFscGhhIGNvbXBvbmVudCBvZiB0aGUgY29sb3IgdG8gZmlsbC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdHJva2VDb2xvciA9IGZ1bmN0aW9uKGNhcCwgam9pbiwgdGhpY2tuZXNzLCByLCBnLCBiLCBhKSB7XHJcblxyXG4gICAgICAgIC8vIFN0cm9rZSB3aXRoIGNvbG9yXHJcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gY2FwO1xyXG4gICAgICAgIGNvbnRleHQubGluZUpvaW4gPSBqb2luO1xyXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGhpY2tuZXNzO1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcInJnYmEoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIsXCIgKyBhLzI1NS4wICsgXCIpXCI7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBQYXRoIG5vdyBpbXBsaWNpdGx5IGNsb3NlZFxyXG4gICAgICAgIHBhdGhDbG9zZWQgPSB0cnVlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxscyB0aGUgY3VycmVudCBwYXRoIHdpdGggdGhlIHNwZWNpZmllZCBjb2xvci4gVGhlIGN1cnJlbnQgcGF0aFxyXG4gICAgICogaXMgaW1wbGljaXRseSBjbG9zZWQuIFRoZSBjdXJyZW50IHBhdGggY2FuIGNvbnRpbnVlIHRvIGJlIHJldXNlZFxyXG4gICAgICogZm9yIG90aGVyIG9wZXJhdGlvbnMgKHN1Y2ggYXMgY2xpcCgpKSBidXQgYSBuZXcgcGF0aCB3aWxsIGJlIHN0YXJ0ZWRcclxuICAgICAqIG9uY2UgYSBwYXRoIGRyYXdpbmcgb3BlcmF0aW9uIChwYXRoKCkgb3IgcmVjdCgpKSBpcyB1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gciBUaGUgcmVkIGNvbXBvbmVudCBvZiB0aGUgY29sb3IgdG8gZmlsbC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBnIFRoZSBncmVlbiBjb21wb25lbnQgb2YgdGhlIGNvbG9yIHRvIGZpbGwuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgYmx1ZSBjb21wb25lbnQgb2YgdGhlIGNvbG9yIHRvIGZpbGwuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgYWxwaGEgY29tcG9uZW50IG9mIHRoZSBjb2xvciB0byBmaWxsLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpbGxDb2xvciA9IGZ1bmN0aW9uKHIsIGcsIGIsIGEpIHtcclxuXHJcbiAgICAgICAgLy8gRmlsbCB3aXRoIGNvbG9yXHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIsXCIgKyBhLzI1NS4wICsgXCIpXCI7XHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gUGF0aCBub3cgaW1wbGljaXRseSBjbG9zZWRcclxuICAgICAgICBwYXRoQ2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Ryb2tlIHRoZSBjdXJyZW50IHBhdGggd2l0aCB0aGUgaW1hZ2Ugd2l0aGluIHRoZSBzcGVjaWZpZWQgbGF5ZXIuIFRoZVxyXG4gICAgICogaW1hZ2UgZGF0YSB3aWxsIGJlIHRpbGVkIGluZmluaXRlbHkgd2l0aGluIHRoZSBzdHJva2UuIFRoZSBjdXJyZW50IHBhdGhcclxuICAgICAqIGlzIGltcGxpY2l0bHkgY2xvc2VkLiBUaGUgY3VycmVudCBwYXRoIGNhbiBjb250aW51ZSB0byBiZSByZXVzZWRcclxuICAgICAqIGZvciBvdGhlciBvcGVyYXRpb25zIChzdWNoIGFzIGNsaXAoKSkgYnV0IGEgbmV3IHBhdGggd2lsbCBiZSBzdGFydGVkXHJcbiAgICAgKiBvbmNlIGEgcGF0aCBkcmF3aW5nIG9wZXJhdGlvbiAocGF0aCgpIG9yIHJlY3QoKSkgaXMgdXNlZC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNhcCBUaGUgbGluZSBjYXAgc3R5bGUuIENhbiBiZSBcInJvdW5kXCIsIFwic3F1YXJlXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIG9yIFwiYnV0dFwiLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGpvaW4gVGhlIGxpbmUgam9pbiBzdHlsZS4gQ2FuIGJlIFwicm91bmRcIiwgXCJiZXZlbFwiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgb3IgXCJtaXRlclwiLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzcyBUaGUgbGluZSB0aGlja25lc3MgaW4gcGl4ZWxzLlxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IHNyY0xheWVyIFRoZSBsYXllciB0byB1c2UgYXMgYSByZXBlYXRpbmcgcGF0dGVyblxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhpbiB0aGUgc3Ryb2tlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0cm9rZUxheWVyID0gZnVuY3Rpb24oY2FwLCBqb2luLCB0aGlja25lc3MsIHNyY0xheWVyKSB7XHJcblxyXG4gICAgICAgIC8vIFN0cm9rZSB3aXRoIGltYWdlIGRhdGFcclxuICAgICAgICBjb250ZXh0LmxpbmVDYXAgPSBjYXA7XHJcbiAgICAgICAgY29udGV4dC5saW5lSm9pbiA9IGpvaW47XHJcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0aGlja25lc3M7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihcclxuICAgICAgICAgICAgc3JjTGF5ZXIuZ2V0Q2FudmFzKCksXHJcbiAgICAgICAgICAgIFwicmVwZWF0XCJcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gUGF0aCBub3cgaW1wbGljaXRseSBjbG9zZWRcclxuICAgICAgICBwYXRoQ2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsbHMgdGhlIGN1cnJlbnQgcGF0aCB3aXRoIHRoZSBpbWFnZSB3aXRoaW4gdGhlIHNwZWNpZmllZCBsYXllci4gVGhlXHJcbiAgICAgKiBpbWFnZSBkYXRhIHdpbGwgYmUgdGlsZWQgaW5maW5pdGVseSB3aXRoaW4gdGhlIHN0cm9rZS4gVGhlIGN1cnJlbnQgcGF0aFxyXG4gICAgICogaXMgaW1wbGljaXRseSBjbG9zZWQuIFRoZSBjdXJyZW50IHBhdGggY2FuIGNvbnRpbnVlIHRvIGJlIHJldXNlZFxyXG4gICAgICogZm9yIG90aGVyIG9wZXJhdGlvbnMgKHN1Y2ggYXMgY2xpcCgpKSBidXQgYSBuZXcgcGF0aCB3aWxsIGJlIHN0YXJ0ZWRcclxuICAgICAqIG9uY2UgYSBwYXRoIGRyYXdpbmcgb3BlcmF0aW9uIChwYXRoKCkgb3IgcmVjdCgpKSBpcyB1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gc3JjTGF5ZXIgVGhlIGxheWVyIHRvIHVzZSBhcyBhIHJlcGVhdGluZyBwYXR0ZXJuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aGluIHRoZSBmaWxsLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpbGxMYXllciA9IGZ1bmN0aW9uKHNyY0xheWVyKSB7XHJcblxyXG4gICAgICAgIC8vIEZpbGwgd2l0aCBpbWFnZSBkYXRhIFxyXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKFxyXG4gICAgICAgICAgICBzcmNMYXllci5nZXRDYW52YXMoKSxcclxuICAgICAgICAgICAgXCJyZXBlYXRcIlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gUGF0aCBub3cgaW1wbGljaXRseSBjbG9zZWRcclxuICAgICAgICBwYXRoQ2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHVzaCBjdXJyZW50IGxheWVyIHN0YXRlIG9udG8gc3RhY2suXHJcbiAgICAgKi9cclxuICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBTYXZlIGN1cnJlbnQgc3RhdGUgb250byBzdGFja1xyXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgIHN0YWNrU2l6ZSsrO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3AgbGF5ZXIgc3RhdGUgb2ZmIHN0YWNrLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvcCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIGN1cnJlbnQgc3RhdGUgZnJvbSBzdGFja1xyXG4gICAgICAgIGlmIChzdGFja1NpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICBzdGFja1NpemUtLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBsYXllciwgY2xlYXJpbmcgdGhlIHN0YWNrLCB0aGUgY3VycmVudCBwYXRoLCBhbmQgYW55IHRyYW5zZm9ybVxyXG4gICAgICogbWF0cml4LlxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIHN0YWNrXHJcbiAgICAgICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIHN0YWNrU2l6ZS0tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzdG9yZSB0byBpbml0aWFsIHN0YXRlXHJcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIHBhdGhcclxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHBhdGhDbG9zZWQgPSBmYWxzZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gYWZmaW5lIHRyYW5zZm9ybSAoZGVmaW5lZCB3aXRoIHNpeCB2YWx1ZXMgZnJvbSB0aGVcclxuICAgICAqIHRyYW5zZm9ybSdzIG1hdHJpeCkuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgdGhpcmQgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZCBUaGUgZm91cnRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGUgVGhlIGZpZnRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGYgVGhlIHNpeHRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShcclxuICAgICAgICAgICAgYSwgYiwgYyxcclxuICAgICAgICAgICAgZCwgZSwgZlxyXG4gICAgICAgICAgLyowLCAwLCAxKi9cclxuICAgICAgICApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIGFmZmluZSB0cmFuc2Zvcm0gKGRlZmluZWQgd2l0aCBzaXggdmFsdWVzIGZyb20gdGhlXHJcbiAgICAgKiB0cmFuc2Zvcm0ncyBtYXRyaXgpLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIHRoaXJkIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVGhlIGZvdXJ0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlIFRoZSBmaWZ0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmIFRoZSBzaXh0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmFuc2Zvcm0gPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0oXHJcbiAgICAgICAgICAgIGEsIGIsIGMsXHJcbiAgICAgICAgICAgIGQsIGUsIGZcclxuICAgICAgICAgIC8qMCwgMCwgMSovXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjaGFubmVsIG1hc2sgZm9yIGZ1dHVyZSBvcGVyYXRpb25zIG9uIHRoaXMgTGF5ZXIuXHJcbiAgICAgKiBcclxuICAgICAqIFRoZSBjaGFubmVsIG1hc2sgaXMgYSBHdWFjYW1vbGUtc3BlY2lmaWMgY29tcG9zaXRpbmcgb3BlcmF0aW9uIGlkZW50aWZpZXJcclxuICAgICAqIHdpdGggYSBzaW5nbGUgYml0IHJlcHJlc2VudGluZyBlYWNoIG9mIGZvdXIgY2hhbm5lbHMgKGluIG9yZGVyKTogc291cmNlXHJcbiAgICAgKiBpbWFnZSB3aGVyZSBkZXN0aW5hdGlvbiB0cmFuc3BhcmVudCwgc291cmNlIHdoZXJlIGRlc3RpbmF0aW9uIG9wYXF1ZSxcclxuICAgICAqIGRlc3RpbmF0aW9uIHdoZXJlIHNvdXJjZSB0cmFuc3BhcmVudCwgYW5kIGRlc3RpbmF0aW9uIHdoZXJlIHNvdXJjZVxyXG4gICAgICogb3BhcXVlLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWFzayBUaGUgY2hhbm5lbCBtYXNrIGZvciBmdXR1cmUgb3BlcmF0aW9ucyBvbiB0aGlzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBMYXllci5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXRDaGFubmVsTWFzayA9IGZ1bmN0aW9uKG1hc2spIHtcclxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvblttYXNrXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtaXRlciBsaW1pdCBmb3Igc3Ryb2tlIG9wZXJhdGlvbnMgdXNpbmcgdGhlIG1pdGVyIGpvaW4uIFRoaXNcclxuICAgICAqIGxpbWl0IGlzIHRoZSBtYXhpbXVtIHJhdGlvIG9mIHRoZSBzaXplIG9mIHRoZSBtaXRlciBqb2luIHRvIHRoZSBzdHJva2VcclxuICAgICAqIHdpZHRoLiBJZiB0aGlzIHJhdGlvIGlzIGV4Y2VlZGVkLCB0aGUgbWl0ZXIgd2lsbCBub3QgYmUgZHJhd24gZm9yIHRoYXRcclxuICAgICAqIGpvaW50IG9mIHRoZSBwYXRoLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgVGhlIG1pdGVyIGxpbWl0IGZvciBzdHJva2Ugb3BlcmF0aW9ucyB1c2luZyB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBtaXRlciBqb2luLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNldE1pdGVyTGltaXQgPSBmdW5jdGlvbihsaW1pdCkge1xyXG4gICAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IGxpbWl0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGNhbnZhcyBkaW1lbnNpb25zXHJcbiAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgLy8gRXhwbGljaXRseSByZW5kZXIgY2FudmFzIGJlbG93IG90aGVyIGVsZW1lbnRzIGluIHRoZSBsYXllciAoc3VjaCBhc1xyXG4gICAgLy8gY2hpbGQgbGF5ZXJzKS4gQ2hyb21lIGFuZCBvdGhlcnMgbWF5IGZhaWwgdG8gcmVuZGVyIGxheWVycyBwcm9wZXJseVxyXG4gICAgLy8gd2l0aG91dCB0aGlzLlxyXG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IC0xO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGFubmVsIG1hc2sgZm9yIHRoZSBjb21wb3NpdGUgb3BlcmF0aW9uIFwicm91dFwiLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkxheWVyLlJPVVQgID0gMHgyO1xyXG5cclxuLyoqXHJcbiAqIENoYW5uZWwgbWFzayBmb3IgdGhlIGNvbXBvc2l0ZSBvcGVyYXRpb24gXCJhdG9wXCIuXHJcbiAqL1xyXG5HdWFjYW1vbGUuTGF5ZXIuQVRPUCAgPSAweDY7XHJcblxyXG4vKipcclxuICogQ2hhbm5lbCBtYXNrIGZvciB0aGUgY29tcG9zaXRlIG9wZXJhdGlvbiBcInhvclwiLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkxheWVyLlhPUiAgID0gMHhBO1xyXG5cclxuLyoqXHJcbiAqIENoYW5uZWwgbWFzayBmb3IgdGhlIGNvbXBvc2l0ZSBvcGVyYXRpb24gXCJyb3ZlclwiLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkxheWVyLlJPVkVSID0gMHhCO1xyXG5cclxuLyoqXHJcbiAqIENoYW5uZWwgbWFzayBmb3IgdGhlIGNvbXBvc2l0ZSBvcGVyYXRpb24gXCJvdmVyXCIuXHJcbiAqL1xyXG5HdWFjYW1vbGUuTGF5ZXIuT1ZFUiAgPSAweEU7XHJcblxyXG4vKipcclxuICogQ2hhbm5lbCBtYXNrIGZvciB0aGUgY29tcG9zaXRlIG9wZXJhdGlvbiBcInBsdXNcIi5cclxuICovXHJcbkd1YWNhbW9sZS5MYXllci5QTFVTICA9IDB4RjtcclxuXHJcbi8qKlxyXG4gKiBDaGFubmVsIG1hc2sgZm9yIHRoZSBjb21wb3NpdGUgb3BlcmF0aW9uIFwicmluXCIuXHJcbiAqIEJld2FyZSB0aGF0IFdlYktpdC1iYXNlZCBicm93c2VycyBtYXkgbGVhdmUgdGhlIGNvbnRlbnRzIG9mIHRoZSBkZXN0aW9uYXRpb25cclxuICogbGF5ZXIgd2hlcmUgdGhlIHNvdXJjZSBsYXllciBpcyB0cmFuc3BhcmVudCwgZGVzcGl0ZSB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzXHJcbiAqIG9wZXJhdGlvbi5cclxuICovXHJcbkd1YWNhbW9sZS5MYXllci5SSU4gICA9IDB4MTtcclxuXHJcbi8qKlxyXG4gKiBDaGFubmVsIG1hc2sgZm9yIHRoZSBjb21wb3NpdGUgb3BlcmF0aW9uIFwiaW5cIi5cclxuICogQmV3YXJlIHRoYXQgV2ViS2l0LWJhc2VkIGJyb3dzZXJzIG1heSBsZWF2ZSB0aGUgY29udGVudHMgb2YgdGhlIGRlc3Rpb25hdGlvblxyXG4gKiBsYXllciB3aGVyZSB0aGUgc291cmNlIGxheWVyIGlzIHRyYW5zcGFyZW50LCBkZXNwaXRlIHRoZSBkZWZpbml0aW9uIG9mIHRoaXNcclxuICogb3BlcmF0aW9uLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkxheWVyLklOICAgID0gMHg0O1xyXG5cclxuLyoqXHJcbiAqIENoYW5uZWwgbWFzayBmb3IgdGhlIGNvbXBvc2l0ZSBvcGVyYXRpb24gXCJvdXRcIi5cclxuICogQmV3YXJlIHRoYXQgV2ViS2l0LWJhc2VkIGJyb3dzZXJzIG1heSBsZWF2ZSB0aGUgY29udGVudHMgb2YgdGhlIGRlc3Rpb25hdGlvblxyXG4gKiBsYXllciB3aGVyZSB0aGUgc291cmNlIGxheWVyIGlzIHRyYW5zcGFyZW50LCBkZXNwaXRlIHRoZSBkZWZpbml0aW9uIG9mIHRoaXNcclxuICogb3BlcmF0aW9uLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkxheWVyLk9VVCAgID0gMHg4O1xyXG5cclxuLyoqXHJcbiAqIENoYW5uZWwgbWFzayBmb3IgdGhlIGNvbXBvc2l0ZSBvcGVyYXRpb24gXCJyYXRvcFwiLlxyXG4gKiBCZXdhcmUgdGhhdCBXZWJLaXQtYmFzZWQgYnJvd3NlcnMgbWF5IGxlYXZlIHRoZSBjb250ZW50cyBvZiB0aGUgZGVzdGlvbmF0aW9uXHJcbiAqIGxheWVyIHdoZXJlIHRoZSBzb3VyY2UgbGF5ZXIgaXMgdHJhbnNwYXJlbnQsIGRlc3BpdGUgdGhlIGRlZmluaXRpb24gb2YgdGhpc1xyXG4gKiBvcGVyYXRpb24uXHJcbiAqL1xyXG5HdWFjYW1vbGUuTGF5ZXIuUkFUT1AgPSAweDk7XHJcblxyXG4vKipcclxuICogQ2hhbm5lbCBtYXNrIGZvciB0aGUgY29tcG9zaXRlIG9wZXJhdGlvbiBcInNyY1wiLlxyXG4gKiBCZXdhcmUgdGhhdCBXZWJLaXQtYmFzZWQgYnJvd3NlcnMgbWF5IGxlYXZlIHRoZSBjb250ZW50cyBvZiB0aGUgZGVzdGlvbmF0aW9uXHJcbiAqIGxheWVyIHdoZXJlIHRoZSBzb3VyY2UgbGF5ZXIgaXMgdHJhbnNwYXJlbnQsIGRlc3BpdGUgdGhlIGRlZmluaXRpb24gb2YgdGhpc1xyXG4gKiBvcGVyYXRpb24uXHJcbiAqL1xyXG5HdWFjYW1vbGUuTGF5ZXIuU1JDICAgPSAweEM7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHNpbmdsZSBwaXhlbCBvZiBpbWFnZSBkYXRhLiBBbGwgY29tcG9uZW50cyBoYXZlIGEgbWluaW11bSB2YWx1ZVxyXG4gKiBvZiAwIGFuZCBhIG1heGltdW0gdmFsdWUgb2YgMjU1LlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIFxyXG4gKiBAcGFyYW0ge051bWJlcn0gciBUaGUgcmVkIGNvbXBvbmVudCBvZiB0aGlzIHBpeGVsLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gZyBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIHRoaXMgcGl4ZWwuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBibHVlIGNvbXBvbmVudCBvZiB0aGlzIHBpeGVsLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgYWxwaGEgY29tcG9uZW50IG9mIHRoaXMgcGl4ZWwuXHJcbiAqL1xyXG5HdWFjYW1vbGUuTGF5ZXIuUGl4ZWwgPSBmdW5jdGlvbihyLCBnLCBiLCBhKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVkIGNvbXBvbmVudCBvZiB0aGlzIHBpeGVsLCB3aGVyZSAwIGlzIHRoZSBtaW5pbXVtIHZhbHVlLFxyXG4gICAgICogYW5kIDI1NSBpcyB0aGUgbWF4aW11bS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWQgICA9IHI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIHRoaXMgcGl4ZWwsIHdoZXJlIDAgaXMgdGhlIG1pbmltdW0gdmFsdWUsXHJcbiAgICAgKiBhbmQgMjU1IGlzIHRoZSBtYXhpbXVtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdyZWVuID0gZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBibHVlIGNvbXBvbmVudCBvZiB0aGlzIHBpeGVsLCB3aGVyZSAwIGlzIHRoZSBtaW5pbXVtIHZhbHVlLFxyXG4gICAgICogYW5kIDI1NSBpcyB0aGUgbWF4aW11bS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5ibHVlICA9IGI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYWxwaGEgY29tcG9uZW50IG9mIHRoaXMgcGl4ZWwsIHdoZXJlIDAgaXMgdGhlIG1pbmltdW0gdmFsdWUsXHJcbiAgICAgKiBhbmQgMjU1IGlzIHRoZSBtYXhpbXVtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmFscGhhID0gYTtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBjcm9zcy1icm93c2VyIG1vdXNlIGV2ZW50cyBmb3IgYSBnaXZlbiBlbGVtZW50LiBUaGUgZXZlbnRzIG9mXHJcbiAqIHRoZSBnaXZlbiBlbGVtZW50IGFyZSBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlZCB3aXRoIGhhbmRsZXJzIHRoYXQgdHJhbnNsYXRlXHJcbiAqIG1vdXNlIGV2ZW50cyBpbnRvIGEgbm9uLWJyb3dzZXItc3BlY2lmaWMgZXZlbnQgcHJvdmlkZWQgYnkgdGhlXHJcbiAqIEd1YWNhbW9sZS5Nb3VzZSBpbnN0YW5jZS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIEVsZW1lbnQgdG8gdXNlIHRvIHByb3ZpZGUgbW91c2UgZXZlbnRzLlxyXG4gKi9cclxuR3VhY2Ftb2xlLk1vdXNlID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLk1vdXNlLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNfbW91c2UgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBtb3VzZW1vdmUgZXZlbnRzIHRvIHJlcXVpcmUgYmVmb3JlIHJlLWVuYWJsaW5nIG1vdXNlXHJcbiAgICAgKiBldmVudCBoYW5kbGluZyBhZnRlciByZWNlaXZpbmcgYSB0b3VjaCBldmVudC5cclxuICAgICAqL1xyXG4gICAgdGhpcy50b3VjaE1vdXNlVGhyZXNob2xkID0gMztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtaW5pbXVtIGFtb3VudCBvZiBwaXhlbHMgc2Nyb2xsZWQgcmVxdWlyZWQgZm9yIGEgc2luZ2xlIHNjcm9sbCBidXR0b25cclxuICAgICAqIGNsaWNrLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjcm9sbFRocmVzaG9sZCA9IDUzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBwaXhlbHMgdG8gc2Nyb2xsIHBlciBsaW5lLlxyXG4gICAgICovXHJcbiAgICB0aGlzLlBJWEVMU19QRVJfTElORSA9IDE4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBwaXhlbHMgdG8gc2Nyb2xsIHBlciBwYWdlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLlBJWEVMU19QRVJfUEFHRSA9IHRoaXMuUElYRUxTX1BFUl9MSU5FICogMTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBtb3VzZSBzdGF0ZS4gVGhlIHByb3BlcnRpZXMgb2YgdGhpcyBzdGF0ZSBhcmUgdXBkYXRlZCB3aGVuXHJcbiAgICAgKiBtb3VzZSBldmVudHMgZmlyZS4gVGhpcyBzdGF0ZSBvYmplY3QgaXMgYWxzbyBwYXNzZWQgaW4gYXMgYSBwYXJhbWV0ZXIgdG9cclxuICAgICAqIHRoZSBoYW5kbGVyIG9mIGFueSBtb3VzZSBldmVudHMuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuTW91c2UuU3RhdGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3IEd1YWNhbW9sZS5Nb3VzZS5TdGF0ZShcclxuICAgICAgICAwLCAwLCBcclxuICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2VcclxuICAgICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgdXNlciBwcmVzc2VzIGEgbW91c2UgYnV0dG9uIGRvd24gb3ZlciB0aGUgZWxlbWVudFxyXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoaXMgR3VhY2Ftb2xlLk1vdXNlLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLk1vdXNlLlN0YXRlfSBzdGF0ZSBUaGUgY3VycmVudCBtb3VzZSBzdGF0ZS5cclxuICAgICAqL1xyXG5cdHRoaXMub25tb3VzZWRvd24gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHVzZXIgcmVsZWFzZXMgYSBtb3VzZSBidXR0b24gZG93biBvdmVyIHRoZSBlbGVtZW50XHJcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBHdWFjYW1vbGUuTW91c2UuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTW91c2UuU3RhdGV9IHN0YXRlIFRoZSBjdXJyZW50IG1vdXNlIHN0YXRlLlxyXG4gICAgICovXHJcblx0dGhpcy5vbm1vdXNldXAgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHVzZXIgbW92ZXMgdGhlIG1vdXNlIG92ZXIgdGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoXHJcbiAgICAgKiB0aGlzIEd1YWNhbW9sZS5Nb3VzZS5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5Nb3VzZS5TdGF0ZX0gc3RhdGUgVGhlIGN1cnJlbnQgbW91c2Ugc3RhdGUuXHJcbiAgICAgKi9cclxuXHR0aGlzLm9ubW91c2Vtb3ZlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIGVsZW1lbnQgYXNzb2NpYXRlZFxyXG4gICAgICogd2l0aCB0aGlzIEd1YWNhbW9sZS5Nb3VzZS5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKi9cclxuXHR0aGlzLm9ubW91c2VvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ291bnRlciBvZiBtb3VzZSBldmVudHMgdG8gaWdub3JlLiBUaGlzIGRlY3JlbWVudGVkIGJ5IG1vdXNlbW92ZSwgYW5kXHJcbiAgICAgKiB3aGlsZSBub24temVybywgbW91c2UgZXZlbnRzIHdpbGwgaGF2ZSBubyBlZmZlY3QuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgaWdub3JlX21vdXNlID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1bXVsYXRpdmUgc2Nyb2xsIGRlbHRhIGFtb3VudC4gVGhpcyB2YWx1ZSBpcyBhY2N1bXVsYXRlZCB0aHJvdWdoIHNjcm9sbFxyXG4gICAgICogZXZlbnRzIGFuZCByZXN1bHRzIGluIHNjcm9sbCBidXR0b24gY2xpY2tzIGlmIGl0IGV4Y2VlZHMgYSBjZXJ0YWluXHJcbiAgICAgKiB0aHJlc2hvbGQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHNjcm9sbF9kZWx0YSA9IDA7XHJcblxyXG4gICAgZnVuY3Rpb24gY2FuY2VsRXZlbnQoZSkge1xyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmxvY2sgY29udGV4dCBtZW51IHNvIHJpZ2h0LWNsaWNrIGdldHMgc2VudCBwcm9wZXJseVxyXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGNhbmNlbEV2ZW50KGUpO1xyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgIGNhbmNlbEV2ZW50KGUpO1xyXG5cclxuICAgICAgICAvLyBJZiBpZ25vcmluZyBldmVudHMsIGRlY3JlbWVudCBjb3VudGVyXHJcbiAgICAgICAgaWYgKGlnbm9yZV9tb3VzZSkge1xyXG4gICAgICAgICAgICBpZ25vcmVfbW91c2UtLTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUuZnJvbUNsaWVudFBvc2l0aW9uKGVsZW1lbnQsIGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHJcbiAgICAgICAgaWYgKGd1YWNfbW91c2Uub25tb3VzZW1vdmUpXHJcbiAgICAgICAgICAgIGd1YWNfbW91c2Uub25tb3VzZW1vdmUoZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUpO1xyXG5cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICBjYW5jZWxFdmVudChlKTtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IGhhbmRsZSBpZiBpZ25vcmluZyBldmVudHNcclxuICAgICAgICBpZiAoaWdub3JlX21vdXNlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHN3aXRjaCAoZS5idXR0b24pIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUubGVmdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUubWlkZGxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBndWFjX21vdXNlLmN1cnJlbnRTdGF0ZS5yaWdodCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChndWFjX21vdXNlLm9ubW91c2Vkb3duKVxyXG4gICAgICAgICAgICBndWFjX21vdXNlLm9ubW91c2Vkb3duKGd1YWNfbW91c2UuY3VycmVudFN0YXRlKTtcclxuXHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgIGNhbmNlbEV2ZW50KGUpO1xyXG5cclxuICAgICAgICAvLyBEbyBub3QgaGFuZGxlIGlmIGlnbm9yaW5nIGV2ZW50c1xyXG4gICAgICAgIGlmIChpZ25vcmVfbW91c2UpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgc3dpdGNoIChlLmJ1dHRvbikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBndWFjX21vdXNlLmN1cnJlbnRTdGF0ZS5sZWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUubWlkZGxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUucmlnaHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGd1YWNfbW91c2Uub25tb3VzZXVwKVxyXG4gICAgICAgICAgICBndWFjX21vdXNlLm9ubW91c2V1cChndWFjX21vdXNlLmN1cnJlbnRTdGF0ZSk7XHJcblxyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgLy8gR2V0IHBhcmVudCBvZiB0aGUgZWxlbWVudCB0aGUgbW91c2UgcG9pbnRlciBpcyBsZWF2aW5nXHJcbiAgICAgICBcdGlmICghZSkgZSA9IHdpbmRvdy5ldmVudDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBtb3VzZW91dCBpcyBkdWUgdG8gYWN0dWFsbHkgTEVBVklORyB0aGUgZWxlbWVudFxyXG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQgfHwgZS50b0VsZW1lbnQ7XHJcbiAgICAgICAgd2hpbGUgKHRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBlbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhbmNlbEV2ZW50KGUpO1xyXG5cclxuICAgICAgICAvLyBSZWxlYXNlIGFsbCBidXR0b25zXHJcbiAgICAgICAgaWYgKGd1YWNfbW91c2UuY3VycmVudFN0YXRlLmxlZnRcclxuICAgICAgICAgICAgfHwgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUubWlkZGxlXHJcbiAgICAgICAgICAgIHx8IGd1YWNfbW91c2UuY3VycmVudFN0YXRlLnJpZ2h0KSB7XHJcblxyXG4gICAgICAgICAgICBndWFjX21vdXNlLmN1cnJlbnRTdGF0ZS5sZWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGd1YWNfbW91c2UuY3VycmVudFN0YXRlLm1pZGRsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBndWFjX21vdXNlLmN1cnJlbnRTdGF0ZS5yaWdodCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGd1YWNfbW91c2Uub25tb3VzZXVwKVxyXG4gICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5vbm1vdXNldXAoZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmlyZSBvbm1vdXNlb3V0IGV2ZW50XHJcbiAgICAgICAgaWYgKGd1YWNfbW91c2Uub25tb3VzZW91dClcclxuICAgICAgICAgICAgZ3VhY19tb3VzZS5vbm1vdXNlb3V0KCk7XHJcblxyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIC8vIE92ZXJyaWRlIHNlbGVjdGlvbiBvbiBtb3VzZSBldmVudCBlbGVtZW50LlxyXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGNhbmNlbEV2ZW50KGUpO1xyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIC8vIElnbm9yZSBhbGwgcGVuZGluZyBtb3VzZSBldmVudHMgd2hlbiB0b3VjaCBldmVudHMgYXJlIHRoZSBhcHBhcmVudCBzb3VyY2VcclxuICAgIGZ1bmN0aW9uIGlnbm9yZVBlbmRpbmdNb3VzZUV2ZW50cygpIHsgaWdub3JlX21vdXNlID0gZ3VhY19tb3VzZS50b3VjaE1vdXNlVGhyZXNob2xkOyB9XHJcblxyXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsICBpZ25vcmVQZW5kaW5nTW91c2VFdmVudHMsIGZhbHNlKTtcclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgaWdub3JlUGVuZGluZ01vdXNlRXZlbnRzLCBmYWxzZSk7XHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAgIGlnbm9yZVBlbmRpbmdNb3VzZUV2ZW50cywgZmFsc2UpO1xyXG5cclxuICAgIC8vIFNjcm9sbCB3aGVlbCBzdXBwb3J0XHJcbiAgICBmdW5jdGlvbiBtb3VzZXdoZWVsX2hhbmRsZXIoZSkge1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgYXBwcm94aW1hdGUgc2Nyb2xsIGFtb3VudCAoaW4gcGl4ZWxzKVxyXG4gICAgICAgIHZhciBkZWx0YSA9IGUuZGVsdGFZIHx8IC1lLndoZWVsRGVsdGFZIHx8IC1lLndoZWVsRGVsdGE7XHJcblxyXG4gICAgICAgIC8vIElmIHN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgc2Nyb2xsIGFtb3VudCwgY29udmVydCB0byBwaXhlbHMgaWYgbm90XHJcbiAgICAgICAgLy8gYWxyZWFkeSBpbiBwaXhlbHNcclxuICAgICAgICBpZiAoZGVsdGEpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIGRlbHRhIHdhcyBsaW5lc1xyXG4gICAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUgPT09IDEpXHJcbiAgICAgICAgICAgICAgICBkZWx0YSA9IGUuZGVsdGFZICogZ3VhY19tb3VzZS5QSVhFTFNfUEVSX0xJTkU7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiBkZWx0YSB3YXMgcGFnZXNcclxuICAgICAgICAgICAgZWxzZSBpZiAoZS5kZWx0YU1vZGUgPT09IDIpXHJcbiAgICAgICAgICAgICAgICBkZWx0YSA9IGUuZGVsdGFZICogZ3VhY19tb3VzZS5QSVhFTFNfUEVSX1BBR0U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgbGVnYWN5IG1vdXNld2hlZWwgZXZlbnQgYW5kIGxpbmUgc2Nyb2xsaW5nXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBkZWx0YSA9IGUuZGV0YWlsICogZ3VhY19tb3VzZS5QSVhFTFNfUEVSX0xJTkU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVXBkYXRlIG92ZXJhbGwgZGVsdGFcclxuICAgICAgICBzY3JvbGxfZGVsdGEgKz0gZGVsdGE7XHJcblxyXG4gICAgICAgIC8vIFVwXHJcbiAgICAgICAgaWYgKHNjcm9sbF9kZWx0YSA8PSAtZ3VhY19tb3VzZS5zY3JvbGxUaHJlc2hvbGQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlcGVhdGVkbHkgY2xpY2sgdGhlIHVwIGJ1dHRvbiB1bnRpbCBpbnN1ZmZpY2llbnQgZGVsdGEgcmVtYWluc1xyXG4gICAgICAgICAgICBkbyB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGd1YWNfbW91c2Uub25tb3VzZWRvd24pIHtcclxuICAgICAgICAgICAgICAgICAgICBndWFjX21vdXNlLmN1cnJlbnRTdGF0ZS51cCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5vbm1vdXNlZG93bihndWFjX21vdXNlLmN1cnJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGd1YWNfbW91c2Uub25tb3VzZXVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUudXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBndWFjX21vdXNlLm9ubW91c2V1cChndWFjX21vdXNlLmN1cnJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsX2RlbHRhICs9IGd1YWNfbW91c2Uuc2Nyb2xsVGhyZXNob2xkO1xyXG5cclxuICAgICAgICAgICAgfSB3aGlsZSAoc2Nyb2xsX2RlbHRhIDw9IC1ndWFjX21vdXNlLnNjcm9sbFRocmVzaG9sZCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXNldCBkZWx0YVxyXG4gICAgICAgICAgICBzY3JvbGxfZGVsdGEgPSAwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvd25cclxuICAgICAgICBpZiAoc2Nyb2xsX2RlbHRhID49IGd1YWNfbW91c2Uuc2Nyb2xsVGhyZXNob2xkKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXBlYXRlZGx5IGNsaWNrIHRoZSBkb3duIGJ1dHRvbiB1bnRpbCBpbnN1ZmZpY2llbnQgZGVsdGEgcmVtYWluc1xyXG4gICAgICAgICAgICBkbyB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGd1YWNfbW91c2Uub25tb3VzZWRvd24pIHtcclxuICAgICAgICAgICAgICAgICAgICBndWFjX21vdXNlLmN1cnJlbnRTdGF0ZS5kb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBndWFjX21vdXNlLm9ubW91c2Vkb3duKGd1YWNfbW91c2UuY3VycmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZ3VhY19tb3VzZS5vbm1vdXNldXApIHtcclxuICAgICAgICAgICAgICAgICAgICBndWFjX21vdXNlLmN1cnJlbnRTdGF0ZS5kb3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5vbm1vdXNldXAoZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNjcm9sbF9kZWx0YSAtPSBndWFjX21vdXNlLnNjcm9sbFRocmVzaG9sZDtcclxuXHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHNjcm9sbF9kZWx0YSA+PSBndWFjX21vdXNlLnNjcm9sbFRocmVzaG9sZCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXNldCBkZWx0YVxyXG4gICAgICAgICAgICBzY3JvbGxfZGVsdGEgPSAwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhbmNlbEV2ZW50KGUpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgbW91c2V3aGVlbF9oYW5kbGVyLCBmYWxzZSk7XHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCAgICAgbW91c2V3aGVlbF9oYW5kbGVyLCBmYWxzZSk7XHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgICAgICAgICAgbW91c2V3aGVlbF9oYW5kbGVyLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIENTUzMgY3Vyc29yIHN0eWxpbmcsIGluY2x1ZGluZyBob3RzcG90XHJcbiAgICAgKiBjb29yZGluYXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHZhciBDU1MzX0NVUlNPUl9TVVBQT1JURUQgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICAvLyBJZiBubyBjdXJzb3IgcHJvcGVydHkgYXQgYWxsLCB0aGVuIG5vIHN1cHBvcnRcclxuICAgICAgICBpZiAoIShcImN1cnNvclwiIGluIGRpdi5zdHlsZSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgc2ltcGxlIDF4MSBQTkdcclxuICAgICAgICAgICAgZGl2LnN0eWxlLmN1cnNvciA9IFwidXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBcIkFRTUFBQUFsMjFiS0FBQUFBMUJNVkVYLy8vK254QnZJXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiQUFBQUNrbEVRVlFJMTJOZ0FBQUFBZ0FCNGlHOE13QUFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgXCJBQUJKUlU1RXJrSmdnZz09KSAwIDAsIGF1dG9cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVmVyaWZ5IGN1cnNvciBwcm9wZXJ0eSBpcyBzZXQgdG8gVVJMIHdpdGggaG90c3BvdFxyXG4gICAgICAgIHJldHVybiAvXFxidXJsXFwoW14oKV0qXFwpXFxzKzBcXHMrMFxcYi8udGVzdChkaXYuc3R5bGUuY3Vyc29yIHx8IFwiXCIpO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBsb2NhbCBtb3VzZSBjdXJzb3IgdG8gdGhlIGdpdmVuIGNhbnZhcywgaGF2aW5nIHRoZSBnaXZlblxyXG4gICAgICogaG90c3BvdCBjb29yZGluYXRlcy4gVGhpcyBhZmZlY3RzIHN0eWxpbmcgb2YgdGhlIGVsZW1lbnQgYmFja2luZyB0aGlzXHJcbiAgICAgKiBHdWFjYW1vbGUuTW91c2Ugb25seSwgYW5kIG1heSBmYWlsIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnQgZm9yXHJcbiAgICAgKiBzZXR0aW5nIHRoZSBtb3VzZSBjdXJzb3IuXHJcbiAgICAgKiBcclxuICAgICAqIElmIHNldHRpbmcgdGhlIGxvY2FsIGN1cnNvciBpcyBkZXNpcmVkLCBpdCBpcyB1cCB0byB0aGUgaW1wbGVtZW50YXRpb25cclxuICAgICAqIHRvIGRvIHNvbWV0aGluZyBlbHNlLCBzdWNoIGFzIHVzZSB0aGUgc29mdHdhcmUgY3Vyc29yIGJ1aWx0IGludG9cclxuICAgICAqIEd1YWNhbW9sZS5EaXNwbGF5LCBpZiB0aGUgbG9jYWwgY3Vyc29yIGNhbm5vdCBiZSBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIFRoZSBjdXJzb3IgaW1hZ2UuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWC1jb29yZGluYXRlIG9mIHRoZSBjdXJzb3IgaG90c3BvdC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZLWNvb3JkaW5hdGUgb2YgdGhlIGN1cnNvciBob3RzcG90LlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgY3Vyc29yIHdhcyBzdWNjZXNzZnVsbHkgc2V0LCBmYWxzZSBpZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgIGN1cnNvciBjb3VsZCBub3QgYmUgc2V0IGZvciBhbnkgcmVhc29uLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNldEN1cnNvciA9IGZ1bmN0aW9uKGNhbnZhcywgeCwgeSkge1xyXG5cclxuICAgICAgICAvLyBBdHRlbXB0IHRvIHNldCB2aWEgQ1NTMyBjdXJzb3Igc3R5bGluZ1xyXG4gICAgICAgIGlmIChDU1MzX0NVUlNPUl9TVVBQT1JURUQpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5jdXJzb3IgPSBcInVybChcIiArIGRhdGFVUkwgKyBcIikgXCIgKyB4ICsgXCIgXCIgKyB5ICsgXCIsIGF1dG9cIjtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHNldHRpbmcgY3Vyc29yIGZhaWxlZFxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTaW1wbGUgY29udGFpbmVyIGZvciBwcm9wZXJ0aWVzIGRlc2NyaWJpbmcgdGhlIHN0YXRlIG9mIGEgbW91c2UuXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggcG9zaXRpb24gb2YgdGhlIG1vdXNlIHBvaW50ZXIgaW4gcGl4ZWxzLlxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBwb3NpdGlvbiBvZiB0aGUgbW91c2UgcG9pbnRlciBpbiBwaXhlbHMuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbGVmdCBXaGV0aGVyIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkLiBcclxuICogQHBhcmFtIHtCb29sZWFufSBtaWRkbGUgV2hldGhlciB0aGUgbWlkZGxlIG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkLiBcclxuICogQHBhcmFtIHtCb29sZWFufSByaWdodCBXaGV0aGVyIHRoZSByaWdodCBtb3VzZSBidXR0b24gaXMgcHJlc3NlZC4gXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdXAgV2hldGhlciB0aGUgdXAgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQgKHRoZSBmb3VydGhcclxuICogICAgICAgICAgICAgICAgICAgICBidXR0b24sIHVzdWFsbHkgcGFydCBvZiBhIHNjcm9sbCB3aGVlbCkuIFxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRvd24gV2hldGhlciB0aGUgZG93biBtb3VzZSBidXR0b24gaXMgcHJlc3NlZCAodGhlIGZpZnRoXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICBidXR0b24sIHVzdWFsbHkgcGFydCBvZiBhIHNjcm9sbCB3aGVlbCkuIFxyXG4gKi9cclxuR3VhY2Ftb2xlLk1vdXNlLlN0YXRlID0gZnVuY3Rpb24oeCwgeSwgbGVmdCwgbWlkZGxlLCByaWdodCwgdXAsIGRvd24pIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIEd1YWNhbW9sZS5Nb3VzZS5TdGF0ZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX3N0YXRlID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IFggcG9zaXRpb24gb2YgdGhlIG1vdXNlIHBvaW50ZXIuXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgWSBwb3NpdGlvbiBvZiB0aGUgbW91c2UgcG9pbnRlci5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgcHJlc3NlZC5cclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgbWlkZGxlIG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgcHJlc3NlZC5cclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pZGRsZSA9IG1pZGRsZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgcHJlc3NlZC5cclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSB1cCBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IHByZXNzZWQuIFRoaXMgaXMgdGhlIGZvdXJ0aFxyXG4gICAgICogbW91c2UgYnV0dG9uLCBhc3NvY2lhdGVkIHdpdGggdXB3YXJkIHNjcm9sbGluZyBvZiB0aGUgbW91c2Ugc2Nyb2xsXHJcbiAgICAgKiB3aGVlbC5cclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnVwID0gdXA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBkb3duIG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgcHJlc3NlZC4gVGhpcyBpcyB0aGUgZmlmdGggXHJcbiAgICAgKiBtb3VzZSBidXR0b24sIGFzc29jaWF0ZWQgd2l0aCBkb3dud2FyZCBzY3JvbGxpbmcgb2YgdGhlIG1vdXNlIHNjcm9sbFxyXG4gICAgICogd2hlZWwuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kb3duID0gZG93bjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIHJlcHJlc2VudGVkIHdpdGhpbiB0aGlzIHN0YXRlIG9iamVjdCBieSB0aGUgZ2l2ZW5cclxuICAgICAqIGVsZW1lbnQgYW5kIGNsaWVudFgvY2xpZW50WSBjb29yZGluYXRlcyAoY29tbW9ubHkgYXZhaWxhYmxlIHdpdGhpbiBldmVudFxyXG4gICAgICogb2JqZWN0cykuIFBvc2l0aW9uIGlzIHRyYW5zbGF0ZWQgZnJvbSBjbGllbnRYL2NsaWVudFkgKHJlbGF0aXZlIHRvXHJcbiAgICAgKiB2aWV3cG9ydCkgdG8gZWxlbWVudC1yZWxhdGl2ZSBjb29yZGluYXRlcy5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRoZSBjb29yZGluYXRlcyBzaG91bGQgYmUgcmVsYXRpdmVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0by5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbGllbnRYIFRoZSBYIGNvb3JkaW5hdGUgdG8gdHJhbnNsYXRlLCB2aWV3cG9ydC1yZWxhdGl2ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbGllbnRZIFRoZSBZIGNvb3JkaW5hdGUgdG8gdHJhbnNsYXRlLCB2aWV3cG9ydC1yZWxhdGl2ZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5mcm9tQ2xpZW50UG9zaXRpb24gPSBmdW5jdGlvbihlbGVtZW50LCBjbGllbnRYLCBjbGllbnRZKSB7XHJcbiAgICBcclxuICAgICAgICBndWFjX3N0YXRlLnggPSBjbGllbnRYIC0gZWxlbWVudC5vZmZzZXRMZWZ0O1xyXG4gICAgICAgIGd1YWNfc3RhdGUueSA9IGNsaWVudFkgLSBlbGVtZW50Lm9mZnNldFRvcDtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBpcyBhbGwgSlVTVCBzbyB3ZSBjYW4gZ2V0IHRoZSBtb3VzZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGVsZW1lbnRcclxuICAgICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiAhKHBhcmVudCA9PT0gZG9jdW1lbnQuYm9keSkpIHtcclxuICAgICAgICAgICAgZ3VhY19zdGF0ZS54IC09IHBhcmVudC5vZmZzZXRMZWZ0IC0gcGFyZW50LnNjcm9sbExlZnQ7XHJcbiAgICAgICAgICAgIGd1YWNfc3RhdGUueSAtPSBwYXJlbnQub2Zmc2V0VG9wICAtIHBhcmVudC5zY3JvbGxUb3A7XHJcblxyXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQub2Zmc2V0UGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRWxlbWVudCB1bHRpbWF0ZWx5IGRlcGVuZHMgb24gcG9zaXRpb25pbmcgd2l0aGluIGRvY3VtZW50IGJvZHksXHJcbiAgICAgICAgLy8gdGFrZSBkb2N1bWVudCBzY3JvbGwgaW50byBhY2NvdW50LiBcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBkb2N1bWVudFNjcm9sbExlZnQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XHJcbiAgICAgICAgICAgIHZhciBkb2N1bWVudFNjcm9sbFRvcCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XHJcblxyXG4gICAgICAgICAgICBndWFjX3N0YXRlLnggLT0gcGFyZW50Lm9mZnNldExlZnQgLSBkb2N1bWVudFNjcm9sbExlZnQ7XHJcbiAgICAgICAgICAgIGd1YWNfc3RhdGUueSAtPSBwYXJlbnQub2Zmc2V0VG9wICAtIGRvY3VtZW50U2Nyb2xsVG9wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBjcm9zcy1icm93c2VyIHJlbGF0aXZlIHRvdWNoIGV2ZW50IHRyYW5zbGF0aW9uIGZvciBhIGdpdmVuIGVsZW1lbnQuXHJcbiAqIFxyXG4gKiBUb3VjaCBldmVudHMgYXJlIHRyYW5zbGF0ZWQgaW50byBtb3VzZSBldmVudHMgYXMgaWYgdGhlIHRvdWNoZXMgb2NjdXJyZWRcclxuICogb24gYSB0b3VjaHBhZCAoZHJhZyB0byBwdXNoIHRoZSBtb3VzZSBwb2ludGVyLCB0YXAgdG8gY2xpY2spLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgRWxlbWVudCB0byB1c2UgdG8gcHJvdmlkZSB0b3VjaCBldmVudHMuXHJcbiAqL1xyXG5HdWFjYW1vbGUuTW91c2UuVG91Y2hwYWQgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuTW91c2UuVG91Y2hwYWQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY190b3VjaHBhZCA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGlzdGFuY2UgYSB0d28tZmluZ2VyIHRvdWNoIG11c3QgbW92ZSBwZXIgc2Nyb2xsd2hlZWwgZXZlbnQsIGluXHJcbiAgICAgKiBwaXhlbHMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2Nyb2xsVGhyZXNob2xkID0gMjAgKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIGEgdG91Y2ggdG8gZW5kIGZvciB0aGVcclxuICAgICAqIGdlc3R1cmUgdG8gYmUgY29uc2lkZXJlZCBhIGNsaWNrLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaWNrVGltaW5nVGhyZXNob2xkID0gMjUwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHBpeGVscyB0byBhbGxvdyBhIHRvdWNoIHRvIG1vdmUgZm9yIHRoZSBnZXN0dXJlIHRvXHJcbiAgICAgKiBiZSBjb25zaWRlcmVkIGEgY2xpY2suXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xpY2tNb3ZlVGhyZXNob2xkID0gMTAgKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBtb3VzZSBzdGF0ZS4gVGhlIHByb3BlcnRpZXMgb2YgdGhpcyBzdGF0ZSBhcmUgdXBkYXRlZCB3aGVuXHJcbiAgICAgKiBtb3VzZSBldmVudHMgZmlyZS4gVGhpcyBzdGF0ZSBvYmplY3QgaXMgYWxzbyBwYXNzZWQgaW4gYXMgYSBwYXJhbWV0ZXIgdG9cclxuICAgICAqIHRoZSBoYW5kbGVyIG9mIGFueSBtb3VzZSBldmVudHMuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuTW91c2UuU3RhdGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3IEd1YWNhbW9sZS5Nb3VzZS5TdGF0ZShcclxuICAgICAgICAwLCAwLCBcclxuICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2VcclxuICAgICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciBhIG1vdXNlIGJ1dHRvbiBpcyBlZmZlY3RpdmVseSBwcmVzc2VkLiBUaGlzIGNhbiBoYXBwZW5cclxuICAgICAqIGFzIHBhcnQgb2YgYSBcImNsaWNrXCIgZ2VzdHVyZSBpbml0aWF0ZWQgYnkgdGhlIHVzZXIgYnkgdGFwcGluZyBvbmVcclxuICAgICAqIG9yIG1vcmUgZmluZ2VycyBvdmVyIHRoZSB0b3VjaHBhZCBlbGVtZW50LCBhcyBwYXJ0IG9mIGEgXCJzY3JvbGxcIlxyXG4gICAgICogZ2VzdHVyZSBpbml0aWF0ZWQgYnkgZHJhZ2dpbmcgdHdvIGZpbmdlcnMgdXAgb3IgZG93biwgZXRjLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLk1vdXNlLlN0YXRlfSBzdGF0ZSBUaGUgY3VycmVudCBtb3VzZSBzdGF0ZS5cclxuICAgICAqL1xyXG5cdHRoaXMub25tb3VzZWRvd24gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgYSBtb3VzZSBidXR0b24gaXMgZWZmZWN0aXZlbHkgcmVsZWFzZWQuIFRoaXMgY2FuIGhhcHBlblxyXG4gICAgICogYXMgcGFydCBvZiBhIFwiY2xpY2tcIiBnZXN0dXJlIGluaXRpYXRlZCBieSB0aGUgdXNlciBieSB0YXBwaW5nIG9uZVxyXG4gICAgICogb3IgbW9yZSBmaW5nZXJzIG92ZXIgdGhlIHRvdWNocGFkIGVsZW1lbnQsIGFzIHBhcnQgb2YgYSBcInNjcm9sbFwiXHJcbiAgICAgKiBnZXN0dXJlIGluaXRpYXRlZCBieSBkcmFnZ2luZyB0d28gZmluZ2VycyB1cCBvciBkb3duLCBldGMuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTW91c2UuU3RhdGV9IHN0YXRlIFRoZSBjdXJyZW50IG1vdXNlIHN0YXRlLlxyXG4gICAgICovXHJcblx0dGhpcy5vbm1vdXNldXAgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHVzZXIgbW92ZXMgdGhlIG1vdXNlIGJ5IGRyYWdnaW5nIHRoZWlyIGZpbmdlciBvdmVyXHJcbiAgICAgKiB0aGUgdG91Y2hwYWQgZWxlbWVudC5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5Nb3VzZS5TdGF0ZX0gc3RhdGUgVGhlIGN1cnJlbnQgbW91c2Ugc3RhdGUuXHJcbiAgICAgKi9cclxuXHR0aGlzLm9ubW91c2Vtb3ZlID0gbnVsbDtcclxuXHJcbiAgICB2YXIgdG91Y2hfY291bnQgPSAwO1xyXG4gICAgdmFyIGxhc3RfdG91Y2hfeCA9IDA7XHJcbiAgICB2YXIgbGFzdF90b3VjaF95ID0gMDtcclxuICAgIHZhciBsYXN0X3RvdWNoX3RpbWUgPSAwO1xyXG4gICAgdmFyIHBpeGVsc19tb3ZlZCA9IDA7XHJcblxyXG4gICAgdmFyIHRvdWNoX2J1dHRvbnMgPSB7XHJcbiAgICAgICAgMTogXCJsZWZ0XCIsXHJcbiAgICAgICAgMjogXCJyaWdodFwiLFxyXG4gICAgICAgIDM6IFwibWlkZGxlXCJcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGdlc3R1cmVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcclxuICAgIHZhciBjbGlja19yZWxlYXNlX3RpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIC8vIElmIHdlJ3JlIGhhbmRsaW5nIGEgZ2VzdHVyZSBBTkQgdGhpcyBpcyB0aGUgbGFzdCB0b3VjaFxyXG4gICAgICAgIGlmIChnZXN0dXJlX2luX3Byb2dyZXNzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgY29ycmVzcG9uZGluZyBtb3VzZSBidXR0b25cclxuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IHRvdWNoX2J1dHRvbnNbdG91Y2hfY291bnRdO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgbW91c2UgYWxyZWFkeSBkb3duLCByZWxlYXNlIGFuYWQgY2xlYXIgdGltZW91dFxyXG4gICAgICAgICAgICBpZiAoZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGVbYnV0dG9uXSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpcmUgYnV0dG9uIHVwIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZVtidXR0b25dID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3VhY190b3VjaHBhZC5vbm1vdXNldXApXHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY190b3VjaHBhZC5vbm1vdXNldXAoZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXQsIGlmIHNldFxyXG4gICAgICAgICAgICAgICAgaWYgKGNsaWNrX3JlbGVhc2VfdGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY2xpY2tfcmVsZWFzZV90aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICBjbGlja19yZWxlYXNlX3RpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgc2luZ2xlIHRhcCBkZXRlY3RlZCAoYmFzZWQgb24gdGltZSBhbmQgZGlzdGFuY2UpXHJcbiAgICAgICAgICAgIGlmICh0aW1lIC0gbGFzdF90b3VjaF90aW1lIDw9IGd1YWNfdG91Y2hwYWQuY2xpY2tUaW1pbmdUaHJlc2hvbGRcclxuICAgICAgICAgICAgICAgICAgICAmJiBwaXhlbHNfbW92ZWQgPCBndWFjX3RvdWNocGFkLmNsaWNrTW92ZVRocmVzaG9sZCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpcmUgYnV0dG9uIGRvd24gZXZlbnRcclxuICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlW2J1dHRvbl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGd1YWNfdG91Y2hwYWQub25tb3VzZWRvd24pXHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY190b3VjaHBhZC5vbm1vdXNlZG93bihndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGVsYXkgbW91c2UgdXAgLSBtb3VzZSB1cCBzaG91bGQgYmUgY2FuY2VsZWQgaWZcclxuICAgICAgICAgICAgICAgIC8vIHRvdWNoc3RhcnQgd2l0aGluIHRpbWVvdXQuXHJcbiAgICAgICAgICAgICAgICBjbGlja19yZWxlYXNlX3RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIGJ1dHRvbiB1cCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlW2J1dHRvbl0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3VhY190b3VjaHBhZC5vbm1vdXNldXApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQub25tb3VzZXVwKGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXN0dXJlIG5vdyBvdmVyXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VzdHVyZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIH0sIGd1YWNfdG91Y2hwYWQuY2xpY2tUaW1pbmdUaHJlc2hvbGQpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgdG8gc2VlIGlmIHRoaXMgaXMgYSBjbGljaywgc3RvcCBnZXN0dXJlXHJcbiAgICAgICAgICAgIGlmICghY2xpY2tfcmVsZWFzZV90aW1lb3V0KVxyXG4gICAgICAgICAgICAgICAgZ2VzdHVyZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIC8vIFRyYWNrIG51bWJlciBvZiB0b3VjaGVzLCBidXQgbm8gbW9yZSB0aGFuIHRocmVlXHJcbiAgICAgICAgdG91Y2hfY291bnQgPSBNYXRoLm1pbihlLnRvdWNoZXMubGVuZ3RoLCAzKTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgdGltZW91dCwgaWYgc2V0XHJcbiAgICAgICAgaWYgKGNsaWNrX3JlbGVhc2VfdGltZW91dCkge1xyXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNsaWNrX3JlbGVhc2VfdGltZW91dCk7XHJcbiAgICAgICAgICAgIGNsaWNrX3JlbGVhc2VfdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWNvcmQgaW5pdGlhbCB0b3VjaCBsb2NhdGlvbiBhbmQgdGltZSBmb3IgdG91Y2ggbW92ZW1lbnRcclxuICAgICAgICAvLyBhbmQgdGFwIGdlc3R1cmVzXHJcbiAgICAgICAgaWYgKCFnZXN0dXJlX2luX3Byb2dyZXNzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTdG9wIG1vdXNlIGV2ZW50cyB3aGlsZSB0b3VjaGluZ1xyXG4gICAgICAgICAgICBnZXN0dXJlX2luX3Byb2dyZXNzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlY29yZCB0b3VjaCBsb2NhdGlvbiBhbmQgdGltZVxyXG4gICAgICAgICAgICB2YXIgc3RhcnRpbmdfdG91Y2ggPSBlLnRvdWNoZXNbMF07XHJcbiAgICAgICAgICAgIGxhc3RfdG91Y2hfeCA9IHN0YXJ0aW5nX3RvdWNoLmNsaWVudFg7XHJcbiAgICAgICAgICAgIGxhc3RfdG91Y2hfeSA9IHN0YXJ0aW5nX3RvdWNoLmNsaWVudFk7XHJcbiAgICAgICAgICAgIGxhc3RfdG91Y2hfdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICBwaXhlbHNfbW92ZWQgPSAwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IGNoYW5nZSBpbiB0b3VjaCBsb2NhdGlvblxyXG4gICAgICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXTtcclxuICAgICAgICB2YXIgZGVsdGFfeCA9IHRvdWNoLmNsaWVudFggLSBsYXN0X3RvdWNoX3g7XHJcbiAgICAgICAgdmFyIGRlbHRhX3kgPSB0b3VjaC5jbGllbnRZIC0gbGFzdF90b3VjaF95O1xyXG5cclxuICAgICAgICAvLyBUcmFjayBwaXhlbHMgbW92ZWRcclxuICAgICAgICBwaXhlbHNfbW92ZWQgKz0gTWF0aC5hYnMoZGVsdGFfeCkgKyBNYXRoLmFicyhkZWx0YV95KTtcclxuXHJcbiAgICAgICAgLy8gSWYgb25seSBvbmUgdG91Y2ggaW52b2x2ZWQsIHRoaXMgaXMgbW91c2UgbW92ZVxyXG4gICAgICAgIGlmICh0b3VjaF9jb3VudCA9PT0gMSkge1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2UgdmVsb2NpdHkgaW4gTWFuaGF0dGVuIHBpeGVscyBwZXIgbWlsbGlzZWNvbmRcclxuICAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gcGl4ZWxzX21vdmVkIC8gKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbGFzdF90b3VjaF90aW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNjYWxlIG1vdXNlIG1vdmVtZW50IHJlbGF0aXZlIHRvIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDEgKyB2ZWxvY2l0eTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBtb3VzZSBsb2NhdGlvblxyXG4gICAgICAgICAgICBndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZS54ICs9IGRlbHRhX3gqc2NhbGU7XHJcbiAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlLnkgKz0gZGVsdGFfeSpzY2FsZTtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZXZlbnQgbW91c2UgZnJvbSBsZWF2aW5nIHNjcmVlblxyXG5cclxuICAgICAgICAgICAgaWYgKGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlLnggPCAwKVxyXG4gICAgICAgICAgICAgICAgZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGUueCA9IDA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlLnggPj0gZWxlbWVudC5vZmZzZXRXaWR0aClcclxuICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlLnggPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gMTtcclxuXHJcbiAgICAgICAgICAgIGlmIChndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZS55IDwgMClcclxuICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlLnkgPSAwO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZS55ID49IGVsZW1lbnQub2Zmc2V0SGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGUueSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gMTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpcmUgbW92ZW1lbnQgZXZlbnQsIGlmIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKGd1YWNfdG91Y2hwYWQub25tb3VzZW1vdmUpXHJcbiAgICAgICAgICAgICAgICBndWFjX3RvdWNocGFkLm9ubW91c2Vtb3ZlKGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0b3VjaCBsb2NhdGlvblxyXG4gICAgICAgICAgICBsYXN0X3RvdWNoX3ggPSB0b3VjaC5jbGllbnRYO1xyXG4gICAgICAgICAgICBsYXN0X3RvdWNoX3kgPSB0b3VjaC5jbGllbnRZO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEludGVycHJldCB0d28tZmluZ2VyIHN3aXBlIGFzIHNjcm9sbHdoZWVsXHJcbiAgICAgICAgZWxzZSBpZiAodG91Y2hfY291bnQgPT09IDIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGNoYW5nZSBpbiBsb2NhdGlvbiBwYXNzZXMgdGhyZXNob2xkIGZvciBzY3JvbGxcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhX3kpID49IGd1YWNfdG91Y2hwYWQuc2Nyb2xsVGhyZXNob2xkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGVjaWRlIGJ1dHRvbiBiYXNlZCBvbiBZIG1vdmVtZW50IGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbjtcclxuICAgICAgICAgICAgICAgIGlmIChkZWx0YV95ID4gMCkgYnV0dG9uID0gXCJkb3duXCI7XHJcbiAgICAgICAgICAgICAgICBlbHNlICAgICAgICAgICAgIGJ1dHRvbiA9IFwidXBcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJlIGJ1dHRvbiBkb3duIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZVtidXR0b25dID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChndWFjX3RvdWNocGFkLm9ubW91c2Vkb3duKVxyXG4gICAgICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQub25tb3VzZWRvd24oZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpcmUgYnV0dG9uIHVwIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZVtidXR0b25dID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3VhY190b3VjaHBhZC5vbm1vdXNldXApXHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY190b3VjaHBhZC5vbm1vdXNldXAoZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIHRvdWNoIGxvY2F0aW9uIGFmdGVyIGEgc2Nyb2xsIGhhcyBiZWVuXHJcbiAgICAgICAgICAgICAgICAvLyBkZXRlY3RlZFxyXG4gICAgICAgICAgICAgICAgbGFzdF90b3VjaF94ID0gdG91Y2guY2xpZW50WDtcclxuICAgICAgICAgICAgICAgIGxhc3RfdG91Y2hfeSA9IHRvdWNoLmNsaWVudFk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGNyb3NzLWJyb3dzZXIgYWJzb2x1dGUgdG91Y2ggZXZlbnQgdHJhbnNsYXRpb24gZm9yIGEgZ2l2ZW4gZWxlbWVudC5cclxuICpcclxuICogVG91Y2ggZXZlbnRzIGFyZSB0cmFuc2xhdGVkIGludG8gbW91c2UgZXZlbnRzIGFzIGlmIHRoZSB0b3VjaGVzIG9jY3VycmVkXHJcbiAqIG9uIGEgdG91Y2hzY3JlZW4gKHRhcHBpbmcgYW55d2hlcmUgb24gdGhlIHNjcmVlbiBjbGlja3MgYXQgdGhhdCBwb2ludCxcclxuICogbG9uZy1wcmVzcyB0byByaWdodC1jbGljaykuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIEVsZW1lbnQgdG8gdXNlIHRvIHByb3ZpZGUgdG91Y2ggZXZlbnRzLlxyXG4gKi9cclxuR3VhY2Ftb2xlLk1vdXNlLlRvdWNoc2NyZWVuID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLk1vdXNlLlRvdWNoc2NyZWVuLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNfdG91Y2hzY3JlZW4gPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBhIGdlc3R1cmUgaXMga25vd24gdG8gYmUgaW4gcHJvZ3Jlc3MuIElmIGZhbHNlLCB0b3VjaCBldmVudHNcclxuICAgICAqIHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ2VzdHVyZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0YXJ0IFggbG9jYXRpb24gb2YgYSBnZXN0dXJlLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGdlc3R1cmVfc3RhcnRfeCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3RhcnQgWSBsb2NhdGlvbiBvZiBhIGdlc3R1cmUuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ2VzdHVyZV9zdGFydF95ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0aW1lb3V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZGVsYXllZCwgY2FuY2VsbGFibGUgY2xpY2sgcmVsZWFzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgY2xpY2tfcmVsZWFzZV90aW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0aW1lb3V0IGFzc29jaWF0ZWQgd2l0aCBsb25nLXByZXNzIGZvciByaWdodCBjbGljay5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgbG9uZ19wcmVzc190aW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkaXN0YW5jZSBhIHR3by1maW5nZXIgdG91Y2ggbXVzdCBtb3ZlIHBlciBzY3JvbGx3aGVlbCBldmVudCwgaW5cclxuICAgICAqIHBpeGVscy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zY3JvbGxUaHJlc2hvbGQgPSAyMCAqICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgYSB0b3VjaCB0byBlbmQgZm9yIHRoZVxyXG4gICAgICogZ2VzdHVyZSB0byBiZSBjb25zaWRlcmVkIGEgY2xpY2suXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xpY2tUaW1pbmdUaHJlc2hvbGQgPSAyNTA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcGl4ZWxzIHRvIGFsbG93IGEgdG91Y2ggdG8gbW92ZSBmb3IgdGhlIGdlc3R1cmUgdG9cclxuICAgICAqIGJlIGNvbnNpZGVyZWQgYSBjbGljay5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jbGlja01vdmVUaHJlc2hvbGQgPSAxNiAqICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbW91bnQgb2YgdGltZSBhIHByZXNzIG11c3QgYmUgaGVsZCBmb3IgbG9uZyBwcmVzcyB0byBiZVxyXG4gICAgICogZGV0ZWN0ZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMubG9uZ1ByZXNzVGhyZXNob2xkID0gNTAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgbW91c2Ugc3RhdGUuIFRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgc3RhdGUgYXJlIHVwZGF0ZWQgd2hlblxyXG4gICAgICogbW91c2UgZXZlbnRzIGZpcmUuIFRoaXMgc3RhdGUgb2JqZWN0IGlzIGFsc28gcGFzc2VkIGluIGFzIGEgcGFyYW1ldGVyIHRvXHJcbiAgICAgKiB0aGUgaGFuZGxlciBvZiBhbnkgbW91c2UgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuTW91c2UuU3RhdGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3IEd1YWNhbW9sZS5Nb3VzZS5TdGF0ZShcclxuICAgICAgICAwLCAwLFxyXG4gICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZVxyXG4gICAgKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIGEgbW91c2UgYnV0dG9uIGlzIGVmZmVjdGl2ZWx5IHByZXNzZWQuIFRoaXMgY2FuIGhhcHBlblxyXG4gICAgICogYXMgcGFydCBvZiBhIFwibW91c2Vkb3duXCIgZ2VzdHVyZSBpbml0aWF0ZWQgYnkgdGhlIHVzZXIgYnkgcHJlc3Npbmcgb25lXHJcbiAgICAgKiBmaW5nZXIgb3ZlciB0aGUgdG91Y2hzY3JlZW4gZWxlbWVudCwgYXMgcGFydCBvZiBhIFwic2Nyb2xsXCIgZ2VzdHVyZVxyXG4gICAgICogaW5pdGlhdGVkIGJ5IGRyYWdnaW5nIHR3byBmaW5nZXJzIHVwIG9yIGRvd24sIGV0Yy5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLk1vdXNlLlN0YXRlfSBzdGF0ZSBUaGUgY3VycmVudCBtb3VzZSBzdGF0ZS5cclxuICAgICAqL1xyXG5cdHRoaXMub25tb3VzZWRvd24gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgYSBtb3VzZSBidXR0b24gaXMgZWZmZWN0aXZlbHkgcmVsZWFzZWQuIFRoaXMgY2FuIGhhcHBlblxyXG4gICAgICogYXMgcGFydCBvZiBhIFwibW91c2V1cFwiIGdlc3R1cmUgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyIGJ5IHJlbW92aW5nIHRoZVxyXG4gICAgICogZmluZ2VyIHByZXNzZWQgYWdhaW5zdCB0aGUgdG91Y2hzY3JlZW4gZWxlbWVudCwgb3IgYXMgcGFydCBvZiBhIFwic2Nyb2xsXCJcclxuICAgICAqIGdlc3R1cmUgaW5pdGlhdGVkIGJ5IGRyYWdnaW5nIHR3byBmaW5nZXJzIHVwIG9yIGRvd24sIGV0Yy5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLk1vdXNlLlN0YXRlfSBzdGF0ZSBUaGUgY3VycmVudCBtb3VzZSBzdGF0ZS5cclxuICAgICAqL1xyXG5cdHRoaXMub25tb3VzZXVwID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSB1c2VyIG1vdmVzIHRoZSBtb3VzZSBieSBkcmFnZ2luZyB0aGVpciBmaW5nZXIgb3ZlclxyXG4gICAgICogdGhlIHRvdWNoc2NyZWVuIGVsZW1lbnQuIE5vdGUgdGhhdCB1bmxpa2UgR3VhY2Ftb2xlLk1vdXNlLlRvdWNocGFkLFxyXG4gICAgICogZHJhZ2dpbmcgYSBmaW5nZXIgb3ZlciB0aGUgdG91Y2hzY3JlZW4gZWxlbWVudCB3aWxsIGFsd2F5cyBjYXVzZVxyXG4gICAgICogdGhlIG1vdXNlIGJ1dHRvbiB0byBiZSBlZmZlY3RpdmVseSBkb3duLCBhcyBpZiBjbGlja2luZy1hbmQtZHJhZ2dpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5Nb3VzZS5TdGF0ZX0gc3RhdGUgVGhlIGN1cnJlbnQgbW91c2Ugc3RhdGUuXHJcbiAgICAgKi9cclxuXHR0aGlzLm9ubW91c2Vtb3ZlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByZXNzZXMgdGhlIGdpdmVuIG1vdXNlIGJ1dHRvbiwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBwcmVzc2VkLiBWYWxpZFxyXG4gICAgICogYnV0dG9uIHZhbHVlcyBhcmUgXCJsZWZ0XCIsIFwibWlkZGxlXCIsIFwicmlnaHRcIiwgXCJ1cFwiLCBhbmQgXCJkb3duXCIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBidXR0b24gVGhlIG1vdXNlIGJ1dHRvbiB0byBwcmVzcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHJlc3NfYnV0dG9uKGJ1dHRvbikge1xyXG4gICAgICAgIGlmICghZ3VhY190b3VjaHNjcmVlbi5jdXJyZW50U3RhdGVbYnV0dG9uXSkge1xyXG4gICAgICAgICAgICBndWFjX3RvdWNoc2NyZWVuLmN1cnJlbnRTdGF0ZVtidXR0b25dID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGd1YWNfdG91Y2hzY3JlZW4ub25tb3VzZWRvd24pXHJcbiAgICAgICAgICAgICAgICBndWFjX3RvdWNoc2NyZWVuLm9ubW91c2Vkb3duKGd1YWNfdG91Y2hzY3JlZW4uY3VycmVudFN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gbW91c2UgYnV0dG9uLCBpZiBpdCBpc24ndCBhbHJlYWR5IHJlbGVhc2VkLiBWYWxpZFxyXG4gICAgICogYnV0dG9uIHZhbHVlcyBhcmUgXCJsZWZ0XCIsIFwibWlkZGxlXCIsIFwicmlnaHRcIiwgXCJ1cFwiLCBhbmQgXCJkb3duXCIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBidXR0b24gVGhlIG1vdXNlIGJ1dHRvbiB0byByZWxlYXNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZWxlYXNlX2J1dHRvbihidXR0b24pIHtcclxuICAgICAgICBpZiAoZ3VhY190b3VjaHNjcmVlbi5jdXJyZW50U3RhdGVbYnV0dG9uXSkge1xyXG4gICAgICAgICAgICBndWFjX3RvdWNoc2NyZWVuLmN1cnJlbnRTdGF0ZVtidXR0b25dID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChndWFjX3RvdWNoc2NyZWVuLm9ubW91c2V1cClcclxuICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hzY3JlZW4ub25tb3VzZXVwKGd1YWNfdG91Y2hzY3JlZW4uY3VycmVudFN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGlja3MgKHByZXNzZXMgYW5kIHJlbGVhc2VzKSB0aGUgZ2l2ZW4gbW91c2UgYnV0dG9uLiBWYWxpZCBidXR0b25cclxuICAgICAqIHZhbHVlcyBhcmUgXCJsZWZ0XCIsIFwibWlkZGxlXCIsIFwicmlnaHRcIiwgXCJ1cFwiLCBhbmQgXCJkb3duXCIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBidXR0b24gVGhlIG1vdXNlIGJ1dHRvbiB0byBjbGljay5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2xpY2tfYnV0dG9uKGJ1dHRvbikge1xyXG4gICAgICAgIHByZXNzX2J1dHRvbihidXR0b24pO1xyXG4gICAgICAgIHJlbGVhc2VfYnV0dG9uKGJ1dHRvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgbW91c2UgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLiBUaGVzZSBjb29yZGluYXRlcyBtdXN0IGJlXHJcbiAgICAgKiByZWxhdGl2ZSB0byB0aGUgYnJvd3NlciB3aW5kb3csIGFzIHRoZXkgd2lsbCBiZSB0cmFuc2xhdGVkIGJhc2VkIG9uXHJcbiAgICAgKiB0aGUgdG91Y2ggZXZlbnQgdGFyZ2V0J3MgbG9jYXRpb24gd2l0aGluIHRoZSBicm93c2VyIHdpbmRvdy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbW91c2UgcG9pbnRlci5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIG1vdXNlIHBvaW50ZXIuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1vdmVfbW91c2UoeCwgeSkge1xyXG4gICAgICAgIGd1YWNfdG91Y2hzY3JlZW4uY3VycmVudFN0YXRlLmZyb21DbGllbnRQb3NpdGlvbihlbGVtZW50LCB4LCB5KTtcclxuICAgICAgICBpZiAoZ3VhY190b3VjaHNjcmVlbi5vbm1vdXNlbW92ZSlcclxuICAgICAgICAgICAgZ3VhY190b3VjaHNjcmVlbi5vbm1vdXNlbW92ZShndWFjX3RvdWNoc2NyZWVuLmN1cnJlbnRTdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIHRvdWNoIGV2ZW50IGV4Y2VlZHMgdGhlIG1vdmVtZW50IHRocmVzaG9sZCBmb3JcclxuICAgICAqIGNsaWNraW5nLCBiYXNlZCBvbiB3aGVyZSB0aGUgdG91Y2ggZ2VzdHVyZSBiZWdhbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlIFRoZSB0b3VjaCBldmVudCB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIG1vdmVtZW50IHRocmVzaG9sZCBpcyBleGNlZWRlZCwgZmFsc2VcclxuICAgICAqICAgICAgICAgICAgICAgICAgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmluZ2VyX21vdmVkKGUpIHtcclxuICAgICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF0gfHwgZS5jaGFuZ2VkVG91Y2hlc1swXTtcclxuICAgICAgICB2YXIgZGVsdGFfeCA9IHRvdWNoLmNsaWVudFggLSBnZXN0dXJlX3N0YXJ0X3g7XHJcbiAgICAgICAgdmFyIGRlbHRhX3kgPSB0b3VjaC5jbGllbnRZIC0gZ2VzdHVyZV9zdGFydF95O1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZGVsdGFfeCpkZWx0YV94ICsgZGVsdGFfeSpkZWx0YV95KSA+PSBndWFjX3RvdWNoc2NyZWVuLmNsaWNrTW92ZVRocmVzaG9sZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJlZ2lucyBhIG5ldyBnZXN0dXJlIGF0IHRoZSBsb2NhdGlvbiBvZiB0aGUgZmlyc3QgdG91Y2ggaW4gdGhlIGdpdmVuXHJcbiAgICAgKiB0b3VjaCBldmVudC5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZSBUaGUgdG91Y2ggZXZlbnQgYmVnaW5uaW5nIHRoaXMgbmV3IGdlc3R1cmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJlZ2luX2dlc3R1cmUoZSkge1xyXG4gICAgICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXTtcclxuICAgICAgICBnZXN0dXJlX2luX3Byb2dyZXNzID0gdHJ1ZTtcclxuICAgICAgICBnZXN0dXJlX3N0YXJ0X3ggPSB0b3VjaC5jbGllbnRYO1xyXG4gICAgICAgIGdlc3R1cmVfc3RhcnRfeSA9IHRvdWNoLmNsaWVudFk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmQgdGhlIGN1cnJlbnQgZ2VzdHVyZSBlbnRpcmVseS4gV2FpdCBmb3IgYWxsIHRvdWNoZXMgdG8gYmUgZG9uZSBiZWZvcmVcclxuICAgICAqIHJlc3VtaW5nIGdlc3R1cmUgZGV0ZWN0aW9uLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBlbmRfZ2VzdHVyZSgpIHtcclxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNsaWNrX3JlbGVhc2VfdGltZW91dCk7XHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChsb25nX3ByZXNzX3RpbWVvdXQpO1xyXG4gICAgICAgIGdlc3R1cmVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBoYW5kbGUgaWYgbm8gZ2VzdHVyZVxyXG4gICAgICAgIGlmICghZ2VzdHVyZV9pbl9wcm9ncmVzcylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBJZ25vcmUgaWYgbW9yZSB0aGFuIG9uZSB0b3VjaFxyXG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAwIHx8IGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGVuZF9nZXN0dXJlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvbmctcHJlc3MsIGlmIGFueSwgaXMgb3ZlclxyXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQobG9uZ19wcmVzc190aW1lb3V0KTtcclxuXHJcbiAgICAgICAgLy8gQWx3YXlzIHJlbGVhc2UgbW91c2UgYnV0dG9uIGlmIHByZXNzZWRcclxuICAgICAgICByZWxlYXNlX2J1dHRvbihcImxlZnRcIik7XHJcblxyXG4gICAgICAgIC8vIElmIGZpbmdlciBoYXNuJ3QgbW92ZWQgZW5vdWdoIHRvIGNhbmNlbCB0aGUgY2xpY2tcclxuICAgICAgICBpZiAoIWZpbmdlcl9tb3ZlZChlKSkge1xyXG5cclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgbm90IHlldCBwcmVzc2VkLCBwcmVzcyBhbmQgc3RhcnQgZGVsYXkgcmVsZWFzZVxyXG4gICAgICAgICAgICBpZiAoIWd1YWNfdG91Y2hzY3JlZW4uY3VycmVudFN0YXRlLmxlZnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgbW92ZV9tb3VzZSh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcclxuICAgICAgICAgICAgICAgIHByZXNzX2J1dHRvbihcImxlZnRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVsZWFzZSBidXR0b24gYWZ0ZXIgYSBkZWxheSwgaWYgbm90IGNhbmNlbGVkXHJcbiAgICAgICAgICAgICAgICBjbGlja19yZWxlYXNlX3RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxlYXNlX2J1dHRvbihcImxlZnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kX2dlc3R1cmUoKTtcclxuICAgICAgICAgICAgICAgIH0sIGd1YWNfdG91Y2hzY3JlZW4uY2xpY2tUaW1pbmdUaHJlc2hvbGQpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IC8vIGVuZCBpZiBmaW5nZXIgbm90IG1vdmVkXHJcblxyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAvLyBJZ25vcmUgaWYgbW9yZSB0aGFuIG9uZSB0b3VjaFxyXG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGVuZF9nZXN0dXJlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgLy8gTmV3IHRvdWNoIGJlZ2lucyBhIG5ldyBnZXN0dXJlXHJcbiAgICAgICAgYmVnaW5fZ2VzdHVyZShlKTtcclxuXHJcbiAgICAgICAgLy8gS2VlcCBidXR0b24gcHJlc3NlZCBpZiB0YXAgYWZ0ZXIgbGVmdCBjbGlja1xyXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY2xpY2tfcmVsZWFzZV90aW1lb3V0KTtcclxuXHJcbiAgICAgICAgLy8gQ2xpY2sgcmlnaHQgYnV0dG9uIGlmIHRoaXMgdHVybnMgaW50byBhIGxvbmctcHJlc3NcclxuICAgICAgICBsb25nX3ByZXNzX3RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdO1xyXG4gICAgICAgICAgICBtb3ZlX21vdXNlKHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xyXG4gICAgICAgICAgICBjbGlja19idXR0b24oXCJyaWdodFwiKTtcclxuICAgICAgICAgICAgZW5kX2dlc3R1cmUoKTtcclxuICAgICAgICB9LCBndWFjX3RvdWNoc2NyZWVuLmxvbmdQcmVzc1RocmVzaG9sZCk7XHJcblxyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBoYW5kbGUgaWYgbm8gZ2VzdHVyZVxyXG4gICAgICAgIGlmICghZ2VzdHVyZV9pbl9wcm9ncmVzcylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBDYW5jZWwgbG9uZyBwcmVzcyBpZiBmaW5nZXIgbW92ZWRcclxuICAgICAgICBpZiAoZmluZ2VyX21vdmVkKGUpKVxyXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGxvbmdfcHJlc3NfdGltZW91dCk7XHJcblxyXG4gICAgICAgIC8vIElnbm9yZSBpZiBtb3JlIHRoYW4gb25lIHRvdWNoXHJcbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgZW5kX2dlc3R1cmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIG1vdXNlIHBvc2l0aW9uIGlmIGRyYWdnaW5nXHJcbiAgICAgICAgaWYgKGd1YWNfdG91Y2hzY3JlZW4uY3VycmVudFN0YXRlLmxlZnQpIHtcclxuXHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxyXG4gICAgICAgICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07XHJcbiAgICAgICAgICAgIG1vdmVfbW91c2UodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGUgbmFtZXNwYWNlIHVzZWQgYnkgdGhlIEd1YWNhbW9sZSBKYXZhU2NyaXB0IEFQSS4gQWJzb2x1dGVseSBhbGwgY2xhc3Nlc1xyXG4gKiBkZWZpbmVkIGJ5IHRoZSBHdWFjYW1vbGUgSmF2YVNjcmlwdCBBUEkgd2lsbCBiZSB3aXRoaW4gdGhpcyBuYW1lc3BhY2UuXHJcbiAqXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgdXNlZCBieSB0aGUgR3VhY2Ftb2xlIGNsaWVudCB0byBob3VzZSBhcmJpdHJhcmlseS1tYW55IG5hbWVkXHJcbiAqIGlucHV0IGFuZCBvdXRwdXQgc3RyZWFtcy5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5DbGllbnR9IGNsaWVudFxyXG4gKiAgICAgVGhlIGNsaWVudCBvd25pbmcgdGhpcyBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gKiAgICAgVGhlIGluZGV4IG9mIHRoaXMgb2JqZWN0LlxyXG4gKi9cclxuR3VhY2Ftb2xlLk9iamVjdCA9IGZ1bmN0aW9uIGd1YWNhbW9sZU9iamVjdChjbGllbnQsIGluZGV4KSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuT2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLk9iamVjdH1cclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNPYmplY3QgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9mIHN0cmVhbSBuYW1lIHRvIGNvcnJlc3BvbmRpbmcgcXVldWUgb2YgY2FsbGJhY2tzLiBUaGUgcXVldWUgb2ZcclxuICAgICAqIGNhbGxiYWNrcyBpcyBndWFyYW50ZWVkIHRvIGJlIGluIG9yZGVyIG9mIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgRnVuY3Rpb25bXT59XHJcbiAgICAgKi9cclxuICAgIHZhciBib2R5Q2FsbGJhY2tzID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSBjYWxsYmFjayBhdCB0aGUgaGVhZCBvZiB0aGUgY2FsbGJhY2sgcXVldWUgZm9yXHJcbiAgICAgKiB0aGUgc3RyZWFtIGhhdmluZyB0aGUgZ2l2ZW4gbmFtZS4gSWYgbm8gc3VjaCBjYWxsYmFja3MgZXhpc3QsIG51bGwgaXNcclxuICAgICAqIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAgICogICAgIFRoZSBuYW1lIG9mIHRoZSBzdHJlYW0gdG8gcmV0cmlldmUgYSBjYWxsYmFjayBmb3IuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gICAgICogICAgIFRoZSBuZXh0IGNhbGxiYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3RyZWFtIGhhdmluZyB0aGUgZ2l2ZW4gbmFtZSxcclxuICAgICAqICAgICBvciBudWxsIGlmIG5vIHN1Y2ggY2FsbGJhY2sgZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICB2YXIgZGVxdWV1ZUJvZHlDYWxsYmFjayA9IGZ1bmN0aW9uIGRlcXVldWVCb2R5Q2FsbGJhY2sobmFtZSkge1xyXG5cclxuICAgICAgICAvLyBJZiBubyBjYWxsYmFja3MgZGVmaW5lZCwgc2ltcGx5IHJldHVybiBudWxsXHJcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGJvZHlDYWxsYmFja3NbbmFtZV07XHJcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHB1bGwgb2ZmIGZpcnN0IGNhbGxiYWNrLCBkZWxldGluZyB0aGUgcXVldWUgaWYgZW1wdHlcclxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3Muc2hpZnQoKTtcclxuICAgICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgZGVsZXRlIGJvZHlDYWxsYmFja3NbbmFtZV07XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBmb3VuZCBjYWxsYmFja1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjaztcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gdGhlIHRhaWwgb2YgdGhlIGNhbGxiYWNrIHF1ZXVlIGZvciB0aGUgc3RyZWFtXHJcbiAgICAgKiBoYXZpbmcgdGhlIGdpdmVuIG5hbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgKiAgICAgVGhlIG5hbWUgb2YgdGhlIHN0cmVhbSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgZ2l2ZW4gY2FsbGJhY2suXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAqICAgICBUaGUgY2FsbGJhY2sgdG8gYWRkIHRvIHRoZSBxdWV1ZSBvZiB0aGUgc3RyZWFtIHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAgICAgKi9cclxuICAgIHZhciBlbnF1ZXVlQm9keUNhbGxiYWNrID0gZnVuY3Rpb24gZW5xdWV1ZUJvZHlDYWxsYmFjayhuYW1lLCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgICAvLyBHZXQgY2FsbGJhY2sgcXVldWUgYnkgbmFtZSwgY3JlYXRpbmcgZmlyc3QgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGJvZHlDYWxsYmFja3NbbmFtZV07XHJcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgICAgIGJvZHlDYWxsYmFja3NbbmFtZV0gPSBjYWxsYmFja3M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgY2FsbGJhY2sgdG8gZW5kIG9mIHF1ZXVlXHJcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhpcyBvYmplY3QgcmVjZWl2ZXMgdGhlIGJvZHkgb2YgYSByZXF1ZXN0ZWQgaW5wdXQgc3RyZWFtLlxyXG4gICAgICogQnkgZGVmYXVsdCwgYWxsIG9iamVjdHMgd2lsbCBpbnZva2UgdGhlIGNhbGxiYWNrcyBwcm92aWRlZCB0byB0aGVpclxyXG4gICAgICogcmVxdWVzdElucHV0U3RyZWFtKCkgZnVuY3Rpb25zIGJhc2VkIG9uIHRoZSBuYW1lIG9mIHRoZSBzdHJlYW1cclxuICAgICAqIHJlcXVlc3RlZC4gVGhpcyBiZWhhdmlvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzcGVjaWZ5aW5nIGEgZGlmZmVyZW50XHJcbiAgICAgKiBoYW5kbGVyIGhlcmUuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gaW5wdXRTdHJlYW1cclxuICAgICAqICAgICBUaGUgaW5wdXQgc3RyZWFtIG9mIHRoZSByZWNlaXZlZCBib2R5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gICAgICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgZGF0YSBiZWluZyByZWNlaXZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAgICogICAgIFRoZSBuYW1lIG9mIHRoZSBzdHJlYW0gd2hvc2UgYm9keSBoYXMgYmVlbiByZWNlaXZlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmJvZHkgPSBmdW5jdGlvbiBkZWZhdWx0Qm9keUhhbmRsZXIoaW5wdXRTdHJlYW0sIG1pbWV0eXBlLCBuYW1lKSB7XHJcblxyXG4gICAgICAgIC8vIENhbGwgcXVldWVkIGNhbGxiYWNrIGZvciB0aGUgcmVjZWl2ZWQgYm9keSwgaWYgYW55XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZGVxdWV1ZUJvZHlDYWxsYmFjayhuYW1lKTtcclxuICAgICAgICBpZiAoY2FsbGJhY2spXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0U3RyZWFtLCBtaW1ldHlwZSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IGlzIGJlaW5nIHVuZGVmaW5lZC4gT25jZSB1bmRlZmluZWQsIG5vIGZ1cnRoZXJcclxuICAgICAqIGNvbW11bmljYXRpb24gaW52b2x2aW5nIHRoaXMgb2JqZWN0IG1heSBvY2N1ci5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHRoaXMub251bmRlZmluZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0cyByZWFkIGFjY2VzcyB0byB0aGUgaW5wdXQgc3RyZWFtIGhhdmluZyB0aGUgZ2l2ZW4gbmFtZS4gSWZcclxuICAgICAqIHN1Y2Nlc3NmdWwsIGEgbmV3IGlucHV0IHN0cmVhbSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUgaW5wdXQgc3RyZWFtIHRvIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2JvZHlDYWxsYmFja11cclxuICAgICAqICAgICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gdGhlIGJvZHkgb2YgdGhlIHJlcXVlc3RlZCBpbnB1dCBzdHJlYW1cclxuICAgICAqICAgICBpcyByZWNlaXZlZC4gVGhpcyBjYWxsYmFjayB3aWxsIGJlIHByb3ZpZGVkIGEgR3VhY2Ftb2xlLklucHV0U3RyZWFtXHJcbiAgICAgKiAgICAgYW5kIGl0cyBtaW1ldHlwZSBhcyBpdHMgdHdvIG9ubHkgYXJndW1lbnRzLiBJZiB0aGUgb25ib2R5IGhhbmRsZXIgb2ZcclxuICAgICAqICAgICB0aGlzIG9iamVjdCBpcyBvdmVycmlkZGVuLCB0aGlzIGNhbGxiYWNrIHdpbGwgbm90IGJlIGludm9rZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVxdWVzdElucHV0U3RyZWFtID0gZnVuY3Rpb24gcmVxdWVzdElucHV0U3RyZWFtKG5hbWUsIGJvZHlDYWxsYmFjaykge1xyXG5cclxuICAgICAgICAvLyBRdWV1ZSBib2R5IGNhbGxiYWNrIGlmIHByb3ZpZGVkXHJcbiAgICAgICAgaWYgKGJvZHlDYWxsYmFjaylcclxuICAgICAgICAgICAgZW5xdWV1ZUJvZHlDYWxsYmFjayhuYW1lLCBib2R5Q2FsbGJhY2spO1xyXG5cclxuICAgICAgICAvLyBTZW5kIHJlcXVlc3QgZm9yIGlucHV0IHN0cmVhbVxyXG4gICAgICAgIGNsaWVudC5yZXF1ZXN0T2JqZWN0SW5wdXRTdHJlYW0oZ3VhY09iamVjdC5pbmRleCwgbmFtZSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgb3V0cHV0IHN0cmVhbSBhc3NvY2lhdGVkIHdpdGggdGhpcyBvYmplY3QgYW5kIGhhdmluZyB0aGVcclxuICAgICAqIGdpdmVuIG1pbWV0eXBlIGFuZCBuYW1lLiBUaGUgbGVnYWxpdHkgb2YgYSBtaW1ldHlwZSBhbmQgbmFtZSBpcyBkaWN0YXRlZFxyXG4gICAgICogYnkgdGhlIG9iamVjdCBpdHNlbGYuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAgICAgKiAgICAgVGhlIG1pbWV0eXBlIG9mIHRoZSBkYXRhIHdoaWNoIHdpbGwgYmUgc2VudCB0byB0aGUgb3V0cHV0IHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAgICogICAgIFRoZSBkZWZpbmVkIG5hbWUgb2YgYW4gb3V0cHV0IHN0cmVhbSB3aXRoaW4gdGhpcyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0d1YWNhbW9sZS5PdXRwdXRTdHJlYW19XHJcbiAgICAgKiAgICAgQW4gb3V0cHV0IHN0cmVhbSB3aGljaCB3aWxsIHdyaXRlIGJsb2JzIHRvIHRoZSBuYW1lZCBvdXRwdXQgc3RyZWFtXHJcbiAgICAgKiAgICAgb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3JlYXRlT3V0cHV0U3RyZWFtID0gZnVuY3Rpb24gY3JlYXRlT3V0cHV0U3RyZWFtKG1pbWV0eXBlLCBuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsaWVudC5jcmVhdGVPYmplY3RPdXRwdXRTdHJlYW0oZ3VhY09iamVjdC5pbmRleCwgbWltZXR5cGUsIG5hbWUpO1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIHJlc2VydmVkIG5hbWUgZGVub3RpbmcgdGhlIHJvb3Qgc3RyZWFtIG9mIGFueSBvYmplY3QuIFRoZSBjb250ZW50cyBvZlxyXG4gKiB0aGUgcm9vdCBzdHJlYW0gTVVTVCBiZSBhIEpTT04gbWFwIG9mIHN0cmVhbSBuYW1lIHRvIG1pbWV0eXBlLlxyXG4gKlxyXG4gKiBAY29uc3RhbnRcclxuICogQHR5cGUge1N0cmluZ31cclxuICovXHJcbkd1YWNhbW9sZS5PYmplY3QuUk9PVF9TVFJFQU0gPSAnLyc7XHJcblxyXG4vKipcclxuICogVGhlIG1pbWV0eXBlIG9mIGEgc3RyZWFtIGNvbnRhaW5pbmcgSlNPTiB3aGljaCBtYXBzIGF2YWlsYWJsZSBzdHJlYW0gbmFtZXNcclxuICogdG8gdGhlaXIgY29ycmVzcG9uZGluZyBtaW1ldHlwZS4gVGhlIHJvb3Qgc3RyZWFtIG9mIGEgR3VhY2Ftb2xlLk9iamVjdCBNVVNUXHJcbiAqIGhhdmUgdGhpcyBtaW1ldHlwZS5cclxuICpcclxuICogQGNvbnN0YW50XHJcbiAqIEB0eXBlIHtTdHJpbmd9XHJcbiAqL1xyXG5HdWFjYW1vbGUuT2JqZWN0LlNUUkVBTV9JTkRFWF9NSU1FVFlQRSA9ICdhcHBsaWNhdGlvbi92bmQuZ2x5cHRvZG9uLmd1YWNhbW9sZS5zdHJlYW0taW5kZXgranNvbic7XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBEeW5hbWljIG9uLXNjcmVlbiBrZXlib2FyZC4gR2l2ZW4gdGhlIGxheW91dCBvYmplY3QgZm9yIGFuIG9uLXNjcmVlblxyXG4gKiBrZXlib2FyZCwgdGhpcyBvYmplY3Qgd2lsbCBjb25zdHJ1Y3QgYSBjbGlja2FibGUgb24tc2NyZWVuIGtleWJvYXJkIHdpdGggaXRzXHJcbiAqIG93biBrZXkgZXZlbnRzLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5MYXlvdXR9IGxheW91dFxyXG4gKiAgICAgVGhlIGxheW91dCBvZiB0aGUgb24tc2NyZWVuIGtleWJvYXJkIHRvIGRpc3BsYXkuXHJcbiAqL1xyXG5HdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZCA9IGZ1bmN0aW9uKGxheW91dCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZH1cclxuICAgICAqL1xyXG4gICAgdmFyIG9zayA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2YgY3VycmVudGx5LXNldCBtb2RpZmllcnMgdG8gdGhlIGtleXN5bSBhc3NvY2lhdGVkIHdpdGggdGhlaXJcclxuICAgICAqIG9yaWdpbmFsIHByZXNzLiBXaGVuIHRoZSBtb2RpZmllciBpcyBjbGVhcmVkLCB0aGlzIGtleXN5bSBtdXN0IGJlXHJcbiAgICAgKiByZWxlYXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge09iamVjdC48U3RyaW5nLCBOdW1iZXI+fVxyXG4gICAgICovXHJcbiAgICB2YXIgbW9kaWZpZXJLZXlzeW1zID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2YgYWxsIGtleSBuYW1lcyB0byB0aGVpciBjdXJyZW50IHByZXNzZWQgc3RhdGVzLiBJZiBhIGtleSBpcyBub3RcclxuICAgICAqIHByZXNzZWQsIGl0IG1heSBub3QgYmUgaW4gdGhpcyBtYXAgYXQgYWxsLCBidXQgYWxsIHByZXNzZWQga2V5cyB3aWxsXHJcbiAgICAgKiBoYXZlIGEgY29ycmVzcG9uZGluZyBtYXBwaW5nIHRvIHRydWUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgQm9vbGVhbj59XHJcbiAgICAgKi9cclxuICAgIHZhciBwcmVzc2VkID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgc2NhbGFibGUgZWxlbWVudHMgd2hpY2ggYXJlIHBhcnQgb2YgdGhlIG9uLXNjcmVlbiBrZXlib2FyZC4gRWFjaFxyXG4gICAgICogc2NhbGFibGUgZWxlbWVudCBpcyBjYXJlZnVsbHkgY29udHJvbGxlZCB0byBlbnN1cmUgdGhlIGludGVyZmFjZSBsYXlvdXRcclxuICAgICAqIGFuZCBzaXppbmcgcmVtYWlucyBjb25zdGFudCwgZXZlbiBvbiBicm93c2VycyB0aGF0IHdvdWxkIG90aGVyd2lzZVxyXG4gICAgICogZXhwZXJpZW5jZSByb3VuZGluZyBlcnJvciBkdWUgdG8gdW5pdCBjb252ZXJzaW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge1NjYWxlZEVsZW1lbnRbXX1cclxuICAgICAqL1xyXG4gICAgdmFyIHNjYWxlZEVsZW1lbnRzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgQ1NTIGNsYXNzIHRvIGFuIGVsZW1lbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAgICogICAgIFRoZSBlbGVtZW50IHRvIGFkZCBhIGNsYXNzIHRvLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc25hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUgY2xhc3MgdG8gYWRkLlxyXG4gICAgICovXHJcbiAgICB2YXIgYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc25hbWUpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgY2xhc3NMaXN0IHN1cHBvcnRlZCwgdXNlIHRoYXRcclxuICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpXHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc25hbWUpO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHNpbXBseSBhcHBlbmQgdGhlIGNsYXNzXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzbmFtZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIENTUyBjbGFzcyBmcm9tIGFuIGVsZW1lbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAgICogICAgIFRoZSBlbGVtZW50IHRvIHJlbW92ZSBhIGNsYXNzIGZyb20uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzbmFtZVxyXG4gICAgICogICAgIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byByZW1vdmUuXHJcbiAgICAgKi9cclxuICAgIHZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzbmFtZSkge1xyXG5cclxuICAgICAgICAvLyBJZiBjbGFzc0xpc3Qgc3VwcG9ydGVkLCB1c2UgdGhhdFxyXG4gICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdClcclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzbmFtZSk7XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbWFudWFsbHkgZmlsdGVyIG91dCBjbGFzc2VzIHdpdGggZ2l2ZW4gbmFtZVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoLyhbXiBdKylbIF0qL2csXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVNYXRjaGluZ0NsYXNzZXMobWF0Y2gsIHRlc3RDbGFzc25hbWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc2FtZSBjbGFzcywgcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3RDbGFzc25hbWUgPT09IGNsYXNzbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgYWxsb3dcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3VudGVyIG9mIG1vdXNlIGV2ZW50cyB0byBpZ25vcmUuIFRoaXMgZGVjcmVtZW50ZWQgYnkgbW91c2Vtb3ZlLCBhbmRcclxuICAgICAqIHdoaWxlIG5vbi16ZXJvLCBtb3VzZSBldmVudHMgd2lsbCBoYXZlIG5vIGVmZmVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIGlnbm9yZU1vdXNlID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElnbm9yZXMgYWxsIHBlbmRpbmcgbW91c2UgZXZlbnRzIHdoZW4gdG91Y2ggZXZlbnRzIGFyZSB0aGUgYXBwYXJlbnRcclxuICAgICAqIHNvdXJjZS4gTW91c2UgZXZlbnRzIGFyZSBpZ25vcmVkIHVudGlsIGF0IGxlYXN0IHRvdWNoTW91c2VUaHJlc2hvbGRcclxuICAgICAqIG1vdXNlIGV2ZW50cyBvY2N1ciB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdG91Y2ggZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBpZ25vcmVQZW5kaW5nTW91c2VFdmVudHMgPSBmdW5jdGlvbiBpZ25vcmVQZW5kaW5nTW91c2VFdmVudHMoKSB7XHJcbiAgICAgICAgaWdub3JlTW91c2UgPSBvc2sudG91Y2hNb3VzZVRocmVzaG9sZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBlbGVtZW50IHdob3NlIGRpbWVuc2lvbnMgYXJlIG1haW50YWluZWQgYWNjb3JkaW5nIHRvIGFuIGFyYml0cmFyeVxyXG4gICAgICogc2NhbGUuIFRoZSBjb252ZXJzaW9uIGZhY3RvciBmb3IgdGhlc2UgYXJiaXRyYXJ5IHVuaXRzIHRvIHBpeGVscyBpc1xyXG4gICAgICogcHJvdmlkZWQgbGF0ZXIgdmlhIGEgY2FsbCB0byBzY2FsZSgpLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAgICogICAgIFRoZSBlbGVtZW50IHdob3NlIHNjYWxlIHNob3VsZCBiZSBtYWludGFpbmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxyXG4gICAgICogICAgIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudCwgaW4gYXJiaXRyYXJ5IHVuaXRzLCByZWxhdGl2ZSB0byBvdGhlclxyXG4gICAgICogICAgIFNjYWxlZEVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcclxuICAgICAqICAgICBUaGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50LCBpbiBhcmJpdHJhcnkgdW5pdHMsIHJlbGF0aXZlIHRvIG90aGVyXHJcbiAgICAgKiAgICAgU2NhbGVkRWxlbWVudHMuXHJcbiAgICAgKiAgICAgXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzY2FsZUZvbnQ9ZmFsc2VdXHJcbiAgICAgKiAgICAgV2hldGhlciB0aGUgbGluZSBoZWlnaHQgYW5kIGZvbnQgc2l6ZSBzaG91bGQgYmUgc2NhbGVkIGFzIHdlbGwuXHJcbiAgICAgKi9cclxuICAgIHZhciBTY2FsZWRFbGVtZW50ID0gZnVuY3Rpb24gU2NhbGVkRWxlbWVudChlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBzY2FsZUZvbnQpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoaXMgU2NhbGVkRWxlbWVudCwgaW4gYXJiaXRyYXJ5IHVuaXRzLCByZWxhdGl2ZSB0b1xyXG4gICAgICAgICAqIG90aGVyIFNjYWxlZEVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoaXMgU2NhbGVkRWxlbWVudCwgaW4gYXJiaXRyYXJ5IHVuaXRzLCByZWxhdGl2ZSB0b1xyXG4gICAgICAgICAqIG90aGVyIFNjYWxlZEVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNpemVzIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQsIHVwZGF0aW5nIGl0cyBkaW1lbnNpb25zIGFjY29yZGluZyB0b1xyXG4gICAgICAgICAqIHRoZSBnaXZlbiBwaXhlbHMgcGVyIHVuaXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcGl4ZWxzXHJcbiAgICAgICAgICogICAgIFRoZSBudW1iZXIgb2YgcGl4ZWxzIHRvIGFzc2lnbiBwZXIgYXJiaXRyYXJ5IHVuaXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IGZ1bmN0aW9uKHBpeGVscykge1xyXG5cclxuICAgICAgICAgICAgLy8gU2NhbGUgZWxlbWVudCB3aWR0aC9oZWlnaHRcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCAgPSAod2lkdGggICogcGl4ZWxzKSArIFwicHhcIjtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoaGVpZ2h0ICogcGl4ZWxzKSArIFwicHhcIjtcclxuXHJcbiAgICAgICAgICAgIC8vIFNjYWxlIGZvbnQsIGlmIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICBpZiAoc2NhbGVGb250KSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmxpbmVIZWlnaHQgPSAoaGVpZ2h0ICogcGl4ZWxzKSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZm9udFNpemUgICA9IHBpeGVscyArIFwicHhcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYWxsIG1vZGlmaWVycyBoYXZpbmcgdGhlIGdpdmVuIG5hbWVzIGFyZSBjdXJyZW50bHlcclxuICAgICAqIGFjdGl2ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gbmFtZXNcclxuICAgICAqICAgICBUaGUgbmFtZXMgb2YgYWxsIG1vZGlmaWVycyB0byB0ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogICAgIHRydWUgaWYgYWxsIHNwZWNpZmllZCBtb2RpZmllcnMgYXJlIHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgdmFyIG1vZGlmaWVyc1ByZXNzZWQgPSBmdW5jdGlvbiBtb2RpZmllcnNQcmVzc2VkKG5hbWVzKSB7XHJcblxyXG4gICAgICAgIC8vIElmIGFueSByZXF1aXJlZCBtb2RpZmllcnMgYXJlIG5vdCBwcmVzc2VkLCByZXR1cm4gZmFsc2VcclxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgLy8gVGVzdCB3aGV0aGVyIGN1cnJlbnQgbW9kaWZpZXIgaXMgcHJlc3NlZFxyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIG1vZGlmaWVyS2V5c3ltcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgcmVxdWlyZWQgbW9kaWZpZXJzIGFyZSBwcmVzc2VkXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNpbmdsZSBtYXRjaGluZyBLZXkgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IG9mIHRoZVxyXG4gICAgICogZ2l2ZW4gbmFtZSwgd2hlcmUgdGhhdCBLZXkgb2JqZWN0J3MgcmVxdWlyZW1lbnRzIChzdWNoIGFzIHByZXNzZWRcclxuICAgICAqIG1vZGlmaWVycykgYXJlIGFsbCBjdXJyZW50bHkgc2F0aXNmaWVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5TmFtZVxyXG4gICAgICogICAgIFRoZSBuYW1lIG9mIHRoZSBrZXkgdG8gcmV0cmlldmUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0d1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleX1cclxuICAgICAqICAgICBUaGUgS2V5IG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIG5hbWUsIHdoZXJlIHRoYXQgb2JqZWN0J3NcclxuICAgICAqICAgICByZXF1aXJlbWVudHMgYXJlIGFsbCBjdXJyZW50bHkgc2F0aXNmaWVkLCBvciBudWxsIGlmIG5vIHN1Y2ggS2V5XHJcbiAgICAgKiAgICAgY2FuIGJlIGZvdW5kLlxyXG4gICAgICovXHJcbiAgICB2YXIgZ2V0QWN0aXZlS2V5ID0gZnVuY3Rpb24gZ2V0QWN0aXZlS2V5KGtleU5hbWUpIHtcclxuXHJcbiAgICAgICAgLy8gR2V0IGtleSBhcnJheSBmb3IgZ2l2ZW4gbmFtZVxyXG4gICAgICAgIHZhciBrZXlzID0gb3NrLmtleXNba2V5TmFtZV07XHJcbiAgICAgICAgaWYgKCFrZXlzKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gRmluZCBsYXN0IG1hdGNoaW5nIGtleVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgY2FuZGlkYXRlIGtleVxyXG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0ga2V5c1tpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGFsbCByZXF1aXJlZCBtb2RpZmllcnMgYXJlIHByZXNzZWQsIHVzZSB0aGF0IGtleVxyXG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzUHJlc3NlZChjYW5kaWRhdGUucmVxdWlyZXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBObyB2YWxpZCBrZXlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJlc3NlcyB0aGUga2V5IGhhdmluZyB0aGUgZ2l2ZW4gbmFtZSwgdXBkYXRpbmcgdGhlIGFzc29jaWF0ZWQga2V5XHJcbiAgICAgKiBlbGVtZW50IHdpdGggdGhlIFwiZ3VhYy1rZXlib2FyZC1wcmVzc2VkXCIgQ1NTIGNsYXNzLiBJZiB0aGUga2V5IGlzXHJcbiAgICAgKiBhbHJlYWR5IHByZXNzZWQsIHRoaXMgZnVuY3Rpb24gaGFzIG5vIGVmZmVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleU5hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHByZXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlFbGVtZW50XHJcbiAgICAgKiAgICAgVGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXHJcbiAgICAgKi9cclxuICAgIHZhciBwcmVzcyA9IGZ1bmN0aW9uIHByZXNzKGtleU5hbWUsIGtleUVsZW1lbnQpIHtcclxuXHJcbiAgICAgICAgLy8gUHJlc3Mga2V5IGlmIG5vdCB5ZXQgcHJlc3NlZFxyXG4gICAgICAgIGlmICghcHJlc3NlZFtrZXlOYW1lXSkge1xyXG5cclxuICAgICAgICAgICAgYWRkQ2xhc3Moa2V5RWxlbWVudCwgXCJndWFjLWtleWJvYXJkLXByZXNzZWRcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBrZXkgYmFzZWQgb24gbW9kaWZpZXIgc3RhdGVcclxuICAgICAgICAgICAgdmFyIGtleSA9IGdldEFjdGl2ZUtleShrZXlOYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBtb2RpZmllciBzdGF0ZVxyXG4gICAgICAgICAgICBpZiAoa2V5Lm1vZGlmaWVyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGNsYXNzbmFtZSBmb3IgbW9kaWZpZXJcclxuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllckNsYXNzID0gXCJndWFjLWtleWJvYXJkLW1vZGlmaWVyLVwiICsgZ2V0Q1NTTmFtZShrZXkubW9kaWZpZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlIG9yaWdpbmFsbHktcHJlc3NlZCBrZXlzeW0sIGlmIG1vZGlmaWVyIHdhcyBhbHJlYWR5IHByZXNzZWRcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEtleXN5bSA9IG1vZGlmaWVyS2V5c3ltc1trZXkubW9kaWZpZXJdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFjdGl2YXRlIG1vZGlmaWVyIGlmIG5vdCBwcmVzc2VkXHJcbiAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsS2V5c3ltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3Moa2V5Ym9hcmQsIG1vZGlmaWVyQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVyS2V5c3ltc1trZXkubW9kaWZpZXJdID0ga2V5LmtleXN5bTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIGtleSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvc2sub25rZXlkb3duKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvc2sub25rZXlkb3duKGtleS5rZXlzeW0pO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZWFjdGl2YXRlIGlmIG5vdCBwcmVzc2VkXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moa2V5Ym9hcmQsIG1vZGlmaWVyQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtb2RpZmllcktleXN5bXNba2V5Lm1vZGlmaWVyXTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIGtleSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvc2sub25rZXl1cClcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3NrLm9ua2V5dXAob3JpZ2luYWxLZXlzeW0pO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vdCBtb2RpZmllciwgc2VuZCBrZXkgZXZlbnQgbm93XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9zay5vbmtleWRvd24pXHJcbiAgICAgICAgICAgICAgICBvc2sub25rZXlkb3duKGtleS5rZXlzeW0pO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFyayBrZXkgYXMgcHJlc3NlZFxyXG4gICAgICAgICAgICBwcmVzc2VkW2tleU5hbWVdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWxlYXNlcyB0aGUga2V5IGhhdmluZyB0aGUgZ2l2ZW4gbmFtZSwgcmVtb3ZpbmcgdGhlXHJcbiAgICAgKiBcImd1YWMta2V5Ym9hcmQtcHJlc3NlZFwiIENTUyBjbGFzcyBmcm9tIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQuIElmIHRoZVxyXG4gICAgICoga2V5IGlzIGFscmVhZHkgcmVsZWFzZWQsIHRoaXMgZnVuY3Rpb24gaGFzIG5vIGVmZmVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleU5hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHJlbGVhc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleUVsZW1lbnRcclxuICAgICAqICAgICBUaGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cclxuICAgICAqL1xyXG4gICAgdmFyIHJlbGVhc2UgPSBmdW5jdGlvbiByZWxlYXNlKGtleU5hbWUsIGtleUVsZW1lbnQpIHtcclxuXHJcbiAgICAgICAgLy8gUmVsZWFzZSBrZXkgaWYgY3VycmVudGx5IHByZXNzZWRcclxuICAgICAgICBpZiAocHJlc3NlZFtrZXlOYW1lXSkge1xyXG5cclxuICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moa2V5RWxlbWVudCwgXCJndWFjLWtleWJvYXJkLXByZXNzZWRcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBrZXkgYmFzZWQgb24gbW9kaWZpZXIgc3RhdGVcclxuICAgICAgICAgICAgdmFyIGtleSA9IGdldEFjdGl2ZUtleShrZXlOYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlbmQga2V5IGV2ZW50IGlmIG5vdCBhIG1vZGlmaWVyIGtleVxyXG4gICAgICAgICAgICBpZiAoIWtleS5tb2RpZmllciAmJiBvc2sub25rZXl1cClcclxuICAgICAgICAgICAgICAgIG9zay5vbmtleXVwKGtleS5rZXlzeW0pO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFyayBrZXkgYXMgcmVsZWFzZWRcclxuICAgICAgICAgICAgcHJlc3NlZFtrZXlOYW1lXSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDcmVhdGUga2V5Ym9hcmRcclxuICAgIHZhciBrZXlib2FyZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICBrZXlib2FyZC5jbGFzc05hbWUgPSBcImd1YWMta2V5Ym9hcmRcIjtcclxuXHJcbiAgICAvLyBEbyBub3QgYWxsb3cgc2VsZWN0aW9uIG9yIG1vdXNlIG1vdmVtZW50IHRvIHByb3BhZ2F0ZS9yZWdpc3Rlci5cclxuICAgIGtleWJvYXJkLm9uc2VsZWN0c3RhcnQgPVxyXG4gICAga2V5Ym9hcmQub25tb3VzZW1vdmUgICA9XHJcbiAgICBrZXlib2FyZC5vbm1vdXNldXAgICAgID1cclxuICAgIGtleWJvYXJkLm9ubW91c2Vkb3duICAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZUV2ZW50cyhlKSB7XHJcblxyXG4gICAgICAgIC8vIElmIGlnbm9yaW5nIGV2ZW50cywgZGVjcmVtZW50IGNvdW50ZXJcclxuICAgICAgICBpZiAoaWdub3JlTW91c2UpXHJcbiAgICAgICAgICAgIGlnbm9yZU1vdXNlLS07XHJcblxyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vdXNlbW92ZSBldmVudHMgdG8gcmVxdWlyZSBiZWZvcmUgcmUtZW5hYmxpbmcgbW91c2VcclxuICAgICAqIGV2ZW50IGhhbmRsaW5nIGFmdGVyIHJlY2VpdmluZyBhIHRvdWNoIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudG91Y2hNb3VzZVRocmVzaG9sZCA9IDM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgdXNlciBwcmVzc2VzIGEga2V5IG9uIHRoaXMgR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtleXN5bSBUaGUga2V5c3ltIG9mIHRoZSBrZXkgYmVpbmcgcHJlc3NlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmtleWRvd24gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgb24gdGhpcyBHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga2V5c3ltIFRoZSBrZXlzeW0gb2YgdGhlIGtleSBiZWluZyByZWxlYXNlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmtleXVwID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBrZXlib2FyZCBsYXlvdXQgcHJvdmlkZWQgYXQgdGltZSBvZiBjb25zdHJ1Y3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLkxheW91dH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sYXlvdXQgPSBuZXcgR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuTGF5b3V0KGxheW91dCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGVudGlyZSBvbi1zY3JlZW4ga2V5Ym9hcmQuXHJcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH0gVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgZW50aXJlIG9uLXNjcmVlbiBrZXlib2FyZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGtleWJvYXJkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZXMgYWxsIGVsZW1lbnRzIHdpdGhpbiB0aGlzIEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkIHN1Y2ggdGhhdFxyXG4gICAgICogdGhlIHdpZHRoIGlzIGNsb3NlIHRvIGJ1dCBkb2VzIG5vdCBleGNlZWQgdGhlIHNwZWNpZmllZCB3aWR0aC4gVGhlXHJcbiAgICAgKiBoZWlnaHQgb2YgdGhlIGtleWJvYXJkIGlzIGRldGVybWluZWQgYmFzZWQgb24gdGhlIHdpZHRoLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIHJlc2l6ZSB0aGlzIEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgdG8sIGluIHBpeGVscy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCkge1xyXG5cclxuICAgICAgICAvLyBHZXQgcGl4ZWwgc2l6ZSBvZiBhIHVuaXRcclxuICAgICAgICB2YXIgdW5pdCA9IE1hdGguZmxvb3Iod2lkdGggKiAxMCAvIG9zay5sYXlvdXQud2lkdGgpIC8gMTA7XHJcblxyXG4gICAgICAgIC8vIFJlc2l6ZSBhbGwgc2NhbGVkIGVsZW1lbnRzXHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjYWxlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZWRFbGVtZW50ID0gc2NhbGVkRWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgIHNjYWxlZEVsZW1lbnQuc2NhbGUodW5pdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiB0aGUgbmFtZSBvZiBhIGtleSBhbmQgaXRzIGNvcnJlc3BvbmRpbmcgZGVmaW5pdGlvbiwgd2hpY2ggbWF5IGJlXHJcbiAgICAgKiBhbiBhcnJheSBvZiBrZXlzIG9iamVjdHMsIGEgbnVtYmVyIChrZXlzeW0pLCBhIHN0cmluZyAoa2V5IHRpdGxlKSwgb3IgYVxyXG4gICAgICogc2luZ2xlIGtleSBvYmplY3QsIHJldHVybnMgYW4gYXJyYXkgb2Yga2V5IG9iamVjdHMsIGRlcml2aW5nIGFueSBtaXNzaW5nXHJcbiAgICAgKiBwcm9wZXJ0aWVzIGFzIG5lZWRlZCwgYW5kIGVuc3VyaW5nIHRoZSBrZXkgbmFtZSBpcyBkZWZpbmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAgICogICAgIFRoZSBuYW1lIG9mIHRoZSBrZXkgYmVpbmcgY29lcmNlZCBpbnRvIGFuIGFycmF5IG9mIEtleSBvYmplY3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5LZXl8R3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuS2V5W119IG9iamVjdFxyXG4gICAgICogICAgIFRoZSBvYmplY3QgZGVmaW5pbmcgdGhlIGJlaGF2aW9yIG9mIHRoZSBrZXkgaGF2aW5nIHRoZSBnaXZlbiBuYW1lLFxyXG4gICAgICogICAgIHdoaWNoIG1heSBiZSB0aGUgdGl0bGUgb2YgdGhlIGtleSAoYSBzdHJpbmcpLCB0aGUga2V5c3ltIChhIG51bWJlciksXHJcbiAgICAgKiAgICAgYSBzaW5nbGUgS2V5IG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgS2V5IG9iamVjdHMuXHJcbiAgICAgKiAgICAgXHJcbiAgICAgKiBAcmV0dXJucyB7R3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuS2V5W119XHJcbiAgICAgKiAgICAgQW4gYXJyYXkgb2YgYWxsIGtleXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgICovXHJcbiAgICB2YXIgYXNLZXlBcnJheSA9IGZ1bmN0aW9uIGFzS2V5QXJyYXkobmFtZSwgb2JqZWN0KSB7XHJcblxyXG4gICAgICAgIC8vIElmIGFscmVhZHkgYW4gYXJyYXksIGp1c3QgY29lcmNlIGludG8gYSB0cnVlIEtleVtdIFxyXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGtleXMucHVzaChuZXcgR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuS2V5KG9iamVjdFtpXSwgbmFtZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVyaXZlIGtleSBvYmplY3QgZnJvbSBrZXlzeW0gaWYgdGhhdCdzIGFsbCB3ZSBoYXZlXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbbmV3IEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleSh7XHJcbiAgICAgICAgICAgICAgICBuYW1lICAgOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAga2V5c3ltIDogb2JqZWN0XHJcbiAgICAgICAgICAgIH0pXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlcml2ZSBrZXkgb2JqZWN0IGZyb20gdGl0bGUgaWYgdGhhdCdzIGFsbCB3ZSBoYXZlXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbbmV3IEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleSh7XHJcbiAgICAgICAgICAgICAgICBuYW1lICA6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICB0aXRsZSA6IG9iamVjdFxyXG4gICAgICAgICAgICB9KV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpdCdzIGFscmVhZHkgYSBrZXkgb2JqZWN0LCBqdXN0IG5vdCBhbiBhcnJheVxyXG4gICAgICAgIHJldHVybiBbbmV3IEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleShvYmplY3QsIG5hbWUpXTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIHJhdGhlciBmb3JnaXZpbmcga2V5IG1hcHBpbmcgYWxsb3dlZCBieVxyXG4gICAgICogR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuTGF5b3V0IGludG8gYSByaWdvcm91cyBtYXBwaW5nIG9mIGtleSBuYW1lXHJcbiAgICAgKiB0byBrZXkgZGVmaW5pdGlvbiwgd2hlcmUgdGhlIGtleSBkZWZpbml0aW9uIGlzIGFsd2F5cyBhbiBhcnJheSBvZiBLZXlcclxuICAgICAqIG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIE51bWJlcnxTdHJpbmd8R3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuS2V5fEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleVtdPn0ga2V5c1xyXG4gICAgICogICAgIEEgbWFwcGluZyBvZiBrZXkgbmFtZSB0byBrZXkgZGVmaW5pdGlvbiwgd2hlcmUgdGhlIGtleSBkZWZpbml0aW9uIGlzXHJcbiAgICAgKiAgICAgdGhlIHRpdGxlIG9mIHRoZSBrZXkgKGEgc3RyaW5nKSwgdGhlIGtleXN5bSAoYSBudW1iZXIpLCBhIHNpbmdsZVxyXG4gICAgICogICAgIEtleSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIEtleSBvYmplY3RzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPFN0cmluZywgR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuS2V5W10+fVxyXG4gICAgICogICAgIEEgbW9yZS1wcmVkaWN0YWJsZSBtYXBwaW5nIG9mIGtleSBuYW1lIHRvIGtleSBkZWZpbml0aW9uLCB3aGVyZSB0aGVcclxuICAgICAqICAgICBrZXkgZGVmaW5pdGlvbiBpcyBhbHdheXMgc2ltcGx5IGFuIGFycmF5IG9mIEtleSBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICB2YXIgZ2V0S2V5cyA9IGZ1bmN0aW9uIGdldEtleXMoa2V5cykge1xyXG5cclxuICAgICAgICB2YXIga2V5QXJyYXlzID0ge307XHJcblxyXG4gICAgICAgIC8vIENvZXJjZSBhbGwga2V5cyBpbnRvIGluZGl2aWR1YWwga2V5IGFycmF5c1xyXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gbGF5b3V0LmtleXMpIHtcclxuICAgICAgICAgICAga2V5QXJyYXlzW25hbWVdID0gYXNLZXlBcnJheShuYW1lLCBrZXlzW25hbWVdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBrZXlBcnJheXM7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBvZiBhbGwga2V5IG5hbWVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgc2V0IG9mIGtleXMuIEVhY2gga2V5IG5hbWVcclxuICAgICAqIG1heSBjb3JyZXNwb25kIHRvIG11bHRpcGxlIGtleXMgZHVlIHRvIHRoZSBlZmZlY3Qgb2YgbW9kaWZpZXJzLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuS2V5W10+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmtleXMgPSBnZXRLZXlzKGxheW91dC5rZXlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGFyYml0cmFyeSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHNvbWUgY29tcG9uZW50IG9mIHRoZVxyXG4gICAgICogb24tc2NyZWVuIGtleWJvYXJkLCByZXR1cm5zIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdXNlIGFzIGEgQ1NTIGNsYXNzXHJcbiAgICAgKiBuYW1lLiBUaGUgcmVzdWx0IHdpbGwgYmUgbG93ZXJjYXNlLiBXb3JkIGJvdW5kYXJpZXMgcHJldmlvdXNseSBkZW5vdGVkXHJcbiAgICAgKiBieSBDYW1lbENhc2Ugd2lsbCBiZSByZXBsYWNlZCBieSBpbmRpdmlkdWFsIGh5cGhlbnMsIGFzIHdpbGwgYWxsXHJcbiAgICAgKiBjb250aWd1b3VzIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAqICAgICBBbiBhcmJpdHJhcnkgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiBzb21lIGNvbXBvbmVudCBvZiB0aGVcclxuICAgICAqICAgICBvbi1zY3JlZW4ga2V5Ym9hcmQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqICAgICBBIHN0cmluZyBmb3JtYXR0ZWQgZm9yIHVzZSBhcyBhIENTUyBjbGFzcyBuYW1lLlxyXG4gICAgICovXHJcbiAgICB2YXIgZ2V0Q1NTTmFtZSA9IGZ1bmN0aW9uIGdldENTU05hbWUobmFtZSkge1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IG5hbWUgZnJvbSBwb3NzaWJseS1DYW1lbENhc2UgdG8gaHlwaGVuYXRlZCBsb3dlcmNhc2VcclxuICAgICAgICB2YXIgY3NzTmFtZSA9IG5hbWVcclxuICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpXHJcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXkEtWmEtejAtOV0rL2csICctJylcclxuICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBjc3NOYW1lO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIERPTSBlbGVtZW50cyB0byB0aGUgZ2l2ZW4gZWxlbWVudCBhcyBkaWN0YXRlZCBieSB0aGUgbGF5b3V0XHJcbiAgICAgKiBzdHJ1Y3R1cmUgb2JqZWN0IHByb3ZpZGVkLiBJZiBhIG5hbWUgaXMgcHJvdmlkZWQsIGFuIGFkZGl0aW9uYWwgQ1NTXHJcbiAgICAgKiBjbGFzcywgcHJlcGVuZGVkIHdpdGggXCJndWFjLWtleWJvYXJkLVwiLCB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0b3AtbGV2ZWxcclxuICAgICAqIGVsZW1lbnQuXHJcbiAgICAgKiBcclxuICAgICAqIElmIHRoZSBsYXlvdXQgc3RydWN0dXJlIG9iamVjdCBpcyBhbiBhcnJheSwgYWxsIGVsZW1lbnRzIHdpdGhpbiB0aGF0XHJcbiAgICAgKiBhcnJheSB3aWxsIGJlIHJlY3Vyc2l2ZWx5IGFwcGVuZGVkIGFzIGNoaWxkcmVuIG9mIGEgZ3JvdXAsIGFuZCB0aGVcclxuICAgICAqIHRvcC1sZXZlbCBlbGVtZW50IHdpbGwgYmUgZ2l2ZW4gdGhlIENTUyBjbGFzcyBcImd1YWMta2V5Ym9hcmQtZ3JvdXBcIi5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGUgbGF5b3V0IHN0cnVjdHVyZSBvYmplY3QgaXMgYW4gb2JqZWN0LCBhbGwgcHJvcGVydGllcyB3aXRoaW4gdGhhdFxyXG4gICAgICogb2JqZWN0IHdpbGwgYmUgcmVjdXJzaXZlbHkgYXBwZW5kZWQgYXMgY2hpbGRyZW4gb2YgYSBncm91cCwgYW5kIHRoZVxyXG4gICAgICogdG9wLWxldmVsIGVsZW1lbnQgd2lsbCBiZSBnaXZlbiB0aGUgQ1NTIGNsYXNzIFwiZ3VhYy1rZXlib2FyZC1ncm91cFwiLiBUaGVcclxuICAgICAqIG5hbWUgb2YgZWFjaCBwcm9wZXJ0eSB3aWxsIGJlIGFwcGxpZWQgYXMgdGhlIG5hbWUgb2YgZWFjaCBjaGlsZCBvYmplY3RcclxuICAgICAqIGZvciB0aGUgc2FrZSBvZiBDU1MuIEVhY2ggcHJvcGVydHkgd2lsbCBiZSBhZGRlZCBpbiBzb3J0ZWQgb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIGxheW91dCBzdHJ1Y3R1cmUgb2JqZWN0IGlzIGEgc3RyaW5nLCB0aGUga2V5IGhhdmluZyB0aGF0IG5hbWVcclxuICAgICAqIHdpbGwgYmUgYXBwZW5kZWQuIFRoZSBrZXkgd2lsbCBiZSBnaXZlbiB0aGUgQ1NTIGNsYXNzXHJcbiAgICAgKiBcImd1YWMta2V5Ym9hcmQta2V5XCIgYW5kIFwiZ3VhYy1rZXlib2FyZC1rZXktTkFNRVwiLCB3aGVyZSBOQU1FIGlzIHRoZSBuYW1lXHJcbiAgICAgKiBvZiB0aGUga2V5LiBJZiB0aGUgbmFtZSBvZiB0aGUga2V5IGlzIGEgc2luZ2xlIGNoYXJhY3RlciwgdGhpcyB3aWxsXHJcbiAgICAgKiBmaXJzdCBiZSB0cmFuc2Zvcm1lZCBpbnRvIHRoZSBDLXN0eWxlIGhleGFkZWNpbWFsIGxpdGVyYWwgZm9yIHRoZVxyXG4gICAgICogVW5pY29kZSBjb2RlcG9pbnQgb2YgdGhhdCBjaGFyYWN0ZXIuIEZvciBleGFtcGxlLCB0aGUga2V5IFwiQVwiIHdvdWxkXHJcbiAgICAgKiBiZWNvbWUgXCJndWFjLWtleWJvYXJkLWtleS0weDQxXCIuXHJcbiAgICAgKiBcclxuICAgICAqIElmIHRoZSBsYXlvdXQgc3RydWN0dXJlIG9iamVjdCBpcyBhIG51bWJlciwgYSBnYXAgb2YgdGhhdCBzaXplIHdpbGwgYmVcclxuICAgICAqIGluc2VydGVkLiBUaGUgZ2FwIHdpbGwgYmUgZ2l2ZW4gdGhlIENTUyBjbGFzcyBcImd1YWMta2V5Ym9hcmQtZ2FwXCIsIGFuZFxyXG4gICAgICogd2lsbCBiZSBzY2FsZWQgYWNjb3JkaW5nIHRvIHRoZSBzYW1lIHNpemUgdW5pdHMgYXMgZWFjaCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAgICogICAgIFRoZSBlbGVtZW50IHRvIGFwcGVuZCBlbGVtZW50cyB0by5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd8TnVtYmVyfSBvYmplY3RcclxuICAgICAqICAgICBUaGUgbGF5b3V0IHN0cnVjdHVyZSBvYmplY3QgdG8gdXNlIHdoZW4gY29uc3RydWN0aW5nIHRoZSBlbGVtZW50cyB0b1xyXG4gICAgICogICAgIGFwcGVuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdXHJcbiAgICAgKiAgICAgVGhlIG5hbWUgb2YgdGhlIHRvcC1sZXZlbCBlbGVtZW50IGJlaW5nIGFwcGVuZGVkLCBpZiBhbnkuXHJcbiAgICAgKi9cclxuICAgIHZhciBhcHBlbmRFbGVtZW50cyA9IGZ1bmN0aW9uIGFwcGVuZEVsZW1lbnRzKGVsZW1lbnQsIG9iamVjdCwgbmFtZSkge1xyXG5cclxuICAgICAgICB2YXIgaTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGRpdiB3aGljaCB3aWxsIGJlY29tZSB0aGUgZ3JvdXAgb3Iga2V5XHJcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICAgICAgICAvLyBBZGQgY2xhc3MgYmFzZWQgb24gbmFtZSwgaWYgbmFtZSBnaXZlblxyXG4gICAgICAgIGlmIChuYW1lKVxyXG4gICAgICAgICAgICBhZGRDbGFzcyhkaXYsICdndWFjLWtleWJvYXJkLScgKyBnZXRDU1NOYW1lKG5hbWUpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgYW4gYXJyYXksIGFwcGVuZCBlYWNoIGVsZW1lbnRcclxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBncm91cCBjbGFzc1xyXG4gICAgICAgICAgICBhZGRDbGFzcyhkaXYsICdndWFjLWtleWJvYXJkLWdyb3VwJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgYWxsIGVsZW1lbnRzIG9mIGFycmF5XHJcbiAgICAgICAgICAgIGZvciAoaT0wOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgYXBwZW5kRWxlbWVudHMoZGl2LCBvYmplY3RbaV0pO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIGFuIG9iamVjdCwgYXBwZW5kIGVhY2ggcHJvcGVydHkgdmFsdWVcclxuICAgICAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPYmplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBncm91cCBjbGFzc1xyXG4gICAgICAgICAgICBhZGRDbGFzcyhkaXYsICdndWFjLWtleWJvYXJkLWdyb3VwJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgYWxsIGNoaWxkcmVuLCBzb3J0ZWQgYnkgbmFtZVxyXG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhvYmplY3QpLnNvcnQoKTtcclxuICAgICAgICAgICAgZm9yIChpPTA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcclxuICAgICAgICAgICAgICAgIGFwcGVuZEVsZW1lbnRzKGRpdiwgb2JqZWN0W25hbWVdLCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIGEgbnVtYmVyLCBjcmVhdGUgYXMgYSBnYXAgXHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBnYXAgY2xhc3NcclxuICAgICAgICAgICAgYWRkQ2xhc3MoZGl2LCAnZ3VhYy1rZXlib2FyZC1nYXAnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1haW50YWluIHNjYWxlXHJcbiAgICAgICAgICAgIHNjYWxlZEVsZW1lbnRzLnB1c2gobmV3IFNjYWxlZEVsZW1lbnQoZGl2LCBvYmplY3QsIG9iamVjdCkpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIGEgc3RyaW5nLCBjcmVhdGUgYXMgYSBrZXlcclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYga2V5IG5hbWUgaXMgb25seSBvbmUgY2hhcmFjdGVyLCB1c2UgY29kZXBvaW50IGZvciBuYW1lXHJcbiAgICAgICAgICAgIHZhciBrZXlOYW1lID0gb2JqZWN0O1xyXG4gICAgICAgICAgICBpZiAoa2V5TmFtZS5sZW5ndGggPT09IDEpXHJcbiAgICAgICAgICAgICAgICBrZXlOYW1lID0gJzB4JyArIGtleU5hbWUuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQga2V5IGNvbnRhaW5lciBjbGFzc1xyXG4gICAgICAgICAgICBhZGRDbGFzcyhkaXYsICdndWFjLWtleWJvYXJkLWtleS1jb250YWluZXInKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBrZXkgZWxlbWVudCB3aGljaCB3aWxsIGNvbnRhaW4gYWxsIHBvc3NpYmxlIGNhcHNcclxuICAgICAgICAgICAgdmFyIGtleUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAga2V5RWxlbWVudC5jbGFzc05hbWUgPSAnZ3VhYy1rZXlib2FyZC1rZXkgJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICdndWFjLWtleWJvYXJkLWtleS0nICsgZ2V0Q1NTTmFtZShrZXlOYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBhbGwgYXNzb2NpYXRlZCBrZXlzIGFzIGNhcHMgd2l0aGluIERPTVxyXG4gICAgICAgICAgICB2YXIga2V5cyA9IG9zay5rZXlzW29iamVjdF07XHJcbiAgICAgICAgICAgIGlmIChrZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBjYXAgZWxlbWVudCBmb3Iga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhcEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXBFbGVtZW50LmNsYXNzTmFtZSAgID0gJ2d1YWMta2V5Ym9hcmQtY2FwJztcclxuICAgICAgICAgICAgICAgICAgICBjYXBFbGVtZW50LnRleHRDb250ZW50ID0ga2V5LnRpdGxlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY2xhc3NlcyBmb3IgYW55IHJlcXVpcmVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgaiA8IGtleS5yZXF1aXJlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZW1lbnQgPSBrZXkucmVxdWlyZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGNhcEVsZW1lbnQsICdndWFjLWtleWJvYXJkLXJlcXVpcmVzLScgKyBnZXRDU1NOYW1lKHJlcXVpcmVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGtleUVsZW1lbnQsICdndWFjLWtleWJvYXJkLXVzZXMtJyAgICAgKyBnZXRDU1NOYW1lKHJlcXVpcmVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY2FwIHRvIGtleSB3aXRoaW4gRE9NXHJcbiAgICAgICAgICAgICAgICAgICAga2V5RWxlbWVudC5hcHBlbmRDaGlsZChjYXBFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBrZXkgdG8gRE9NLCBtYWludGFpbiBzY2FsZVxyXG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoa2V5RWxlbWVudCk7XHJcbiAgICAgICAgICAgIHNjYWxlZEVsZW1lbnRzLnB1c2gobmV3IFNjYWxlZEVsZW1lbnQoZGl2LCBvc2subGF5b3V0LmtleVdpZHRoc1tvYmplY3RdIHx8IDEsIDEsIHRydWUpKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGEgdG91Y2ggZXZlbnQgd2hpY2ggcmVzdWx0cyBpbiB0aGUgcHJlc3Npbmcgb2YgYW4gT1NLXHJcbiAgICAgICAgICAgICAqIGtleS4gVG91Y2ggZXZlbnRzIHdpbGwgcmVzdWx0IGluIG1vdXNlIGV2ZW50cyBiZWluZyBpZ25vcmVkIGZvclxyXG4gICAgICAgICAgICAgKiB0b3VjaE1vdXNlVGhyZXNob2xkIGV2ZW50cy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXHJcbiAgICAgICAgICAgICAqICAgICBUaGUgdG91Y2ggZXZlbnQgYmVpbmcgaGFuZGxlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciB0b3VjaFByZXNzID0gZnVuY3Rpb24gdG91Y2hQcmVzcyhlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBpZ25vcmVNb3VzZSA9IG9zay50b3VjaE1vdXNlVGhyZXNob2xkO1xyXG4gICAgICAgICAgICAgICAgcHJlc3Mob2JqZWN0LCBrZXlFbGVtZW50KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGEgdG91Y2ggZXZlbnQgd2hpY2ggcmVzdWx0cyBpbiB0aGUgcmVsZWFzZSBvZiBhbiBPU0tcclxuICAgICAgICAgICAgICoga2V5LiBUb3VjaCBldmVudHMgd2lsbCByZXN1bHQgaW4gbW91c2UgZXZlbnRzIGJlaW5nIGlnbm9yZWQgZm9yXHJcbiAgICAgICAgICAgICAqIHRvdWNoTW91c2VUaHJlc2hvbGQgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcclxuICAgICAgICAgICAgICogICAgIFRoZSB0b3VjaCBldmVudCBiZWluZyBoYW5kbGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIHRvdWNoUmVsZWFzZSA9IGZ1bmN0aW9uIHRvdWNoUmVsZWFzZShlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBpZ25vcmVNb3VzZSA9IG9zay50b3VjaE1vdXNlVGhyZXNob2xkO1xyXG4gICAgICAgICAgICAgICAgcmVsZWFzZShvYmplY3QsIGtleUVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgYSBtb3VzZSBldmVudCB3aGljaCByZXN1bHRzIGluIHRoZSBwcmVzc2luZyBvZiBhbiBPU0tcclxuICAgICAgICAgICAgICoga2V5LiBJZiBtb3VzZSBldmVudHMgYXJlIGN1cnJlbnRseSBiZWluZyBpZ25vcmVkLCB0aGlzIGhhbmRsZXJcclxuICAgICAgICAgICAgICogZG9lcyBub3RoaW5nLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcclxuICAgICAgICAgICAgICogICAgIFRoZSB0b3VjaCBldmVudCBiZWluZyBoYW5kbGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIG1vdXNlUHJlc3MgPSBmdW5jdGlvbiBtb3VzZVByZXNzKGUpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVNb3VzZSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICBwcmVzcyhvYmplY3QsIGtleUVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgYSBtb3VzZSBldmVudCB3aGljaCByZXN1bHRzIGluIHRoZSByZWxlYXNlIG9mIGFuIE9TS1xyXG4gICAgICAgICAgICAgKiBrZXkuIElmIG1vdXNlIGV2ZW50cyBhcmUgY3VycmVudGx5IGJlaW5nIGlnbm9yZWQsIHRoaXMgaGFuZGxlclxyXG4gICAgICAgICAgICAgKiBkb2VzIG5vdGhpbmcuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxyXG4gICAgICAgICAgICAgKiAgICAgVGhlIHRvdWNoIGV2ZW50IGJlaW5nIGhhbmRsZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgbW91c2VSZWxlYXNlID0gZnVuY3Rpb24gbW91c2VSZWxlYXNlKGUpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVNb3VzZSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZWxlYXNlKG9iamVjdCwga2V5RWxlbWVudCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgdG91Y2ggZXZlbnRzIG9uIGtleVxyXG4gICAgICAgICAgICBrZXlFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoUHJlc3MsICAgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGtleUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsICAgdG91Y2hSZWxlYXNlLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtb3VzZSBldmVudHMgb24ga2V5XHJcbiAgICAgICAgICAgIGtleUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBtb3VzZVByZXNzLCAgIHRydWUpO1xyXG4gICAgICAgICAgICBrZXlFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsICAgbW91c2VSZWxlYXNlLCB0cnVlKTtcclxuICAgICAgICAgICAga2V5RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgIG1vdXNlUmVsZWFzZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIH0gLy8gZW5kIGlmIG9iamVjdCBpcyBrZXkgbmFtZVxyXG5cclxuICAgICAgICAvLyBBZGQgbmV3bHktY3JlYXRlZCBncm91cC9rZXlcclxuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGRpdik7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDcmVhdGUga2V5Ym9hcmQgbGF5b3V0IGluIERPTVxyXG4gICAgYXBwZW5kRWxlbWVudHMoa2V5Ym9hcmQsIGxheW91dC5sYXlvdXQpO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGVudGlyZSBvbi1zY3JlZW4ga2V5Ym9hcmQgbGF5b3V0LCBpbmNsdWRpbmcgYWxsIGF2YWlsYWJsZVxyXG4gKiBrZXlzLCB0aGVpciBiZWhhdmlvcnMsIGFuZCB0aGVpciByZWxhdGl2ZSBwb3NpdGlvbiBhbmQgc2l6aW5nLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5MYXlvdXR8T2JqZWN0fSB0ZW1wbGF0ZVxyXG4gKiAgICAgVGhlIG9iamVjdCB3aG9zZSBpZGVudGljYWxseS1uYW1lZCBwcm9wZXJ0aWVzIHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXHJcbiAqICAgICB0aGUgcHJvcGVydGllcyBvZiB0aGlzIGxheW91dC5cclxuICovXHJcbkd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLkxheW91dCA9IGZ1bmN0aW9uKHRlbXBsYXRlKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGFuZ3VhZ2Ugb2Yga2V5Ym9hcmQgbGF5b3V0LCBzdWNoIGFzIFwiZW5fVVNcIi4gVGhpcyBwcm9wZXJ0eSBpcyBmb3JcclxuICAgICAqIGluZm9ybWF0aW9uYWwgcHVycG9zZXMgb25seSwgYnV0IGl0IGlzIHJlY29tbWVuZCB0byBjb25mb3JtIHRvIHRoZVxyXG4gICAgICogW2xhbmd1YWdlIGNvZGVdX1tjb3VudHJ5IGNvZGVdIGZvcm1hdC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhbmd1YWdlID0gdGVtcGxhdGUubGFuZ3VhZ2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHlwZSBvZiBrZXlib2FyZCBsYXlvdXQsIHN1Y2ggYXMgXCJxd2VydHlcIi4gVGhpcyBwcm9wZXJ0eSBpcyBmb3JcclxuICAgICAqIGluZm9ybWF0aW9uYWwgcHVycG9zZXMgb25seSwgYW5kIGRvZXMgbm90IGNvbmZvcm0gdG8gYW55IHN0YW5kYXJkLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHlwZSA9IHRlbXBsYXRlLnR5cGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2Yga2V5IG5hbWUgdG8gY29ycmVzcG9uZGluZyBrZXlzeW0sIHRpdGxlLCBvciBrZXkgb2JqZWN0LiBJZiBvbmx5XHJcbiAgICAgKiB0aGUga2V5c3ltIG9yIHRpdGxlIGlzIHByb3ZpZGVkLCB0aGUga2V5IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWRcclxuICAgICAqIGltcGxpY2l0bHkuIEluIGFsbCBjYXNlcywgdGhlIG5hbWUgcHJvcGVydHkgb2YgdGhlIGtleSBvYmplY3Qgd2lsbCBiZVxyXG4gICAgICogdGFrZW4gZnJvbSB0aGUgbmFtZSBnaXZlbiBpbiB0aGUgbWFwcGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIE51bWJlcnxTdHJpbmd8R3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuS2V5fEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleVtdPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5rZXlzID0gdGVtcGxhdGUua2V5cztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFyYml0cmFyaWx5IG5lc3RlZCwgYXJiaXRyYXJpbHkgZ3JvdXBlZCBrZXkgbmFtZXMuIFRoZSBjb250ZW50cyBvZiB0aGVcclxuICAgICAqIGxheW91dCB3aWxsIGJlIHRyYXZlcnNlZCB0byBwcm9kdWNlIGFuIGlkZW50aWNhbGx5LW5lc3RlZCBncm91cGluZyBvZlxyXG4gICAgICoga2V5cyBpbiB0aGUgRE9NIHRyZWUuIEFsbCBzdHJpbmdzIHdpbGwgYmUgdHJhbnNmb3JtZWQgaW50byB0aGVpclxyXG4gICAgICogY29ycmVzcG9uZGluZyBzZXRzIG9mIGtleXMsIHdoaWxlIGFsbCBvYmplY3RzIGFuZCBhcnJheXMgd2lsbCBiZVxyXG4gICAgICogdHJhbnNmb3JtZWQgaW50byBuYW1lZCBncm91cHMgYW5kIGFub255bW91cyBncm91cHMgcmVzcGVjdGl2ZWx5LiBBbnlcclxuICAgICAqIG51bWJlcnMgcHJlc2VudCB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG8gZ2FwcyBvZiB0aGF0IHNpemUsIHNjYWxlZFxyXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBzYW1lIHVuaXRzIGFzIGVhY2gga2V5LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGF5b3V0ID0gdGVtcGxhdGUubGF5b3V0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBlbnRpcmUga2V5Ym9hcmQsIGluIGFyYml0cmFyeSB1bml0cy4gVGhlIHdpZHRoIG9mIGVhY2hcclxuICAgICAqIGtleSBpcyByZWxhdGl2ZSB0byB0aGlzIHdpZHRoLCBhcyBib3RoIHdpZHRoIHZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSBpblxyXG4gICAgICogdGhlIHNhbWUgdW5pdHMuIFRoZSBjb252ZXJzaW9uIGZhY3RvciBiZXR3ZWVuIHRoZXNlIHVuaXRzIGFuZCBwaXhlbHMgaXNcclxuICAgICAqIGRlcml2ZWQgbGF0ZXIgdmlhIGEgY2FsbCB0byByZXNpemUoKSBvbiB0aGUgR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IHRlbXBsYXRlLndpZHRoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIGVhY2gga2V5LCBpbiBhcmJpdHJhcnkgdW5pdHMsIHJlbGF0aXZlIHRvIG90aGVyIGtleXMgaW5cclxuICAgICAqIHRoaXMgbGF5b3V0LiBUaGUgdHJ1ZSBwaXhlbCBzaXplIG9mIGVhY2gga2V5IHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB0aGVcclxuICAgICAqIG92ZXJhbGwgc2l6ZSBvZiB0aGUga2V5Ym9hcmQuIElmIG5vdCBkZWZpbmVkIGhlcmUsIHRoZSB3aWR0aCBvZiBlYWNoXHJcbiAgICAgKiBrZXkgd2lsbCBkZWZhdWx0IHRvIDEuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge09iamVjdC48U3RyaW5nLCBOdW1iZXI+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmtleVdpZHRocyA9IHRlbXBsYXRlLmtleVdpZHRocyB8fCB7fTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHNpbmdsZSBrZXksIG9yIGEgc2luZ2xlIHBvc3NpYmxlIGJlaGF2aW9yIG9mIGEga2V5LiBFYWNoIGtleVxyXG4gKiBvbiB0aGUgb24tc2NyZWVuIGtleWJvYXJkIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYXNzb2NpYXRlZFxyXG4gKiBHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5LZXksIHdoZXRoZXIgdGhhdCBrZXkgaXMgZXhwbGljaXRseSBkZWZpbmVkIG9yXHJcbiAqIGltcGxpZWQsIGFuZCBtYXkgaGF2ZSBtdWx0aXBsZSBHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5LZXkgaWYgYmVoYXZpb3JcclxuICogZGVwZW5kcyBvbiBtb2RpZmllciBzdGF0ZXMuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleXxPYmplY3R9IHRlbXBsYXRlXHJcbiAqICAgICBUaGUgb2JqZWN0IHdob3NlIGlkZW50aWNhbGx5LW5hbWVkIHByb3BlcnRpZXMgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcclxuICogICAgIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMga2V5LlxyXG4gKiAgICAgXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV1cclxuICogICAgIFRoZSBuYW1lIHRvIHVzZSBpbnN0ZWFkIG9mIGFueSBuYW1lIHByb3ZpZGVkIHdpdGhpbiB0aGUgdGVtcGxhdGUsIGlmXHJcbiAqICAgICBhbnkuIElmIG9taXR0ZWQsIHRoZSBuYW1lIHdpdGhpbiB0aGUgdGVtcGxhdGUgd2lsbCBiZSB1c2VkLCBhc3N1bWluZyB0aGVcclxuICogICAgIHRlbXBsYXRlIGNvbnRhaW5zIGEgbmFtZS5cclxuICovXHJcbkd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleSA9IGZ1bmN0aW9uKHRlbXBsYXRlLCBuYW1lKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdW5pcXVlIG5hbWUgaWRlbnRpZnlpbmcgdGhpcyBrZXkgd2l0aGluIHRoZSBrZXlib2FyZCBsYXlvdXQuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCB0ZW1wbGF0ZS5uYW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGh1bWFuLXJlYWRhYmxlIHRpdGxlIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgd2l0aGluIHRoZVxyXG4gICAgICoga2V5LiBJZiBub3QgcHJvdmlkZWQsIHRoaXMgd2lsbCBiZSBkZXJpdmVkIGZyb20gdGhlIGtleSBuYW1lLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGl0bGUgPSB0ZW1wbGF0ZS50aXRsZSB8fCB0aGlzLm5hbWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUga2V5c3ltIHRvIGJlIHByZXNzZWQvcmVsZWFzZWQgd2hlbiB0aGlzIGtleSBpcyBwcmVzc2VkL3JlbGVhc2VkLiBJZlxyXG4gICAgICogbm90IHByb3ZpZGVkLCB0aGlzIHdpbGwgYmUgZGVyaXZlZCBmcm9tIHRoZSB0aXRsZSBpZiB0aGUgdGl0bGUgaXMgYVxyXG4gICAgICogc2luZ2xlIGNoYXJhY3Rlci5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmtleXN5bSA9IHRlbXBsYXRlLmtleXN5bSB8fCAoZnVuY3Rpb24gZGVyaXZlS2V5c3ltKHRpdGxlKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBkZXJpdmUga2V5c3ltIGlmIHRpdGxlIGlzIG5vdCBleGFjdGx5IG9uZSBjaGFyYWN0ZXJcclxuICAgICAgICBpZiAoIXRpdGxlIHx8IHRpdGxlLmxlbmd0aCAhPT0gMSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIC8vIEZvciBjaGFyYWN0ZXJzIGJldHdlZW4gVSswMDAwIGFuZCBVKzAwRkYsIHRoZSBrZXlzeW0gaXMgdGhlIGNvZGVwb2ludFxyXG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHRpdGxlLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgaWYgKGNoYXJDb2RlID49IDB4MDAwMCAmJiBjaGFyQ29kZSA8PSAweDAwRkYpXHJcbiAgICAgICAgICAgIHJldHVybiBjaGFyQ29kZTtcclxuXHJcbiAgICAgICAgLy8gRm9yIGNoYXJhY3RlcnMgYmV0d2VlbiBVKzAxMDAgYW5kIFUrMTBGRkZGLCB0aGUga2V5c3ltIGlzIHRoZSBjb2RlcG9pbnQgb3InZCB3aXRoIDB4MDEwMDAwMDBcclxuICAgICAgICBpZiAoY2hhckNvZGUgPj0gMHgwMTAwICYmIGNoYXJDb2RlIDw9IDB4MTBGRkZGKVxyXG4gICAgICAgICAgICByZXR1cm4gMHgwMTAwMDAwMCB8IGNoYXJDb2RlO1xyXG5cclxuICAgICAgICAvLyBVbmFibGUgdG8gZGVyaXZlIGtleXN5bVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIH0pKHRoaXMudGl0bGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIG1vZGlmaWVyIHNldCB3aGVuIHRoZSBrZXkgaXMgcHJlc3NlZCBhbmQgY2xlYXJlZCB3aGVuXHJcbiAgICAgKiB0aGlzIGtleSBpcyByZWxlYXNlZCwgaWYgYW55LiBUaGUgbmFtZXMgb2YgbW9kaWZpZXJzIGFyZSBkaXN0aW5jdCBmcm9tXHJcbiAgICAgKiB0aGUgbmFtZXMgb2Yga2V5czsgYm90aCB0aGUgXCJSaWdodFNoaWZ0XCIgYW5kIFwiTGVmdFNoaWZ0XCIga2V5cyBtYXkgc2V0XHJcbiAgICAgKiB0aGUgXCJzaGlmdFwiIG1vZGlmaWVyLCBmb3IgZXhhbXBsZS4gQnkgZGVmYXVsdCwgdGhlIGtleSB3aWxsIGFmZmVjdCBub1xyXG4gICAgICogbW9kaWZpZXJzLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vZGlmaWVyID0gdGVtcGxhdGUubW9kaWZpZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBlYWNoIG1vZGlmaWVyIHJlcXVpcmVkIGZvciB0aGlzIGtleSB0b1xyXG4gICAgICogaGF2ZSBhbiBlZmZlY3QuIEZvciBleGFtcGxlLCBhIGxvd2VyY2FzZSBsZXR0ZXIgbWF5IHJlcXVpcmUgbm90aGluZyxcclxuICAgICAqIHdoaWxlIGFuIHVwcGVyY2FzZSBsZXR0ZXIgd291bGQgcmVxdWlyZSBcInNoaWZ0XCIsIGFzc3VtaW5nIHRoZSBTaGlmdCBrZXlcclxuICAgICAqIGlzIG5hbWVkIFwic2hpZnRcIiB3aXRoaW4gdGhlIGxheW91dC4gQnkgZGVmYXVsdCwgdGhlIGtleSB3aWxsIHJlcXVpcmVcclxuICAgICAqIG5vIG1vZGlmaWVycy5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nW119XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVxdWlyZXMgPSB0ZW1wbGF0ZS5yZXF1aXJlcyB8fCBbXTtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBzdHJlYW0gd2hpY2ggY2FuIHJlY2VpdmUgZGF0YS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5DbGllbnR9IGNsaWVudCBUaGUgY2xpZW50IG93bmluZyB0aGlzIHN0cmVhbS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGlzIHN0cmVhbS5cclxuICovXHJcbkd1YWNhbW9sZS5PdXRwdXRTdHJlYW0gPSBmdW5jdGlvbihjbGllbnQsIGluZGV4KSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBzdHJlYW0uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY19zdHJlYW0gPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoaXMgc3RyZWFtLlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgYW4gYWNrbm93bGVkZ2VtZW50IGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciwgaW5kaWNhdGluZ1xyXG4gICAgICogdGhhdCBhIHN0cmVhbSBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZCwgb3IgYW4gZXJyb3IgaGFzIG9jY3VycmVkLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLlN0YXR1c30gc3RhdHVzIFRoZSBzdGF0dXMgb2YgdGhlIG9wZXJhdGlvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmFjayA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgdGhlIGdpdmVuIGJhc2U2NC1lbmNvZGVkIGRhdGEgdG8gdGhpcyBzdHJlYW0gYXMgYSBibG9iLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBUaGUgYmFzZTY0LWVuY29kZWQgZGF0YSB0byBzZW5kLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmRCbG9iID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIGNsaWVudC5zZW5kQmxvYihndWFjX3N0cmVhbS5pbmRleCwgZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoaXMgc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmRFbmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBjbGllbnQuZW5kU3RyZWFtKGd1YWNfc3RyZWFtLmluZGV4KTtcclxuICAgIH07XHJcblxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogU2ltcGxlIEd1YWNhbW9sZSBwcm90b2NvbCBwYXJzZXIgdGhhdCBpbnZva2VzIGFuIG9uaW5zdHJ1Y3Rpb24gZXZlbnQgd2hlblxyXG4gKiBmdWxsIGluc3RydWN0aW9ucyBhcmUgYXZhaWxhYmxlIGZyb20gZGF0YSByZWNlaXZlZCB2aWEgcmVjZWl2ZSgpLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5HdWFjYW1vbGUuUGFyc2VyID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBwYXJzZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgcGFyc2VyID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgYnVmZmVyIG9mIHJlY2VpdmVkIGRhdGEuIFRoaXMgYnVmZmVyIGdyb3dzIHVudGlsIGEgZnVsbFxyXG4gICAgICogZWxlbWVudCBpcyBhdmFpbGFibGUuIEFmdGVyIGEgZnVsbCBlbGVtZW50IGlzIGF2YWlsYWJsZSwgdGhhdCBlbGVtZW50XHJcbiAgICAgKiBpcyBmbHVzaGVkIGludG8gdGhlIGVsZW1lbnQgYnVmZmVyLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgYnVmZmVyID0gXCJcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1ZmZlciBvZiBhbGwgcmVjZWl2ZWQsIGNvbXBsZXRlIGVsZW1lbnRzLiBBZnRlciBhbiBlbnRpcmUgaW5zdHJ1Y3Rpb25cclxuICAgICAqIGlzIHJlYWQsIHRoaXMgYnVmZmVyIGlzIGZsdXNoZWQsIGFuZCBhIG5ldyBpbnN0cnVjdGlvbiBiZWdpbnMuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBlbGVtZW50X2J1ZmZlciA9IFtdO1xyXG5cclxuICAgIC8vIFRoZSBsb2NhdGlvbiBvZiB0aGUgbGFzdCBlbGVtZW50J3MgdGVybWluYXRvclxyXG4gICAgdmFyIGVsZW1lbnRfZW5kID0gLTE7XHJcblxyXG4gICAgLy8gV2hlcmUgdG8gc3RhcnQgdGhlIG5leHQgbGVuZ3RoIHNlYXJjaCBvciB0aGUgbmV4dCBlbGVtZW50XHJcbiAgICB2YXIgc3RhcnRfaW5kZXggPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gaW5zdHJ1Y3Rpb24gZGF0YSBwYWNrZXQgdG8gdGhlIGludGVybmFsIGJ1ZmZlciBvZlxyXG4gICAgICogdGhpcyBHdWFjYW1vbGUuUGFyc2VyLCBleGVjdXRpbmcgYWxsIGNvbXBsZXRlZCBpbnN0cnVjdGlvbnMgYXRcclxuICAgICAqIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBidWZmZXIsIGlmIGFueS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IFRoZSBpbnN0cnVjdGlvbiBkYXRhIHRvIHJlY2VpdmUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVjZWl2ZSA9IGZ1bmN0aW9uKHBhY2tldCkge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0ZSBidWZmZXIgYXMgbmVjZXNzYXJ5XHJcbiAgICAgICAgaWYgKHN0YXJ0X2luZGV4ID4gNDA5NiAmJiBlbGVtZW50X2VuZCA+PSBzdGFydF9pbmRleCkge1xyXG5cclxuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YnN0cmluZyhzdGFydF9pbmRleCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXNldCBwYXJzZSByZWxhdGl2ZSB0byB0cnVuY2F0aW9uXHJcbiAgICAgICAgICAgIGVsZW1lbnRfZW5kIC09IHN0YXJ0X2luZGV4O1xyXG4gICAgICAgICAgICBzdGFydF9pbmRleCA9IDA7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGRhdGEgdG8gYnVmZmVyXHJcbiAgICAgICAgYnVmZmVyICs9IHBhY2tldDtcclxuXHJcbiAgICAgICAgLy8gV2hpbGUgc2VhcmNoIGlzIHdpdGhpbiBjdXJyZW50bHkgcmVjZWl2ZWQgZGF0YVxyXG4gICAgICAgIHdoaWxlIChlbGVtZW50X2VuZCA8IGJ1ZmZlci5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSB3YWl0aW5nIGZvciBlbGVtZW50IGRhdGFcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnRfZW5kID49IHN0YXJ0X2luZGV4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugbm93IGhhdmUgZW5vdWdoIGRhdGEgZm9yIHRoZSBlbGVtZW50LiBQYXJzZS5cclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gYnVmZmVyLnN1YnN0cmluZyhzdGFydF9pbmRleCwgZWxlbWVudF9lbmQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlcm1pbmF0b3IgPSBidWZmZXIuc3Vic3RyaW5nKGVsZW1lbnRfZW5kLCBlbGVtZW50X2VuZCsxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgZWxlbWVudCB0byBhcnJheVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudF9idWZmZXIucHVzaChlbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBsYXN0IGVsZW1lbnQsIGhhbmRsZSBpbnN0cnVjdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKHRlcm1pbmF0b3IgPT0gXCI7XCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG9wY29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGNvZGUgPSBlbGVtZW50X2J1ZmZlci5zaGlmdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGluc3RydWN0aW9uIGhhbmRsZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5vbmluc3RydWN0aW9uICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5vbmluc3RydWN0aW9uKG9wY29kZSwgZWxlbWVudF9idWZmZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRfYnVmZmVyLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGVybWluYXRvciAhPSAnLCcpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCB0ZXJtaW5hdG9yLlwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBzZWFyY2hpbmcgZm9yIGxlbmd0aCBhdCBjaGFyYWN0ZXIgYWZ0ZXJcclxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgdGVybWluYXRvclxyXG4gICAgICAgICAgICAgICAgc3RhcnRfaW5kZXggPSBlbGVtZW50X2VuZCArIDE7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTZWFyY2ggZm9yIGVuZCBvZiBsZW5ndGhcclxuICAgICAgICAgICAgdmFyIGxlbmd0aF9lbmQgPSBidWZmZXIuaW5kZXhPZihcIi5cIiwgc3RhcnRfaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAobGVuZ3RoX2VuZCAhPSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KGJ1ZmZlci5zdWJzdHJpbmcoZWxlbWVudF9lbmQrMSwgbGVuZ3RoX2VuZCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGxlbmd0aCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLW51bWVyaWMgY2hhcmFjdGVyIGluIGVsZW1lbnQgbGVuZ3RoLlwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgc3RhcnQgb2YgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgc3RhcnRfaW5kZXggPSBsZW5ndGhfZW5kICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgbG9jYXRpb24gb2YgZWxlbWVudCB0ZXJtaW5hdG9yXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50X2VuZCA9IHN0YXJ0X2luZGV4ICsgbGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gSWYgbm8gcGVyaW9kIHlldCwgY29udGludWUgc2VhcmNoIHdoZW4gbW9yZSBkYXRhXHJcbiAgICAgICAgICAgIC8vIGlzIHJlY2VpdmVkXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRfaW5kZXggPSBidWZmZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSAvLyBlbmQgcGFyc2UgbG9vcFxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCBvbmNlIGZvciBldmVyeSBjb21wbGV0ZSBHdWFjYW1vbGUgaW5zdHJ1Y3Rpb24gcmVjZWl2ZWQsIGluIG9yZGVyLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcGNvZGUgVGhlIEd1YWNhbW9sZSBpbnN0cnVjdGlvbiBvcGNvZGUuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIHByb3ZpZGVkIGZvciB0aGUgaW5zdHJ1Y3Rpb24sXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGFueS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmluc3RydWN0aW9uID0gbnVsbDtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIGRlc2NyaXB0aW9uIG9mIHRoZSBmb3JtYXQgb2YgcmF3IFBDTSBhdWRpbywgc3VjaCBhcyB0aGF0IHVzZWQgYnlcclxuICogR3VhY2Ftb2xlLlJhd0F1ZGlvUGxheWVyIGFuZCBHdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlci4gVGhpcyBvYmplY3RcclxuICogZGVzY3JpYmVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgcGVyIHNhbXBsZSwgdGhlIG51bWJlciBvZiBjaGFubmVscywgYW5kIHRoZVxyXG4gKiBvdmVyYWxsIHNhbXBsZSByYXRlLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuUmF3QXVkaW9Gb3JtYXR8T2JqZWN0fSB0ZW1wbGF0ZVxyXG4gKiAgICAgVGhlIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSBjb3BpZWQgaW50byB0aGUgY29ycmVzcG9uZGluZ1xyXG4gKiAgICAgcHJvcGVydGllcyBvZiB0aGUgbmV3IEd1YWNhbW9sZS5SYXdBdWRpb0Zvcm1hdC5cclxuICovXHJcbkd1YWNhbW9sZS5SYXdBdWRpb0Zvcm1hdCA9IGZ1bmN0aW9uIFJhd0F1ZGlvRm9ybWF0KHRlbXBsYXRlKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIGluIGVhY2ggc2FtcGxlIG9mIGF1ZGlvIGRhdGEuIFRoaXMgdmFsdWUgaXNcclxuICAgICAqIGluZGVwZW5kZW50IG9mIHRoZSBudW1iZXIgb2YgY2hhbm5lbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ieXRlc1BlclNhbXBsZSA9IHRlbXBsYXRlLmJ5dGVzUGVyU2FtcGxlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBhdWRpbyBjaGFubmVscyAoaWU6IDEgZm9yIG1vbm8sIDIgZm9yIHN0ZXJlbykuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jaGFubmVscyA9IHRlbXBsYXRlLmNoYW5uZWxzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBzZWNvbmQsIHBlciBjaGFubmVsLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmF0ZSA9IHRlbXBsYXRlLnJhdGU7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gbWltZXR5cGUsIHJldHVybmluZyBhIG5ldyBHdWFjYW1vbGUuUmF3QXVkaW9Gb3JtYXRcclxuICogd2hpY2ggZGVzY3JpYmVzIHRoZSB0eXBlIG9mIHJhdyBhdWRpbyBkYXRhIHJlcHJlc2VudGVkIGJ5IHRoYXQgbWltZXR5cGUuIElmXHJcbiAqIHRoZSBtaW1ldHlwZSBpcyBub3QgYSBzdXBwb3J0ZWQgcmF3IGF1ZGlvIGRhdGEgbWltZXR5cGUsIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gKiAgICAgVGhlIGF1ZGlvIG1pbWV0eXBlIHRvIHBhcnNlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7R3VhY2Ftb2xlLlJhd0F1ZGlvRm9ybWF0fVxyXG4gKiAgICAgQSBuZXcgR3VhY2Ftb2xlLlJhd0F1ZGlvRm9ybWF0IHdoaWNoIGRlc2NyaWJlcyB0aGUgdHlwZSBvZiByYXdcclxuICogICAgIGF1ZGlvIGRhdGEgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIG1pbWV0eXBlLCBvciBudWxsIGlmIHRoZSBnaXZlblxyXG4gKiAgICAgbWltZXR5cGUgaXMgbm90IHN1cHBvcnRlZC5cclxuICovXHJcbkd1YWNhbW9sZS5SYXdBdWRpb0Zvcm1hdC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlRm9ybWF0KG1pbWV0eXBlKSB7XHJcblxyXG4gICAgdmFyIGJ5dGVzUGVyU2FtcGxlO1xyXG5cclxuICAgIC8vIFJhdGUgaXMgYWJzb2x1dGVseSByZXF1aXJlZCAtIGlmIG51bGwgaXMgc3RpbGwgcHJlc2VudCBsYXRlciwgdGhlXHJcbiAgICAvLyBtaW1ldHlwZSBtdXN0IG5vdCBiZSBzdXBwb3J0ZWRcclxuICAgIHZhciByYXRlID0gbnVsbDtcclxuXHJcbiAgICAvLyBEZWZhdWx0IGZvciBib3RoIFwiYXVkaW8vTDhcIiBhbmQgXCJhdWRpby9MMTZcIiBpcyBvbmUgY2hhbm5lbFxyXG4gICAgdmFyIGNoYW5uZWxzID0gMTtcclxuXHJcbiAgICAvLyBcImF1ZGlvL0w4XCIgaGFzIG9uZSBieXRlIHBlciBzYW1wbGVcclxuICAgIGlmIChtaW1ldHlwZS5zdWJzdHJpbmcoMCwgOSkgPT09ICdhdWRpby9MODsnKSB7XHJcbiAgICAgICAgbWltZXR5cGUgPSBtaW1ldHlwZS5zdWJzdHJpbmcoOSk7XHJcbiAgICAgICAgYnl0ZXNQZXJTYW1wbGUgPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFwiYXVkaW8vTDE2XCIgaGFzIHR3byBieXRlcyBwZXIgc2FtcGxlXHJcbiAgICBlbHNlIGlmIChtaW1ldHlwZS5zdWJzdHJpbmcoMCwgMTApID09PSAnYXVkaW8vTDE2OycpIHtcclxuICAgICAgICBtaW1ldHlwZSA9IG1pbWV0eXBlLnN1YnN0cmluZygxMCk7XHJcbiAgICAgICAgYnl0ZXNQZXJTYW1wbGUgPSAyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFsbCBvdGhlciB0eXBlcyBhcmUgdW5zdXBwb3J0ZWRcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAvLyBQYXJzZSBhbGwgcGFyYW1ldGVyc1xyXG4gICAgdmFyIHBhcmFtZXRlcnMgPSBtaW1ldHlwZS5zcGxpdCgnLCcpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgIHZhciBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzW2ldO1xyXG5cclxuICAgICAgICAvLyBBbGwgcGFyYW1ldGVycyBtdXN0IGhhdmUgYW4gZXF1YWxzIHNpZ24gc2VwYXJhdGluZyBuYW1lIGZyb20gdmFsdWVcclxuICAgICAgICB2YXIgZXF1YWxzID0gcGFyYW1ldGVyLmluZGV4T2YoJz0nKTtcclxuICAgICAgICBpZiAoZXF1YWxzID09PSAtMSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIC8vIFBhcnNlIG5hbWUgYW5kIHZhbHVlIGZyb20gcGFyYW1ldGVyIHN0cmluZ1xyXG4gICAgICAgIHZhciBuYW1lICA9IHBhcmFtZXRlci5zdWJzdHJpbmcoMCwgZXF1YWxzKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbWV0ZXIuc3Vic3RyaW5nKGVxdWFscysxKTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGVhY2ggc3VwcG9ydGVkIHBhcmFtZXRlclxyXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gTnVtYmVyIG9mIGF1ZGlvIGNoYW5uZWxzXHJcbiAgICAgICAgICAgIGNhc2UgJ2NoYW5uZWxzJzpcclxuICAgICAgICAgICAgICAgIGNoYW5uZWxzID0gcGFyc2VJbnQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyBTYW1wbGUgcmF0ZVxyXG4gICAgICAgICAgICBjYXNlICdyYXRlJzpcclxuICAgICAgICAgICAgICAgIHJhdGUgPSBwYXJzZUludCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIEFsbCBvdGhlciBwYXJhbWV0ZXJzIGFyZSB1bnN1cHBvcnRlZFxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRoZSByYXRlIHBhcmFtZXRlciBpcyByZXF1aXJlZFxyXG4gICAgaWYgKHJhdGUgPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgLy8gUmV0dXJuIHBhcnNlZCBmb3JtYXQgZGV0YWlsc1xyXG4gICAgcmV0dXJuIG5ldyBHdWFjYW1vbGUuUmF3QXVkaW9Gb3JtYXQoe1xyXG4gICAgICAgIGJ5dGVzUGVyU2FtcGxlIDogYnl0ZXNQZXJTYW1wbGUsXHJcbiAgICAgICAgY2hhbm5lbHMgICAgICAgOiBjaGFubmVscyxcclxuICAgICAgICByYXRlICAgICAgICAgICA6IHJhdGVcclxuICAgIH0pO1xyXG5cclxufTtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgcmVjb3JkaW5nIG9mIGEgR3VhY2Ftb2xlIHNlc3Npb24uIEdpdmVuIGEge0BsaW5rIEd1YWNhbW9sZS5UdW5uZWx9LCB0aGVcclxuICogR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcgYXV0b21hdGljYWxseSBoYW5kbGVzIGluY29taW5nIEd1YWNhbW9sZVxyXG4gKiBpbnN0cnVjdGlvbnMsIHN0b3JpbmcgdGhlbSBmb3IgcGxheWJhY2suIFBsYXliYWNrIG9mIHRoZSByZWNvcmRpbmcgbWF5IGJlXHJcbiAqIGNvbnRyb2xsZWQgdGhyb3VnaCBmdW5jdGlvbiBjYWxscyB0byB0aGUgR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcsIGV2ZW5cclxuICogd2hpbGUgdGhlIHJlY29yZGluZyBoYXMgbm90IHlldCBmaW5pc2hlZCBiZWluZyBjcmVhdGVkIG9yIGRvd25sb2FkZWQuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5UdW5uZWx9IHR1bm5lbFxyXG4gKiAgICAgVGhlIEd1YWNhbW9sZS5UdW5uZWwgZnJvbSB3aGljaCB0aGUgaW5zdHJ1Y3Rpb25zIG9mIHRoZSByZWNvcmRpbmcgc2hvdWxkXHJcbiAqICAgICBiZSByZWFkLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcgPSBmdW5jdGlvbiBTZXNzaW9uUmVjb3JkaW5nKHR1bm5lbCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZ31cclxuICAgICAqL1xyXG4gICAgdmFyIHJlY29yZGluZyA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB3aGljaCBtdXN0IGhhdmUgYmVlbiByZWFkIGJldHdlZW5cclxuICAgICAqIGtleWZyYW1lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgS0VZRlJBTUVfQ0hBUl9JTlRFUlZBTCA9IDE2Mzg0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1pbmltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB3aGljaCBtdXN0IGVsYXBzZSBiZXR3ZWVuIGtleWZyYW1lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgS0VZRlJBTUVfVElNRV9JTlRFUlZBTCA9IDUwMDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byBzcGVuZCBpbiBhbnkgcGFydGljdWxhciBzZWVrIG9wZXJhdGlvblxyXG4gICAgICogYmVmb3JlIHJldHVybmluZyBjb250cm9sIHRvIHRoZSBtYWluIHRocmVhZCwgaW4gbWlsbGlzZWNvbmRzLiBTZWVrXHJcbiAgICAgKiBvcGVyYXRpb25zIGV4Y2VlZGluZyB0aGlzIGFtb3VudCBvZiB0aW1lIHdpbGwgcHJvY2VlZCBhc3luY2hyb25vdXNseS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgTUFYSU1VTV9TRUVLX1RJTUUgPSA1O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsIGZyYW1lcyBwYXJzZWQgZnJvbSB0aGUgcHJvdmlkZWQgdHVubmVsLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcuX0ZyYW1lW119XHJcbiAgICAgKi9cclxuICAgIHZhciBmcmFtZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBpbnN0cnVjdGlvbnMgd2hpY2ggaGF2ZSBiZWVuIHJlYWQgc2luY2UgdGhlIGxhc3QgZnJhbWUgd2FzIGFkZGVkIHRvXHJcbiAgICAgKiB0aGUgZnJhbWVzIGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcuX0ZyYW1lLkluc3RydWN0aW9uW119XHJcbiAgICAgKi9cclxuICAgIHZhciBpbnN0cnVjdGlvbnMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgY2hhcmFjdGVycyB3aGljaCBoYXZlIGJlZW4gcmVhZCBmcm9tIHRoZVxyXG4gICAgICogcHJvdmlkZWQgdHVubmVsIHNpbmNlIHRoZSBsYXN0IGZyYW1lIHdhcyBmbGFnZ2VkIGZvciB1c2UgYXMgYSBrZXlmcmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIGNoYXJhY3RlcnNTaW5jZUxhc3RLZXlmcmFtZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGltZXN0YW1wIG9mIHRoZSBsYXN0IGZyYW1lIHdoaWNoIHdhcyBmbGFnZ2VkIGZvciB1c2UgYXMgYSBrZXlmcmFtZS5cclxuICAgICAqIElmIG5vIHRpbWVzdGFtcCBoYXMgeWV0IGJlZW4gZmxhZ2dlZCwgdGhpcyB3aWxsIGJlIDAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBsYXN0S2V5ZnJhbWVUaW1lc3RhbXAgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVubmVsIHdoaWNoIGZlZWRzIGFyYml0cmFyeSBpbnN0cnVjdGlvbnMgdG8gdGhlIGNsaWVudCB1c2VkIGJ5IHRoaXNcclxuICAgICAqIEd1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nIGZvciBwbGF5YmFjayBvZiB0aGUgc2Vzc2lvbiByZWNvcmRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fUGxheWJhY2tUdW5uZWx9XHJcbiAgICAgKi9cclxuICAgIHZhciBwbGF5YmFja1R1bm5lbCA9IG5ldyBHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fUGxheWJhY2tUdW5uZWwoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEd1YWNhbW9sZS5DbGllbnQgaW5zdGFuY2UgdXNlZCBmb3IgdmlzaWJsZSBwbGF5YmFjayBvZiB0aGUgc2Vzc2lvblxyXG4gICAgICogcmVjb3JkaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLkNsaWVudH1cclxuICAgICAqL1xyXG4gICAgdmFyIHBsYXliYWNrQ2xpZW50ID0gbmV3IEd1YWNhbW9sZS5DbGllbnQocGxheWJhY2tUdW5uZWwpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgZnJhbWUgcmVuZGVyZWQgd2l0aGluIHRoZSBwbGF5YmFjayBjbGllbnQuIElmIG5vIGZyYW1lIGlzXHJcbiAgICAgKiB5ZXQgcmVuZGVyZWQsIHRoaXMgd2lsbCBiZSAtMS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIGN1cnJlbnRGcmFtZSA9IC0xO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRpbWVzdGFtcCBvZiB0aGUgZnJhbWUgd2hlbiBwbGF5YmFjayBiZWdhbiwgaW4gbWlsbGlzZWNvbmRzLiBJZlxyXG4gICAgICogcGxheWJhY2sgaXMgbm90IGluIHByb2dyZXNzLCB0aGlzIHdpbGwgYmUgbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIHN0YXJ0VmlkZW9UaW1lc3RhbXAgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlYWwtd29ybGQgdGltZXN0YW1wIHdoZW4gcGxheWJhY2sgYmVnYW4sIGluIG1pbGxpc2Vjb25kcy4gSWZcclxuICAgICAqIHBsYXliYWNrIGlzIG5vdCBpbiBwcm9ncmVzcywgdGhpcyB3aWxsIGJlIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBzdGFydFJlYWxUaW1lc3RhbXAgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIElEIG9mIHRoZSB0aW1lb3V0IHdoaWNoIHdpbGwgY29udGludWUgdGhlIGluLXByb2dyZXNzIHNlZWtcclxuICAgICAqIG9wZXJhdGlvbi4gSWYgbm8gc2VlayBvcGVyYXRpb24gaXMgaW4gcHJvZ3Jlc3MsIHRoZSBJRCBzdG9yZWQgaGVyZSAoaWZcclxuICAgICAqIGFueSkgd2lsbCBub3QgYmUgdmFsaWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBzZWVrVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLy8gU3RhcnQgcGxheWJhY2sgY2xpZW50IGNvbm5lY3RlZFxyXG4gICAgcGxheWJhY2tDbGllbnQuY29ubmVjdCgpO1xyXG5cclxuICAgIC8vIEhpZGUgY3Vyc29yIHVubGVzcyBtb3VzZSBwb3NpdGlvbiBpcyByZWNlaXZlZFxyXG4gICAgcGxheWJhY2tDbGllbnQuZ2V0RGlzcGxheSgpLnNob3dDdXJzb3IoZmFsc2UpO1xyXG5cclxuICAgIC8vIFJlYWQgaW5zdHJ1Y3Rpb25zIGZyb20gcHJvdmlkZWQgdHVubmVsLCBleHRyYWN0aW5nIGVhY2ggZnJhbWVcclxuICAgIHR1bm5lbC5vbmluc3RydWN0aW9uID0gZnVuY3Rpb24gaGFuZGxlSW5zdHJ1Y3Rpb24ob3Bjb2RlLCBhcmdzKSB7XHJcblxyXG4gICAgICAgIC8vIFN0b3JlIG9wY29kZSBhbmQgYXJndW1lbnRzIGZvciByZWNlaXZlZCBpbnN0cnVjdGlvblxyXG4gICAgICAgIHZhciBpbnN0cnVjdGlvbiA9IG5ldyBHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fRnJhbWUuSW5zdHJ1Y3Rpb24ob3Bjb2RlLCBhcmdzLnNsaWNlKCkpO1xyXG4gICAgICAgIGluc3RydWN0aW9ucy5wdXNoKGluc3RydWN0aW9uKTtcclxuICAgICAgICBjaGFyYWN0ZXJzU2luY2VMYXN0S2V5ZnJhbWUgKz0gaW5zdHJ1Y3Rpb24uZ2V0U2l6ZSgpO1xyXG5cclxuICAgICAgICAvLyBPbmNlIGEgc3luYyBpcyByZWNlaXZlZCwgc3RvcmUgYWxsIGluc3RydWN0aW9ucyBzaW5jZSB0aGUgbGFzdFxyXG4gICAgICAgIC8vIGZyYW1lIGFzIGEgbmV3IGZyYW1lXHJcbiAgICAgICAgaWYgKG9wY29kZSA9PT0gJ3N5bmMnKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBQYXJzZSBmcmFtZSB0aW1lc3RhbXAgZnJvbSBzeW5jIGluc3RydWN0aW9uXHJcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBwYXJzZUludChhcmdzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBhIG5ldyBmcmFtZSBjb250YWluaW5nIHRoZSBpbnN0cnVjdGlvbnMgcmVhZCBzaW5jZSBsYXN0IGZyYW1lXHJcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IG5ldyBHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fRnJhbWUodGltZXN0YW1wLCBpbnN0cnVjdGlvbnMpO1xyXG4gICAgICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGlzIGZyYW1lIHNob3VsZCBldmVudHVhbGx5IGJlY29tZSBhIGtleWZyYW1lIGlmIGVub3VnaCBkYXRhXHJcbiAgICAgICAgICAgIC8vIGhhcyBiZWVuIHByb2Nlc3NlZCBhbmQgZW5vdWdoIHJlY29yZGluZyB0aW1lIGhhcyBlbGFwc2VkLCBvciBpZlxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBhYnNvbHV0ZSBmaXJzdCBmcmFtZVxyXG4gICAgICAgICAgICBpZiAoZnJhbWVzLmxlbmd0aCA9PT0gMSB8fCAoY2hhcmFjdGVyc1NpbmNlTGFzdEtleWZyYW1lID49IEtFWUZSQU1FX0NIQVJfSU5URVJWQUxcclxuICAgICAgICAgICAgICAgICAgICAmJiB0aW1lc3RhbXAgLSBsYXN0S2V5ZnJhbWVUaW1lc3RhbXAgPj0gS0VZRlJBTUVfVElNRV9JTlRFUlZBTCkpIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lLmtleWZyYW1lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGxhc3RLZXlmcmFtZVRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuICAgICAgICAgICAgICAgIGNoYXJhY3RlcnNTaW5jZUxhc3RLZXlmcmFtZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENsZWFyIHNldCBvZiBpbnN0cnVjdGlvbnMgaW4gcHJlcGFyYXRpb24gZm9yIG5leHQgZnJhbWVcclxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gW107XHJcblxyXG4gICAgICAgICAgICAvLyBOb3RpZnkgdGhhdCBhZGRpdGlvbmFsIGNvbnRlbnQgaXMgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGlmIChyZWNvcmRpbmcub25wcm9ncmVzcylcclxuICAgICAgICAgICAgICAgIHJlY29yZGluZy5vbnByb2dyZXNzKHJlY29yZGluZy5nZXREdXJhdGlvbigpKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gYWJzb2x1dGUgdGltZXN0YW1wIHRvIGEgdGltZXN0YW1wIHdoaWNoIGlzIHJlbGF0aXZlXHJcbiAgICAgKiB0byB0aGUgZmlyc3QgZnJhbWUgaW4gdGhlIHJlY29yZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVzdGFtcFxyXG4gICAgICogICAgIFRoZSB0aW1lc3RhbXAgdG8gY29udmVydCB0byBhIHJlbGF0aXZlIHRpbWVzdGFtcC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogICAgIFRoZSBkaWZmZXJlbmNlIGluIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHRoZSBnaXZlbiB0aW1lc3RhbXAgYW5kIHRoZVxyXG4gICAgICogICAgIGZpcnN0IGZyYW1lIG9mIHRoZSByZWNvcmRpbmcsIG9yIHplcm8gaWYgbm8gZnJhbWVzIHlldCBleGlzdC5cclxuICAgICAqL1xyXG4gICAgdmFyIHRvUmVsYXRpdmVUaW1lc3RhbXAgPSBmdW5jdGlvbiB0b1JlbGF0aXZlVGltZXN0YW1wKHRpbWVzdGFtcCkge1xyXG5cclxuICAgICAgICAvLyBJZiBubyBmcmFtZXMgeWV0IGV4aXN0LCBhbGwgdGltZXN0YW1wcyBhcmUgemVyb1xyXG4gICAgICAgIGlmIChmcmFtZXMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRpbWVzdGFtcCByZWxhdGl2ZSB0byBmaXJzdCBmcmFtZVxyXG4gICAgICAgIHJldHVybiB0aW1lc3RhbXAgLSBmcmFtZXNbMF0udGltZXN0YW1wO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2hlcyB0aHJvdWdoIHRoZSBnaXZlbiByZWdpb24gb2YgZnJhbWVzIGZvciB0aGUgZnJhbWUgaGF2aW5nIGFcclxuICAgICAqIHJlbGF0aXZlIHRpbWVzdGFtcCBjbG9zZXN0IHRvIHRoZSB0aW1lc3RhbXAgZ2l2ZW4uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5JbmRleFxyXG4gICAgICogICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZnJhbWUgaW4gdGhlIHJlZ2lvbiAodGhlIGZyYW1lIGhhdmluZyB0aGVcclxuICAgICAqICAgICBzbWFsbGVzdCB0aW1lc3RhbXApLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhJbmRleFxyXG4gICAgICogICAgIFRoZSBpbmRleCBvZiB0aGUgbGFzdCBmcmFtZSBpbiB0aGUgcmVnaW9uICh0aGUgZnJhbWUgaGF2aW5nIHRoZVxyXG4gICAgICogICAgIGxhcmdlc3QgdGltZXN0YW1wKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZXN0YW1wXHJcbiAgICAgKiAgICAgVGhlIHJlbGF0aXZlIHRpbWVzdGFtcCB0byBzZWFyY2ggZm9yLCB3aGVyZSB6ZXJvIGRlbm90ZXMgdGhlIGZpcnN0XHJcbiAgICAgKiAgICAgZnJhbWUgaW4gdGhlIHJlY29yZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogICAgIFRoZSBpbmRleCBvZiB0aGUgZnJhbWUgaGF2aW5nIGEgcmVsYXRpdmUgdGltZXN0YW1wIGNsb3Nlc3QgdG8gdGhlXHJcbiAgICAgKiAgICAgZ2l2ZW4gdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHZhciBmaW5kRnJhbWUgPSBmdW5jdGlvbiBmaW5kRnJhbWUobWluSW5kZXgsIG1heEluZGV4LCB0aW1lc3RhbXApIHtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IHNlYXJjaCBpZiB0aGUgcmVnaW9uIGNvbnRhaW5zIG9ubHkgb25lIGVsZW1lbnRcclxuICAgICAgICBpZiAobWluSW5kZXggPT09IG1heEluZGV4KVxyXG4gICAgICAgICAgICByZXR1cm4gbWluSW5kZXg7XHJcblxyXG4gICAgICAgIC8vIFNwbGl0IHNlYXJjaCByZWdpb24gaW50byB0d28gaGFsdmVzXHJcbiAgICAgICAgdmFyIG1pZEluZGV4ID0gTWF0aC5mbG9vcigobWluSW5kZXggKyBtYXhJbmRleCkgLyAyKTtcclxuICAgICAgICB2YXIgbWlkVGltZXN0YW1wID0gdG9SZWxhdGl2ZVRpbWVzdGFtcChmcmFtZXNbbWlkSW5kZXhdLnRpbWVzdGFtcCk7XHJcblxyXG4gICAgICAgIC8vIElmIHRpbWVzdGFtcCBpcyB3aXRoaW4gbGVzc2VyIGhhbGYsIHNlYXJjaCBhZ2FpbiB3aXRoaW4gdGhhdCBoYWxmXHJcbiAgICAgICAgaWYgKHRpbWVzdGFtcCA8IG1pZFRpbWVzdGFtcCAmJiBtaWRJbmRleCA+IG1pbkluZGV4KVxyXG4gICAgICAgICAgICByZXR1cm4gZmluZEZyYW1lKG1pbkluZGV4LCBtaWRJbmRleCAtIDEsIHRpbWVzdGFtcCk7XHJcblxyXG4gICAgICAgIC8vIElmIHRpbWVzdGFtcCBpcyB3aXRoaW4gZ3JlYXRlciBoYWxmLCBzZWFyY2ggYWdhaW4gd2l0aGluIHRoYXQgaGFsZlxyXG4gICAgICAgIGlmICh0aW1lc3RhbXAgPiBtaWRUaW1lc3RhbXAgJiYgbWlkSW5kZXggPCBtYXhJbmRleClcclxuICAgICAgICAgICAgcmV0dXJuIGZpbmRGcmFtZShtaWRJbmRleCArIDEsIG1heEluZGV4LCB0aW1lc3RhbXApO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGx1Y2tlZCBvdXQgYW5kIGZvdW5kIGEgZnJhbWUgd2l0aCBleGFjdGx5IHRoZVxyXG4gICAgICAgIC8vIGRlc2lyZWQgdGltZXN0YW1wXHJcbiAgICAgICAgcmV0dXJuIG1pZEluZGV4O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYXlzIHRoZSBpbnN0cnVjdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBmcmFtZSwgc2VuZGluZyB0aG9zZVxyXG4gICAgICogaW5zdHJ1Y3Rpb25zIHRvIHRoZSBwbGF5YmFjayBjbGllbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gICAgICogICAgIFRoZSBpbmRleCBvZiB0aGUgZnJhbWUgd2l0aGluIHRoZSBmcmFtZXMgYXJyYXkgd2hpY2ggc2hvdWxkIGJlXHJcbiAgICAgKiAgICAgcmVwbGF5ZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciByZXBsYXlGcmFtZSA9IGZ1bmN0aW9uIHJlcGxheUZyYW1lKGluZGV4KSB7XHJcblxyXG4gICAgICAgIHZhciBmcmFtZSA9IGZyYW1lc1tpbmRleF07XHJcblxyXG4gICAgICAgIC8vIFJlcGxheSBhbGwgaW5zdHJ1Y3Rpb25zIHdpdGhpbiB0aGUgcmV0cmlldmVkIGZyYW1lXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5pbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGluc3RydWN0aW9uID0gZnJhbWUuaW5zdHJ1Y3Rpb25zW2ldO1xyXG4gICAgICAgICAgICBwbGF5YmFja1R1bm5lbC5yZWNlaXZlSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24ub3Bjb2RlLCBpbnN0cnVjdGlvbi5hcmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN0b3JlIGNsaWVudCBzdGF0ZSBpZiBmcmFtZSBpcyBmbGFnZ2VkIGFzIGEga2V5ZnJhbWVcclxuICAgICAgICBpZiAoZnJhbWUua2V5ZnJhbWUgJiYgIWZyYW1lLmNsaWVudFN0YXRlKSB7XHJcbiAgICAgICAgICAgIHBsYXliYWNrQ2xpZW50LmV4cG9ydFN0YXRlKGZ1bmN0aW9uIHN0b3JlQ2xpZW50U3RhdGUoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lLmNsaWVudFN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIHBsYXliYWNrIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBmcmFtZSwgcmVzZXR0aW5nIHRoZSBzdGF0ZSBvZlxyXG4gICAgICogdGhlIHBsYXliYWNrIGNsaWVudCBhbmQgcmVwbGF5aW5nIGZyYW1lcyBhcyBuZWNlc3NhcnkuIFRoZSBzZWVrXHJcbiAgICAgKiBvcGVyYXRpb24gd2lsbCBwcm9jZWVkIGFzeW5jaHJvbm91c2x5LiBJZiBhIHNlZWsgb3BlcmF0aW9uIGlzIGFscmVhZHkgaW5cclxuICAgICAqIHByb2dyZXNzLCB0aGF0IHNlZWsgaXMgZmlyc3QgYWJvcnRlZC4gVGhlIHByb2dyZXNzIG9mIHRoZSBzZWVrIG9wZXJhdGlvblxyXG4gICAgICogY2FuIGJlIG9ic2VydmVkIHRocm91Z2ggdGhlIG9uc2VlayBoYW5kbGVyIGFuZCB0aGUgcHJvdmlkZWQgY2FsbGJhY2suXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gICAgICogICAgIFRoZSBpbmRleCBvZiB0aGUgZnJhbWUgd2hpY2ggc2hvdWxkIGJlY29tZSB0aGUgbmV3IHBsYXliYWNrXHJcbiAgICAgKiAgICAgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAqICAgICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uY2UgdGhlIHNlZWsgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWxheT0wXVxyXG4gICAgICogICAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgdGhlIHNlZWsgb3BlcmF0aW9uIHNob3VsZCBiZVxyXG4gICAgICogICAgIHNjaGVkdWxlZCB0byB0YWtlLlxyXG4gICAgICovXHJcbiAgICB2YXIgc2Vla1RvRnJhbWUgPSBmdW5jdGlvbiBzZWVrVG9GcmFtZShpbmRleCwgY2FsbGJhY2ssIGRlbGF5KSB7XHJcblxyXG4gICAgICAgIC8vIEFib3J0IGFueSBpbi1wcm9ncmVzcyBzZWVrXHJcbiAgICAgICAgYWJvcnRTZWVrKCk7XHJcblxyXG4gICAgICAgIC8vIFJlcGxheSBmcmFtZXMgYXN5bmNocm9ub3VzbHlcclxuICAgICAgICBzZWVrVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uIGNvbnRpbnVlU2VlaygpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4O1xyXG5cclxuICAgICAgICAgICAgLy8gQmFjayB1cCB1bnRpbCBzdGFydEluZGV4IHJlcHJlc2VudHMgY3VycmVudCBzdGF0ZVxyXG4gICAgICAgICAgICBmb3IgKHN0YXJ0SW5kZXggPSBpbmRleDsgc3RhcnRJbmRleCA+PSAwOyBzdGFydEluZGV4LS0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBmcmFtZXNbc3RhcnRJbmRleF07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCB0aGUgY3VycmVudCBmcmFtZSwgc3RhcnRJbmRleCByZXByZXNlbnRzXHJcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHN0YXRlIGJ5IGRlZmluaXRpb25cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSBjdXJyZW50RnJhbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZnJhbWUgaGFzIGFzc29jaWF0ZWQgYWJzb2x1dGUgc3RhdGUsIG1ha2UgdGhhdCBmcmFtZSB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5jbGllbnRTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYXliYWNrQ2xpZW50LmltcG9ydFN0YXRlKGZyYW1lLmNsaWVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gZnJhbWUgaW5kZXggYWZ0ZXIgY3VycmVudCBzdGF0ZVxyXG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXBsYXkgYW55IGFwcGxpY2FibGUgaW5jcmVtZW50YWwgZnJhbWVzXHJcbiAgICAgICAgICAgIGZvciAoOyBzdGFydEluZGV4IDw9IGluZGV4OyBzdGFydEluZGV4KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdG9wIHNlZWtpbmcgaWYgdGhlIG9wZXJhdGlvbiBpcyB0YWtpbmcgdG9vIGxvbmdcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lID49IE1BWElNVU1fU0VFS19USU1FKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlcGxheUZyYW1lKHN0YXJ0SW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDdXJyZW50IGZyYW1lIGlzIG5vdyBhdCByZXF1ZXN0ZWQgaW5kZXhcclxuICAgICAgICAgICAgY3VycmVudEZyYW1lID0gc3RhcnRJbmRleCAtIDE7XHJcblxyXG4gICAgICAgICAgICAvLyBOb3RpZnkgb2YgY2hhbmdlcyBpbiBwb3NpdGlvblxyXG4gICAgICAgICAgICBpZiAocmVjb3JkaW5nLm9uc2VlaylcclxuICAgICAgICAgICAgICAgIHJlY29yZGluZy5vbnNlZWsocmVjb3JkaW5nLmdldFBvc2l0aW9uKCkpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIHNlZWsgb3BlcmF0aW9uIGhhcyBub3QgeWV0IGNvbXBsZXRlZCwgc2NoZWR1bGUgY29udGludWF0aW9uXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUgIT09IGluZGV4KVxyXG4gICAgICAgICAgICAgICAgc2Vla1RvRnJhbWUoaW5kZXgsIGNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGRlbGF5IC0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lKSwgMCkpO1xyXG5cclxuICAgICAgICAgICAgLy8gTm90aWZ5IHRoYXQgdGhlIHJlcXVlc3RlZCBzZWVrIGhhcyBjb21wbGV0ZWRcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgfSwgZGVsYXkgfHwgMCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFib3J0cyB0aGUgc2VlayBvcGVyYXRpb24gY3VycmVudGx5IGluIHByb2dyZXNzLCBpZiBhbnkuIElmIG5vIHNlZWtcclxuICAgICAqIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzcywgdGhpcyBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBhYm9ydFNlZWsgPSBmdW5jdGlvbiBhYm9ydFNlZWsoKSB7XHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChzZWVrVGltZW91dCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWR2YW5jZXMgcGxheWJhY2sgdG8gdGhlIG5leHQgZnJhbWUgaW4gdGhlIGZyYW1lcyBhcnJheSBhbmQgc2NoZWR1bGVzXHJcbiAgICAgKiBwbGF5YmFjayBvZiB0aGUgZnJhbWUgZm9sbG93aW5nIHRoYXQgZnJhbWUgYmFzZWQgb24gdGhlaXIgYXNzb2NpYXRlZFxyXG4gICAgICogdGltZXN0YW1wcy4gSWYgbm8gZnJhbWVzIGV4aXN0IGFmdGVyIHRoZSBuZXh0IGZyYW1lLCBwbGF5YmFjayBpcyBwYXVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGNvbnRpbnVlUGxheWJhY2sgPSBmdW5jdGlvbiBjb250aW51ZVBsYXliYWNrKCkge1xyXG5cclxuICAgICAgICAvLyBJZiBmcmFtZXMgcmVtYWluIGFmdGVyIGFkdmFuY2luZywgc2NoZWR1bGUgbmV4dCBmcmFtZVxyXG4gICAgICAgIGlmIChjdXJyZW50RnJhbWUgKyAxIDwgZnJhbWVzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgLy8gUHVsbCB0aGUgdXBjb21pbmcgZnJhbWVcclxuICAgICAgICAgICAgdmFyIG5leHQgPSBmcmFtZXNbY3VycmVudEZyYW1lICsgMV07XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHJlYWwgdGltZXN0YW1wIGNvcnJlc3BvbmRpbmcgdG8gd2hlbiB0aGUgbmV4dFxyXG4gICAgICAgICAgICAvLyBmcmFtZSBiZWdpbnNcclxuICAgICAgICAgICAgdmFyIG5leHRSZWFsVGltZXN0YW1wID0gbmV4dC50aW1lc3RhbXAgLSBzdGFydFZpZGVvVGltZXN0YW1wICsgc3RhcnRSZWFsVGltZXN0YW1wO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSByZWxhdGl2ZSBkZWxheSBiZXR3ZWVuIHRoZSBjdXJyZW50IHRpbWUgYW5kXHJcbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IGZyYW1lIHN0YXJ0XHJcbiAgICAgICAgICAgIHZhciBkZWxheSA9IE1hdGgubWF4KG5leHRSZWFsVGltZXN0YW1wIC0gbmV3IERhdGUoKS5nZXRUaW1lKCksIDApO1xyXG5cclxuICAgICAgICAgICAgLy8gQWR2YW5jZSB0byBuZXh0IGZyYW1lIGFmdGVyIGVub3VnaCB0aW1lIGhhcyBlbGFwc2VkXHJcbiAgICAgICAgICAgIHNlZWtUb0ZyYW1lKGN1cnJlbnRGcmFtZSArIDEsIGZ1bmN0aW9uIGZyYW1lRGVsYXlFbGFwc2VkKCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWVQbGF5YmFjaygpO1xyXG4gICAgICAgICAgICB9LCBkZWxheSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHN0b3AgcGxheWJhY2tcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJlY29yZGluZy5wYXVzZSgpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIG5ldyBmcmFtZXMgaGF2ZSBiZWNvbWUgYXZhaWxhYmxlIHdoaWxlIHRoZSByZWNvcmRpbmcgaXNcclxuICAgICAqIGJlaW5nIGRvd25sb2FkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb25cclxuICAgICAqICAgICBUaGUgbmV3IGR1cmF0aW9uIG9mIHRoZSByZWNvcmRpbmcsIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbnByb2dyZXNzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHBsYXliYWNrIG9mIHRoZSByZWNvcmRpbmcgaGFzIHN0YXJ0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHRoaXMub25wbGF5ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHBsYXliYWNrIG9mIHRoZSByZWNvcmRpbmcgaGFzIGJlZW4gcGF1c2VkLiBUaGlzIG1heVxyXG4gICAgICogaGFwcGVuIHdoZW4gcGxheWJhY2sgaXMgZXhwbGljaXRseSBwYXVzZWQgd2l0aCBhIGNhbGwgdG8gcGF1c2UoKSwgb3JcclxuICAgICAqIHdoZW4gcGxheWJhY2sgaXMgaW1wbGljaXRseSBwYXVzZWQgZHVlIHRvIHJlYWNoaW5nIHRoZSBlbmQgb2YgdGhlXHJcbiAgICAgKiByZWNvcmRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHRoaXMub25wYXVzZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgcGxheWJhY2sgcG9zaXRpb24gd2l0aGluIHRoZSByZWNvcmRpbmcgY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvblxyXG4gICAgICogICAgIFRoZSBuZXcgcG9zaXRpb24gd2l0aGluIHRoZSByZWNvcmRpbmcsIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbnNlZWsgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgdGhlIHVuZGVybHlpbmcgdHVubmVsLCBiZWdpbm5pbmcgZG93bmxvYWQgb2YgdGhlIEd1YWNhbW9sZVxyXG4gICAgICogc2Vzc2lvbi4gUGxheWJhY2sgb2YgdGhlIEd1YWNhbW9sZSBzZXNzaW9uIGNhbm5vdCBvY2N1ciB1bnRpbCBhdCBsZWFzdFxyXG4gICAgICogb25lIGZyYW1lIHdvcnRoIG9mIGluc3RydWN0aW9ucyBoYXMgYmVlbiBkb3dubG9hZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXHJcbiAgICAgKiAgICAgVGhlIGRhdGEgdG8gc2VuZCB0byB0aGUgdHVubmVsIHdoZW4gY29ubmVjdGluZy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24gY29ubmVjdChkYXRhKSB7XHJcbiAgICAgICAgdHVubmVsLmNvbm5lY3QoZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzY29ubmVjdHMgdGhlIHVuZGVybHlpbmcgdHVubmVsLCBzdG9wcGluZyBmdXJ0aGVyIGRvd25sb2FkIG9mIHRoZVxyXG4gICAgICogR3VhY2Ftb2xlIHNlc3Npb24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XHJcbiAgICAgICAgdHVubmVsLmRpc2Nvbm5lY3QoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGRpc3BsYXkgb2YgdGhlIEd1YWNhbW9sZS5DbGllbnQgdXNlZCBieSB0aGlzXHJcbiAgICAgKiBHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZyBmb3IgcGxheWJhY2suIFRoZSBkaXNwbGF5IGNvbnRhaW5zIGFuIEVsZW1lbnRcclxuICAgICAqIHdoaWNoIGNhbiBiZSBhZGRlZCB0byB0aGUgRE9NLCBjYXVzaW5nIHRoZSBkaXNwbGF5IChhbmQgdGh1cyBwbGF5YmFjayBvZlxyXG4gICAgICogdGhlIHJlY29yZGluZykgdG8gYmVjb21lIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7R3VhY2Ftb2xlLkRpc3BsYXl9XHJcbiAgICAgKiAgICAgVGhlIHVuZGVybHlpbmcgZGlzcGxheSBvZiB0aGUgR3VhY2Ftb2xlLkNsaWVudCB1c2VkIGJ5IHRoaXNcclxuICAgICAqICAgICBHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZyBmb3IgcGxheWJhY2suXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0RGlzcGxheSA9IGZ1bmN0aW9uIGdldERpc3BsYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBsYXliYWNrQ2xpZW50LmdldERpc3BsYXkoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgcGxheWJhY2sgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogICAgIHRydWUgaWYgcGxheWJhY2sgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaXNQbGF5aW5nID0gZnVuY3Rpb24gaXNQbGF5aW5nKCkge1xyXG4gICAgICAgIHJldHVybiAhIXN0YXJ0VmlkZW9UaW1lc3RhbXA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiB3aXRoaW4gdGhlIHJlY29yZGluZywgaW5cclxuICAgICAqIG1pbGxpc2Vjb25kcywgd2hlcmUgemVybyBpcyB0aGUgc3RhcnQgb2YgdGhlIHJlY29yZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogICAgIFRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIHdpdGhpbiB0aGUgcmVjb3JkaW5nLCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbigpIHtcclxuXHJcbiAgICAgICAgLy8gUG9zaXRpb24gaXMgc2ltcGx5IHplcm8gaWYgcGxheWJhY2sgaGFzIG5vdCBzdGFydGVkIGF0IGFsbFxyXG4gICAgICAgIGlmIChjdXJyZW50RnJhbWUgPT09IC0xKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIGN1cnJlbnQgcG9zaXRpb24gYXMgYSBtaWxsaXNlY29uZCB0aW1lc3RhbXAgcmVsYXRpdmUgdG8gdGhlXHJcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIHJlY29yZGluZ1xyXG4gICAgICAgIHJldHVybiB0b1JlbGF0aXZlVGltZXN0YW1wKGZyYW1lc1tjdXJyZW50RnJhbWVdLnRpbWVzdGFtcCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGR1cmF0aW9uIG9mIHRoaXMgcmVjb3JkaW5nLCBpbiBtaWxsaXNlY29uZHMuIElmIHRoZVxyXG4gICAgICogcmVjb3JkaW5nIGlzIHN0aWxsIGJlaW5nIGRvd25sb2FkZWQsIHRoaXMgdmFsdWUgd2lsbCBncmFkdWFsbHkgaW5jcmVhc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqICAgICBUaGUgZHVyYXRpb24gb2YgdGhpcyByZWNvcmRpbmcsIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uIGdldER1cmF0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBJZiBubyBmcmFtZXMgeWV0IGV4aXN0LCBkdXJhdGlvbiBpcyB6ZXJvXHJcbiAgICAgICAgaWYgKGZyYW1lcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG5cclxuICAgICAgICAvLyBSZWNvcmRpbmcgZHVyYXRpb24gaXMgc2ltcGx5IHRoZSB0aW1lc3RhbXAgb2YgdGhlIGxhc3QgZnJhbWVcclxuICAgICAgICByZXR1cm4gdG9SZWxhdGl2ZVRpbWVzdGFtcChmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdLnRpbWVzdGFtcCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJlZ2lucyBjb250aW51b3VzIHBsYXliYWNrIG9mIHRoZSByZWNvcmRpbmcgZG93bmxvYWRlZCB0aHVzIGZhci5cclxuICAgICAqIFBsYXliYWNrIG9mIHRoZSByZWNvcmRpbmcgd2lsbCBjb250aW51ZSB1bnRpbCBwYXVzZSgpIGlzIGludm9rZWQgb3JcclxuICAgICAqIHVudGlsIG5vIGZ1cnRoZXIgZnJhbWVzIGV4aXN0LiBQbGF5YmFjayBpcyBpbml0aWFsbHkgcGF1c2VkIHdoZW4gYVxyXG4gICAgICogR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcgaXMgY3JlYXRlZCwgYW5kIG11c3QgYmUgZXhwbGljaXRseSBzdGFydGVkXHJcbiAgICAgKiB0aHJvdWdoIGEgY2FsbCB0byB0aGlzIGZ1bmN0aW9uLiBJZiBwbGF5YmFjayBpcyBhbHJlYWR5IGluIHByb2dyZXNzLFxyXG4gICAgICogdGhpcyBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0LiBJZiBhIHNlZWsgb3BlcmF0aW9uIGlzIGluIHByb2dyZXNzLFxyXG4gICAgICogcGxheWJhY2sgcmVzdW1lcyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoZSBzZWVrIGlzIGFib3J0ZWQgYXMgaWZcclxuICAgICAqIGNvbXBsZXRlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5wbGF5ID0gZnVuY3Rpb24gcGxheSgpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgcGxheWJhY2sgaXMgbm90IGFscmVhZHkgaW4gcHJvZ3Jlc3MgYW5kIGZyYW1lcyByZW1haW4sXHJcbiAgICAgICAgLy8gYmVnaW4gcGxheWJhY2tcclxuICAgICAgICBpZiAoIXJlY29yZGluZy5pc1BsYXlpbmcoKSAmJiBjdXJyZW50RnJhbWUgKyAxIDwgZnJhbWVzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgLy8gTm90aWZ5IHRoYXQgcGxheWJhY2sgaXMgc3RhcnRpbmdcclxuICAgICAgICAgICAgaWYgKHJlY29yZGluZy5vbnBsYXkpXHJcbiAgICAgICAgICAgICAgICByZWNvcmRpbmcub25wbGF5KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdG9yZSB0aW1lc3RhbXAgb2YgcGxheWJhY2sgc3RhcnQgZm9yIHJlbGF0aXZlIHNjaGVkdWxpbmcgb2ZcclxuICAgICAgICAgICAgLy8gZnV0dXJlIGZyYW1lc1xyXG4gICAgICAgICAgICB2YXIgbmV4dCA9IGZyYW1lc1tjdXJyZW50RnJhbWUgKyAxXTtcclxuICAgICAgICAgICAgc3RhcnRWaWRlb1RpbWVzdGFtcCA9IG5leHQudGltZXN0YW1wO1xyXG4gICAgICAgICAgICBzdGFydFJlYWxUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJlZ2luIHBsYXliYWNrIG9mIHZpZGVvXHJcbiAgICAgICAgICAgIGNvbnRpbnVlUGxheWJhY2soKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWVrcyB0byB0aGUgZ2l2ZW4gcG9zaXRpb24gd2l0aGluIHRoZSByZWNvcmRpbmcuIElmIHRoZSByZWNvcmRpbmcgaXNcclxuICAgICAqIGN1cnJlbnRseSBiZWluZyBwbGF5ZWQgYmFjaywgcGxheWJhY2sgd2lsbCBjb250aW51ZSBhZnRlciB0aGUgc2VlayBpc1xyXG4gICAgICogcGVyZm9ybWVkLiBJZiB0aGUgcmVjb3JkaW5nIGlzIGN1cnJlbnRseSBwYXVzZWQsIHBsYXliYWNrIHdpbGwgYmVcclxuICAgICAqIHBhdXNlZCBhZnRlciB0aGUgc2VlayBpcyBwZXJmb3JtZWQuIElmIGEgc2VlayBvcGVyYXRpb24gaXMgYWxyZWFkeSBpblxyXG4gICAgICogcHJvZ3Jlc3MsIHRoYXQgc2VlayBpcyBmaXJzdCBhYm9ydGVkLiBUaGUgc2VlayBvcGVyYXRpb24gd2lsbCBwcm9jZWVkXHJcbiAgICAgKiBhc3luY2hyb25vdXNseS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25cclxuICAgICAqICAgICBUaGUgcG9zaXRpb24gd2l0aGluIHRoZSByZWNvcmRpbmcgdG8gc2VlayB0bywgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja11cclxuICAgICAqICAgICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uY2UgdGhlIHNlZWsgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VlayA9IGZ1bmN0aW9uIHNlZWsocG9zaXRpb24sIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBzZWVrIGlmIG5vIGZyYW1lcyBleGlzdFxyXG4gICAgICAgIGlmIChmcmFtZXMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIFBhdXNlIHBsYXliYWNrLCBwcmVzZXJ2aW5nIHBsYXliYWNrIHN0YXRlXHJcbiAgICAgICAgdmFyIG9yaWdpbmFsbHlQbGF5aW5nID0gcmVjb3JkaW5nLmlzUGxheWluZygpO1xyXG4gICAgICAgIHJlY29yZGluZy5wYXVzZSgpO1xyXG5cclxuICAgICAgICAvLyBQZXJmb3JtIHNlZWtcclxuICAgICAgICBzZWVrVG9GcmFtZShmaW5kRnJhbWUoMCwgZnJhbWVzLmxlbmd0aCAtIDEsIHBvc2l0aW9uKSwgZnVuY3Rpb24gcmVzdG9yZVBsYXliYWNrU3RhdGUoKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXN0b3JlIHBsYXliYWNrIHN0YXRlXHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbGx5UGxheWluZylcclxuICAgICAgICAgICAgICAgIHJlY29yZGluZy5wbGF5KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBOb3RpZnkgdGhhdCBzZWVrIGhhcyBjb21wbGV0ZWRcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhdXNlcyBwbGF5YmFjayBvZiB0aGUgcmVjb3JkaW5nLCBpZiBwbGF5YmFjayBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXHJcbiAgICAgKiBJZiBwbGF5YmFjayBpcyBub3QgaW4gcHJvZ3Jlc3MsIHRoaXMgZnVuY3Rpb24gaGFzIG5vIGVmZmVjdC4gSWYgYSBzZWVrXHJcbiAgICAgKiBvcGVyYXRpb24gaXMgaW4gcHJvZ3Jlc3MsIHRoZSBzZWVrIGlzIGFib3J0ZWQuIFBsYXliYWNrIGlzIGluaXRpYWxseVxyXG4gICAgICogcGF1c2VkIHdoZW4gYSBHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZyBpcyBjcmVhdGVkLCBhbmQgbXVzdCBiZVxyXG4gICAgICogZXhwbGljaXRseSBzdGFydGVkIHRocm91Z2ggYSBjYWxsIHRvIHBsYXkoKS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xyXG5cclxuICAgICAgICAvLyBBYm9ydCBhbnkgaW4tcHJvZ3Jlc3Mgc2VlayAvIHBsYXliYWNrXHJcbiAgICAgICAgYWJvcnRTZWVrKCk7XHJcblxyXG4gICAgICAgIC8vIFN0b3AgcGxheWJhY2sgb25seSBpZiBwbGF5YmFjayBpcyBpbiBwcm9ncmVzc1xyXG4gICAgICAgIGlmIChyZWNvcmRpbmcuaXNQbGF5aW5nKCkpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vdGlmeSB0aGF0IHBsYXliYWNrIGlzIHN0b3BwaW5nXHJcbiAgICAgICAgICAgIGlmIChyZWNvcmRpbmcub25wYXVzZSlcclxuICAgICAgICAgICAgICAgIHJlY29yZGluZy5vbnBhdXNlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBQbGF5YmFjayBpcyBzdG9wcGVkXHJcbiAgICAgICAgICAgIHN0YXJ0VmlkZW9UaW1lc3RhbXAgPSBudWxsO1xyXG4gICAgICAgICAgICBzdGFydFJlYWxUaW1lc3RhbXAgPSBudWxsO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQSBzaW5nbGUgZnJhbWUgb2YgR3VhY2Ftb2xlIHNlc3Npb24gZGF0YS4gRWFjaCBmcmFtZSBpcyBtYWRlIHVwIG9mIHRoZSBzZXRcclxuICogb2YgaW5zdHJ1Y3Rpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhhdCBmcmFtZSwgYW5kIHRoZSB0aW1lc3RhbXAgYXMgZGljdGF0ZWRcclxuICogYnkgdGhlIFwic3luY1wiIGluc3RydWN0aW9uIHRlcm1pbmF0aW5nIHRoZSBmcmFtZS4gT3B0aW9uYWxseSwgYSBmcmFtZSBtYXlcclxuICogYWxzbyBiZSBhc3NvY2lhdGVkIHdpdGggYSBzbmFwc2hvdCBvZiBHdWFjYW1vbGUgY2xpZW50IHN0YXRlLCBzdWNoIHRoYXQgdGhlXHJcbiAqIGZyYW1lIGNhbiBiZSByZW5kZXJlZCB3aXRob3V0IHJlcGxheWluZyBhbGwgcHJldmlvdXMgZnJhbWVzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVzdGFtcFxyXG4gKiAgICAgVGhlIHRpbWVzdGFtcCBvZiB0aGlzIGZyYW1lLCBhcyBkaWN0YXRlZCBieSB0aGUgXCJzeW5jXCIgaW5zdHJ1Y3Rpb24gd2hpY2hcclxuICogICAgIHRlcm1pbmF0ZXMgdGhlIGZyYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLl9GcmFtZS5JbnN0cnVjdGlvbltdfSBpbnN0cnVjdGlvbnNcclxuICogICAgIEFsbCBpbnN0cnVjdGlvbnMgd2hpY2ggYXJlIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aGlzIGZyYW1lIHJlbGF0aXZlIHRvXHJcbiAqICAgICB0aGUgcHJldmlvdXMgZnJhbWUgaW4gdGhlIEd1YWNhbW9sZSBzZXNzaW9uLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcuX0ZyYW1lID0gZnVuY3Rpb24gX0ZyYW1lKHRpbWVzdGFtcCwgaW5zdHJ1Y3Rpb25zKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgZnJhbWUgc2hvdWxkIGJlIHVzZWQgYXMgYSBrZXlmcmFtZSBpZiBwb3NzaWJsZS4gVGhpcyB2YWx1ZVxyXG4gICAgICogaXMgcHVyZWx5IGFkdmlzb3J5LiBUaGUgc3RvcmVkIGNsaWVudFN0YXRlIG11c3QgZXZlbnR1YWxseSBiZSBtYW51YWxseVxyXG4gICAgICogc2V0IGZvciB0aGUgZnJhbWUgdG8gYmUgdXNlZCBhcyBhIGtleWZyYW1lLiBCeSBkZWZhdWx0LCBmcmFtZXMgYXJlIG5vdFxyXG4gICAgICoga2V5ZnJhbWVzLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5rZXlmcmFtZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRpbWVzdGFtcCBvZiB0aGlzIGZyYW1lLCBhcyBkaWN0YXRlZCBieSB0aGUgXCJzeW5jXCIgaW5zdHJ1Y3Rpb24gd2hpY2hcclxuICAgICAqIHRlcm1pbmF0ZXMgdGhlIGZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsIGluc3RydWN0aW9ucyB3aGljaCBhcmUgbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRoaXMgZnJhbWUgcmVsYXRpdmUgdG9cclxuICAgICAqIHRoZSBwcmV2aW91cyBmcmFtZSBpbiB0aGUgR3VhY2Ftb2xlIHNlc3Npb24uXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLl9GcmFtZS5JbnN0cnVjdGlvbltdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc25hcHNob3Qgb2YgY2xpZW50IHN0YXRlIGFmdGVyIHRoaXMgZnJhbWUgd2FzIHJlbmRlcmVkLCBhcyByZXR1cm5lZCBieVxyXG4gICAgICogYSBjYWxsIHRvIGV4cG9ydFN0YXRlKCkuIElmIG5vIHN1Y2ggc25hcHNob3QgaGFzIGJlZW4gdGFrZW4sIHRoaXMgd2lsbFxyXG4gICAgICogYmUgbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaWVudFN0YXRlID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQSBHdWFjYW1vbGUgcHJvdG9jb2wgaW5zdHJ1Y3Rpb24uIEVhY2ggR3VhY2Ftb2xlIHByb3RvY29sIGluc3RydWN0aW9uIGlzXHJcbiAqIG1hZGUgdXAgb2YgYW4gb3Bjb2RlIGFuZCBzZXQgb2YgYXJndW1lbnRzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtTdHJpbmd9IG9wY29kZVxyXG4gKiAgICAgVGhlIG9wY29kZSBvZiB0aGlzIEd1YWNhbW9sZSBpbnN0cnVjdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmdbXX0gYXJnc1xyXG4gKiAgICAgQWxsIGFyZ3VtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBHdWFjYW1vbGUgaW5zdHJ1Y3Rpb24uXHJcbiAqL1xyXG5HdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fRnJhbWUuSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiBJbnN0cnVjdGlvbihvcGNvZGUsIGFyZ3MpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIEd1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLl9GcmFtZS5JbnN0cnVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLl9GcmFtZS5JbnN0cnVjdGlvbn1cclxuICAgICAqL1xyXG4gICAgdmFyIGluc3RydWN0aW9uID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGNvZGUgb2YgdGhpcyBHdWFjYW1vbGUgaW5zdHJ1Y3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcGNvZGUgPSBvcGNvZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgYXJndW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEd1YWNhbW9sZSBpbnN0cnVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nW119XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXJncyA9IGFyZ3M7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgY2hhcmFjdGVycyB3aGljaCBtYWtlIHVwIHRoaXNcclxuICAgICAqIGluc3RydWN0aW9uLiBUaGlzIHZhbHVlIGlzIG9ubHkgYXBwcm94aW1hdGUgYXMgaXQgZXhjbHVkZXMgdGhlIGxlbmd0aFxyXG4gICAgICogcHJlZml4ZXMgYW5kIHZhcmlvdXMgZGVsaW1pdGVycyB1c2VkIGJ5IHRoZSBHdWFjYW1vbGUgcHJvdG9jb2w7IG9ubHlcclxuICAgICAqIHRoZSBjb250ZW50IG9mIHRoZSBvcGNvZGUgYW5kIGVhY2ggYXJndW1lbnQgaXMgdGFrZW4gaW50byBhY2NvdW50LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiAgICAgVGhlIGFwcHJveGltYXRlIHNpemUgb2YgdGhpcyBpbnN0cnVjdGlvbiwgaW4gY2hhcmFjdGVycy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZSgpIHtcclxuXHJcbiAgICAgICAgLy8gSW5pdCB3aXRoIGxlbmd0aCBvZiBvcGNvZGVcclxuICAgICAgICB2YXIgc2l6ZSA9IGluc3RydWN0aW9uLm9wY29kZS5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIEFkZCBsZW5ndGggb2YgYWxsIGFyZ3VtZW50c1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb24uYXJncy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgc2l6ZSArPSBpbnN0cnVjdGlvbi5hcmdzW2ldLmxlbmd0aDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNpemU7XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQSByZWFkLW9ubHkgR3VhY2Ftb2xlLlR1bm5lbCBpbXBsZW1lbnRhdGlvbiB3aGljaCBzdHJlYW1zIGluc3RydWN0aW9uc1xyXG4gKiByZWNlaXZlZCB0aHJvdWdoIGV4cGxpY2l0IGNhbGxzIHRvIGl0cyByZWNlaXZlSW5zdHJ1Y3Rpb24oKSBmdW5jdGlvbi5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdWdtZW50cyB7R3VhY2Ftb2xlLlR1bm5lbH1cclxuICovXHJcbkd1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLl9QbGF5YmFja1R1bm5lbCA9IGZ1bmN0aW9uIF9QbGF5YmFja1R1bm5lbCgpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIEd1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLl9QbGF5YmFja1R1bm5lbC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLl9QbGF5YmFja1R1bm5lbH1cclxuICAgICAqL1xyXG4gICAgdmFyIHR1bm5lbCA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24gY29ubmVjdChkYXRhKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZ1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gc2VuZE1lc3NhZ2UoZWxlbWVudHMpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZ1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhpcyB0dW5uZWwncyBvbmluc3RydWN0aW9uIGhhbmRsZXIsIG5vdGlmeWluZyB1c2VycyBvZiB0aGlzXHJcbiAgICAgKiB0dW5uZWwgKHN1Y2ggYXMgYSBHdWFjYW1vbGUuQ2xpZW50IGluc3RhbmNlKSB0aGF0IGFuIGluc3RydWN0aW9uIGhhc1xyXG4gICAgICogYmVlbiByZWNlaXZlZC4gSWYgdGhlIG9uaW5zdHJ1Y3Rpb24gaGFuZGxlciBoYXMgbm90IGJlZW4gc2V0LCB0aGlzXHJcbiAgICAgKiBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcGNvZGVcclxuICAgICAqICAgICBUaGUgb3Bjb2RlIG9mIHRoZSBHdWFjYW1vbGUgaW5zdHJ1Y3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gYXJnc1xyXG4gICAgICogICAgIEFsbCBhcmd1bWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgR3VhY2Ftb2xlIGluc3RydWN0aW9uLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlY2VpdmVJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIHJlY2VpdmVJbnN0cnVjdGlvbihvcGNvZGUsIGFyZ3MpIHtcclxuICAgICAgICBpZiAodHVubmVsLm9uaW5zdHJ1Y3Rpb24pXHJcbiAgICAgICAgICAgIHR1bm5lbC5vbmluc3RydWN0aW9uKG9wY29kZSwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxufTtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgR3VhY2Ftb2xlIHN0YXR1cy4gRWFjaCBHdWFjYW1vbGUgc3RhdHVzIGNvbnNpc3RzIG9mIGEgc3RhdHVzIGNvZGUsIGRlZmluZWRcclxuICogYnkgdGhlIHByb3RvY29sLCBhbmQgYW4gb3B0aW9uYWwgaHVtYW4tcmVhZGFibGUgbWVzc2FnZSwgdXN1YWxseSBvbmx5XHJcbiAqIGluY2x1ZGVkIGZvciBkZWJ1Z2dpbmcgY29udmVuaWVuY2UuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVxyXG4gKiAgICAgVGhlIEd1YWNhbW9sZSBzdGF0dXMgY29kZSwgYXMgZGVmaW5lZCBieSBHdWFjYW1vbGUuU3RhdHVzLkNvZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV1cclxuICogICAgIEFuIG9wdGlvbmFsIGh1bWFuLXJlYWRhYmxlIG1lc3NhZ2UuXHJcbiAqL1xyXG5HdWFjYW1vbGUuU3RhdHVzID0gZnVuY3Rpb24oY29kZSwgbWVzc2FnZSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLlN0YXR1cy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX3N0YXR1cyA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgR3VhY2Ftb2xlIHN0YXR1cyBjb2RlLlxyXG4gICAgICogQHNlZSBHdWFjYW1vbGUuU3RhdHVzLkNvZGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcmJpdHJhcnkgaHVtYW4tcmVhZGFibGUgbWVzc2FnZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGF0dXMsIGlmIGFueS5cclxuICAgICAqIFRoZSBodW1hbi1yZWFkYWJsZSBtZXNzYWdlIGlzIG5vdCByZXF1aXJlZCwgYW5kIGlzIGdlbmVyYWxseSBwcm92aWRlZFxyXG4gICAgICogZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBvbmx5LiBGb3IgdXNlciBmZWVkYmFjaywgaXQgaXMgYmV0dGVyIHRvIHRyYW5zbGF0ZVxyXG4gICAgICogdGhlIEd1YWNhbW9sZSBzdGF0dXMgY29kZSBpbnRvIGEgbWVzc2FnZS5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIHN0YXR1cyByZXByZXNlbnRzIGFuIGVycm9yLlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBzdGF0dXMgcmVwcmVzZW50cyBhbiBlcnJvciwgZmFsc2VcclxuICAgICAqICAgICAgICAgICAgICAgICAgICBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaXNFcnJvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBndWFjX3N0YXR1cy5jb2RlIDwgMCB8fCBndWFjX3N0YXR1cy5jb2RlID4gMHgwMEZGO1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogRW51bWVyYXRpb24gb2YgYWxsIEd1YWNhbW9sZSBzdGF0dXMgY29kZXMuXHJcbiAqL1xyXG5HdWFjYW1vbGUuU3RhdHVzLkNvZGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BlcmF0aW9uIHN1Y2NlZWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIlNVQ0NFU1NcIjogMHgwMDAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlcXVlc3RlZCBvcGVyYXRpb24gaXMgdW5zdXBwb3J0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJVTlNVUFBPUlRFRFwiOiAweDAxMDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgZHVlIHRvIGFuIGludGVybmFsIGZhaWx1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJTRVJWRVJfRVJST1JcIjogMHgwMjAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGFzIHRoZSBzZXJ2ZXIgaXMgYnVzeS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIlNFUlZFUl9CVVNZXCI6IDB4MDIwMSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gY291bGQgbm90IGJlIHBlcmZvcm1lZCBiZWNhdXNlIHRoZSB1cHN0cmVhbSBzZXJ2ZXIgaXMgbm90XHJcbiAgICAgKiByZXNwb25kaW5nLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiVVBTVFJFQU1fVElNRU9VVFwiOiAweDAyMDIsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BlcmF0aW9uIHdhcyB1bnN1Y2Nlc3NmdWwgZHVlIHRvIGFuIGVycm9yIG9yIG90aGVyd2lzZSB1bmV4cGVjdGVkXHJcbiAgICAgKiBjb25kaXRpb24gb2YgdGhlIHVwc3RyZWFtIHNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIlVQU1RSRUFNX0VSUk9SXCI6IDB4MDIwMyxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gY291bGQgbm90IGJlIHBlcmZvcm1lZCBhcyB0aGUgcmVxdWVzdGVkIHJlc291cmNlIGRvZXMgbm90XHJcbiAgICAgKiBleGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIlJFU09VUkNFX05PVF9GT1VORFwiOiAweDAyMDQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgYXMgdGhlIHJlcXVlc3RlZCByZXNvdXJjZSBpc1xyXG4gICAgICogYWxyZWFkeSBpbiB1c2UuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJSRVNPVVJDRV9DT05GTElDVFwiOiAweDAyMDUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgYXMgdGhlIHJlcXVlc3RlZCByZXNvdXJjZSBpcyBub3dcclxuICAgICAqIGNsb3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIlJFU09VUkNFX0NMT1NFRFwiOiAweDAyMDYsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgYmVjYXVzZSB0aGUgdXBzdHJlYW0gc2VydmVyIGRvZXNcclxuICAgICAqIG5vdCBhcHBlYXIgdG8gZXhpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJVUFNUUkVBTV9OT1RfRk9VTkRcIjogMHgwMjA3LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGJlY2F1c2UgdGhlIHVwc3RyZWFtIHNlcnZlciBpcyBub3RcclxuICAgICAqIGF2YWlsYWJsZSB0byBzZXJ2aWNlIHRoZSByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiVVBTVFJFQU1fVU5BVkFJTEFCTEVcIjogMHgwMjA4LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNlc3Npb24gd2l0aGluIHRoZSB1cHN0cmVhbSBzZXJ2ZXIgaGFzIGVuZGVkIGJlY2F1c2UgaXQgY29uZmxpY3RlZFxyXG4gICAgICogd2l0aCBhbm90aGVyIHNlc3Npb24uXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJTRVNTSU9OX0NPTkZMSUNUXCI6IDB4MDIwOSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXNzaW9uIHdpdGhpbiB0aGUgdXBzdHJlYW0gc2VydmVyIGhhcyBlbmRlZCBiZWNhdXNlIGl0IGFwcGVhcmVkIHRvXHJcbiAgICAgKiBiZSBpbmFjdGl2ZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIlNFU1NJT05fVElNRU9VVFwiOiAweDAyMEEsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2Vzc2lvbiB3aXRoaW4gdGhlIHVwc3RyZWFtIHNlcnZlciBoYXMgYmVlbiBmb3JjaWJseSB0ZXJtaW5hdGVkLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiU0VTU0lPTl9DTE9TRURcIjogMHgwMjBCLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGJlY2F1c2UgYmFkIHBhcmFtZXRlcnMgd2VyZSBnaXZlbi5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIkNMSUVOVF9CQURfUkVRVUVTVFwiOiAweDAzMDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJtaXNzaW9uIHdhcyBkZW5pZWQgdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLCBhcyB0aGUgdXNlciBpcyBub3QgeWV0XHJcbiAgICAgKiBhdXRob3JpemVkIChub3QgeWV0IGxvZ2dlZCBpbiwgZm9yIGV4YW1wbGUpLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiQ0xJRU5UX1VOQVVUSE9SSVpFRFwiOiAweDAzMDEsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJtaXNzaW9uIHdhcyBkZW5pZWQgdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLCBhbmQgdGhpcyBwZXJtaXNzaW9uIHdpbGxcclxuICAgICAqIG5vdCBiZSBncmFudGVkIGV2ZW4gaWYgdGhlIHVzZXIgaXMgYXV0aG9yaXplZC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIkNMSUVOVF9GT1JCSURERU5cIjogMHgwMzAzLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNsaWVudCB0b29rIHRvbyBsb25nIHRvIHJlc3BvbmQuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJDTElFTlRfVElNRU9VVFwiOiAweDAzMDgsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2xpZW50IHNlbnQgdG9vIG11Y2ggZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIkNMSUVOVF9PVkVSUlVOXCI6IDB4MDMwRCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjbGllbnQgc2VudCBkYXRhIG9mIGFuIHVuc3VwcG9ydGVkIG9yIHVuZXhwZWN0ZWQgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIkNMSUVOVF9CQURfVFlQRVwiOiAweDAzMEYsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BlcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBjdXJyZW50IGNsaWVudCBpcyBhbHJlYWR5IHVzaW5nIHRvb1xyXG4gICAgICogbWFueSByZXNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJDTElFTlRfVE9PX01BTllcIjogMHgwMzFEXHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIEd1YWNhbW9sZSBwcm90b2NvbCBzdGF0dXMgY29kZSB3aGljaCBtb3N0IGNsb3NlbHlcclxuICogcmVwcmVzZW50cyB0aGUgZ2l2ZW4gSFRUUCBzdGF0dXMgY29kZS5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xyXG4gKiAgICAgVGhlIEhUVFAgc3RhdHVzIGNvZGUgdG8gdHJhbnNsYXRlIGludG8gYSBHdWFjYW1vbGUgcHJvdG9jb2wgc3RhdHVzXHJcbiAqICAgICBjb2RlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gKiAgICAgVGhlIEd1YWNhbW9sZSBwcm90b2NvbCBzdGF0dXMgY29kZSB3aGljaCBtb3N0IGNsb3NlbHkgcmVwcmVzZW50cyB0aGVcclxuICogICAgIGdpdmVuIEhUVFAgc3RhdHVzIGNvZGUuXHJcbiAqL1xyXG5HdWFjYW1vbGUuU3RhdHVzLkNvZGUuZnJvbUhUVFBDb2RlID0gZnVuY3Rpb24gZnJvbUhUVFBDb2RlKHN0YXR1cykge1xyXG5cclxuICAgIC8vIFRyYW5zbGF0ZSBzdGF0dXMgY29kZXMgd2l0aCBrbm93biBlcXVpdmFsZW50c1xyXG4gICAgc3dpdGNoIChzdGF0dXMpIHtcclxuXHJcbiAgICAgICAgLy8gSFRUUCA0MDAgLSBCYWQgcmVxdWVzdFxyXG4gICAgICAgIGNhc2UgNDAwOlxyXG4gICAgICAgICAgICByZXR1cm4gR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLkNMSUVOVF9CQURfUkVRVUVTVDtcclxuXHJcbiAgICAgICAgLy8gSFRUUCA0MDMgLSBGb3JiaWRkZW5cclxuICAgICAgICBjYXNlIDQwMzpcclxuICAgICAgICAgICAgcmV0dXJuIEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5DTElFTlRfRk9SQklEREVOO1xyXG5cclxuICAgICAgICAvLyBIVFRQIDQwNCAtIFJlc291cmNlIG5vdCBmb3VuZFxyXG4gICAgICAgIGNhc2UgNDA0OlxyXG4gICAgICAgICAgICByZXR1cm4gR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlJFU09VUkNFX05PVF9GT1VORDtcclxuXHJcbiAgICAgICAgLy8gSFRUUCA0MjkgLSBUb28gbWFueSByZXF1ZXN0c1xyXG4gICAgICAgIGNhc2UgNDI5OlxyXG4gICAgICAgICAgICByZXR1cm4gR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLkNMSUVOVF9UT09fTUFOWTtcclxuXHJcbiAgICAgICAgLy8gSFRUUCA1MDMgLSBTZXJ2ZXIgdW5hdmFpbGFibGVcclxuICAgICAgICBjYXNlIDUwMzpcclxuICAgICAgICAgICAgcmV0dXJuIEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5TRVJWRVJfQlVTWTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVmYXVsdCBhbGwgb3RoZXIgY29kZXMgdG8gZ2VuZXJpYyBpbnRlcm5hbCBlcnJvclxyXG4gICAgcmV0dXJuIEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5TRVJWRVJfRVJST1I7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIEd1YWNhbW9sZSBwcm90b2NvbCBzdGF0dXMgY29kZSB3aGljaCBtb3N0IGNsb3NlbHlcclxuICogcmVwcmVzZW50cyB0aGUgZ2l2ZW4gV2ViU29ja2V0IHN0YXR1cyBjb2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVxyXG4gKiAgICAgVGhlIFdlYlNvY2tldCBzdGF0dXMgY29kZSB0byB0cmFuc2xhdGUgaW50byBhIEd1YWNhbW9sZSBwcm90b2NvbFxyXG4gKiAgICAgc3RhdHVzIGNvZGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAqICAgICBUaGUgR3VhY2Ftb2xlIHByb3RvY29sIHN0YXR1cyBjb2RlIHdoaWNoIG1vc3QgY2xvc2VseSByZXByZXNlbnRzIHRoZVxyXG4gKiAgICAgZ2l2ZW4gV2ViU29ja2V0IHN0YXR1cyBjb2RlLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLmZyb21XZWJTb2NrZXRDb2RlID0gZnVuY3Rpb24gZnJvbVdlYlNvY2tldENvZGUoY29kZSkge1xyXG5cclxuICAgIC8vIFRyYW5zbGF0ZSBzdGF0dXMgY29kZXMgd2l0aCBrbm93biBlcXVpdmFsZW50c1xyXG4gICAgc3dpdGNoIChjb2RlKSB7XHJcblxyXG4gICAgICAgIC8vIFN1Y2Nlc3NmdWwgZGlzY29ubmVjdCAobm8gZXJyb3IpXHJcbiAgICAgICAgY2FzZSAxMDAwOiAvLyBOb3JtYWwgQ2xvc3VyZVxyXG4gICAgICAgICAgICByZXR1cm4gR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlNVQ0NFU1M7XHJcblxyXG4gICAgICAgIC8vIENvZGVzIHdoaWNoIGluZGljYXRlIHRoZSBzZXJ2ZXIgaXMgbm90IHJlYWNoYWJsZVxyXG4gICAgICAgIGNhc2UgMTAwNjogLy8gQWJub3JtYWwgQ2xvc3VyZSAoYWxzbyBzaWduYWxsZWQgYnkgSmF2YVNjcmlwdCB3aGVuIHRoZSBjb25uZWN0aW9uIGNhbm5vdCBiZSBvcGVuZWQgaW4gdGhlIGZpcnN0IHBsYWNlKVxyXG4gICAgICAgIGNhc2UgMTAxNTogLy8gVExTIEhhbmRzaGFrZVxyXG4gICAgICAgICAgICByZXR1cm4gR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlVQU1RSRUFNX05PVF9GT1VORDtcclxuXHJcbiAgICAgICAgLy8gQ29kZXMgd2hpY2ggaW5kaWNhdGUgdGhlIHNlcnZlciBpcyByZWFjaGFibGUgYnV0IGJ1c3kvdW5hdmFpbGFibGVcclxuICAgICAgICBjYXNlIDEwMDE6IC8vIEdvaW5nIEF3YXlcclxuICAgICAgICBjYXNlIDEwMTI6IC8vIFNlcnZpY2UgUmVzdGFydFxyXG4gICAgICAgIGNhc2UgMTAxMzogLy8gVHJ5IEFnYWluIExhdGVyXHJcbiAgICAgICAgY2FzZSAxMDE0OiAvLyBCYWQgR2F0ZXdheVxyXG4gICAgICAgICAgICByZXR1cm4gR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlVQU1RSRUFNX1VOQVZBSUxBQkxFO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWZhdWx0IGFsbCBvdGhlciBjb2RlcyB0byBnZW5lcmljIGludGVybmFsIGVycm9yXHJcbiAgICByZXR1cm4gR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlNFUlZFUl9FUlJPUjtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIHJlYWRlciB3aGljaCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgdGhlIGdpdmVuIGlucHV0IHN0cmVhbSwgcmV0dXJuaW5nXHJcbiAqIHN0cmljdGx5IHRleHQgZGF0YS4gTm90ZSB0aGF0IHRoaXMgb2JqZWN0IHdpbGwgb3ZlcndyaXRlIGFueSBpbnN0YWxsZWQgZXZlbnRcclxuICogaGFuZGxlcnMgb24gdGhlIGdpdmVuIEd1YWNhbW9sZS5JbnB1dFN0cmVhbS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gc3RyZWFtIFRoZSBzdHJlYW0gdGhhdCBkYXRhIHdpbGwgYmUgcmVhZFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20uXHJcbiAqL1xyXG5HdWFjYW1vbGUuU3RyaW5nUmVhZGVyID0gZnVuY3Rpb24oc3RyZWFtKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuSW5wdXRTdHJlYW0uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY19yZWFkZXIgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JhcHBlZCBHdWFjYW1vbGUuQXJyYXlCdWZmZXJSZWFkZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5BcnJheUJ1ZmZlclJlYWRlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIGFycmF5X3JlYWRlciA9IG5ldyBHdWFjYW1vbGUuQXJyYXlCdWZmZXJSZWFkZXIoc3RyZWFtKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGZvciB0aGUgY3VycmVudCBjb2RlcG9pbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBieXRlc19yZW1haW5pbmcgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgY29kZXBvaW50IHZhbHVlLCBhcyBjYWxjdWxhdGVkIGZyb20gYnl0ZXMgcmVhZCBzbyBmYXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBjb2RlcG9pbnQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyB0aGUgZ2l2ZW4gVVRGLTggZGF0YSBpbnRvIGEgVW5pY29kZSBzdHJpbmcuIFRoZSBkYXRhIG1heSBlbmQgaW5cclxuICAgICAqIHRoZSBtaWRkbGUgb2YgYSBtdWx0aWJ5dGUgY2hhcmFjdGVyLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIEFyYml0cmFyeSBVVEYtOCBkYXRhLlxyXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBBIGRlY29kZWQgVW5pY29kZSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9fZGVjb2RlX3V0ZjgoYnVmZmVyKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0ID0gXCJcIjtcclxuXHJcbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8Ynl0ZXMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGJ5dGVcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYnl0ZXNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBTdGFydCBuZXcgY29kZXBvaW50IGlmIG5vdGhpbmcgeWV0IHJlYWRcclxuICAgICAgICAgICAgaWYgKGJ5dGVzX3JlbWFpbmluZyA9PT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDEgYnl0ZSAoMHh4eHh4eHgpXHJcbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlIHwgMHg3RikgPT09IDB4N0YpXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAyIGJ5dGUgKDExMHh4eHh4KVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHZhbHVlIHwgMHgxRikgPT09IDB4REYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlcG9pbnQgPSB2YWx1ZSAmIDB4MUY7XHJcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNfcmVtYWluaW5nID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyAzIGJ5dGUgKDExMTB4eHh4KVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHZhbHVlIHwgMHgwRiApPT09IDB4RUYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlcG9pbnQgPSB2YWx1ZSAmIDB4MEY7XHJcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNfcmVtYWluaW5nID0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyA0IGJ5dGUgKDExMTEweHh4KVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHZhbHVlIHwgMHgwNykgPT09IDB4RjcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlcG9pbnQgPSB2YWx1ZSAmIDB4MDc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNfcmVtYWluaW5nID0gMztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGJ5dGVcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiXFx1RkZGRFwiO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29udGludWUgZXhpc3RpbmcgY29kZXBvaW50ICgxMHh4eHh4eClcclxuICAgICAgICAgICAgZWxzZSBpZiAoKHZhbHVlIHwgMHgzRikgPT09IDB4QkYpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb2RlcG9pbnQgPSAoY29kZXBvaW50IDw8IDYpIHwgKHZhbHVlICYgMHgzRik7XHJcbiAgICAgICAgICAgICAgICBieXRlc19yZW1haW5pbmctLTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSBjb2RlcG9pbnQgaWYgZmluaXNoZWRcclxuICAgICAgICAgICAgICAgIGlmIChieXRlc19yZW1haW5pbmcgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVwb2ludCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbnZhbGlkIGJ5dGVcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBieXRlc19yZW1haW5pbmcgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIlxcdUZGRkRcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWNlaXZlIGJsb2JzIGFzIHN0cmluZ3NcclxuICAgIGFycmF5X3JlYWRlci5vbmRhdGEgPSBmdW5jdGlvbihidWZmZXIpIHtcclxuXHJcbiAgICAgICAgLy8gRGVjb2RlIFVURi04XHJcbiAgICAgICAgdmFyIHRleHQgPSBfX2RlY29kZV91dGY4KGJ1ZmZlcik7XHJcblxyXG4gICAgICAgIC8vIENhbGwgaGFuZGxlciwgaWYgcHJlc2VudFxyXG4gICAgICAgIGlmIChndWFjX3JlYWRlci5vbnRleHQpXHJcbiAgICAgICAgICAgIGd1YWNfcmVhZGVyLm9udGV4dCh0ZXh0KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFNpbXBseSBjYWxsIG9uZW5kIHdoZW4gZW5kIHJlY2VpdmVkXHJcbiAgICBhcnJheV9yZWFkZXIub25lbmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoZ3VhY19yZWFkZXIub25lbmQpXHJcbiAgICAgICAgICAgIGd1YWNfcmVhZGVyLm9uZW5kKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgb25jZSBmb3IgZXZlcnkgYmxvYiBvZiB0ZXh0IGRhdGEgcmVjZWl2ZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIGRhdGEgcGFja2V0IHJlY2VpdmVkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9udGV4dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCBvbmNlIHRoaXMgc3RyZWFtIGlzIGZpbmlzaGVkIGFuZCBubyBmdXJ0aGVyIGRhdGEgd2lsbCBiZSB3cml0dGVuLlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHRoaXMub25lbmQgPSBudWxsO1xyXG5cclxufTtcbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQSB3cml0ZXIgd2hpY2ggYXV0b21hdGljYWxseSB3cml0ZXMgdG8gdGhlIGdpdmVuIG91dHB1dCBzdHJlYW0gd2l0aCB0ZXh0XHJcbiAqIGRhdGEuXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuT3V0cHV0U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSB0aGF0IGRhdGEgd2lsbCBiZSB3cml0dGVuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlN0cmluZ1dyaXRlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLlN0cmluZ1dyaXRlci5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX3dyaXRlciA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcGVkIEd1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlci5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLkFycmF5QnVmZmVyV3JpdGVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgYXJyYXlfd3JpdGVyID0gbmV3IEd1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlcihzdHJlYW0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgYnVmZmVyIGZvciBVVEYtOCBvdXRwdXQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoODE5Mik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGxlbmd0aCA9IDA7XHJcblxyXG4gICAgLy8gU2ltcGx5IGNhbGwgb25hY2sgZm9yIGFja25vd2xlZGdlbWVudHNcclxuICAgIGFycmF5X3dyaXRlci5vbmFjayA9IGZ1bmN0aW9uKHN0YXR1cykge1xyXG4gICAgICAgIGlmIChndWFjX3dyaXRlci5vbmFjaylcclxuICAgICAgICAgICAgZ3VhY193cml0ZXIub25hY2soc3RhdHVzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBhbmRzIHRoZSBzaXplIG9mIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBieSB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGJ5dGVzLFxyXG4gICAgICogdXBkYXRpbmcgdGhlIGxlbmd0aCBhcHByb3ByaWF0ZWx5LlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVzIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gYWRkIHRvIHRoZSB1bmRlcmx5aW5nXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfX2V4cGFuZChieXRlcykge1xyXG5cclxuICAgICAgICAvLyBSZXNpemUgYnVmZmVyIGlmIG1vcmUgc3BhY2UgbmVlZGVkXHJcbiAgICAgICAgaWYgKGxlbmd0aCtieXRlcyA+PSBidWZmZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdfYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoKGxlbmd0aCtieXRlcykqMik7XHJcbiAgICAgICAgICAgIG5ld19idWZmZXIuc2V0KGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ld19idWZmZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZW5ndGggKz0gYnl0ZXM7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBhIHNpbmdsZSBVbmljb2RlIGNoYXJhY3RlciB0byB0aGUgY3VycmVudCBidWZmZXIsIHJlc2l6aW5nIHRoZVxyXG4gICAgICogYnVmZmVyIGlmIG5lY2Vzc2FyeS4gVGhlIGNoYXJhY3RlciB3aWxsIGJlIGVuY29kZWQgYXMgVVRGLTguXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29kZXBvaW50IFRoZSBjb2RlcG9pbnQgb2YgdGhlIFVuaWNvZGUgY2hhcmFjdGVyIHRvXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX19hcHBlbmRfdXRmOChjb2RlcG9pbnQpIHtcclxuXHJcbiAgICAgICAgdmFyIG1hc2s7XHJcbiAgICAgICAgdmFyIGJ5dGVzO1xyXG5cclxuICAgICAgICAvLyAxIGJ5dGVcclxuICAgICAgICBpZiAoY29kZXBvaW50IDw9IDB4N0YpIHtcclxuICAgICAgICAgICAgbWFzayA9IDB4MDA7XHJcbiAgICAgICAgICAgIGJ5dGVzID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDIgYnl0ZVxyXG4gICAgICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweDdGRikge1xyXG4gICAgICAgICAgICBtYXNrID0gMHhDMDtcclxuICAgICAgICAgICAgYnl0ZXMgPSAyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMyBieXRlXHJcbiAgICAgICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4RkZGRikge1xyXG4gICAgICAgICAgICBtYXNrID0gMHhFMDtcclxuICAgICAgICAgICAgYnl0ZXMgPSAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gNCBieXRlXHJcbiAgICAgICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4MUZGRkZGKSB7XHJcbiAgICAgICAgICAgIG1hc2sgPSAweEYwO1xyXG4gICAgICAgICAgICBieXRlcyA9IDQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBpbnZhbGlkIGNvZGVwb2ludCwgYXBwZW5kIHJlcGxhY2VtZW50IGNoYXJhY3RlclxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfX2FwcGVuZF91dGY4KDB4RkZGRCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9mZnNldCBidWZmZXIgYnkgc2l6ZVxyXG4gICAgICAgIF9fZXhwYW5kKGJ5dGVzKTtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gbGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRyYWlsaW5nIGJ5dGVzLCBpZiBhbnlcclxuICAgICAgICBmb3IgKHZhciBpPTE7IGk8Ynl0ZXM7IGkrKykge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0LS1dID0gMHg4MCB8IChjb2RlcG9pbnQgJiAweDNGKTtcclxuICAgICAgICAgICAgY29kZXBvaW50ID4+PSA2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2V0IGluaXRpYWwgYnl0ZVxyXG4gICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gbWFzayB8IGNvZGVwb2ludDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgYXMgVVRGLTgsIHJldHVybmluZyBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nXHJcbiAgICAgKiB0aGUgcmVzdWx0aW5nIGJ5dGVzLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHN0cmluZyB0byBlbmNvZGUgYXMgVVRGLTguXHJcbiAgICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSBUaGUgZW5jb2RlZCBVVEYtOCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfX2VuY29kZV91dGY4KHRleHQpIHtcclxuXHJcbiAgICAgICAgLy8gRmlsbCBidWZmZXIgd2l0aCBVVEYtOFxyXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTx0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2RlcG9pbnQgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICAgIF9fYXBwZW5kX3V0ZjgoY29kZXBvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZsdXNoIGJ1ZmZlclxyXG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRfYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KDAsIGxlbmd0aCk7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRfYnVmZmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyB0aGUgZ2l2ZW4gdGV4dC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc2VuZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5kVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgICBpZiAodGV4dC5sZW5ndGgpXHJcbiAgICAgICAgICAgIGFycmF5X3dyaXRlci5zZW5kRGF0YShfX2VuY29kZV91dGY4KHRleHQpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduYWxzIHRoYXQgbm8gZnVydGhlciB0ZXh0IHdpbGwgYmUgc2VudCwgZWZmZWN0aXZlbHkgY2xvc2luZyB0aGVcclxuICAgICAqIHN0cmVhbS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5kRW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYXJyYXlfd3JpdGVyLnNlbmRFbmQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCBmb3IgcmVjZWl2ZWQgZGF0YSwgaWYgYWNrbm93bGVkZ2VkIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLlN0YXR1c30gc3RhdHVzIFRoZSBzdGF0dXMgb2YgdGhlIG9wZXJhdGlvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmFjayA9IG51bGw7XHJcblxyXG59O1xuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBDb3JlIG9iamVjdCBwcm92aWRpbmcgYWJzdHJhY3QgY29tbXVuaWNhdGlvbiBmb3IgR3VhY2Ftb2xlLiBUaGlzIG9iamVjdFxyXG4gKiBpcyBhIG51bGwgaW1wbGVtZW50YXRpb24gd2hvc2UgZnVuY3Rpb25zIGRvIG5vdGhpbmcuIEd1YWNhbW9sZSBhcHBsaWNhdGlvbnNcclxuICogc2hvdWxkIHVzZSB7QGxpbmsgR3VhY2Ftb2xlLkhUVFBUdW5uZWx9IGluc3RlYWQsIG9yIGltcGxlbWVudCB0aGVpciBvd24gdHVubmVsIGJhc2VkXHJcbiAqIG9uIHRoaXMgb25lLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBzZWUgR3VhY2Ftb2xlLkhUVFBUdW5uZWxcclxuICovXHJcbkd1YWNhbW9sZS5UdW5uZWwgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbm5lY3QgdG8gdGhlIHR1bm5lbCB3aXRoIHRoZSBnaXZlbiBvcHRpb25hbCBkYXRhLiBUaGlzIGRhdGEgaXNcclxuICAgICAqIHR5cGljYWxseSB1c2VkIGZvciBhdXRoZW50aWNhdGlvbi4gVGhlIGZvcm1hdCBvZiBkYXRhIGFjY2VwdGVkIGlzXHJcbiAgICAgKiB1cCB0byB0aGUgdHVubmVsIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBzZW5kIHRvIHRoZSB0dW5uZWwgd2hlbiBjb25uZWN0aW5nLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbm5lY3QgPSBmdW5jdGlvbihkYXRhKSB7fTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNjb25uZWN0IGZyb20gdGhlIHR1bm5lbC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7fTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIHRoZSBnaXZlbiBtZXNzYWdlIHRocm91Z2ggdGhlIHR1bm5lbCB0byB0aGUgc2VydmljZSBvbiB0aGUgb3RoZXJcclxuICAgICAqIHNpZGUuIEFsbCBtZXNzYWdlcyBhcmUgZ3VhcmFudGVlZCB0byBiZSByZWNlaXZlZCBpbiB0aGUgb3JkZXIgc2VudC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHsuLi4qfSBlbGVtZW50c1xyXG4gICAgICogICAgIFRoZSBlbGVtZW50cyBvZiB0aGUgbWVzc2FnZSB0byBzZW5kIHRvIHRoZSBzZXJ2aWNlIG9uIHRoZSBvdGhlciBzaWRlXHJcbiAgICAgKiAgICAgb2YgdGhlIHR1bm5lbC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIHN0b3JlZCBudW1lcmljIHN0YXRlIG9mIHRoaXMgdHVubmVsLCBmaXJpbmcgdGhlIG9uc3RhdGVjaGFuZ2VcclxuICAgICAqIGV2ZW50IGlmIHRoZSBuZXcgc3RhdGUgaXMgZGlmZmVyZW50IGFuZCBhIGhhbmRsZXIgaGFzIGJlZW4gZGVmaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXRlXHJcbiAgICAgKiAgICAgVGhlIG5ldyBzdGF0ZSBvZiB0aGlzIHR1bm5lbC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XHJcblxyXG4gICAgICAgIC8vIE5vdGlmeSBvbmx5IGlmIHN0YXRlIGNoYW5nZXNcclxuICAgICAgICBpZiAoc3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbnN0YXRlY2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbnN0YXRlY2hhbmdlKHN0YXRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIHN0b3JlZCBVVUlEIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGlzIHR1bm5lbCwgZmlyaW5nIHRoZVxyXG4gICAgICogb251dWlkIGV2ZW50IGlmIGEgaGFuZGxlciBoYXMgYmVlbiBkZWZpbmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXVpZFxyXG4gICAgICogICAgIFRoZSBuZXcgc3RhdGUgb2YgdGhpcyB0dW5uZWwuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2V0VVVJRCA9IGZ1bmN0aW9uIHNldFVVSUQodXVpZCkge1xyXG4gICAgICAgIHRoaXMudXVpZCA9IHV1aWQ7XHJcbiAgICAgICAgaWYgKHRoaXMub251dWlkKVxyXG4gICAgICAgICAgICB0aGlzLm9udXVpZCh1dWlkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyB0dW5uZWwgaXMgY3VycmVudGx5IGNvbm5lY3RlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqICAgICB0cnVlIGlmIHRoaXMgdHVubmVsIGlzIGN1cnJlbnRseSBjb25uZWN0ZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uIGlzQ29ubmVjdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBHdWFjYW1vbGUuVHVubmVsLlN0YXRlLk9QRU5cclxuICAgICAgICAgICAgfHwgdGhpcy5zdGF0ZSA9PT0gR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5VTlNUQUJMRTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIHR1bm5lbC5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGF0ZSA9IEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuQ09OTkVDVElORztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgZm9yIGRhdGEgdG8gYmUgcmVjZWl2ZWQsIGluXHJcbiAgICAgKiBtaWxsaXNlY29uZHMuIElmIGRhdGEgaXMgbm90IHJlY2VpdmVkIHdpdGhpbiB0aGlzIGFtb3VudCBvZiB0aW1lLFxyXG4gICAgICogdGhlIHR1bm5lbCBpcyBjbG9zZWQgd2l0aCBhbiBlcnJvci4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMTUwMDAuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWNlaXZlVGltZW91dCA9IDE1MDAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgZm9yIGRhdGEgdG8gYmUgcmVjZWl2ZWQgYmVmb3JlIGNvbnNpZGVyaW5nXHJcbiAgICAgKiB0aGUgY29ubmVjdGlvbiB0byBiZSB1bnN0YWJsZSwgaW4gbWlsbGlzZWNvbmRzLiBJZiBkYXRhIGlzIG5vdCByZWNlaXZlZFxyXG4gICAgICogd2l0aGluIHRoaXMgYW1vdW50IG9mIHRpbWUsIHRoZSB0dW5uZWwgc3RhdHVzIGlzIHVwZGF0ZWQgdG8gd2FybiB0aGF0XHJcbiAgICAgKiB0aGUgY29ubmVjdGlvbiBhcHBlYXJzIHVucmVzcG9uc2l2ZSBhbmQgbWF5IGNsb3NlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpc1xyXG4gICAgICogMTUwMC5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy51bnN0YWJsZVRocmVzaG9sZCA9IDE1MDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgVVVJRCB1bmlxdWVseSBpZGVudGlmeWluZyB0aGlzIHR1bm5lbC4gSWYgbm90IHlldCBrbm93biwgdGhpcyB3aWxsXHJcbiAgICAgKiBiZSBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudXVpZCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBVVUlEIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGlzIHR1bm5lbCBpcyBrbm93bi5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfVxyXG4gICAgICogICAgIFRoZSBVVUlEIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIHRoaXMgdHVubmVsLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9udXVpZCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCBieSB0aGUgdHVubmVsLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLlN0YXR1c30gc3RhdHVzIEEgc3RhdHVzIG9iamVjdCB3aGljaCBkZXNjcmliZXMgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmVycm9yID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBzdGF0ZSBvZiB0aGUgdHVubmVsIGNoYW5nZXMuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXRlIFRoZSBuZXcgc3RhdGUgb2YgdGhlIGNsaWVudC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbnN0YXRlY2hhbmdlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIG9uY2UgZm9yIGV2ZXJ5IGNvbXBsZXRlIEd1YWNhbW9sZSBpbnN0cnVjdGlvbiByZWNlaXZlZCwgaW4gb3JkZXIuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wY29kZSBUaGUgR3VhY2Ftb2xlIGluc3RydWN0aW9uIG9wY29kZS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgcHJvdmlkZWQgZm9yIHRoZSBpbnN0cnVjdGlvbixcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgYW55LlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uaW5zdHJ1Y3Rpb24gPSBudWxsO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgR3VhY2Ftb2xlIHByb3RvY29sIGluc3RydWN0aW9uIG9wY29kZSByZXNlcnZlZCBmb3IgYXJiaXRyYXJ5IGludGVybmFsXHJcbiAqIHVzZSBieSB0dW5uZWwgaW1wbGVtZW50YXRpb25zLiBUaGUgdmFsdWUgb2YgdGhpcyBvcGNvZGUgaXMgZ3VhcmFudGVlZCB0byBiZVxyXG4gKiB0aGUgZW1wdHkgc3RyaW5nIChcIlwiKS4gVHVubmVsIGltcGxlbWVudGF0aW9ucyBtYXkgdXNlIHRoaXMgb3Bjb2RlIGZvciBhbnlcclxuICogcHVycG9zZS4gSXQgaXMgY3VycmVudGx5IHVzZWQgYnkgdGhlIEhUVFAgdHVubmVsIHRvIG1hcmsgdGhlIGVuZCBvZiB0aGUgSFRUUFxyXG4gKiByZXNwb25zZSwgYW5kIGJ5IHRoZSBXZWJTb2NrZXQgdHVubmVsIHRvIHRyYW5zbWl0IHRoZSB0dW5uZWwgVVVJRCBhbmQgc2VuZFxyXG4gKiBjb25uZWN0aW9uIHN0YWJpbGl0eSB0ZXN0IHBpbmdzL3Jlc3BvbnNlcy5cclxuICpcclxuICogQGNvbnN0YW50XHJcbiAqIEB0eXBlIHtTdHJpbmd9XHJcbiAqL1xyXG5HdWFjYW1vbGUuVHVubmVsLklOVEVSTkFMX0RBVEFfT1BDT0RFID0gJyc7XHJcblxyXG4vKipcclxuICogQWxsIHBvc3NpYmxlIHR1bm5lbCBzdGF0ZXMuXHJcbiAqL1xyXG5HdWFjYW1vbGUuVHVubmVsLlN0YXRlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjb25uZWN0aW9uIGlzIGluIHBlbmRpbmcuIEl0IGlzIG5vdCB5ZXQga25vd24gd2hldGhlciBjb25uZWN0aW9uIHdhc1xyXG4gICAgICogc3VjY2Vzc2Z1bC5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJDT05ORUNUSU5HXCI6IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0aW9uIHdhcyBzdWNjZXNzZnVsLCBhbmQgZGF0YSBpcyBiZWluZyByZWNlaXZlZC5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJPUEVOXCI6IDEsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQuIENvbm5lY3Rpb24gbWF5IG5vdCBoYXZlIGJlZW4gc3VjY2Vzc2Z1bCwgdGhlXHJcbiAgICAgKiB0dW5uZWwgbWF5IGhhdmUgYmVlbiBleHBsaWNpdGx5IGNsb3NlZCBieSBlaXRoZXIgc2lkZSwgb3IgYW4gZXJyb3IgbWF5XHJcbiAgICAgKiBoYXZlIG9jY3VycmVkLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIkNMT1NFRFwiOiAyLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgb3BlbiwgYnV0IGNvbW11bmljYXRpb24gdGhyb3VnaCB0aGUgdHVubmVsIGFwcGVhcnMgdG9cclxuICAgICAqIGJlIGRpc3J1cHRlZCwgYW5kIHRoZSBjb25uZWN0aW9uIG1heSBjbG9zZSBhcyBhIHJlc3VsdC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIlVOU1RBQkxFXCIgOiAzXHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEd1YWNhbW9sZSBUdW5uZWwgaW1wbGVtZW50ZWQgb3ZlciBIVFRQIHZpYSBYTUxIdHRwUmVxdWVzdC5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXVnbWVudHMgR3VhY2Ftb2xlLlR1bm5lbFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHVubmVsVVJMXHJcbiAqICAgICBUaGUgVVJMIG9mIHRoZSBIVFRQIHR1bm5lbGluZyBzZXJ2aWNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtjcm9zc0RvbWFpbj1mYWxzZV1cclxuICogICAgIFdoZXRoZXIgdHVubmVsIHJlcXVlc3RzIHdpbGwgYmUgY3Jvc3MtZG9tYWluLCBhbmQgdGh1cyBtdXN0IHVzZSBDT1JTXHJcbiAqICAgICBtZWNoYW5pc21zIGFuZCBoZWFkZXJzLiBCeSBkZWZhdWx0LCBpdCBpcyBhc3N1bWVkIHRoYXQgdHVubmVsIHJlcXVlc3RzXHJcbiAqICAgICB3aWxsIGJlIG1hZGUgdG8gdGhlIHNhbWUgZG9tYWluLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2V4dHJhVHVubmVsSGVhZGVycz17fV1cclxuICogICAgIEtleSB2YWx1ZSBwYWlycyBjb250YWluaW5nIHRoZSBoZWFkZXIgbmFtZXMgYW5kIHZhbHVlcyBvZiBhbnkgYWRkaXRpb25hbFxyXG4gKiAgICAgaGVhZGVycyB0byBiZSBzZW50IGluIHR1bm5lbCByZXF1ZXN0cy4gQnkgZGVmYXVsdCwgbm8gZXh0cmEgaGVhZGVycyB3aWxsXHJcbiAqICAgICBiZSBhZGRlZC5cclxuICovXHJcbkd1YWNhbW9sZS5IVFRQVHVubmVsID0gZnVuY3Rpb24odHVubmVsVVJMLCBjcm9zc0RvbWFpbiwgZXh0cmFUdW5uZWxIZWFkZXJzKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBIVFRQIHR1bm5lbC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciB0dW5uZWwgPSB0aGlzO1xyXG5cclxuICAgIHZhciBUVU5ORUxfQ09OTkVDVCA9IHR1bm5lbFVSTCArIFwiP2Nvbm5lY3RcIjtcclxuICAgIHZhciBUVU5ORUxfUkVBRCAgICA9IHR1bm5lbFVSTCArIFwiP3JlYWQ6XCI7XHJcbiAgICB2YXIgVFVOTkVMX1dSSVRFICAgPSB0dW5uZWxVUkwgKyBcIj93cml0ZTpcIjtcclxuXHJcbiAgICB2YXIgUE9MTElOR19FTkFCTEVEICAgICA9IDE7XHJcbiAgICB2YXIgUE9MTElOR19ESVNBQkxFRCAgICA9IDA7XHJcblxyXG4gICAgLy8gRGVmYXVsdCB0byBwb2xsaW5nIC0gd2lsbCBiZSB0dXJuZWQgb2ZmIGF1dG9tYXRpY2FsbHkgaWYgbm90IG5lZWRlZFxyXG4gICAgdmFyIHBvbGxpbmdNb2RlID0gUE9MTElOR19FTkFCTEVEO1xyXG5cclxuICAgIHZhciBzZW5kaW5nTWVzc2FnZXMgPSBmYWxzZTtcclxuICAgIHZhciBvdXRwdXRNZXNzYWdlQnVmZmVyID0gXCJcIjtcclxuXHJcbiAgICAvLyBJZiByZXF1ZXN0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgY3Jvc3MtZG9tYWluLCB0aGUgY29va2llIHRoYXQgdGhlIEhUVFBcclxuICAgIC8vIHR1bm5lbCBkZXBlbmRzIG9uIHdpbGwgb25seSBiZSBzZW50IGlmIHdpdGhDcmVkZW50aWFscyBpcyB0cnVlXHJcbiAgICB2YXIgd2l0aENyZWRlbnRpYWxzID0gISFjcm9zc0RvbWFpbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IHJlY2VpdmUgdGltZW91dCBJRCwgaWYgYW55LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHJlY2VpdmVfdGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBjb25uZWN0aW9uIHN0YWJpbGl0eSB0aW1lb3V0IElELCBpZiBhbnkuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciB1bnN0YWJsZVRpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGFiaWxpdHkgdGVzdCBwaW5nIGludGVydmFsIElELCBpZiBhbnkuIFRoaXNcclxuICAgICAqIHdpbGwgb25seSBiZSBzZXQgdXBvbiBzdWNjZXNzZnVsIGNvbm5lY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBwaW5nSW50ZXJ2YWwgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuIGNvbm5lY3Rpb24gc3RhYmlsaXR5IHRlc3RcclxuICAgICAqIHBpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBQSU5HX0ZSRVFVRU5DWSA9IDUwMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZGl0aW9uYWwgaGVhZGVycyB0byBiZSBzZW50IGluIHR1bm5lbCByZXF1ZXN0cy4gVGhpcyBkaWN0aW9uYXJ5IGNhbiBiZVxyXG4gICAgICogcG9wdWxhdGVkIHdpdGgga2V5L3ZhbHVlIGhlYWRlciBwYWlycyB0byBwYXNzIGluZm9ybWF0aW9uIHN1Y2ggYXMgYXV0aGVudGljYXRpb25cclxuICAgICAqIHRva2VucywgZXRjLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBleHRyYUhlYWRlcnMgPSBleHRyYVR1bm5lbEhlYWRlcnMgfHwge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBjb25maWd1cmVkIGFkZGl0aW9uYWwgaGVhZGVycyB0byB0aGUgZ2l2ZW4gcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSByZXF1ZXN0XHJcbiAgICAgKiAgICAgVGhlIHJlcXVlc3Qgd2hlcmUgdGhlIGNvbmZpZ3VyZWQgZXh0cmEgaGVhZGVycyB3aWxsIGJlIGFkZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXHJcbiAgICAgKiAgICAgVGhlIGhlYWRlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkRXh0cmFIZWFkZXJzKHJlcXVlc3QsIGhlYWRlcnMpIHtcclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcclxuICAgICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYXRlcyBhIHRpbWVvdXQgd2hpY2gsIGlmIGRhdGEgaXMgbm90IHJlY2VpdmVkLCBjYXVzZXMgdGhlIHR1bm5lbFxyXG4gICAgICogdG8gY2xvc2Ugd2l0aCBhbiBlcnJvci5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVzZXRfdGltZW91dCgpIHtcclxuXHJcbiAgICAgICAgLy8gR2V0IHJpZCBvZiBvbGQgdGltZW91dHMgKGlmIGFueSlcclxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJlY2VpdmVfdGltZW91dCk7XHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh1bnN0YWJsZVRpbWVvdXQpO1xyXG5cclxuICAgICAgICAvLyBDbGVhciB1bnN0YWJsZSBzdGF0dXNcclxuICAgICAgICBpZiAodHVubmVsLnN0YXRlID09PSBHdWFjYW1vbGUuVHVubmVsLlN0YXRlLlVOU1RBQkxFKVxyXG4gICAgICAgICAgICB0dW5uZWwuc2V0U3RhdGUoR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5PUEVOKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IG5ldyB0aW1lb3V0IGZvciB0cmFja2luZyBvdmVyYWxsIGNvbm5lY3Rpb24gdGltZW91dFxyXG4gICAgICAgIHJlY2VpdmVfdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2xvc2VfdHVubmVsKG5ldyBHdWFjYW1vbGUuU3RhdHVzKEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5VUFNUUkVBTV9USU1FT1VULCBcIlNlcnZlciB0aW1lb3V0LlwiKSk7XHJcbiAgICAgICAgfSwgdHVubmVsLnJlY2VpdmVUaW1lb3V0KTtcclxuXHJcbiAgICAgICAgLy8gU2V0IG5ldyB0aW1lb3V0IGZvciB0cmFja2luZyBzdXNwZWN0ZWQgY29ubmVjdGlvbiBpbnN0YWJpbGl0eVxyXG4gICAgICAgIHVuc3RhYmxlVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0dW5uZWwuc2V0U3RhdGUoR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5VTlNUQUJMRSk7XHJcbiAgICAgICAgfSwgdHVubmVsLnVuc3RhYmxlVGhyZXNob2xkKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhpcyB0dW5uZWwsIHNpZ25hbGluZyB0aGUgZ2l2ZW4gc3RhdHVzIGFuZCBjb3JyZXNwb25kaW5nXHJcbiAgICAgKiBtZXNzYWdlLCB3aGljaCB3aWxsIGJlIHNlbnQgdG8gdGhlIG9uZXJyb3IgaGFuZGxlciBpZiB0aGUgc3RhdHVzIGlzXHJcbiAgICAgKiBhbiBlcnJvciBzdGF0dXMuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5TdGF0dXN9IHN0YXR1cyBUaGUgc3RhdHVzIGNhdXNpbmcgdGhlIGNvbm5lY3Rpb24gdG9cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbG9zZV90dW5uZWwoc3RhdHVzKSB7XHJcblxyXG4gICAgICAgIC8vIEdldCByaWQgb2Ygb2xkIHRpbWVvdXRzIChpZiBhbnkpXHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChyZWNlaXZlX3RpbWVvdXQpO1xyXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodW5zdGFibGVUaW1lb3V0KTtcclxuXHJcbiAgICAgICAgLy8gQ2Vhc2UgY29ubmVjdGlvbiB0ZXN0IHBpbmdzXHJcbiAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwocGluZ0ludGVydmFsKTtcclxuXHJcbiAgICAgICAgLy8gSWdub3JlIGlmIGFscmVhZHkgY2xvc2VkXHJcbiAgICAgICAgaWYgKHR1bm5lbC5zdGF0ZSA9PT0gR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5DTE9TRUQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gSWYgY29ubmVjdGlvbiBjbG9zZWQgYWJub3JtYWxseSwgc2lnbmFsIGVycm9yLlxyXG4gICAgICAgIGlmIChzdGF0dXMuY29kZSAhPT0gR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlNVQ0NFU1MgJiYgdHVubmVsLm9uZXJyb3IpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElnbm9yZSBSRVNPVVJDRV9OT1RfRk9VTkQgaWYgd2UndmUgYWxyZWFkeSBjb25uZWN0ZWQsIGFzIHRoYXRcclxuICAgICAgICAgICAgLy8gb25seSBzaWduYWxzIGVuZC1vZi1zdHJlYW0gZm9yIHRoZSBIVFRQIHR1bm5lbC5cclxuICAgICAgICAgICAgaWYgKHR1bm5lbC5zdGF0ZSA9PT0gR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5DT05ORUNUSU5HXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgc3RhdHVzLmNvZGUgIT09IEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5SRVNPVVJDRV9OT1RfRk9VTkQpXHJcbiAgICAgICAgICAgICAgICB0dW5uZWwub25lcnJvcihzdGF0dXMpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IG91dHB1dCBtZXNzYWdlIGJ1ZmZlclxyXG4gICAgICAgIHNlbmRpbmdNZXNzYWdlcyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBNYXJrIGFzIGNsb3NlZFxyXG4gICAgICAgIHR1bm5lbC5zZXRTdGF0ZShHdWFjYW1vbGUuVHVubmVsLlN0YXRlLkNMT1NFRCk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICB0aGlzLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHNlbmQgbWVzc2FnZXMgaWYgbm90IGNvbm5lY3RlZFxyXG4gICAgICAgIGlmICghdHVubmVsLmlzQ29ubmVjdGVkKCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gc2VuZCBlbXB0eSBtZXNzYWdlc1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSB0byBhIGxlbmd0aC9zdHJpbmcgcGFpciBmb3IgdXNlIGFzIGFuXHJcbiAgICAgICAgICogZWxlbWVudCBpbiBhIEd1YWNhbW9sZSBpbnN0cnVjdGlvbi5cclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb252ZXJ0ZWQgdmFsdWUuIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldEVsZW1lbnQodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHN0cmluZyA9IG5ldyBTdHJpbmcodmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aCArIFwiLlwiICsgc3RyaW5nOyBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemVkIG1lc3NhZ2Ugd2l0aCBmaXJzdCBlbGVtZW50XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBnZXRFbGVtZW50KGFyZ3VtZW50c1swXSk7XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCByZW1haW5pbmcgZWxlbWVudHNcclxuICAgICAgICBmb3IgKHZhciBpPTE7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiLFwiICsgZ2V0RWxlbWVudChhcmd1bWVudHNbaV0pO1xyXG5cclxuICAgICAgICAvLyBGaW5hbCB0ZXJtaW5hdG9yXHJcbiAgICAgICAgbWVzc2FnZSArPSBcIjtcIjtcclxuXHJcbiAgICAgICAgLy8gQWRkIG1lc3NhZ2UgdG8gYnVmZmVyXHJcbiAgICAgICAgb3V0cHV0TWVzc2FnZUJ1ZmZlciArPSBtZXNzYWdlO1xyXG5cclxuICAgICAgICAvLyBTZW5kIGlmIG5vdCBjdXJyZW50bHkgc2VuZGluZ1xyXG4gICAgICAgIGlmICghc2VuZGluZ01lc3NhZ2VzKVxyXG4gICAgICAgICAgICBzZW5kUGVuZGluZ01lc3NhZ2VzKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBzZW5kUGVuZGluZ01lc3NhZ2VzKCkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byBzZW5kIG1lc3NhZ2VzIGlmIG5vdCBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoIXR1bm5lbC5pc0Nvbm5lY3RlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChvdXRwdXRNZXNzYWdlQnVmZmVyLmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICAgICAgICAgIHNlbmRpbmdNZXNzYWdlcyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZV94bWxodHRwcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICBtZXNzYWdlX3htbGh0dHByZXF1ZXN0Lm9wZW4oXCJQT1NUXCIsIFRVTk5FTF9XUklURSArIHR1bm5lbC51dWlkKTtcclxuICAgICAgICAgICAgbWVzc2FnZV94bWxodHRwcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgICAgIGFkZEV4dHJhSGVhZGVycyhtZXNzYWdlX3htbGh0dHByZXF1ZXN0LCBleHRyYUhlYWRlcnMpO1xyXG4gICAgICAgICAgICBtZXNzYWdlX3htbGh0dHByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XHJcblxyXG4gICAgICAgICAgICAvLyBPbmNlIHJlc3BvbnNlIHJlY2VpdmVkLCBzZW5kIG5leHQgcXVldWVkIGV2ZW50LlxyXG4gICAgICAgICAgICBtZXNzYWdlX3htbGh0dHByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VfeG1saHR0cHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXNldF90aW1lb3V0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgc2VuZCwgaGFuZGxlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VfeG1saHR0cHJlcXVlc3Quc3RhdHVzICE9PSAyMDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhUVFBUdW5uZWxFcnJvcihtZXNzYWdlX3htbGh0dHByZXF1ZXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjb250aW51ZSB0aGUgc2VuZCBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kUGVuZGluZ01lc3NhZ2VzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgbWVzc2FnZV94bWxodHRwcmVxdWVzdC5zZW5kKG91dHB1dE1lc3NhZ2VCdWZmZXIpO1xyXG4gICAgICAgICAgICBvdXRwdXRNZXNzYWdlQnVmZmVyID0gXCJcIjsgLy8gQ2xlYXIgYnVmZmVyXHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHNlbmRpbmdNZXNzYWdlcyA9IGZhbHNlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVIVFRQVHVubmVsRXJyb3IoeG1saHR0cHJlcXVlc3QpIHtcclxuXHJcbiAgICAgICAgLy8gUHVsbCBzdGF0dXMgY29kZSBkaXJlY3RseSBmcm9tIGhlYWRlcnMgcHJvdmlkZWQgYnkgR3VhY2Ftb2xlXHJcbiAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludCh4bWxodHRwcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihcIkd1YWNhbW9sZS1TdGF0dXMtQ29kZVwiKSk7XHJcbiAgICAgICAgaWYgKGNvZGUpIHtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB4bWxodHRwcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihcIkd1YWNhbW9sZS1FcnJvci1NZXNzYWdlXCIpO1xyXG4gICAgICAgICAgICBjbG9zZV90dW5uZWwobmV3IEd1YWNhbW9sZS5TdGF0dXMoY29kZSwgbWVzc2FnZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmFpbGluZyB0aGF0LCBkZXJpdmUgYSBHdWFjYW1vbGUgc3RhdHVzIGNvZGUgZnJvbSB0aGUgSFRUUCBzdGF0dXNcclxuICAgICAgICAvLyBjb2RlIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyXHJcbiAgICAgICAgZWxzZSBpZiAoeG1saHR0cHJlcXVlc3Quc3RhdHVzKVxyXG4gICAgICAgICAgICBjbG9zZV90dW5uZWwobmV3IEd1YWNhbW9sZS5TdGF0dXMoXHJcbiAgICAgICAgICAgICAgICBHdWFjYW1vbGUuU3RhdHVzLkNvZGUuZnJvbUhUVFBDb2RlKHhtbGh0dHByZXF1ZXN0LnN0YXR1cyksXHJcbiAgICAgICAgICAgICAgICAgICAgeG1saHR0cHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBzZXJ2ZXIgaXMgdW5yZWFjaGFibGVcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGNsb3NlX3R1bm5lbChuZXcgR3VhY2Ftb2xlLlN0YXR1cyhHdWFjYW1vbGUuU3RhdHVzLkNvZGUuVVBTVFJFQU1fTk9UX0ZPVU5EKSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHhtbGh0dHByZXF1ZXN0KSB7XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG51bGw7XHJcbiAgICAgICAgdmFyIG5leHRSZXF1ZXN0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIGRhdGFVcGRhdGVFdmVudHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBUaGUgbG9jYXRpb24gb2YgdGhlIGxhc3QgZWxlbWVudCdzIHRlcm1pbmF0b3JcclxuICAgICAgICB2YXIgZWxlbWVudEVuZCA9IC0xO1xyXG5cclxuICAgICAgICAvLyBXaGVyZSB0byBzdGFydCB0aGUgbmV4dCBsZW5ndGggc2VhcmNoIG9yIHRoZSBuZXh0IGVsZW1lbnRcclxuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IDA7XHJcblxyXG4gICAgICAgIC8vIFBhcnNlZCBlbGVtZW50c1xyXG4gICAgICAgIHZhciBlbGVtZW50cyA9IG5ldyBBcnJheSgpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBwYXJzZVJlc3BvbnNlKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gRG8gbm90IGhhbmRsZSByZXNwb25zZXMgaWYgbm90IGNvbm5lY3RlZFxyXG4gICAgICAgICAgICBpZiAoIXR1bm5lbC5pc0Nvbm5lY3RlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIGludGVydmFsIGlmIHBvbGxpbmdcclxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnZhbCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEbyBub3QgcGFyc2UgcmVzcG9uc2UgeWV0IGlmIG5vdCByZWFkeVxyXG4gICAgICAgICAgICBpZiAoeG1saHR0cHJlcXVlc3QucmVhZHlTdGF0ZSA8IDIpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcmVhZCBzdGF0dXNcclxuICAgICAgICAgICAgdmFyIHN0YXR1cztcclxuICAgICAgICAgICAgdHJ5IHsgc3RhdHVzID0geG1saHR0cHJlcXVlc3Quc3RhdHVzOyB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBzdGF0dXMgY291bGQgbm90IGJlIHJlYWQsIGFzc3VtZSBzdWNjZXNzZnVsLlxyXG4gICAgICAgICAgICBjYXRjaCAoZSkgeyBzdGF0dXMgPSAyMDA7IH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IG5leHQgcmVxdWVzdCBhcyBzb29uIGFzIHBvc3NpYmxlIElGIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxcclxuICAgICAgICAgICAgaWYgKCFuZXh0UmVxdWVzdCAmJiBzdGF0dXMgPT09IDIwMClcclxuICAgICAgICAgICAgICAgIG5leHRSZXF1ZXN0ID0gbWFrZVJlcXVlc3QoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFBhcnNlIHN0cmVhbSB3aGVuIGRhdGEgaXMgcmVjZWl2ZWQgYW5kIHdoZW4gY29tcGxldGUuXHJcbiAgICAgICAgICAgIGlmICh4bWxodHRwcmVxdWVzdC5yZWFkeVN0YXRlID09PSAzIHx8XHJcbiAgICAgICAgICAgICAgICB4bWxodHRwcmVxdWVzdC5yZWFkeVN0YXRlID09PSA0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzZXRfdGltZW91dCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFsc28gcG9sbCBldmVyeSAzMG1zIChzb21lIGJyb3dzZXJzIGRvbid0IHJlcGVhdGVkbHkgY2FsbCBvbnJlYWR5c3RhdGVjaGFuZ2UgZm9yIG5ldyBkYXRhKVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvbGxpbmdNb2RlID09PSBQT0xMSU5HX0VOQUJMRUQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeG1saHR0cHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gMyAmJiAhaW50ZXJ2YWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwocGFyc2VSZXNwb25zZSwgMzApO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHhtbGh0dHByZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQgJiYgaW50ZXJ2YWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGNhbmNlbGVkLCBzdG9wIHRyYW5zZmVyXHJcbiAgICAgICAgICAgICAgICBpZiAoeG1saHR0cHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHVubmVsLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFsdCBvbiBlcnJvciBkdXJpbmcgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeG1saHR0cHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIVFRQVHVubmVsRXJyb3IoeG1saHR0cHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHJlYWQgaW4tcHJvZ3Jlc3MgZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0cnkgeyBjdXJyZW50ID0geG1saHR0cHJlcXVlc3QucmVzcG9uc2VUZXh0OyB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcGFyc2UgaWYgZGF0YSBjb3VsZCBub3QgYmUgcmVhZFxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgc2VhcmNoIGlzIHdpdGhpbiBjdXJyZW50bHkgcmVjZWl2ZWQgZGF0YVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnRFbmQgPCBjdXJyZW50Lmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgd2FpdGluZyBmb3IgZWxlbWVudCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRFbmQgPj0gc3RhcnRJbmRleCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugbm93IGhhdmUgZW5vdWdoIGRhdGEgZm9yIHRoZSBlbGVtZW50LiBQYXJzZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjdXJyZW50LnN1YnN0cmluZyhzdGFydEluZGV4LCBlbGVtZW50RW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1pbmF0b3IgPSBjdXJyZW50LnN1YnN0cmluZyhlbGVtZW50RW5kLCBlbGVtZW50RW5kKzEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGVsZW1lbnQgdG8gYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGxhc3QgZWxlbWVudCwgaGFuZGxlIGluc3RydWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXJtaW5hdG9yID09PSBcIjtcIikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBvcGNvZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGNvZGUgPSBlbGVtZW50cy5zaGlmdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgaW5zdHJ1Y3Rpb24gaGFuZGxlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0dW5uZWwub25pbnN0cnVjdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dW5uZWwub25pbnN0cnVjdGlvbihvcGNvZGUsIGVsZW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHNlYXJjaGluZyBmb3IgbGVuZ3RoIGF0IGNoYXJhY3RlciBhZnRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHRlcm1pbmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IGVsZW1lbnRFbmQgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgZW5kIG9mIGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhFbmQgPSBjdXJyZW50LmluZGV4T2YoXCIuXCIsIHN0YXJ0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGhFbmQgIT09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBsZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KGN1cnJlbnQuc3Vic3RyaW5nKGVsZW1lbnRFbmQrMSwgbGVuZ3RoRW5kKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBkb25lIHBhcnNpbmcsIGhhbmRsZSB0aGUgbmV4dCByZXNwb25zZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIGludGVydmFsIGlmIHBvbGxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnZhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbGh0dHByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWxodHRwcmVxdWVzdC5hYm9ydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGhhbmRsaW5nIG5leHQgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRSZXF1ZXN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKG5leHRSZXF1ZXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb25lIHBhcnNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHN0YXJ0IG9mIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IGxlbmd0aEVuZCArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgbG9jYXRpb24gb2YgZWxlbWVudCB0ZXJtaW5hdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRFbmQgPSBzdGFydEluZGV4ICsgbGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gcGVyaW9kIHlldCwgY29udGludWUgc2VhcmNoIHdoZW4gbW9yZSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgcmVjZWl2ZWRcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IGN1cnJlbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSAvLyBlbmQgcGFyc2UgbG9vcFxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHJlc3BvbnNlIHBvbGxpbmcgZW5hYmxlZCwgYXR0ZW1wdCB0byBkZXRlY3QgaWYgc3RpbGxcclxuICAgICAgICAvLyBuZWNlc3NhcnkgKHZpYSB3cmFwcGluZyBwYXJzZVJlc3BvbnNlKCkpXHJcbiAgICAgICAgaWYgKHBvbGxpbmdNb2RlID09PSBQT0xMSU5HX0VOQUJMRUQpIHtcclxuICAgICAgICAgICAgeG1saHR0cHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVjZWl2ZSB0d28gb3IgbW9yZSByZWFkeVN0YXRlPT0zIGV2ZW50cyxcclxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gcG9sbC5cclxuICAgICAgICAgICAgICAgIGlmICh4bWxodHRwcmVxdWVzdC5yZWFkeVN0YXRlID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVwZGF0ZUV2ZW50cysrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVXBkYXRlRXZlbnRzID49IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9sbGluZ01vZGUgPSBQT0xMSU5HX0RJU0FCTEVEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxodHRwcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBwYXJzZVJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwYXJzZVJlc3BvbnNlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGp1c3QgcGFyc2VcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHhtbGh0dHByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHBhcnNlUmVzcG9uc2U7XHJcblxyXG4gICAgICAgIHBhcnNlUmVzcG9uc2UoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcmJpdHJhcnkgaW50ZWdlciwgdW5pcXVlIGZvciBlYWNoIHR1bm5lbCByZWFkIHJlcXVlc3QuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgcmVxdWVzdF9pZCA9IDA7XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZVJlcXVlc3QoKSB7XHJcblxyXG4gICAgICAgIC8vIE1ha2UgcmVxdWVzdCwgaW5jcmVtZW50IHJlcXVlc3QgSURcclxuICAgICAgICB2YXIgeG1saHR0cHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB4bWxodHRwcmVxdWVzdC5vcGVuKFwiR0VUXCIsIFRVTk5FTF9SRUFEICsgdHVubmVsLnV1aWQgKyBcIjpcIiArIChyZXF1ZXN0X2lkKyspKTtcclxuICAgICAgICB4bWxodHRwcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgYWRkRXh0cmFIZWFkZXJzKHhtbGh0dHByZXF1ZXN0LCBleHRyYUhlYWRlcnMpO1xyXG4gICAgICAgIHhtbGh0dHByZXF1ZXN0LnNlbmQobnVsbCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4bWxodHRwcmVxdWVzdDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24oZGF0YSkge1xyXG5cclxuICAgICAgICAvLyBTdGFydCB3YWl0aW5nIGZvciBjb25uZWN0XHJcbiAgICAgICAgcmVzZXRfdGltZW91dCgpO1xyXG5cclxuICAgICAgICAvLyBNYXJrIHRoZSB0dW5uZWwgYXMgY29ubmVjdGluZ1xyXG4gICAgICAgIHR1bm5lbC5zZXRTdGF0ZShHdWFjYW1vbGUuVHVubmVsLlN0YXRlLkNPTk5FQ1RJTkcpO1xyXG5cclxuICAgICAgICAvLyBTdGFydCB0dW5uZWwgYW5kIGNvbm5lY3RcclxuICAgICAgICB2YXIgY29ubmVjdF94bWxodHRwcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIGNvbm5lY3RfeG1saHR0cHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29ubmVjdF94bWxodHRwcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZmFpbHVyZSwgdGhyb3cgZXJyb3JcclxuICAgICAgICAgICAgaWYgKGNvbm5lY3RfeG1saHR0cHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUhUVFBUdW5uZWxFcnJvcihjb25uZWN0X3htbGh0dHByZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzZXRfdGltZW91dCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IFVVSUQgZnJvbSByZXNwb25zZVxyXG4gICAgICAgICAgICB0dW5uZWwuc2V0VVVJRChjb25uZWN0X3htbGh0dHByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XHJcblxyXG4gICAgICAgICAgICAvLyBNYXJrIGFzIG9wZW5cclxuICAgICAgICAgICAgdHVubmVsLnNldFN0YXRlKEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuT1BFTik7XHJcblxyXG4gICAgICAgICAgICAvLyBQaW5nIHR1bm5lbCBlbmRwb2ludCByZWd1bGFybHkgdG8gdGVzdCBjb25uZWN0aW9uIHN0YWJpbGl0eVxyXG4gICAgICAgICAgICBwaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiBzZW5kUGluZygpIHtcclxuICAgICAgICAgICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcIm5vcFwiKTtcclxuICAgICAgICAgICAgfSwgUElOR19GUkVRVUVOQ1kpO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RhcnQgcmVhZGluZyBkYXRhXHJcbiAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKG1ha2VSZXF1ZXN0KCkpO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25uZWN0X3htbGh0dHByZXF1ZXN0Lm9wZW4oXCJQT1NUXCIsIFRVTk5FTF9DT05ORUNULCB0cnVlKTtcclxuICAgICAgICBjb25uZWN0X3htbGh0dHByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscztcclxuICAgICAgICBhZGRFeHRyYUhlYWRlcnMoY29ubmVjdF94bWxodHRwcmVxdWVzdCwgZXh0cmFIZWFkZXJzKTtcclxuICAgICAgICBjb25uZWN0X3htbGh0dHByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIik7XHJcbiAgICAgICAgY29ubmVjdF94bWxodHRwcmVxdWVzdC5zZW5kKGRhdGEpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2xvc2VfdHVubmVsKG5ldyBHdWFjYW1vbGUuU3RhdHVzKEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5TVUNDRVNTLCBcIk1hbnVhbGx5IGNsb3NlZC5cIikpO1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5HdWFjYW1vbGUuSFRUUFR1bm5lbC5wcm90b3R5cGUgPSBuZXcgR3VhY2Ftb2xlLlR1bm5lbCgpO1xyXG5cclxuLyoqXHJcbiAqIEd1YWNhbW9sZSBUdW5uZWwgaW1wbGVtZW50ZWQgb3ZlciBXZWJTb2NrZXQgdmlhIFhNTEh0dHBSZXF1ZXN0LlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdWdtZW50cyBHdWFjYW1vbGUuVHVubmVsXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0dW5uZWxVUkwgVGhlIFVSTCBvZiB0aGUgV2ViU29ja2V0IHR1bm5lbGluZyBzZXJ2aWNlLlxyXG4gKi9cclxuR3VhY2Ftb2xlLldlYlNvY2tldFR1bm5lbCA9IGZ1bmN0aW9uKHR1bm5lbFVSTCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgV2ViU29ja2V0IHR1bm5lbC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciB0dW5uZWwgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFdlYlNvY2tldCB1c2VkIGJ5IHRoaXMgdHVubmVsLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHNvY2tldCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCByZWNlaXZlIHRpbWVvdXQgSUQsIGlmIGFueS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciByZWNlaXZlX3RpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGFiaWxpdHkgdGltZW91dCBJRCwgaWYgYW55LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgdW5zdGFibGVUaW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IGNvbm5lY3Rpb24gc3RhYmlsaXR5IHRlc3QgcGluZyBpbnRlcnZhbCBJRCwgaWYgYW55LiBUaGlzXHJcbiAgICAgKiB3aWxsIG9ubHkgYmUgc2V0IHVwb24gc3VjY2Vzc2Z1bCBjb25uZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgcGluZ0ludGVydmFsID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBXZWJTb2NrZXQgcHJvdG9jb2wgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdG9jb2wgdXNlZCBmb3IgdGhlIGN1cnJlbnRcclxuICAgICAqIGxvY2F0aW9uLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHdzX3Byb3RvY29sID0ge1xyXG4gICAgICAgIFwiaHR0cDpcIjogIFwid3M6XCIsXHJcbiAgICAgICAgXCJodHRwczpcIjogXCJ3c3M6XCJcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW4gY29ubmVjdGlvbiBzdGFiaWxpdHkgdGVzdFxyXG4gICAgICogcGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIFBJTkdfRlJFUVVFTkNZID0gNTAwO1xyXG5cclxuICAgIC8vIFRyYW5zZm9ybSBjdXJyZW50IFVSTCB0byBXZWJTb2NrZXQgVVJMXHJcblxyXG4gICAgLy8gSWYgbm90IGFscmVhZHkgYSB3ZWJzb2NrZXQgVVJMXHJcbiAgICBpZiAoICAgdHVubmVsVVJMLnN1YnN0cmluZygwLCAzKSAhPT0gXCJ3czpcIlxyXG4gICAgICAgICYmIHR1bm5lbFVSTC5zdWJzdHJpbmcoMCwgNCkgIT09IFwid3NzOlwiKSB7XHJcblxyXG4gICAgICAgIHZhciBwcm90b2NvbCA9IHdzX3Byb3RvY29sW3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbF07XHJcblxyXG4gICAgICAgIC8vIElmIGFic29sdXRlIFVSTCwgY29udmVydCB0byBhYnNvbHV0ZSBXUyBVUkxcclxuICAgICAgICBpZiAodHVubmVsVVJMLnN1YnN0cmluZygwLCAxKSA9PT0gXCIvXCIpXHJcbiAgICAgICAgICAgIHR1bm5lbFVSTCA9XHJcbiAgICAgICAgICAgICAgICBwcm90b2NvbFxyXG4gICAgICAgICAgICAgICAgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdFxyXG4gICAgICAgICAgICAgICAgKyB0dW5uZWxVUkw7XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgY29uc3RydWN0IGFic29sdXRlIGZyb20gcmVsYXRpdmUgVVJMXHJcbiAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgcGF0aCBmcm9tIHBhdGhuYW1lXHJcbiAgICAgICAgICAgIHZhciBzbGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5sYXN0SW5kZXhPZihcIi9cIik7XHJcbiAgICAgICAgICAgIHZhciBwYXRoICA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5zdWJzdHJpbmcoMCwgc2xhc2ggKyAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBhYnNvbHV0ZSBVUkxcclxuICAgICAgICAgICAgdHVubmVsVVJMID1cclxuICAgICAgICAgICAgICAgIHByb3RvY29sXHJcbiAgICAgICAgICAgICAgICArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0XHJcbiAgICAgICAgICAgICAgICArIHBhdGhcclxuICAgICAgICAgICAgICAgICsgdHVubmVsVVJMO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhdGVzIGEgdGltZW91dCB3aGljaCwgaWYgZGF0YSBpcyBub3QgcmVjZWl2ZWQsIGNhdXNlcyB0aGUgdHVubmVsXHJcbiAgICAgKiB0byBjbG9zZSB3aXRoIGFuIGVycm9yLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXNldF90aW1lb3V0KCkge1xyXG5cclxuICAgICAgICAvLyBHZXQgcmlkIG9mIG9sZCB0aW1lb3V0cyAoaWYgYW55KVxyXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocmVjZWl2ZV90aW1lb3V0KTtcclxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHVuc3RhYmxlVGltZW91dCk7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIHVuc3RhYmxlIHN0YXR1c1xyXG4gICAgICAgIGlmICh0dW5uZWwuc3RhdGUgPT09IEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuVU5TVEFCTEUpXHJcbiAgICAgICAgICAgIHR1bm5lbC5zZXRTdGF0ZShHdWFjYW1vbGUuVHVubmVsLlN0YXRlLk9QRU4pO1xyXG5cclxuICAgICAgICAvLyBTZXQgbmV3IHRpbWVvdXQgZm9yIHRyYWNraW5nIG92ZXJhbGwgY29ubmVjdGlvbiB0aW1lb3V0XHJcbiAgICAgICAgcmVjZWl2ZV90aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjbG9zZV90dW5uZWwobmV3IEd1YWNhbW9sZS5TdGF0dXMoR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlVQU1RSRUFNX1RJTUVPVVQsIFwiU2VydmVyIHRpbWVvdXQuXCIpKTtcclxuICAgICAgICB9LCB0dW5uZWwucmVjZWl2ZVRpbWVvdXQpO1xyXG5cclxuICAgICAgICAvLyBTZXQgbmV3IHRpbWVvdXQgZm9yIHRyYWNraW5nIHN1c3BlY3RlZCBjb25uZWN0aW9uIGluc3RhYmlsaXR5XHJcbiAgICAgICAgdW5zdGFibGVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHR1bm5lbC5zZXRTdGF0ZShHdWFjYW1vbGUuVHVubmVsLlN0YXRlLlVOU1RBQkxFKTtcclxuICAgICAgICB9LCB0dW5uZWwudW5zdGFibGVUaHJlc2hvbGQpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyB0aGlzIHR1bm5lbCwgc2lnbmFsaW5nIHRoZSBnaXZlbiBzdGF0dXMgYW5kIGNvcnJlc3BvbmRpbmdcclxuICAgICAqIG1lc3NhZ2UsIHdoaWNoIHdpbGwgYmUgc2VudCB0byB0aGUgb25lcnJvciBoYW5kbGVyIGlmIHRoZSBzdGF0dXMgaXNcclxuICAgICAqIGFuIGVycm9yIHN0YXR1cy5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLlN0YXR1c30gc3RhdHVzIFRoZSBzdGF0dXMgY2F1c2luZyB0aGUgY29ubmVjdGlvbiB0b1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsb3NlX3R1bm5lbChzdGF0dXMpIHtcclxuXHJcbiAgICAgICAgLy8gR2V0IHJpZCBvZiBvbGQgdGltZW91dHMgKGlmIGFueSlcclxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJlY2VpdmVfdGltZW91dCk7XHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh1bnN0YWJsZVRpbWVvdXQpO1xyXG5cclxuICAgICAgICAvLyBDZWFzZSBjb25uZWN0aW9uIHRlc3QgcGluZ3NcclxuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChwaW5nSW50ZXJ2YWwpO1xyXG5cclxuICAgICAgICAvLyBJZ25vcmUgaWYgYWxyZWFkeSBjbG9zZWRcclxuICAgICAgICBpZiAodHVubmVsLnN0YXRlID09PSBHdWFjYW1vbGUuVHVubmVsLlN0YXRlLkNMT1NFRClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBJZiBjb25uZWN0aW9uIGNsb3NlZCBhYm5vcm1hbGx5LCBzaWduYWwgZXJyb3IuXHJcbiAgICAgICAgaWYgKHN0YXR1cy5jb2RlICE9PSBHdWFjYW1vbGUuU3RhdHVzLkNvZGUuU1VDQ0VTUyAmJiB0dW5uZWwub25lcnJvcilcclxuICAgICAgICAgICAgdHVubmVsLm9uZXJyb3Ioc3RhdHVzKTtcclxuXHJcbiAgICAgICAgLy8gTWFyayBhcyBjbG9zZWRcclxuICAgICAgICB0dW5uZWwuc2V0U3RhdGUoR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5DTE9TRUQpO1xyXG5cclxuICAgICAgICBzb2NrZXQuY2xvc2UoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHNlbmQgbWVzc2FnZXMgaWYgbm90IGNvbm5lY3RlZFxyXG4gICAgICAgIGlmICghdHVubmVsLmlzQ29ubmVjdGVkKCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gc2VuZCBlbXB0eSBtZXNzYWdlc1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSB0byBhIGxlbmd0aC9zdHJpbmcgcGFpciBmb3IgdXNlIGFzIGFuXHJcbiAgICAgICAgICogZWxlbWVudCBpbiBhIEd1YWNhbW9sZSBpbnN0cnVjdGlvbi5cclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb252ZXJ0ZWQgdmFsdWUuIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldEVsZW1lbnQodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHN0cmluZyA9IG5ldyBTdHJpbmcodmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aCArIFwiLlwiICsgc3RyaW5nOyBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemVkIG1lc3NhZ2Ugd2l0aCBmaXJzdCBlbGVtZW50XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBnZXRFbGVtZW50KGFyZ3VtZW50c1swXSk7XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCByZW1haW5pbmcgZWxlbWVudHNcclxuICAgICAgICBmb3IgKHZhciBpPTE7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiLFwiICsgZ2V0RWxlbWVudChhcmd1bWVudHNbaV0pO1xyXG5cclxuICAgICAgICAvLyBGaW5hbCB0ZXJtaW5hdG9yXHJcbiAgICAgICAgbWVzc2FnZSArPSBcIjtcIjtcclxuXHJcbiAgICAgICAgc29ja2V0LnNlbmQobWVzc2FnZSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNvbm5lY3QgPSBmdW5jdGlvbihkYXRhKSB7XHJcblxyXG4gICAgICAgIHJlc2V0X3RpbWVvdXQoKTtcclxuXHJcbiAgICAgICAgLy8gTWFyayB0aGUgdHVubmVsIGFzIGNvbm5lY3RpbmdcclxuICAgICAgICB0dW5uZWwuc2V0U3RhdGUoR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5DT05ORUNUSU5HKTtcclxuXHJcbiAgICAgICAgLy8gQ29ubmVjdCBzb2NrZXRcclxuICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHR1bm5lbFVSTCArIFwiP1wiICsgZGF0YSwgXCJndWFjYW1vbGVcIik7XHJcblxyXG4gICAgICAgIHNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICByZXNldF90aW1lb3V0KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBQaW5nIHR1bm5lbCBlbmRwb2ludCByZWd1bGFybHkgdG8gdGVzdCBjb25uZWN0aW9uIHN0YWJpbGl0eVxyXG4gICAgICAgICAgICBwaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiBzZW5kUGluZygpIHtcclxuICAgICAgICAgICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShHdWFjYW1vbGUuVHVubmVsLklOVEVSTkFMX0RBVEFfT1BDT0RFLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicGluZ1wiLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XHJcbiAgICAgICAgICAgIH0sIFBJTkdfRlJFUVVFTkNZKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbihldmVudCkge1xyXG5cclxuICAgICAgICAgICAgLy8gUHVsbCBzdGF0dXMgY29kZSBkaXJlY3RseSBmcm9tIGNsb3N1cmUgcmVhc29uIHByb3ZpZGVkIGJ5IEd1YWNhbW9sZVxyXG4gICAgICAgICAgICBpZiAoZXZlbnQucmVhc29uKVxyXG4gICAgICAgICAgICAgICAgY2xvc2VfdHVubmVsKG5ldyBHdWFjYW1vbGUuU3RhdHVzKHBhcnNlSW50KGV2ZW50LnJlYXNvbiksIGV2ZW50LnJlYXNvbikpO1xyXG5cclxuICAgICAgICAgICAgLy8gRmFpbGluZyB0aGF0LCBkZXJpdmUgYSBHdWFjYW1vbGUgc3RhdHVzIGNvZGUgZnJvbSB0aGUgV2ViU29ja2V0XHJcbiAgICAgICAgICAgIC8vIHN0YXR1cyBjb2RlIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmNvZGUpXHJcbiAgICAgICAgICAgICAgICBjbG9zZV90dW5uZWwobmV3IEd1YWNhbW9sZS5TdGF0dXMoR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLmZyb21XZWJTb2NrZXRDb2RlKGV2ZW50LmNvZGUpKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBzZXJ2ZXIgaXMgdW5yZWFjaGFibGVcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgY2xvc2VfdHVubmVsKG5ldyBHdWFjYW1vbGUuU3RhdHVzKEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5VUFNUUkVBTV9OT1RfRk9VTkQpKTtcclxuXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuXHJcbiAgICAgICAgICAgIHJlc2V0X3RpbWVvdXQoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXZlbnQuZGF0YTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudEVuZDtcclxuXHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZG8ge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgZW5kIG9mIGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aEVuZCA9IG1lc3NhZ2UuaW5kZXhPZihcIi5cIiwgc3RhcnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoRW5kICE9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBsZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQobWVzc2FnZS5zdWJzdHJpbmcoZWxlbWVudEVuZCsxLCBsZW5ndGhFbmQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHN0YXJ0IG9mIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gbGVuZ3RoRW5kICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGxvY2F0aW9uIG9mIGVsZW1lbnQgdGVybWluYXRvclxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRFbmQgPSBzdGFydEluZGV4ICsgbGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gcGVyaW9kLCBpbmNvbXBsZXRlIGluc3RydWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlX3R1bm5lbChuZXcgR3VhY2Ftb2xlLlN0YXR1cyhHdWFjYW1vbGUuU3RhdHVzLkNvZGUuU0VSVkVSX0VSUk9SLCBcIkluY29tcGxldGUgaW5zdHJ1Y3Rpb24uXCIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBub3cgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgdGhlIGVsZW1lbnQuIFBhcnNlLlxyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBtZXNzYWdlLnN1YnN0cmluZyhzdGFydEluZGV4LCBlbGVtZW50RW5kKTtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hdG9yID0gbWVzc2FnZS5zdWJzdHJpbmcoZWxlbWVudEVuZCwgZWxlbWVudEVuZCsxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgZWxlbWVudCB0byBhcnJheVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBsYXN0IGVsZW1lbnQsIGhhbmRsZSBpbnN0cnVjdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKHRlcm1pbmF0b3IgPT09IFwiO1wiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBvcGNvZGVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3Bjb2RlID0gZWxlbWVudHMuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlIGFuZCBVVUlEIHdoZW4gZmlyc3QgaW5zdHJ1Y3Rpb24gcmVjZWl2ZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHVubmVsLnV1aWQgPT09IG51bGwpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc29jaWF0ZSB0dW5uZWwgVVVJRCBpZiByZWNlaXZlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3Bjb2RlID09PSBHdWFjYW1vbGUuVHVubmVsLklOVEVSTkFMX0RBVEFfT1BDT0RFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHVubmVsLnNldFVVSUQoZWxlbWVudHNbMF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHVubmVsIGlzIG5vdyBvcGVuIGFuZCBVVUlEIGlzIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0dW5uZWwuc2V0U3RhdGUoR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5PUEVOKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGluc3RydWN0aW9uIGhhbmRsZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wY29kZSAhPT0gR3VhY2Ftb2xlLlR1bm5lbC5JTlRFUk5BTF9EQVRBX09QQ09ERSAmJiB0dW5uZWwub25pbnN0cnVjdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHVubmVsLm9uaW5zdHJ1Y3Rpb24ob3Bjb2RlLCBlbGVtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgc2VhcmNoaW5nIGZvciBsZW5ndGggYXQgY2hhcmFjdGVyIGFmdGVyXHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHRlcm1pbmF0b3JcclxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBlbGVtZW50RW5kICsgMTtcclxuXHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHN0YXJ0SW5kZXggPCBtZXNzYWdlLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBjbG9zZV90dW5uZWwobmV3IEd1YWNhbW9sZS5TdGF0dXMoR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlNVQ0NFU1MsIFwiTWFudWFsbHkgY2xvc2VkLlwiKSk7XHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcbkd1YWNhbW9sZS5XZWJTb2NrZXRUdW5uZWwucHJvdG90eXBlID0gbmV3IEd1YWNhbW9sZS5UdW5uZWwoKTtcclxuXHJcbi8qKlxyXG4gKiBHdWFjYW1vbGUgVHVubmVsIHdoaWNoIGN5Y2xlcyBiZXR3ZWVuIGFsbCBzcGVjaWZpZWQgdHVubmVscyB1bnRpbFxyXG4gKiBubyB0dW5uZWxzIGFyZSBsZWZ0LiBBbm90aGVyIHR1bm5lbCBpcyB1c2VkIGlmIGFuIGVycm9yIG9jY3VycyBidXRcclxuICogbm8gaW5zdHJ1Y3Rpb25zIGhhdmUgYmVlbiByZWNlaXZlZC4gSWYgYW4gaW5zdHJ1Y3Rpb24gaGFzIGJlZW5cclxuICogcmVjZWl2ZWQsIG9yIG5vIHR1bm5lbHMgcmVtYWluLCB0aGUgZXJyb3IgaXMgcGFzc2VkIGRpcmVjdGx5IG91dFxyXG4gKiB0aHJvdWdoIHRoZSBvbmVycm9yIGhhbmRsZXIgKGlmIGRlZmluZWQpLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdWdtZW50cyBHdWFjYW1vbGUuVHVubmVsXHJcbiAqIEBwYXJhbSB7Li4uKn0gdHVubmVsQ2hhaW5cclxuICogICAgIFRoZSB0dW5uZWxzIHRvIHVzZSwgaW4gb3JkZXIgb2YgcHJpb3JpdHkuXHJcbiAqL1xyXG5HdWFjYW1vbGUuQ2hhaW5lZFR1bm5lbCA9IGZ1bmN0aW9uKHR1bm5lbENoYWluKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBjaGFpbmVkIHR1bm5lbC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBjaGFpbmVkX3R1bm5lbCA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEYXRhIHBhc3NlZCBpbiB2aWEgY29ubmVjdCgpLCB0byBiZSB1c2VkIGZvclxyXG4gICAgICogd3JhcHBlZCBjYWxscyB0byBvdGhlciB0dW5uZWxzJyBjb25uZWN0KCkgZnVuY3Rpb25zLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGNvbm5lY3RfZGF0YTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIGFsbCB0dW5uZWxzIHBhc3NlZCB0byB0aGlzIENoYWluZWRUdW5uZWwgdGhyb3VnaCB0aGVcclxuICAgICAqIGNvbnN0cnVjdG9yIGFyZ3VtZW50cy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciB0dW5uZWxzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHVubmVsIGNvbW1pdHRlZCB2aWEgY29tbWl0X3R1bm5lbCgpLCBpZiBhbnksIG9yIG51bGwgaWYgbm8gdHVubmVsXHJcbiAgICAgKiBoYXMgeWV0IGJlZW4gY29tbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLlR1bm5lbH1cclxuICAgICAqL1xyXG4gICAgdmFyIGNvbW1pdHRlZFR1bm5lbCA9IG51bGw7XHJcblxyXG4gICAgLy8gTG9hZCBhbGwgdHVubmVscyBpbnRvIGFycmF5XHJcbiAgICBmb3IgKHZhciBpPTA7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHR1bm5lbHMucHVzaChhcmd1bWVudHNbaV0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCB0dW5uZWwuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5UdW5uZWx9IHR1bm5lbCBUaGUgdHVubmVsIHRvIHNldCBhcyB0aGUgY3VycmVudCB0dW5uZWwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGF0dGFjaCh0dW5uZWwpIHtcclxuXHJcbiAgICAgICAgLy8gU2V0IG93biBmdW5jdGlvbnMgdG8gdHVubmVsJ3MgZnVuY3Rpb25zXHJcbiAgICAgICAgY2hhaW5lZF90dW5uZWwuZGlzY29ubmVjdCAgPSB0dW5uZWwuZGlzY29ubmVjdDtcclxuICAgICAgICBjaGFpbmVkX3R1bm5lbC5zZW5kTWVzc2FnZSA9IHR1bm5lbC5zZW5kTWVzc2FnZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmFpbHMgdGhlIGN1cnJlbnRseS1hdHRhY2hlZCB0dW5uZWwsIGF0dGFjaGluZyBhIG5ldyB0dW5uZWwgaWZcclxuICAgICAgICAgKiBwb3NzaWJsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtHdWFjYW1vbGUuU3RhdHVzfSBbc3RhdHVzXVxyXG4gICAgICAgICAqICAgICBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBmYWlsdXJlIHRoYXQgb2NjdXJlZCBpbiB0aGVcclxuICAgICAgICAgKiAgICAgY3VycmVudGx5LWF0dGFjaGVkIHR1bm5lbCwgaWYga25vd24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtHdWFjYW1vbGUuVHVubmVsfVxyXG4gICAgICAgICAqICAgICBUaGUgbmV4dCB0dW5uZWwsIG9yIG51bGwgaWYgdGhlcmUgYXJlIG5vIG1vcmUgdHVubmVscyB0byB0cnkgb3JcclxuICAgICAgICAgKiAgICAgaWYgbm8gbW9yZSB0dW5uZWxzIHNob3VsZCBiZSB0cmllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgZmFpbFR1bm5lbCA9IGZ1bmN0aW9uIGZhaWxUdW5uZWwoc3RhdHVzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byBjb250aW51ZSB1c2luZyBuZXh0IHR1bm5lbCBvbiBzZXJ2ZXIgdGltZW91dFxyXG4gICAgICAgICAgICBpZiAoc3RhdHVzICYmIHN0YXR1cy5jb2RlID09PSBHdWFjYW1vbGUuU3RhdHVzLkNvZGUuVVBTVFJFQU1fVElNRU9VVCkge1xyXG4gICAgICAgICAgICAgICAgdHVubmVscyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBuZXh0IHR1bm5lbFxyXG4gICAgICAgICAgICB2YXIgbmV4dF90dW5uZWwgPSB0dW5uZWxzLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBJUyBhIG5leHQgdHVubmVsLCB0cnkgdXNpbmcgaXQuXHJcbiAgICAgICAgICAgIGlmIChuZXh0X3R1bm5lbCkge1xyXG4gICAgICAgICAgICAgICAgdHVubmVsLm9uZXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdHVubmVsLm9uaW5zdHJ1Y3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdHVubmVsLm9uc3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgYXR0YWNoKG5leHRfdHVubmVsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5leHRfdHVubmVsO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2UgdGhlIGN1cnJlbnQgdHVubmVsIGZyb20gdGhpcyBwb2ludCBmb3J3YXJkLiBEbyBub3QgdHJ5IGFueSBtb3JlXHJcbiAgICAgICAgICogdHVubmVscywgZXZlbiBpZiB0aGUgY3VycmVudCB0dW5uZWwgZmFpbHMuXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBjb21taXRfdHVubmVsKCkge1xyXG5cclxuICAgICAgICAgICAgdHVubmVsLm9uc3RhdGVjaGFuZ2UgPSBjaGFpbmVkX3R1bm5lbC5vbnN0YXRlY2hhbmdlO1xyXG4gICAgICAgICAgICB0dW5uZWwub25pbnN0cnVjdGlvbiA9IGNoYWluZWRfdHVubmVsLm9uaW5zdHJ1Y3Rpb247XHJcbiAgICAgICAgICAgIHR1bm5lbC5vbmVycm9yID0gY2hhaW5lZF90dW5uZWwub25lcnJvcjtcclxuICAgICAgICAgICAgdHVubmVsLm9udXVpZCA9IGNoYWluZWRfdHVubmVsLm9udXVpZDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFzc2lnbiBVVUlEIGlmIGFscmVhZHkga25vd25cclxuICAgICAgICAgICAgaWYgKHR1bm5lbC51dWlkKVxyXG4gICAgICAgICAgICAgICAgY2hhaW5lZF90dW5uZWwuc2V0VVVJRCh0dW5uZWwudXVpZCk7XHJcblxyXG4gICAgICAgICAgICBjb21taXR0ZWRUdW5uZWwgPSB0dW5uZWw7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV3JhcCBvd24gb25zdGF0ZWNoYW5nZSB3aXRoaW4gY3VycmVudCB0dW5uZWxcclxuICAgICAgICB0dW5uZWwub25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgb3BlbiwgdXNlIHRoaXMgdHVubmVsIGZyb20gdGhpcyBwb2ludCBmb3J3YXJkLlxyXG4gICAgICAgICAgICAgICAgY2FzZSBHdWFjYW1vbGUuVHVubmVsLlN0YXRlLk9QRU46XHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0X3R1bm5lbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFpbmVkX3R1bm5lbC5vbnN0YXRlY2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbmVkX3R1bm5lbC5vbnN0YXRlY2hhbmdlKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBjbG9zZWQsIG1hcmsgZmFpbHVyZSwgYXR0ZW1wdCBuZXh0IHR1bm5lbFxyXG4gICAgICAgICAgICAgICAgY2FzZSBHdWFjYW1vbGUuVHVubmVsLlN0YXRlLkNMT1NFRDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZhaWxUdW5uZWwoKSAmJiBjaGFpbmVkX3R1bm5lbC5vbnN0YXRlY2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbmVkX3R1bm5lbC5vbnN0YXRlY2hhbmdlKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFdyYXAgb3duIG9uaW5zdHJ1Y3Rpb24gd2l0aGluIGN1cnJlbnQgdHVubmVsXHJcbiAgICAgICAgdHVubmVsLm9uaW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbihvcGNvZGUsIGVsZW1lbnRzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBBY2NlcHQgY3VycmVudCB0dW5uZWxcclxuICAgICAgICAgICAgY29tbWl0X3R1bm5lbCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gSW52b2tlIGhhbmRsZXJcclxuICAgICAgICAgICAgaWYgKGNoYWluZWRfdHVubmVsLm9uaW5zdHJ1Y3Rpb24pXHJcbiAgICAgICAgICAgICAgICBjaGFpbmVkX3R1bm5lbC5vbmluc3RydWN0aW9uKG9wY29kZSwgZWxlbWVudHMpO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBBdHRhY2ggbmV4dCB0dW5uZWwgb24gZXJyb3JcclxuICAgICAgICB0dW5uZWwub25lcnJvciA9IGZ1bmN0aW9uKHN0YXR1cykge1xyXG5cclxuICAgICAgICAgICAgLy8gTWFyayBmYWlsdXJlLCBhdHRlbXB0IG5leHQgdHVubmVsXHJcbiAgICAgICAgICAgIGlmICghZmFpbFR1bm5lbChzdGF0dXMpICYmIGNoYWluZWRfdHVubmVsLm9uZXJyb3IpXHJcbiAgICAgICAgICAgICAgICBjaGFpbmVkX3R1bm5lbC5vbmVycm9yKHN0YXR1cyk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEF0dGVtcHQgY29ubmVjdGlvblxyXG4gICAgICAgIHR1bm5lbC5jb25uZWN0KGNvbm5lY3RfZGF0YSk7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgXHJcbiAgICAgICAgLy8gUmVtZW1iZXIgY29ubmVjdCBkYXRhXHJcbiAgICAgICAgY29ubmVjdF9kYXRhID0gZGF0YTtcclxuXHJcbiAgICAgICAgLy8gR2V0IGNvbW1pdHRlZCB0dW5uZWwgaWYgZXhpc3RzIG9yIHRoZSBmaXJzdCB0dW5uZWwgb24gdGhlIGxpc3RcclxuICAgICAgICB2YXIgbmV4dF90dW5uZWwgPSBjb21taXR0ZWRUdW5uZWwgPyBjb21taXR0ZWRUdW5uZWwgOiB0dW5uZWxzLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgIC8vIEF0dGFjaCBmaXJzdCB0dW5uZWxcclxuICAgICAgICBpZiAobmV4dF90dW5uZWwpXHJcbiAgICAgICAgICAgIGF0dGFjaChuZXh0X3R1bm5lbCk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZXJlIElTIG5vIGZpcnN0IHR1bm5lbCwgZXJyb3JcclxuICAgICAgICBlbHNlIGlmIChjaGFpbmVkX3R1bm5lbC5vbmVycm9yKVxyXG4gICAgICAgICAgICBjaGFpbmVkX3R1bm5lbC5vbmVycm9yKEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5TRVJWRVJfRVJST1IsIFwiTm8gdHVubmVscyB0byB0cnkuXCIpO1xyXG5cclxuICAgIH07XHJcbiAgICBcclxufTtcclxuXHJcbkd1YWNhbW9sZS5DaGFpbmVkVHVubmVsLnByb3RvdHlwZSA9IG5ldyBHdWFjYW1vbGUuVHVubmVsKCk7XHJcblxyXG4vKipcclxuICogR3VhY2Ftb2xlIFR1bm5lbCB3aGljaCByZXBsYXlzIGEgR3VhY2Ftb2xlIHByb3RvY29sIGR1bXAgZnJvbSBhIHN0YXRpYyBmaWxlXHJcbiAqIHJlY2VpdmVkIHZpYSBIVFRQLiBJbnN0cnVjdGlvbnMgd2l0aGluIHRoZSBmaWxlIGFyZSBwYXJzZWQgYW5kIGhhbmRsZWQgYXNcclxuICogcXVpY2tseSBhcyBwb3NzaWJsZSwgd2hpbGUgdGhlIGZpbGUgaXMgYmVpbmcgZG93bmxvYWRlZC5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdWdtZW50cyBHdWFjYW1vbGUuVHVubmVsXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcclxuICogICAgIFRoZSBVUkwgb2YgYSBHdWFjYW1vbGUgcHJvdG9jb2wgZHVtcC5cclxuICpcclxuICogQHBhcmFtIHtCb29sZWFufSBbY3Jvc3NEb21haW49ZmFsc2VdXHJcbiAqICAgICBXaGV0aGVyIHR1bm5lbCByZXF1ZXN0cyB3aWxsIGJlIGNyb3NzLWRvbWFpbiwgYW5kIHRodXMgbXVzdCB1c2UgQ09SU1xyXG4gKiAgICAgbWVjaGFuaXNtcyBhbmQgaGVhZGVycy4gQnkgZGVmYXVsdCwgaXQgaXMgYXNzdW1lZCB0aGF0IHR1bm5lbCByZXF1ZXN0c1xyXG4gKiAgICAgd2lsbCBiZSBtYWRlIHRvIHRoZSBzYW1lIGRvbWFpbi5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtleHRyYVR1bm5lbEhlYWRlcnM9e31dXHJcbiAqICAgICBLZXkgdmFsdWUgcGFpcnMgY29udGFpbmluZyB0aGUgaGVhZGVyIG5hbWVzIGFuZCB2YWx1ZXMgb2YgYW55IGFkZGl0aW9uYWxcclxuICogICAgIGhlYWRlcnMgdG8gYmUgc2VudCBpbiB0dW5uZWwgcmVxdWVzdHMuIEJ5IGRlZmF1bHQsIG5vIGV4dHJhIGhlYWRlcnMgd2lsbFxyXG4gKiAgICAgYmUgYWRkZWQuXHJcbiAqL1xyXG5HdWFjYW1vbGUuU3RhdGljSFRUUFR1bm5lbCA9IGZ1bmN0aW9uIFN0YXRpY0hUVFBUdW5uZWwodXJsLCBjcm9zc0RvbWFpbiwgZXh0cmFUdW5uZWxIZWFkZXJzKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuU3RhdGljSFRUUFR1bm5lbC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgdHVubmVsID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50LCBpbi1wcm9ncmVzcyBIVFRQIHJlcXVlc3QuIElmIG5vIHJlcXVlc3QgaXMgY3VycmVudGx5IGluXHJcbiAgICAgKiBwcm9ncmVzcywgdGhpcyB3aWxsIGJlIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtYTUxIdHRwUmVxdWVzdH1cclxuICAgICAqL1xyXG4gICAgdmFyIHhociA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRpdGlvbmFsIGhlYWRlcnMgdG8gYmUgc2VudCBpbiB0dW5uZWwgcmVxdWVzdHMuIFRoaXMgZGljdGlvbmFyeSBjYW4gYmVcclxuICAgICAqIHBvcHVsYXRlZCB3aXRoIGtleS92YWx1ZSBoZWFkZXIgcGFpcnMgdG8gcGFzcyBpbmZvcm1hdGlvbiBzdWNoIGFzIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgKiB0b2tlbnMsIGV0Yy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZXh0cmFIZWFkZXJzID0gZXh0cmFUdW5uZWxIZWFkZXJzIHx8IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgY29uZmlndXJlZCBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gdGhlIGdpdmVuIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdH0gcmVxdWVzdFxyXG4gICAgICogICAgIFRoZSByZXF1ZXN0IHdoZXJlIHRoZSBjb25maWd1cmVkIGV4dHJhIGhlYWRlcnMgd2lsbCBiZSBhZGRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xyXG4gICAgICogICAgIFRoZSBoZWFkZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZEV4dHJhSGVhZGVycyhyZXF1ZXN0LCBoZWFkZXJzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBoZWFkZXJzW25hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uIHNlbmRNZXNzYWdlKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZ1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNvbm5lY3QgPSBmdW5jdGlvbiBjb25uZWN0KGRhdGEpIHtcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIGFueSBleGlzdGluZyBjb25uZWN0aW9uIGlzIGtpbGxlZFxyXG4gICAgICAgIHR1bm5lbC5kaXNjb25uZWN0KCk7XHJcblxyXG4gICAgICAgIC8vIENvbm5lY3Rpb24gaXMgbm93IHN0YXJ0aW5nXHJcbiAgICAgICAgdHVubmVsLnNldFN0YXRlKEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuQ09OTkVDVElORyk7XHJcblxyXG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IGNvbm5lY3Rpb25cclxuICAgICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcclxuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFjcm9zc0RvbWFpbjtcclxuICAgICAgICBhZGRFeHRyYUhlYWRlcnMoeGhyLCBleHRyYUhlYWRlcnMpO1xyXG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAndGV4dCc7XHJcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcblxyXG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgR3VhY2Ftb2xlIHByb3RvY29sIHBhcnNlciBzcGVjaWZpY2FsbHkgZm9yIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgR3VhY2Ftb2xlLlBhcnNlcigpO1xyXG5cclxuICAgICAgICAvLyBJbnZva2UgdHVubmVsJ3Mgb25pbnN0cnVjdGlvbiBoYW5kbGVyIGZvciBlYWNoIHBhcnNlZCBpbnN0cnVjdGlvblxyXG4gICAgICAgIHBhcnNlci5vbmluc3RydWN0aW9uID0gZnVuY3Rpb24gaW5zdHJ1Y3Rpb25SZWNlaXZlZChvcGNvZGUsIGFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKHR1bm5lbC5vbmluc3RydWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgdHVubmVsLm9uaW5zdHJ1Y3Rpb24ob3Bjb2RlLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDb250aW51b3VzbHkgcGFyc2UgcmVjZWl2ZWQgZGF0YVxyXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiByZWFkeVN0YXRlQ2hhbmdlZCgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFBhcnNlIHdoaWxlIGRhdGEgaXMgYmVpbmcgcmVjZWl2ZWRcclxuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSAzIHx8IHhoci5yZWFkeVN0YXRlID09PSA0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29ubmVjdGlvbiBpcyBvcGVuXHJcbiAgICAgICAgICAgICAgICB0dW5uZWwuc2V0U3RhdGUoR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5PUEVOKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0geGhyLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG9ubHkgdGhlIHBvcnRpb24gb2YgZGF0YSB3aGljaCBpcyBuZXdseSByZWNlaXZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5yZWNlaXZlKGJ1ZmZlci5zdWJzdHJpbmcob2Zmc2V0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgYW5kIGNsb3NlIHdoZW4gZG9uZVxyXG4gICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpXHJcbiAgICAgICAgICAgICAgICB0dW5uZWwuZGlzY29ubmVjdCgpO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBSZXNldCBzdGF0ZSBhbmQgY2xvc2UgdXBvbiBlcnJvclxyXG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gaHR0cEVycm9yKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gRmFpbCBpZiBmaWxlIGNvdWxkIG5vdCBiZSBkb3dubG9hZGVkIHZpYSBIVFRQXHJcbiAgICAgICAgICAgIGlmICh0dW5uZWwub25lcnJvcilcclxuICAgICAgICAgICAgICAgIHR1bm5lbC5vbmVycm9yKG5ldyBHdWFjYW1vbGUuU3RhdHVzKFxyXG4gICAgICAgICAgICAgICAgICAgIEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5mcm9tSFRUUENvZGUoeGhyLnN0YXR1cyksIHhoci5zdGF0dXNUZXh0KSk7XHJcblxyXG4gICAgICAgICAgICB0dW5uZWwuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xyXG5cclxuICAgICAgICAvLyBBYm9ydCBhbmQgZGlzcG9zZSBvZiBYSFIgaWYgYSByZXF1ZXN0IGlzIGluIHByb2dyZXNzXHJcbiAgICAgICAgaWYgKHhocikge1xyXG4gICAgICAgICAgICB4aHIuYWJvcnQoKTtcclxuICAgICAgICAgICAgeGhyID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbm5lY3Rpb24gaXMgbm93IGNsb3NlZFxyXG4gICAgICAgIHR1bm5lbC5zZXRTdGF0ZShHdWFjYW1vbGUuVHVubmVsLlN0YXRlLkNMT1NFRCk7XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5HdWFjYW1vbGUuU3RhdGljSFRUUFR1bm5lbC5wcm90b3R5cGUgPSBuZXcgR3VhY2Ftb2xlLlR1bm5lbCgpO1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogVGhlIHVuaXF1ZSBJRCBvZiB0aGlzIHZlcnNpb24gb2YgdGhlIEd1YWNhbW9sZSBKYXZhU2NyaXB0IEFQSS4gVGhpcyBJRCB3aWxsXHJcbiAqIGJlIHRoZSB2ZXJzaW9uIHN0cmluZyBvZiB0aGUgZ3VhY2Ftb2xlLWNvbW1vbi1qcyBNYXZlbiBwcm9qZWN0LCBhbmQgY2FuIGJlXHJcbiAqIHVzZWQgaW4gZG93bnN0cmVhbSBhcHBsaWNhdGlvbnMgYXMgYSBzYW5pdHkgY2hlY2sgdGhhdCB0aGUgcHJvcGVyIHZlcnNpb25cclxuICogb2YgdGhlIEFQSXMgaXMgYmVpbmcgdXNlZCAoaW4gY2FzZSBhbiBvbGRlciB2ZXJzaW9uIGlzIGNhY2hlZCwgZm9yIGV4YW1wbGUpLlxyXG4gKlxyXG4gKiBAdHlwZSB7U3RyaW5nfVxyXG4gKi9cclxuR3VhY2Ftb2xlLkFQSV9WRVJTSU9OID0gXCIxLjMuMFwiO1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgdmlkZW8gcGxheWVyIHdoaWNoIGFjY2VwdHMsIHF1ZXVlcyBhbmQgcGxheXMgYmFjayBhcmJpdHJhcnkgdmlkZW9cclxuICogZGF0YS4gSXQgaXMgdXAgdG8gaW1wbGVtZW50YXRpb25zIG9mIHRoaXMgY2xhc3MgdG8gcHJvdmlkZSBzb21lIG1lYW5zIG9mXHJcbiAqIGhhbmRsaW5nIGEgcHJvdmlkZWQgR3VhY2Ftb2xlLklucHV0U3RyZWFtIGFuZCByZW5kZXJpbmcgdGhlIHJlY2VpdmVkIGRhdGEgdG9cclxuICogdGhlIHByb3ZpZGVkIEd1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllci4gRGF0YSByZWNlaXZlZCBhbG9uZyB0aGVcclxuICogcHJvdmlkZWQgc3RyZWFtIGlzIHRvIGJlIHBsYXllZCBiYWNrIGltbWVkaWF0ZWx5LlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbkd1YWNhbW9sZS5WaWRlb1BsYXllciA9IGZ1bmN0aW9uIFZpZGVvUGxheWVyKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm90aWZpZXMgdGhpcyBHdWFjYW1vbGUuVmlkZW9QbGF5ZXIgdGhhdCBhbGwgdmlkZW8gdXAgdG8gdGhlIGN1cnJlbnRcclxuICAgICAqIHBvaW50IGluIHRpbWUgaGFzIGJlZW4gZ2l2ZW4gdmlhIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSwgYW5kIHRoYXQgYW55XHJcbiAgICAgKiBkaWZmZXJlbmNlIGluIHRpbWUgYmV0d2VlbiBxdWV1ZWQgdmlkZW8gZGF0YSBhbmQgdGhlIGN1cnJlbnQgdGltZSBjYW4gYmVcclxuICAgICAqIGNvbnNpZGVyZWQgbGF0ZW5jeS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zeW5jID0gZnVuY3Rpb24gc3luYygpIHtcclxuICAgICAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIC0gZG8gbm90aGluZ1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBtaW1ldHlwZSBpcyBzdXBwb3J0ZWQgYnkgYW55IGJ1aWx0LWluXHJcbiAqIGltcGxlbWVudGF0aW9uIG9mIEd1YWNhbW9sZS5WaWRlb1BsYXllciwgYW5kIHRodXMgd2lsbCBiZSBwcm9wZXJseSBoYW5kbGVkXHJcbiAqIGJ5IEd1YWNhbW9sZS5WaWRlb1BsYXllci5nZXRJbnN0YW5jZSgpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICogICAgIFRoZSBtaW1ldHlwZSB0byBjaGVjay5cclxuICpcclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqICAgICB0cnVlIGlmIHRoZSBnaXZlbiBtaW1ldHlwZSBpcyBzdXBwb3J0ZWQgYnkgYW55IGJ1aWx0LWluXHJcbiAqICAgICBHdWFjYW1vbGUuVmlkZW9QbGF5ZXIsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbkd1YWNhbW9sZS5WaWRlb1BsYXllci5pc1N1cHBvcnRlZFR5cGUgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZFR5cGUobWltZXR5cGUpIHtcclxuXHJcbiAgICAvLyBUaGVyZSBhcmUgY3VycmVudGx5IG5vIGJ1aWx0LWluIHZpZGVvIHBsYXllcnMgKGFuZCB0aGVyZWZvcmUgbm9cclxuICAgIC8vIHN1cHBvcnRlZCB0eXBlcylcclxuICAgIHJldHVybiBmYWxzZTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIG1pbWV0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IGJ1aWx0LWluXHJcbiAqIEd1YWNhbW9sZS5WaWRlb1BsYXllciwgaW4gcm91Z2ggb3JkZXIgb2YgcHJpb3JpdHkuIEJld2FyZSB0aGF0IG9ubHkgdGhlIGNvcmVcclxuICogbWltZXR5cGVzIHRoZW1zZWx2ZXMgd2lsbCBiZSBsaXN0ZWQuIEFueSBtaW1ldHlwZSBwYXJhbWV0ZXJzLCBldmVuIHJlcXVpcmVkXHJcbiAqIG9uZXMsIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBsaXN0LlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nW119XHJcbiAqICAgICBBIGxpc3Qgb2YgYWxsIG1pbWV0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IGJ1aWx0LWluIEd1YWNhbW9sZS5WaWRlb1BsYXllcixcclxuICogICAgIGV4Y2x1ZGluZyBhbnkgcGFyYW1ldGVycy5cclxuICovXHJcbkd1YWNhbW9sZS5WaWRlb1BsYXllci5nZXRTdXBwb3J0ZWRUeXBlcyA9IGZ1bmN0aW9uIGdldFN1cHBvcnRlZFR5cGVzKCkge1xyXG5cclxuICAgIC8vIFRoZXJlIGFyZSBjdXJyZW50bHkgbm8gYnVpbHQtaW4gdmlkZW8gcGxheWVycyAoYW5kIHRoZXJlZm9yZSBub1xyXG4gICAgLy8gc3VwcG9ydGVkIHR5cGVzKVxyXG4gICAgcmV0dXJuIFtdO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIEd1YWNhbW9sZS5WaWRlb1BsYXllciBwcm92aWRpbmcgc3VwcG9ydCBmb3IgdGhlIGdpdmVuXHJcbiAqIHZpZGVvIGZvcm1hdC4gSWYgc3VwcG9ydCBmb3IgdGhlIGdpdmVuIHZpZGVvIGZvcm1hdCBpcyBub3QgYXZhaWxhYmxlLCBudWxsXHJcbiAqIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gc3RyZWFtXHJcbiAqICAgICBUaGUgR3VhY2Ftb2xlLklucHV0U3RyZWFtIHRvIHJlYWQgdmlkZW8gZGF0YSBmcm9tLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllcn0gbGF5ZXJcclxuICogICAgIFRoZSBkZXN0aW5hdGlvbiBsYXllciBpbiB3aGljaCB0aGlzIEd1YWNhbW9sZS5WaWRlb1BsYXllciBzaG91bGQgcGxheVxyXG4gKiAgICAgdGhlIHJlY2VpdmVkIHZpZGVvIGRhdGEuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gKiAgICAgVGhlIG1pbWV0eXBlIG9mIHRoZSB2aWRlbyBkYXRhIGluIHRoZSBwcm92aWRlZCBzdHJlYW0uXHJcbiAqXHJcbiAqIEByZXR1cm4ge0d1YWNhbW9sZS5WaWRlb1BsYXllcn1cclxuICogICAgIEEgR3VhY2Ftb2xlLlZpZGVvUGxheWVyIGluc3RhbmNlIHN1cHBvcnRpbmcgdGhlIGdpdmVuIG1pbWV0eXBlIGFuZFxyXG4gKiAgICAgcmVhZGluZyBmcm9tIHRoZSBnaXZlbiBzdHJlYW0sIG9yIG51bGwgaWYgc3VwcG9ydCBmb3IgdGhlIGdpdmVuIG1pbWV0eXBlXHJcbiAqICAgICBpcyBhYnNlbnQuXHJcbiAqL1xyXG5HdWFjYW1vbGUuVmlkZW9QbGF5ZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRJbnN0YW5jZShzdHJlYW0sIGxheWVyLCBtaW1ldHlwZSkge1xyXG5cclxuICAgIC8vIFRoZXJlIGFyZSBjdXJyZW50bHkgbm8gYnVpbHQtaW4gdmlkZW8gcGxheWVyc1xyXG4gICAgcmV0dXJuIG51bGw7XHJcblxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IEd1YWNhbW9sZTsiLCJleHBvcnQgY2xhc3MgR3JlZXRlclxyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIGdyZWV0KG1lc3NhZ2U6IHN0cmluZyk6IHN0cmluZ1xyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBgSGVsbG8sICR7bWVzc2FnZX0hYDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRlc3RDbGFzczJcclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBIZWxsbzIobWVzc2FnZTogc3RyaW5nKTogdm9pZFxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSGVsbG8gXCIgKyBtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRlc3RDbGFzczFcclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBIZWxsbyhtZXNzYWdlOiBzdHJpbmcpOiB2b2lkXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJIZWxsbyBcIiArIG1lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgU2xlZXBBc3luYyhtc2VjOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+XHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAocmVzb2x2ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0sIG1zZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBIZWxsb0FzeW5jKCk6IFByb21pc2U8dm9pZD5cclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0XCIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChpID49IDEwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlRoaXMgaXMgRXJyb3IgISEhXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5TbGVlcEFzeW5jKDUwKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJOZWtvXyAxMTEgOiBcIiArIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhcImVuZFwiKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7IH0iLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCBcImNvcmUtanMvZXMvcHJvbWlzZVwiO1xyXG5cclxuaW1wb3J0IHsgR3JlZXRlciwgVGVzdENsYXNzMSwgVGVzdENsYXNzMiB9IGZyb20gXCIuL0RuTGliXCI7XHJcblxyXG5pbXBvcnQgR3VhY2Ftb2xlIGZyb20gXCJndWFjYW1vbGUtY29tbW9uLWpzXCI7XHJcbi8vaW1wb3J0ICogYXMgR3VhY2Ftb2xlIGZyb20gXCIuL2d1YWNhbW9sZS1jb21tb25cIjtcclxuXHJcblxyXG4vL2NvbnNvbGUubG9nKFwiSGVsbG8gV29ybGRcIik7XHJcblxyXG4vL2FsZXJ0KEdyZWV0ZXIuZ3JlZXQoXCJ3b3JsZCAwMjFcIikpO1xyXG5cclxuVGVzdENsYXNzMi5IZWxsbzIoXCJJbnVcIik7XHJcblRlc3RDbGFzczEuSGVsbG8oXCJOZWtvXCIpO1xyXG5cclxuLy9UZXN0RnVuYzEoKTtcclxuXHJcblxyXG5mdW5jdGlvbiBUZXN0RnVuYzEoKTogdm9pZFxyXG57XHJcbiAgICBjb25zb2xlLmxvZyhcIi0tYVwiKTtcclxuICAgIGNvbnN0IHRhc2sgPSBUZXN0Q2xhc3MxLkhlbGxvQXN5bmMoKTtcclxuICAgIHRhc2suY2F0Y2goeCA9PlxyXG4gICAge1xyXG4gICAgICAgIGFsZXJ0KHgpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZyhcIi0tYlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRvbVxyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIEh0bWxUZXN0MSgpOiB2b2lkXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJUb20gSHRtbCB0ZXN0IDFcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBHdWFjYW1vbGVUZXN0MShkaXNwbGF5OiBIVE1MRWxlbWVudCk6IHZvaWRcclxuICAgIHtcclxuICAgICAgICBjb25zdCB0dW5uZWwgPSBuZXcgR3VhY2Ftb2xlLldlYlNvY2tldFR1bm5lbChcIk1vZGVsLldlYlNvY2tldFVybFwiKTtcclxuXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgdHVubmVsLm9uZXJyb3IgPSBmdW5jdGlvbiAoc3RhdHVzOiBhbnkpOiB2b2lkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0dXMpO1xyXG4gICAgICAgICAgICBhbGVydChcIlR1bm5lbCBFcnJvciBDb2RlOiBcIiArIHN0YXR1cy5jb2RlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBJbnN0YW50aWF0ZSBjbGllbnQsIHVzaW5nIGEgV2ViU29ja2V0IHR1bm5lbCBmb3IgY29tbXVuaWNhdGlvbnMuXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGNvbnN0IGd1YWMgPSBuZXcgR3VhY2Ftb2xlLkNsaWVudCh0dW5uZWwpO1xyXG5cclxuICAgICAgICAvLyBBZGQgY2xpZW50IHRvIGRpc3BsYXkgZGl2XHJcbiAgICAgICAgZGlzcGxheS5hcHBlbmRDaGlsZChndWFjLmdldERpc3BsYXkoKS5nZXRFbGVtZW50KCkpO1xyXG5cclxuICAgICAgICAvLyBFcnJvciBoYW5kbGVyXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBndWFjLm9uZXJyb3IgPSBmdW5jdGlvbiAoc3RhdHVzOiBhbnkpOiB2b2lkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0dXMpO1xyXG4gICAgICAgICAgICBhbGVydChcIlJlbW90ZSBEZXNrdG9wIEVycm9yIENvZGU6IFwiICsgc3RhdHVzLmNvZGUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGd1YWMuY29ubmVjdChcImlkPU1vZGVsLlNlc3Npb25JZFwiKTtcclxuXHJcbiAgICAgICAgd2luZG93Lm9udW5sb2FkID0gZnVuY3Rpb24gKCk6IHZvaWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGd1YWMuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2FtcGxlRnVuY3Rpb25FeHBvcnRlZDEoKTogdm9pZFxyXG57XHJcbiAgICBjb25zb2xlLmxvZyhcInNhbXBsZUZ1bmN0aW9uRXhwb3J0ZWQxXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gVGVzdEZ1bmMyKCk6IHZvaWRcclxue1xyXG4gICAgY29uc29sZS5sb2coXCJUZXN0RnVuYzJcIik7XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==