(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Hoge"] = factory();
	else
		root["Hoge"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 7633:
/*!**************************************************!*\
  !*** ./node_modules/core-js/es/promise/index.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.aggregate-error */ 9170);
__webpack_require__(/*! ../../modules/es.object.to-string */ 1539);
__webpack_require__(/*! ../../modules/es.promise */ 8674);
__webpack_require__(/*! ../../modules/es.promise.all-settled */ 7922);
__webpack_require__(/*! ../../modules/es.promise.any */ 4668);
__webpack_require__(/*! ../../modules/es.promise.finally */ 7727);
__webpack_require__(/*! ../../modules/es.string.iterator */ 8783);
__webpack_require__(/*! ../../modules/web.dom-collections.iterator */ 3948);
var path = __webpack_require__(/*! ../../internals/path */ 857);

module.exports = path.Promise;


/***/ }),

/***/ 3099:
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-function.js ***!
  \******************************************************/
/***/ (function(module) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ 6077:
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ 111);

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ 1223:
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var create = __webpack_require__(/*! ../internals/object-create */ 30);
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ 3070);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ 5787:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
/***/ (function(module) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ 9670:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ 111);

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ 1318:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ 5656);
var toLength = __webpack_require__(/*! ../internals/to-length */ 7466);
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ 1400);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 7072:
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ 4326:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/***/ (function(module) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ 648:
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ 1694);
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ 4326);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ 9920:
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ 6656);
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ 3887);
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ 1236);
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ 3070);

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ 8544:
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ 7293);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 4994:
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ 3383).IteratorPrototype;
var create = __webpack_require__(/*! ../internals/object-create */ 30);
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ 9114);
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ 8003);
var Iterators = __webpack_require__(/*! ../internals/iterators */ 7497);

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ 8880:
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ 3070);
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ 9114);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 9114:
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/***/ (function(module) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 654:
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-iterator.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ 4994);
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ 9518);
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ 7674);
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ 8003);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ 1913);
var Iterators = __webpack_require__(/*! ../internals/iterators */ 7497);
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ 3383);

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ 9781:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ 7293);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 317:
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var isObject = __webpack_require__(/*! ../internals/is-object */ 111);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 8324:
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/***/ (function(module) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ 6833:
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-ios.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ 8113);

module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);


/***/ }),

/***/ 5268:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-node.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ 4326);
var global = __webpack_require__(/*! ../internals/global */ 7854);

module.exports = classof(global.process) == 'process';


/***/ }),

/***/ 1036:
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-webos-webkit.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ 8113);

module.exports = /web0s(?!.*chrome)/i.test(userAgent);


/***/ }),

/***/ 8113:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 7392:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ 8113);

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ 748:
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/***/ (function(module) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 2109:
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ 1236).f;
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);
var setGlobal = __webpack_require__(/*! ../internals/set-global */ 3505);
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ 9920);
var isForced = __webpack_require__(/*! ../internals/is-forced */ 4705);

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 7293:
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 9974:
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 5005:
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ 857);
var global = __webpack_require__(/*! ../internals/global */ 7854);

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 1246:
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof */ 648);
var Iterators = __webpack_require__(/*! ../internals/iterators */ 7497);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ 7854:
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  /* global globalThis -- safe */
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 6656:
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/***/ (function(module) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ 3501:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 842:
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/host-report-errors.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ 490:
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 4664:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);
var fails = __webpack_require__(/*! ../internals/fails */ 7293);
var createElement = __webpack_require__(/*! ../internals/document-create-element */ 317);

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 8361:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ 7293);
var classof = __webpack_require__(/*! ../internals/classof-raw */ 4326);

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ 2788:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var store = __webpack_require__(/*! ../internals/shared-store */ 5465);

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 9909:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ 8536);
var global = __webpack_require__(/*! ../internals/global */ 7854);
var isObject = __webpack_require__(/*! ../internals/is-object */ 111);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var objectHas = __webpack_require__(/*! ../internals/has */ 6656);
var shared = __webpack_require__(/*! ../internals/shared-store */ 5465);
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ 6200);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ 3501);

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 7659:
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var Iterators = __webpack_require__(/*! ../internals/iterators */ 7497);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ 4705:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ 7293);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 111:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/***/ (function(module) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ 1913:
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/***/ (function(module) {

module.exports = false;


/***/ }),

/***/ 408:
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/iterate.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ 7659);
var toLength = __webpack_require__(/*! ../internals/to-length */ 7466);
var bind = __webpack_require__(/*! ../internals/function-bind-context */ 9974);
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ 1246);
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ 9212);

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator);
      throw error;
    }
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};


/***/ }),

/***/ 9212:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-close.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);

module.exports = function (iterator) {
  var returnMethod = iterator['return'];
  if (returnMethod !== undefined) {
    return anObject(returnMethod.call(iterator)).value;
  }
};


/***/ }),

/***/ 3383:
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ 7293);
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ 9518);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var has = __webpack_require__(/*! ../internals/has */ 6656);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ 1913);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 7497:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 5948:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/microtask.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ 1236).f;
var macrotask = __webpack_require__(/*! ../internals/task */ 261).set;
var IS_IOS = __webpack_require__(/*! ../internals/engine-is-ios */ 6833);
var IS_WEBOS_WEBKIT = __webpack_require__(/*! ../internals/engine-is-webos-webkit */ 1036);
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ 5268);

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    then = promise.then;
    notify = function () {
      then.call(promise, flush);
    };
  // Node.js without promises
  } else if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ 3366:
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/native-promise-constructor.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);

module.exports = global.Promise;


/***/ }),

/***/ 133:
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ 5268);
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ 7392);
var fails = __webpack_require__(/*! ../internals/fails */ 7293);

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  /* global Symbol -- required for testing */
  return !Symbol.sham &&
    // Chrome 38 Symbol has incorrect toString conversion
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    (IS_NODE ? V8_VERSION === 38 : V8_VERSION > 37 && V8_VERSION < 41);
});


/***/ }),

/***/ 8536:
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ 2788);

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 8523:
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/new-promise-capability.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ 30:
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ 6048);
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ 748);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ 3501);
var html = __webpack_require__(/*! ../internals/html */ 490);
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ 317);
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ 6200);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject -- old IE */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ 6048:
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ 3070);
var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ 1956);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ 3070:
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ 4664);
var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ 7593);

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 1236:
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ 5296);
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ 9114);
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ 5656);
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ 7593);
var has = __webpack_require__(/*! ../internals/has */ 6656);
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ 4664);

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ 8006:
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ 6324);
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ 748);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 5181:
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 9518:
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ 6656);
var toObject = __webpack_require__(/*! ../internals/to-object */ 7908);
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ 6200);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ 8544);

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 6324:
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ 6656);
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ 5656);
var indexOf = __webpack_require__(/*! ../internals/array-includes */ 1318).indexOf;
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ 3501);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ 1956:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ 6324);
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ 748);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 5296:
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),

/***/ 7674:
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable no-proto -- safe */
var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ 6077);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 288:
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ 1694);
var classof = __webpack_require__(/*! ../internals/classof */ 648);

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ 3887:
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ 8006);
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ 5181);
var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 857:
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);

module.exports = global;


/***/ }),

/***/ 2534:
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/perform.js ***!
  \***************************************************/
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ 9478:
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/promise-resolve.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var isObject = __webpack_require__(/*! ../internals/is-object */ 111);
var newPromiseCapability = __webpack_require__(/*! ../internals/new-promise-capability */ 8523);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ 2248:
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/redefine-all.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ 1320:
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var has = __webpack_require__(/*! ../internals/has */ 6656);
var setGlobal = __webpack_require__(/*! ../internals/set-global */ 3505);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ 2788);
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ 9909);

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ 4488:
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/***/ (function(module) {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 3505:
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 6340:
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-species.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ 3070);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ 9781);

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ 8003:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ 3070).f;
var has = __webpack_require__(/*! ../internals/has */ 6656);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ 6200:
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var shared = __webpack_require__(/*! ../internals/shared */ 2309);
var uid = __webpack_require__(/*! ../internals/uid */ 9711);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5465:
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var setGlobal = __webpack_require__(/*! ../internals/set-global */ 3505);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ 2309:
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ 1913);
var store = __webpack_require__(/*! ../internals/shared-store */ 5465);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.9.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ 6707:
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/species-constructor.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ 9670);
var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),

/***/ 8710:
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/string-multibyte.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ 9958);
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ 4488);

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ 261:
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/task.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var fails = __webpack_require__(/*! ../internals/fails */ 7293);
var bind = __webpack_require__(/*! ../internals/function-bind-context */ 9974);
var html = __webpack_require__(/*! ../internals/html */ 490);
var createElement = __webpack_require__(/*! ../internals/document-create-element */ 317);
var IS_IOS = __webpack_require__(/*! ../internals/engine-is-ios */ 6833);
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ 5268);

var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins -- safe
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func -- spec requirement
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    typeof postMessage == 'function' &&
    !global.importScripts &&
    location && location.protocol !== 'file:' &&
    !fails(post)
  ) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ 1400:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ 9958);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5656:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ 8361);
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ 4488);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 9958:
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/***/ (function(module) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ 7466:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ 9958);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 7908:
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ 4488);

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 7593:
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ 111);

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 1694:
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 9711:
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/***/ (function(module) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ 3307:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ 133);

module.exports = NATIVE_SYMBOL
  /* global Symbol -- safe */
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 5112:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var shared = __webpack_require__(/*! ../internals/shared */ 2309);
var has = __webpack_require__(/*! ../internals/has */ 6656);
var uid = __webpack_require__(/*! ../internals/uid */ 9711);
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ 133);
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ 3307);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 9170:
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.aggregate-error.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ 9518);
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ 7674);
var create = __webpack_require__(/*! ../internals/object-create */ 30);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ 9114);
var iterate = __webpack_require__(/*! ../internals/iterate */ 408);

var $AggregateError = function AggregateError(errors, message) {
  var that = this;
  if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message);
  if (setPrototypeOf) {
    // eslint-disable-next-line unicorn/error-message -- expected
    that = setPrototypeOf(new Error(undefined), getPrototypeOf(that));
  }
  if (message !== undefined) createNonEnumerableProperty(that, 'message', String(message));
  var errorsArray = [];
  iterate(errors, errorsArray.push, { that: errorsArray });
  createNonEnumerableProperty(that, 'errors', errorsArray);
  return that;
};

$AggregateError.prototype = create(Error.prototype, {
  constructor: createPropertyDescriptor(5, $AggregateError),
  message: createPropertyDescriptor(5, ''),
  name: createPropertyDescriptor(5, 'AggregateError')
});

// `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor
$({ global: true }, {
  AggregateError: $AggregateError
});


/***/ }),

/***/ 6992:
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ 5656);
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ 1223);
var Iterators = __webpack_require__(/*! ../internals/iterators */ 7497);
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ 9909);
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ 654);

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ 1539:
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ 1694);
var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);
var toString = __webpack_require__(/*! ../internals/object-to-string */ 288);

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ 7922:
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.all-settled.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ 8523);
var perform = __webpack_require__(/*! ../internals/perform */ 2534);
var iterate = __webpack_require__(/*! ../internals/iterate */ 408);

// `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled
$({ target: 'Promise', stat: true }, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'fulfilled', value: value };
          --remaining || resolve(values);
        }, function (error) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'rejected', reason: error };
          --remaining || resolve(values);
        });
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 4668:
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.any.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ 8523);
var perform = __webpack_require__(/*! ../internals/perform */ 2534);
var iterate = __webpack_require__(/*! ../internals/iterate */ 408);

var PROMISE_ANY_ERROR = 'No one promise resolved';

// `Promise.any` method
// https://tc39.es/ecma262/#sec-promise.any
$({ target: 'Promise', stat: true }, {
  any: function any(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aFunction(C.resolve);
      var errors = [];
      var counter = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyRejected = false;
        errors.push(undefined);
        remaining++;
        promiseResolve.call(C, promise).then(function (value) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyResolved = true;
          resolve(value);
        }, function (error) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyRejected = true;
          errors[index] = error;
          --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 7727:
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.finally.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ 1913);
var NativePromise = __webpack_require__(/*! ../internals/native-promise-constructor */ 3366);
var fails = __webpack_require__(/*! ../internals/fails */ 7293);
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ 6707);
var promiseResolve = __webpack_require__(/*! ../internals/promise-resolve */ 9478);
var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);

// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromise && fails(function () {
  NativePromise.prototype['finally'].call({ then: function () { /* empty */ } }, function () { /* empty */ });
});

// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = typeof onFinally == 'function';
    return this.then(
      isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () { return x; });
      } : onFinally,
      isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () { throw e; });
      } : onFinally
    );
  }
});

// patch native Promise.prototype for native async functions
if (!IS_PURE && typeof NativePromise == 'function' && !NativePromise.prototype['finally']) {
  redefine(NativePromise.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
}


/***/ }),

/***/ 8674:
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ 2109);
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ 1913);
var global = __webpack_require__(/*! ../internals/global */ 7854);
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ 5005);
var NativePromise = __webpack_require__(/*! ../internals/native-promise-constructor */ 3366);
var redefine = __webpack_require__(/*! ../internals/redefine */ 1320);
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ 2248);
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ 8003);
var setSpecies = __webpack_require__(/*! ../internals/set-species */ 6340);
var isObject = __webpack_require__(/*! ../internals/is-object */ 111);
var aFunction = __webpack_require__(/*! ../internals/a-function */ 3099);
var anInstance = __webpack_require__(/*! ../internals/an-instance */ 5787);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ 2788);
var iterate = __webpack_require__(/*! ../internals/iterate */ 408);
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ 7072);
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ 6707);
var task = __webpack_require__(/*! ../internals/task */ 261).set;
var microtask = __webpack_require__(/*! ../internals/microtask */ 5948);
var promiseResolve = __webpack_require__(/*! ../internals/promise-resolve */ 9478);
var hostReportErrors = __webpack_require__(/*! ../internals/host-report-errors */ 842);
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ 8523);
var perform = __webpack_require__(/*! ../internals/perform */ 2534);
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ 9909);
var isForced = __webpack_require__(/*! ../internals/is-forced */ 4705);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ 5268);
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ 7392);

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (V8_VERSION === 66) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    if (!IS_NODE && !NATIVE_REJECTION_EVENT) return true;
  }
  // We need Promise#finally in the pure version for preventing prototype pollution
  if (IS_PURE && !PromiseConstructor.prototype['finally']) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  task.call(global, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  task.call(global, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.es/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.es/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && typeof NativePromise == 'function') {
    nativeThen = NativePromise.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
    // https://github.com/zloirock/core-js/issues/640
    }, { unsafe: true });

    // wrap fetch result
    if (typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
      }
    });
  }
}

$({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.es/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.es/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.es/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.es/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 8783:
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__(/*! ../internals/string-multibyte */ 8710).charAt;
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ 9909);
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ 654);

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ 3948:
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ 7854);
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ 8324);
var ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ 6992);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ 8880);
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ 5112);

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ }),

/***/ 8943:
/*!*******************************************************************!*\
  !*** ./node_modules/guacamole-common-js/dist/guacamole-common.js ***!
  \*******************************************************************/
/***/ (function(module) {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, returning
 * strictly received packets as array buffers. Note that this object will
 * overwrite any installed event handlers on the given Guacamole.InputStream.
 * 
 * @constructor
 * @param {Guacamole.InputStream} stream The stream that data will be read
 *                                       from.
 */
Guacamole.ArrayBufferReader = function(stream) {

    /**
     * Reference to this Guacamole.InputStream.
     * @private
     */
    var guac_reader = this;

    // Receive blobs as array buffers
    stream.onblob = function(data) {

        // Convert to ArrayBuffer
        var binary = window.atob(data);
        var arrayBuffer = new ArrayBuffer(binary.length);
        var bufferView = new Uint8Array(arrayBuffer);

        for (var i=0; i<binary.length; i++)
            bufferView[i] = binary.charCodeAt(i);

        // Call handler, if present
        if (guac_reader.ondata)
            guac_reader.ondata(arrayBuffer);

    };

    // Simply call onend when end received
    stream.onend = function() {
        if (guac_reader.onend)
            guac_reader.onend();
    };

    /**
     * Fired once for every blob of data received.
     * 
     * @event
     * @param {ArrayBuffer} buffer The data packet received.
     */
    this.ondata = null;

    /**
     * Fired once this stream is finished and no further data will be written.
     * @event
     */
    this.onend = null;

};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A writer which automatically writes to the given output stream with arbitrary
 * binary data, supplied as ArrayBuffers.
 * 
 * @constructor
 * @param {Guacamole.OutputStream} stream The stream that data will be written
 *                                        to.
 */
Guacamole.ArrayBufferWriter = function(stream) {

    /**
     * Reference to this Guacamole.StringWriter.
     * @private
     */
    var guac_writer = this;

    // Simply call onack for acknowledgements
    stream.onack = function(status) {
        if (guac_writer.onack)
            guac_writer.onack(status);
    };

    /**
     * Encodes the given data as base64, sending it as a blob. The data must
     * be small enough to fit into a single blob instruction.
     * 
     * @private
     * @param {Uint8Array} bytes The data to send.
     */
    function __send_blob(bytes) {

        var binary = "";

        // Produce binary string from bytes in buffer
        for (var i=0; i<bytes.byteLength; i++)
            binary += String.fromCharCode(bytes[i]);

        // Send as base64
        stream.sendBlob(window.btoa(binary));

    }

    /**
     * The maximum length of any blob sent by this Guacamole.ArrayBufferWriter,
     * in bytes. Data sent via
     * [sendData()]{@link Guacamole.ArrayBufferWriter#sendData} which exceeds
     * this length will be split into multiple blobs. As the Guacamole protocol
     * limits the maximum size of any instruction or instruction element to
     * 8192 bytes, and the contents of blobs will be base64-encoded, this value
     * should only be increased with extreme caution.
     *
     * @type {Number}
     * @default {@link Guacamole.ArrayBufferWriter.DEFAULT_BLOB_LENGTH}
     */
    this.blobLength = Guacamole.ArrayBufferWriter.DEFAULT_BLOB_LENGTH;

    /**
     * Sends the given data.
     * 
     * @param {ArrayBuffer|TypedArray} data The data to send.
     */
    this.sendData = function(data) {

        var bytes = new Uint8Array(data);

        // If small enough to fit into single instruction, send as-is
        if (bytes.length <= guac_writer.blobLength)
            __send_blob(bytes);

        // Otherwise, send as multiple instructions
        else {
            for (var offset=0; offset<bytes.length; offset += guac_writer.blobLength)
                __send_blob(bytes.subarray(offset, offset + guac_writer.blobLength));
        }

    };

    /**
     * Signals that no further text will be sent, effectively closing the
     * stream.
     */
    this.sendEnd = function() {
        stream.sendEnd();
    };

    /**
     * Fired for received data, if acknowledged by the server.
     * @event
     * @param {Guacamole.Status} status The status of the operation.
     */
    this.onack = null;

};

/**
 * The default maximum blob length for new Guacamole.ArrayBufferWriter
 * instances.
 *
 * @constant
 * @type {Number}
 */
Guacamole.ArrayBufferWriter.DEFAULT_BLOB_LENGTH = 6048;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Maintains a singleton instance of the Web Audio API AudioContext class,
 * instantiating the AudioContext only in response to the first call to
 * getAudioContext(), and only if no existing AudioContext instance has been
 * provided via the singleton property. Subsequent calls to getAudioContext()
 * will return the same instance.
 *
 * @namespace
 */
Guacamole.AudioContextFactory = {

    /**
     * A singleton instance of a Web Audio API AudioContext object, or null if
     * no instance has yes been created. This property may be manually set if
     * you wish to supply your own AudioContext instance, but care must be
     * taken to do so as early as possible. Assignments to this property will
     * not retroactively affect the value returned by previous calls to
     * getAudioContext().
     *
     * @type {AudioContext}
     */
    'singleton' : null,

    /**
     * Returns a singleton instance of a Web Audio API AudioContext object.
     *
     * @return {AudioContext}
     *     A singleton instance of a Web Audio API AudioContext object, or null
     *     if the Web Audio API is not supported.
     */
    'getAudioContext' : function getAudioContext() {

        // Fallback to Webkit-specific AudioContext implementation
        var AudioContext = window.AudioContext || window.webkitAudioContext;

        // Get new AudioContext instance if Web Audio API is supported
        if (AudioContext) {
            try {

                // Create new instance if none yet exists
                if (!Guacamole.AudioContextFactory.singleton)
                    Guacamole.AudioContextFactory.singleton = new AudioContext();

                // Return singleton instance
                return Guacamole.AudioContextFactory.singleton;

            }
            catch (e) {
                // Do not use Web Audio API if not allowed by browser
            }
        }

        // Web Audio API not supported
        return null;

    }

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract audio player which accepts, queues and plays back arbitrary audio
 * data. It is up to implementations of this class to provide some means of
 * handling a provided Guacamole.InputStream. Data received along the provided
 * stream is to be played back immediately.
 *
 * @constructor
 */
Guacamole.AudioPlayer = function AudioPlayer() {

    /**
     * Notifies this Guacamole.AudioPlayer that all audio up to the current
     * point in time has been given via the underlying stream, and that any
     * difference in time between queued audio data and the current time can be
     * considered latency.
     */
    this.sync = function sync() {
        // Default implementation - do nothing
    };

};

/**
 * Determines whether the given mimetype is supported by any built-in
 * implementation of Guacamole.AudioPlayer, and thus will be properly handled
 * by Guacamole.AudioPlayer.getInstance().
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by any built-in
 *     Guacamole.AudioPlayer, false otherwise.
 */
Guacamole.AudioPlayer.isSupportedType = function isSupportedType(mimetype) {

    return Guacamole.RawAudioPlayer.isSupportedType(mimetype);

};

/**
 * Returns a list of all mimetypes supported by any built-in
 * Guacamole.AudioPlayer, in rough order of priority. Beware that only the core
 * mimetypes themselves will be listed. Any mimetype parameters, even required
 * ones, will not be included in the list. For example, "audio/L8" is a
 * supported raw audio mimetype that is supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by any built-in Guacamole.AudioPlayer,
 *     excluding any parameters.
 */
Guacamole.AudioPlayer.getSupportedTypes = function getSupportedTypes() {

    return Guacamole.RawAudioPlayer.getSupportedTypes();

};

/**
 * Returns an instance of Guacamole.AudioPlayer providing support for the given
 * audio format. If support for the given audio format is not available, null
 * is returned.
 *
 * @param {Guacamole.InputStream} stream
 *     The Guacamole.InputStream to read audio data from.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data in the provided stream.
 *
 * @return {Guacamole.AudioPlayer}
 *     A Guacamole.AudioPlayer instance supporting the given mimetype and
 *     reading from the given stream, or null if support for the given mimetype
 *     is absent.
 */
Guacamole.AudioPlayer.getInstance = function getInstance(stream, mimetype) {

    // Use raw audio player if possible
    if (Guacamole.RawAudioPlayer.isSupportedType(mimetype))
        return new Guacamole.RawAudioPlayer(stream, mimetype);

    // No support for given mimetype
    return null;

};

/**
 * Implementation of Guacamole.AudioPlayer providing support for raw PCM format
 * audio. This player relies only on the Web Audio API and does not require any
 * browser-level support for its audio formats.
 *
 * @constructor
 * @augments Guacamole.AudioPlayer
 * @param {Guacamole.InputStream} stream
 *     The Guacamole.InputStream to read audio data from.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data in the provided stream, which must be a
 *     "audio/L8" or "audio/L16" mimetype with necessary parameters, such as:
 *     "audio/L16;rate=44100,channels=2".
 */
Guacamole.RawAudioPlayer = function RawAudioPlayer(stream, mimetype) {

    /**
     * The format of audio this player will decode.
     *
     * @private
     * @type {Guacamole.RawAudioFormat}
     */
    var format = Guacamole.RawAudioFormat.parse(mimetype);

    /**
     * An instance of a Web Audio API AudioContext object, or null if the
     * Web Audio API is not supported.
     *
     * @private
     * @type {AudioContext}
     */
    var context = Guacamole.AudioContextFactory.getAudioContext();

    /**
     * The earliest possible time that the next packet could play without
     * overlapping an already-playing packet, in seconds. Note that while this
     * value is in seconds, it is not an integer value and has microsecond
     * resolution.
     *
     * @private
     * @type {Number}
     */
    var nextPacketTime = context.currentTime;

    /**
     * Guacamole.ArrayBufferReader wrapped around the audio input stream
     * provided with this Guacamole.RawAudioPlayer was created.
     *
     * @private
     * @type {Guacamole.ArrayBufferReader}
     */
    var reader = new Guacamole.ArrayBufferReader(stream);

    /**
     * The minimum size of an audio packet split by splitAudioPacket(), in
     * seconds. Audio packets smaller than this will not be split, nor will the
     * split result of a larger packet ever be smaller in size than this
     * minimum.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var MIN_SPLIT_SIZE = 0.02;

    /**
     * The maximum amount of latency to allow between the buffered data stream
     * and the playback position, in seconds. Initially, this is set to
     * roughly one third of a second.
     *
     * @private
     * @type {Number}
     */
    var maxLatency = 0.3;

    /**
     * The type of typed array that will be used to represent each audio packet
     * internally. This will be either Int8Array or Int16Array, depending on
     * whether the raw audio format is 8-bit or 16-bit.
     *
     * @private
     * @constructor
     */
    var SampleArray = (format.bytesPerSample === 1) ? window.Int8Array : window.Int16Array;

    /**
     * The maximum absolute value of any sample within a raw audio packet
     * received by this audio player. This depends only on the size of each
     * sample, and will be 128 for 8-bit audio and 32768 for 16-bit audio.
     *
     * @private
     * @type {Number}
     */
    var maxSampleValue = (format.bytesPerSample === 1) ? 128 : 32768;

    /**
     * The queue of all pending audio packets, as an array of sample arrays.
     * Audio packets which are pending playback will be added to this queue for
     * further manipulation prior to scheduling via the Web Audio API. Once an
     * audio packet leaves this queue and is scheduled via the Web Audio API,
     * no further modifications can be made to that packet.
     *
     * @private
     * @type {SampleArray[]}
     */
    var packetQueue = [];

    /**
     * Given an array of audio packets, returns a single audio packet
     * containing the concatenation of those packets.
     *
     * @private
     * @param {SampleArray[]} packets
     *     The array of audio packets to concatenate.
     *
     * @returns {SampleArray}
     *     A single audio packet containing the concatenation of all given
     *     audio packets. If no packets are provided, this will be undefined.
     */
    var joinAudioPackets = function joinAudioPackets(packets) {

        // Do not bother joining if one or fewer packets are in the queue
        if (packets.length <= 1)
            return packets[0];

        // Determine total sample length of the entire queue
        var totalLength = 0;
        packets.forEach(function addPacketLengths(packet) {
            totalLength += packet.length;
        });

        // Append each packet within queue
        var offset = 0;
        var joined = new SampleArray(totalLength);
        packets.forEach(function appendPacket(packet) {
            joined.set(packet, offset);
            offset += packet.length;
        });

        return joined;

    };

    /**
     * Given a single packet of audio data, splits off an arbitrary length of
     * audio data from the beginning of that packet, returning the split result
     * as an array of two packets. The split location is determined through an
     * algorithm intended to minimize the liklihood of audible clicking between
     * packets. If no such split location is possible, an array containing only
     * the originally-provided audio packet is returned.
     *
     * @private
     * @param {SampleArray} data
     *     The audio packet to split.
     *
     * @returns {SampleArray[]}
     *     An array of audio packets containing the result of splitting the
     *     provided audio packet. If splitting is possible, this array will
     *     contain two packets. If splitting is not possible, this array will
     *     contain only the originally-provided packet.
     */
    var splitAudioPacket = function splitAudioPacket(data) {

        var minValue = Number.MAX_VALUE;
        var optimalSplitLength = data.length;

        // Calculate number of whole samples in the provided audio packet AND
        // in the minimum possible split packet
        var samples = Math.floor(data.length / format.channels);
        var minSplitSamples = Math.floor(format.rate * MIN_SPLIT_SIZE);

        // Calculate the beginning of the "end" of the audio packet
        var start = Math.max(
            format.channels * minSplitSamples,
            format.channels * (samples - minSplitSamples)
        );

        // For all samples at the end of the given packet, find a point where
        // the perceptible volume across all channels is lowest (and thus is
        // the optimal point to split)
        for (var offset = start; offset < data.length; offset += format.channels) {

            // Calculate the sum of all values across all channels (the result
            // will be proportional to the average volume of a sample)
            var totalValue = 0;
            for (var channel = 0; channel < format.channels; channel++) {
                totalValue += Math.abs(data[offset + channel]);
            }

            // If this is the smallest average value thus far, set the split
            // length such that the first packet ends with the current sample
            if (totalValue <= minValue) {
                optimalSplitLength = offset + format.channels;
                minValue = totalValue;
            }

        }

        // If packet is not split, return the supplied packet untouched
        if (optimalSplitLength === data.length)
            return [data];

        // Otherwise, split the packet into two new packets according to the
        // calculated optimal split length
        return [
            new SampleArray(data.buffer.slice(0, optimalSplitLength * format.bytesPerSample)),
            new SampleArray(data.buffer.slice(optimalSplitLength * format.bytesPerSample))
        ];

    };

    /**
     * Pushes the given packet of audio data onto the playback queue. Unlike
     * other private functions within Guacamole.RawAudioPlayer, the type of the
     * ArrayBuffer packet of audio data here need not be specific to the type
     * of audio (as with SampleArray). The ArrayBuffer type provided by a
     * Guacamole.ArrayBufferReader, for example, is sufficient. Any necessary
     * conversions will be performed automatically internally.
     *
     * @private
     * @param {ArrayBuffer} data
     *     A raw packet of audio data that should be pushed onto the audio
     *     playback queue.
     */
    var pushAudioPacket = function pushAudioPacket(data) {
        packetQueue.push(new SampleArray(data));
    };

    /**
     * Shifts off and returns a packet of audio data from the beginning of the
     * playback queue. The length of this audio packet is determined
     * dynamically according to the click-reduction algorithm implemented by
     * splitAudioPacket().
     *
     * @private
     * @returns {SampleArray}
     *     A packet of audio data pulled from the beginning of the playback
     *     queue.
     */
    var shiftAudioPacket = function shiftAudioPacket() {

        // Flatten data in packet queue
        var data = joinAudioPackets(packetQueue);
        if (!data)
            return null;

        // Pull an appropriate amount of data from the front of the queue
        packetQueue = splitAudioPacket(data);
        data = packetQueue.shift();

        return data;

    };

    /**
     * Converts the given audio packet into an AudioBuffer, ready for playback
     * by the Web Audio API. Unlike the raw audio packets received by this
     * audio player, AudioBuffers require floating point samples and are split
     * into isolated planes of channel-specific data.
     *
     * @private
     * @param {SampleArray} data
     *     The raw audio packet that should be converted into a Web Audio API
     *     AudioBuffer.
     *
     * @returns {AudioBuffer}
     *     A new Web Audio API AudioBuffer containing the provided audio data,
     *     converted to the format used by the Web Audio API.
     */
    var toAudioBuffer = function toAudioBuffer(data) {

        // Calculate total number of samples
        var samples = data.length / format.channels;

        // Determine exactly when packet CAN play
        var packetTime = context.currentTime;
        if (nextPacketTime < packetTime)
            nextPacketTime = packetTime;

        // Get audio buffer for specified format
        var audioBuffer = context.createBuffer(format.channels, samples, format.rate);

        // Convert each channel
        for (var channel = 0; channel < format.channels; channel++) {

            var audioData = audioBuffer.getChannelData(channel);

            // Fill audio buffer with data for channel
            var offset = channel;
            for (var i = 0; i < samples; i++) {
                audioData[i] = data[offset] / maxSampleValue;
                offset += format.channels;
            }

        }

        return audioBuffer;

    };

    // Defer playback of received audio packets slightly
    reader.ondata = function playReceivedAudio(data) {

        // Push received samples onto queue
        pushAudioPacket(new SampleArray(data));

        // Shift off an arbitrary packet of audio data from the queue (this may
        // be different in size from the packet just pushed)
        var packet = shiftAudioPacket();
        if (!packet)
            return;

        // Determine exactly when packet CAN play
        var packetTime = context.currentTime;
        if (nextPacketTime < packetTime)
            nextPacketTime = packetTime;

        // Set up buffer source
        var source = context.createBufferSource();
        source.connect(context.destination);

        // Use noteOn() instead of start() if necessary
        if (!source.start)
            source.start = source.noteOn;

        // Schedule packet
        source.buffer = toAudioBuffer(packet);
        source.start(nextPacketTime);

        // Update timeline by duration of scheduled packet
        nextPacketTime += packet.length / format.channels / format.rate;

    };

    /** @override */
    this.sync = function sync() {

        // Calculate elapsed time since last sync
        var now = context.currentTime;

        // Reschedule future playback time such that playback latency is
        // bounded within a reasonable latency threshold
        nextPacketTime = Math.min(nextPacketTime, now + maxLatency);

    };

};

Guacamole.RawAudioPlayer.prototype = new Guacamole.AudioPlayer();

/**
 * Determines whether the given mimetype is supported by
 * Guacamole.RawAudioPlayer.
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by Guacamole.RawAudioPlayer,
 *     false otherwise.
 */
Guacamole.RawAudioPlayer.isSupportedType = function isSupportedType(mimetype) {

    // No supported types if no Web Audio API
    if (!Guacamole.AudioContextFactory.getAudioContext())
        return false;

    return Guacamole.RawAudioFormat.parse(mimetype) !== null;

};

/**
 * Returns a list of all mimetypes supported by Guacamole.RawAudioPlayer. Only
 * the core mimetypes themselves will be listed. Any mimetype parameters, even
 * required ones, will not be included in the list. For example, "audio/L8" is
 * a raw audio mimetype that may be supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by Guacamole.RawAudioPlayer, excluding
 *     any parameters. If the necessary JavaScript APIs for playing raw audio
 *     are absent, this list will be empty.
 */
Guacamole.RawAudioPlayer.getSupportedTypes = function getSupportedTypes() {

    // No supported types if no Web Audio API
    if (!Guacamole.AudioContextFactory.getAudioContext())
        return [];

    // We support 8-bit and 16-bit raw PCM
    return [
        'audio/L8',
        'audio/L16'
    ];

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract audio recorder which streams arbitrary audio data to an underlying
 * Guacamole.OutputStream. It is up to implementations of this class to provide
 * some means of handling this Guacamole.OutputStream. Data produced by the
 * recorder is to be sent along the provided stream immediately.
 *
 * @constructor
 */
Guacamole.AudioRecorder = function AudioRecorder() {

    /**
     * Callback which is invoked when the audio recording process has stopped
     * and the underlying Guacamole stream has been closed normally. Audio will
     * only resume recording if a new Guacamole.AudioRecorder is started. This
     * Guacamole.AudioRecorder instance MAY NOT be reused.
     *
     * @event
     */
    this.onclose = null;

    /**
     * Callback which is invoked when the audio recording process cannot
     * continue due to an error, if it has started at all. The underlying
     * Guacamole stream is automatically closed. Future attempts to record
     * audio should not be made, and this Guacamole.AudioRecorder instance
     * MAY NOT be reused.
     *
     * @event
     */
    this.onerror = null;

};

/**
 * Determines whether the given mimetype is supported by any built-in
 * implementation of Guacamole.AudioRecorder, and thus will be properly handled
 * by Guacamole.AudioRecorder.getInstance().
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by any built-in
 *     Guacamole.AudioRecorder, false otherwise.
 */
Guacamole.AudioRecorder.isSupportedType = function isSupportedType(mimetype) {

    return Guacamole.RawAudioRecorder.isSupportedType(mimetype);

};

/**
 * Returns a list of all mimetypes supported by any built-in
 * Guacamole.AudioRecorder, in rough order of priority. Beware that only the
 * core mimetypes themselves will be listed. Any mimetype parameters, even
 * required ones, will not be included in the list. For example, "audio/L8" is
 * a supported raw audio mimetype that is supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by any built-in
 *     Guacamole.AudioRecorder, excluding any parameters.
 */
Guacamole.AudioRecorder.getSupportedTypes = function getSupportedTypes() {

    return Guacamole.RawAudioRecorder.getSupportedTypes();

};

/**
 * Returns an instance of Guacamole.AudioRecorder providing support for the
 * given audio format. If support for the given audio format is not available,
 * null is returned.
 *
 * @param {Guacamole.OutputStream} stream
 *     The Guacamole.OutputStream to send audio data through.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data to be sent along the provided stream.
 *
 * @return {Guacamole.AudioRecorder}
 *     A Guacamole.AudioRecorder instance supporting the given mimetype and
 *     writing to the given stream, or null if support for the given mimetype
 *     is absent.
 */
Guacamole.AudioRecorder.getInstance = function getInstance(stream, mimetype) {

    // Use raw audio recorder if possible
    if (Guacamole.RawAudioRecorder.isSupportedType(mimetype))
        return new Guacamole.RawAudioRecorder(stream, mimetype);

    // No support for given mimetype
    return null;

};

/**
 * Implementation of Guacamole.AudioRecorder providing support for raw PCM
 * format audio. This recorder relies only on the Web Audio API and does not
 * require any browser-level support for its audio formats.
 *
 * @constructor
 * @augments Guacamole.AudioRecorder
 * @param {Guacamole.OutputStream} stream
 *     The Guacamole.OutputStream to write audio data to.
 *
 * @param {String} mimetype
 *     The mimetype of the audio data to send along the provided stream, which
 *     must be a "audio/L8" or "audio/L16" mimetype with necessary parameters,
 *     such as: "audio/L16;rate=44100,channels=2".
 */
Guacamole.RawAudioRecorder = function RawAudioRecorder(stream, mimetype) {

    /**
     * Reference to this RawAudioRecorder.
     *
     * @private
     * @type {Guacamole.RawAudioRecorder}
     */
    var recorder = this;

    /**
     * The size of audio buffer to request from the Web Audio API when
     * recording or processing audio, in sample-frames. This must be a power of
     * two between 256 and 16384 inclusive, as required by
     * AudioContext.createScriptProcessor().
     *
     * @private
     * @constant
     * @type {Number}
     */
    var BUFFER_SIZE = 2048;

    /**
     * The window size to use when applying Lanczos interpolation, commonly
     * denoted by the variable "a".
     * See: https://en.wikipedia.org/wiki/Lanczos_resampling
     *
     * @private
     * @contant
     * @type Number
     */
    var LANCZOS_WINDOW_SIZE = 3;

    /**
     * The format of audio this recorder will encode.
     *
     * @private
     * @type {Guacamole.RawAudioFormat}
     */
    var format = Guacamole.RawAudioFormat.parse(mimetype);

    /**
     * An instance of a Web Audio API AudioContext object, or null if the
     * Web Audio API is not supported.
     *
     * @private
     * @type {AudioContext}
     */
    var context = Guacamole.AudioContextFactory.getAudioContext();

    // Some browsers do not implement navigator.mediaDevices - this
    // shims in this functionality to ensure code compatibility.
    if (!navigator.mediaDevices)
        navigator.mediaDevices = {};

    // Browsers that either do not implement navigator.mediaDevices
    // at all or do not implement it completely need the getUserMedia
    // method defined.  This shims in this function by detecting
    // one of the supported legacy methods.
    if (!navigator.mediaDevices.getUserMedia)
        navigator.mediaDevices.getUserMedia = (navigator.getUserMedia
                || navigator.webkitGetUserMedia
                || navigator.mozGetUserMedia
                || navigator.msGetUserMedia).bind(navigator);

    /**
     * Guacamole.ArrayBufferWriter wrapped around the audio output stream
     * provided when this Guacamole.RawAudioRecorder was created.
     *
     * @private
     * @type {Guacamole.ArrayBufferWriter}
     */
    var writer = new Guacamole.ArrayBufferWriter(stream);

    /**
     * The type of typed array that will be used to represent each audio packet
     * internally. This will be either Int8Array or Int16Array, depending on
     * whether the raw audio format is 8-bit or 16-bit.
     *
     * @private
     * @constructor
     */
    var SampleArray = (format.bytesPerSample === 1) ? window.Int8Array : window.Int16Array;

    /**
     * The maximum absolute value of any sample within a raw audio packet sent
     * by this audio recorder. This depends only on the size of each sample,
     * and will be 128 for 8-bit audio and 32768 for 16-bit audio.
     *
     * @private
     * @type {Number}
     */
    var maxSampleValue = (format.bytesPerSample === 1) ? 128 : 32768;

    /**
     * The total number of audio samples read from the local audio input device
     * over the life of this audio recorder.
     *
     * @private
     * @type {Number}
     */
    var readSamples = 0;

    /**
     * The total number of audio samples written to the underlying Guacamole
     * connection over the life of this audio recorder.
     *
     * @private
     * @type {Number}
     */
    var writtenSamples = 0;

    /**
     * The audio stream provided by the browser, if allowed. If no stream has
     * yet been received, this will be null.
     *
     * @type MediaStream
     */
    var mediaStream = null;

    /**
     * The source node providing access to the local audio input device.
     *
     * @private
     * @type {MediaStreamAudioSourceNode}
     */
    var source = null;

    /**
     * The script processing node which receives audio input from the media
     * stream source node as individual audio buffers.
     *
     * @private
     * @type {ScriptProcessorNode}
     */
    var processor = null;

    /**
     * The normalized sinc function. The normalized sinc function is defined as
     * 1 for x=0 and sin(PI * x) / (PI * x) for all other values of x.
     *
     * See: https://en.wikipedia.org/wiki/Sinc_function
     *
     * @private
     * @param {Number} x
     *     The point at which the normalized sinc function should be computed.
     *
     * @returns {Number}
     *     The value of the normalized sinc function at x.
     */
    var sinc = function sinc(x) {

        // The value of sinc(0) is defined as 1
        if (x === 0)
            return 1;

        // Otherwise, normlized sinc(x) is sin(PI * x) / (PI * x)
        var piX = Math.PI * x;
        return Math.sin(piX) / piX;

    };

    /**
     * Calculates the value of the Lanczos kernal at point x for a given window
     * size. See: https://en.wikipedia.org/wiki/Lanczos_resampling
     *
     * @private
     * @param {Number} x
     *     The point at which the value of the Lanczos kernel should be
     *     computed.
     *
     * @param {Number} a
     *     The window size to use for the Lanczos kernel.
     *
     * @returns {Number}
     *     The value of the Lanczos kernel at the given point for the given
     *     window size.
     */
    var lanczos = function lanczos(x, a) {

        // Lanczos is sinc(x) * sinc(x / a) for -a < x < a ...
        if (-a < x && x < a)
            return sinc(x) * sinc(x / a);

        // ... and 0 otherwise
        return 0;

    };

    /**
     * Determines the value of the waveform represented by the audio data at
     * the given location. If the value cannot be determined exactly as it does
     * not correspond to an exact sample within the audio data, the value will
     * be derived through interpolating nearby samples.
     *
     * @private
     * @param {Float32Array} audioData
     *     An array of audio data, as returned by AudioBuffer.getChannelData().
     *
     * @param {Number} t
     *     The relative location within the waveform from which the value
     *     should be retrieved, represented as a floating point number between
     *     0 and 1 inclusive, where 0 represents the earliest point in time and
     *     1 represents the latest.
     *
     * @returns {Number}
     *     The value of the waveform at the given location.
     */
    var interpolateSample = function getValueAt(audioData, t) {

        // Convert [0, 1] range to [0, audioData.length - 1]
        var index = (audioData.length - 1) * t;

        // Determine the start and end points for the summation used by the
        // Lanczos interpolation algorithm (see: https://en.wikipedia.org/wiki/Lanczos_resampling)
        var start = Math.floor(index) - LANCZOS_WINDOW_SIZE + 1;
        var end = Math.floor(index) + LANCZOS_WINDOW_SIZE;

        // Calculate the value of the Lanczos interpolation function for the
        // required range
        var sum = 0;
        for (var i = start; i <= end; i++) {
            sum += (audioData[i] || 0) * lanczos(index - i, LANCZOS_WINDOW_SIZE);
        }

        return sum;

    };

    /**
     * Converts the given AudioBuffer into an audio packet, ready for streaming
     * along the underlying output stream. Unlike the raw audio packets used by
     * this audio recorder, AudioBuffers require floating point samples and are
     * split into isolated planes of channel-specific data.
     *
     * @private
     * @param {AudioBuffer} audioBuffer
     *     The Web Audio API AudioBuffer that should be converted to a raw
     *     audio packet.
     *
     * @returns {SampleArray}
     *     A new raw audio packet containing the audio data from the provided
     *     AudioBuffer.
     */
    var toSampleArray = function toSampleArray(audioBuffer) {

        // Track overall amount of data read
        var inSamples = audioBuffer.length;
        readSamples += inSamples;

        // Calculate the total number of samples that should be written as of
        // the audio data just received and adjust the size of the output
        // packet accordingly
        var expectedWrittenSamples = Math.round(readSamples * format.rate / audioBuffer.sampleRate);
        var outSamples = expectedWrittenSamples - writtenSamples;

        // Update number of samples written
        writtenSamples += outSamples;

        // Get array for raw PCM storage
        var data = new SampleArray(outSamples * format.channels);

        // Convert each channel
        for (var channel = 0; channel < format.channels; channel++) {

            var audioData = audioBuffer.getChannelData(channel);

            // Fill array with data from audio buffer channel
            var offset = channel;
            for (var i = 0; i < outSamples; i++) {
                data[offset] = interpolateSample(audioData, i / (outSamples - 1)) * maxSampleValue;
                offset += format.channels;
            }

        }

        return data;

    };

    /**
     * getUserMedia() callback which handles successful retrieval of an
     * audio stream (successful start of recording).
     *
     * @private
     * @param {MediaStream} stream
     *     A MediaStream which provides access to audio data read from the
     *     user's local audio input device.
     */
    var streamReceived = function streamReceived(stream) {

        // Create processing node which receives appropriately-sized audio buffers
        processor = context.createScriptProcessor(BUFFER_SIZE, format.channels, format.channels);
        processor.connect(context.destination);

        // Send blobs when audio buffers are received
        processor.onaudioprocess = function processAudio(e) {
            writer.sendData(toSampleArray(e.inputBuffer).buffer);
        };

        // Connect processing node to user's audio input source
        source = context.createMediaStreamSource(stream);
        source.connect(processor);

        // Attempt to explicitly resume AudioContext, as it may be paused
        // by default
        if (context.state === 'suspended')
            context.resume();

        // Save stream for later cleanup
        mediaStream = stream;

    };

    /**
     * getUserMedia() callback which handles audio recording denial. The
     * underlying Guacamole output stream is closed, and the failure to
     * record is noted using onerror.
     *
     * @private
     */
    var streamDenied = function streamDenied() {

        // Simply end stream if audio access is not allowed
        writer.sendEnd();

        // Notify of closure
        if (recorder.onerror)
            recorder.onerror();

    };

    /**
     * Requests access to the user's microphone and begins capturing audio. All
     * received audio data is resampled as necessary and forwarded to the
     * Guacamole stream underlying this Guacamole.RawAudioRecorder. This
     * function must be invoked ONLY ONCE per instance of
     * Guacamole.RawAudioRecorder.
     *
     * @private
     */
    var beginAudioCapture = function beginAudioCapture() {

        // Attempt to retrieve an audio input stream from the browser
        var promise = navigator.mediaDevices.getUserMedia({
            'audio' : true
        }, streamReceived, streamDenied);

        // Handle stream creation/rejection via Promise for newer versions of
        // getUserMedia()
        if (promise && promise.then)
            promise.then(streamReceived, streamDenied);

    };

    /**
     * Stops capturing audio, if the capture has started, freeing all associated
     * resources. If the capture has not started, this function simply ends the
     * underlying Guacamole stream.
     *
     * @private
     */
    var stopAudioCapture = function stopAudioCapture() {

        // Disconnect media source node from script processor
        if (source)
            source.disconnect();

        // Disconnect associated script processor node
        if (processor)
            processor.disconnect();

        // Stop capture
        if (mediaStream) {
            var tracks = mediaStream.getTracks();
            for (var i = 0; i < tracks.length; i++)
                tracks[i].stop();
        }

        // Remove references to now-unneeded components
        processor = null;
        source = null;
        mediaStream = null;

        // End stream
        writer.sendEnd();

    };

    // Once audio stream is successfully open, request and begin reading audio
    writer.onack = function audioStreamAcknowledged(status) {

        // Begin capture if successful response and not yet started
        if (status.code === Guacamole.Status.Code.SUCCESS && !mediaStream)
            beginAudioCapture();

        // Otherwise stop capture and cease handling any further acks
        else {

            // Stop capturing audio
            stopAudioCapture();
            writer.onack = null;

            // Notify if stream has closed normally
            if (status.code === Guacamole.Status.Code.RESOURCE_CLOSED) {
                if (recorder.onclose)
                    recorder.onclose();
            }

            // Otherwise notify of closure due to error
            else {
                if (recorder.onerror)
                    recorder.onerror();
            }

        }

    };

};

Guacamole.RawAudioRecorder.prototype = new Guacamole.AudioRecorder();

/**
 * Determines whether the given mimetype is supported by
 * Guacamole.RawAudioRecorder.
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by Guacamole.RawAudioRecorder,
 *     false otherwise.
 */
Guacamole.RawAudioRecorder.isSupportedType = function isSupportedType(mimetype) {

    // No supported types if no Web Audio API
    if (!Guacamole.AudioContextFactory.getAudioContext())
        return false;

    return Guacamole.RawAudioFormat.parse(mimetype) !== null;

};

/**
 * Returns a list of all mimetypes supported by Guacamole.RawAudioRecorder. Only
 * the core mimetypes themselves will be listed. Any mimetype parameters, even
 * required ones, will not be included in the list. For example, "audio/L8" is
 * a raw audio mimetype that may be supported, but it is invalid without
 * additional parameters. Something like "audio/L8;rate=44100" would be valid,
 * however (see https://tools.ietf.org/html/rfc4856).
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by Guacamole.RawAudioRecorder,
 *     excluding any parameters. If the necessary JavaScript APIs for recording
 *     raw audio are absent, this list will be empty.
 */
Guacamole.RawAudioRecorder.getSupportedTypes = function getSupportedTypes() {

    // No supported types if no Web Audio API
    if (!Guacamole.AudioContextFactory.getAudioContext())
        return [];

    // We support 8-bit and 16-bit raw PCM
    return [
        'audio/L8',
        'audio/L16'
    ];

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, assembling all
 * received blobs into a single blob by appending them to each other in order.
 * Note that this object will overwrite any installed event handlers on the
 * given Guacamole.InputStream.
 * 
 * @constructor
 * @param {Guacamole.InputStream} stream The stream that data will be read
 *                                       from.
 * @param {String} mimetype The mimetype of the blob being built.
 */
Guacamole.BlobReader = function(stream, mimetype) {

    /**
     * Reference to this Guacamole.InputStream.
     * @private
     */
    var guac_reader = this;

    /**
     * The length of this Guacamole.InputStream in bytes.
     * @private
     */
    var length = 0;

    // Get blob builder
    var blob_builder;
    if      (window.BlobBuilder)       blob_builder = new BlobBuilder();
    else if (window.WebKitBlobBuilder) blob_builder = new WebKitBlobBuilder();
    else if (window.MozBlobBuilder)    blob_builder = new MozBlobBuilder();
    else
        blob_builder = new (function() {

            var blobs = [];

            /** @ignore */
            this.append = function(data) {
                blobs.push(new Blob([data], {"type": mimetype}));
            };

            /** @ignore */
            this.getBlob = function() {
                return new Blob(blobs, {"type": mimetype});
            };

        })();

    // Append received blobs
    stream.onblob = function(data) {

        // Convert to ArrayBuffer
        var binary = window.atob(data);
        var arrayBuffer = new ArrayBuffer(binary.length);
        var bufferView = new Uint8Array(arrayBuffer);

        for (var i=0; i<binary.length; i++)
            bufferView[i] = binary.charCodeAt(i);

        blob_builder.append(arrayBuffer);
        length += arrayBuffer.byteLength;

        // Call handler, if present
        if (guac_reader.onprogress)
            guac_reader.onprogress(arrayBuffer.byteLength);

        // Send success response
        stream.sendAck("OK", 0x0000);

    };

    // Simply call onend when end received
    stream.onend = function() {
        if (guac_reader.onend)
            guac_reader.onend();
    };

    /**
     * Returns the current length of this Guacamole.InputStream, in bytes.
     * @return {Number} The current length of this Guacamole.InputStream.
     */
    this.getLength = function() {
        return length;
    };

    /**
     * Returns the contents of this Guacamole.BlobReader as a Blob.
     * @return {Blob} The contents of this Guacamole.BlobReader.
     */
    this.getBlob = function() {
        return blob_builder.getBlob();
    };

    /**
     * Fired once for every blob of data received.
     * 
     * @event
     * @param {Number} length The number of bytes received.
     */
    this.onprogress = null;

    /**
     * Fired once this stream is finished and no further data will be written.
     * @event
     */
    this.onend = null;

};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A writer which automatically writes to the given output stream with the
 * contents of provided Blob objects.
 *
 * @constructor
 * @param {Guacamole.OutputStream} stream
 *     The stream that data will be written to.
 */
Guacamole.BlobWriter = function BlobWriter(stream) {

    /**
     * Reference to this Guacamole.BlobWriter.
     *
     * @private
     * @type {Guacamole.BlobWriter}
     */
    var guacWriter = this;

    /**
     * Wrapped Guacamole.ArrayBufferWriter which will be used to send any
     * provided file data.
     *
     * @private
     * @type {Guacamole.ArrayBufferWriter}
     */
    var arrayBufferWriter = new Guacamole.ArrayBufferWriter(stream);

    // Initially, simply call onack for acknowledgements
    arrayBufferWriter.onack = function(status) {
        if (guacWriter.onack)
            guacWriter.onack(status);
    };

    /**
     * Browser-independent implementation of Blob.slice() which uses an end
     * offset to determine the span of the resulting slice, rather than a
     * length.
     *
     * @private
     * @param {Blob} blob
     *     The Blob to slice.
     *
     * @param {Number} start
     *     The starting offset of the slice, in bytes, inclusive.
     *
     * @param {Number} end
     *     The ending offset of the slice, in bytes, exclusive.
     *
     * @returns {Blob}
     *     A Blob containing the data within the given Blob starting at
     *     <code>start</code> and ending at <code>end - 1</code>.
     */
    var slice = function slice(blob, start, end) {

        // Use prefixed implementations if necessary
        var sliceImplementation = (
                blob.slice
             || blob.webkitSlice
             || blob.mozSlice
        ).bind(blob);

        var length = end - start;

        // The old Blob.slice() was length-based (not end-based). Try the
        // length version first, if the two calls are not equivalent.
        if (length !== end) {

            // If the result of the slice() call matches the expected length,
            // trust that result. It must be correct.
            var sliceResult = sliceImplementation(start, length);
            if (sliceResult.size === length)
                return sliceResult;

        }

        // Otherwise, use the most-recent standard: end-based slice()
        return sliceImplementation(start, end);

    };

    /**
     * Sends the contents of the given blob over the underlying stream.
     *
     * @param {Blob} blob
     *     The blob to send.
     */
    this.sendBlob = function sendBlob(blob) {

        var offset = 0;
        var reader = new FileReader();

        /**
         * Reads the next chunk of the blob provided to
         * [sendBlob()]{@link Guacamole.BlobWriter#sendBlob}. The chunk itself
         * is read asynchronously, and will not be available until
         * reader.onload fires.
         *
         * @private
         */
        var readNextChunk = function readNextChunk() {

            // If no further chunks remain, inform of completion and stop
            if (offset >= blob.size) {

                // Fire completion event for completed blob
                if (guacWriter.oncomplete)
                    guacWriter.oncomplete(blob);

                // No further chunks to read
                return;

            }

            // Obtain reference to next chunk as a new blob
            var chunk = slice(blob, offset, offset + arrayBufferWriter.blobLength);
            offset += arrayBufferWriter.blobLength;

            // Attempt to read the blob contents represented by the blob into
            // a new array buffer
            reader.readAsArrayBuffer(chunk);

        };

        // Send each chunk over the stream, continue reading the next chunk
        reader.onload = function chunkLoadComplete() {

            // Send the successfully-read chunk
            arrayBufferWriter.sendData(reader.result);

            // Continue sending more chunks after the latest chunk is
            // acknowledged
            arrayBufferWriter.onack = function sendMoreChunks(status) {

                if (guacWriter.onack)
                    guacWriter.onack(status);

                // Abort transfer if an error occurs
                if (status.isError())
                    return;

                // Inform of blob upload progress via progress events
                if (guacWriter.onprogress)
                    guacWriter.onprogress(blob, offset - arrayBufferWriter.blobLength);

                // Queue the next chunk for reading
                readNextChunk();

            };

        };

        // If an error prevents further reading, inform of error and stop
        reader.onerror = function chunkLoadFailed() {

            // Fire error event, including the context of the error
            if (guacWriter.onerror)
                guacWriter.onerror(blob, offset, reader.error);

        };

        // Begin reading the first chunk
        readNextChunk();

    };

    /**
     * Signals that no further text will be sent, effectively closing the
     * stream.
     */
    this.sendEnd = function sendEnd() {
        arrayBufferWriter.sendEnd();
    };

    /**
     * Fired for received data, if acknowledged by the server.
     *
     * @event
     * @param {Guacamole.Status} status
     *     The status of the operation.
     */
    this.onack = null;

    /**
     * Fired when an error occurs reading a blob passed to
     * [sendBlob()]{@link Guacamole.BlobWriter#sendBlob}. The transfer for the
     * the given blob will cease, but the stream will remain open.
     *
     * @event
     * @param {Blob} blob
     *     The blob that was being read when the error occurred.
     *
     * @param {Number} offset
     *     The offset of the failed read attempt within the blob, in bytes.
     *
     * @param {DOMError} error
     *     The error that occurred.
     */
    this.onerror = null;

    /**
     * Fired for each successfully-read chunk of data as a blob is being sent
     * via [sendBlob()]{@link Guacamole.BlobWriter#sendBlob}.
     *
     * @event
     * @param {Blob} blob
     *     The blob that is being read.
     *
     * @param {Number} offset
     *     The offset of the read that just succeeded.
     */
    this.onprogress = null;

    /**
     * Fired when a blob passed to
     * [sendBlob()]{@link Guacamole.BlobWriter#sendBlob} has finished being
     * sent.
     *
     * @event
     * @param {Blob} blob
     *     The blob that was sent.
     */
    this.oncomplete = null;

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Guacamole protocol client. Given a {@link Guacamole.Tunnel},
 * automatically handles incoming and outgoing Guacamole instructions via the
 * provided tunnel, updating its display using one or more canvas elements.
 * 
 * @constructor
 * @param {Guacamole.Tunnel} tunnel The tunnel to use to send and receive
 *                                  Guacamole instructions.
 */
Guacamole.Client = function(tunnel) {

    var guac_client = this;

    var STATE_IDLE          = 0;
    var STATE_CONNECTING    = 1;
    var STATE_WAITING       = 2;
    var STATE_CONNECTED     = 3;
    var STATE_DISCONNECTING = 4;
    var STATE_DISCONNECTED  = 5;

    var currentState = STATE_IDLE;
    
    var currentTimestamp = 0;
    var pingInterval = null;

    /**
     * Translation from Guacamole protocol line caps to Layer line caps.
     * @private
     */
    var lineCap = {
        0: "butt",
        1: "round",
        2: "square"
    };

    /**
     * Translation from Guacamole protocol line caps to Layer line caps.
     * @private
     */
    var lineJoin = {
        0: "bevel",
        1: "miter",
        2: "round"
    };

    /**
     * The underlying Guacamole display.
     *
     * @private
     * @type {Guacamole.Display}
     */
    var display = new Guacamole.Display();

    /**
     * All available layers and buffers
     *
     * @private
     * @type {Object.<Number, (Guacamole.Display.VisibleLayer|Guacamole.Layer)>}
     */
    var layers = {};
    
    /**
     * All audio players currently in use by the client. Initially, this will
     * be empty, but audio players may be allocated by the server upon request.
     *
     * @private
     * @type {Object.<Number, Guacamole.AudioPlayer>}
     */
    var audioPlayers = {};

    /**
     * All video players currently in use by the client. Initially, this will
     * be empty, but video players may be allocated by the server upon request.
     *
     * @private
     * @type {Object.<Number, Guacamole.VideoPlayer>}
     */
    var videoPlayers = {};

    // No initial parsers
    var parsers = [];

    // No initial streams 
    var streams = [];

    /**
     * All current objects. The index of each object is dictated by the
     * Guacamole server.
     *
     * @private
     * @type {Guacamole.Object[]}
     */
    var objects = [];

    // Pool of available stream indices
    var stream_indices = new Guacamole.IntegerPool();

    // Array of allocated output streams by index
    var output_streams = [];

    function setState(state) {
        if (state != currentState) {
            currentState = state;
            if (guac_client.onstatechange)
                guac_client.onstatechange(currentState);
        }
    }

    function isConnected() {
        return currentState == STATE_CONNECTED
            || currentState == STATE_WAITING;
    }

    /**
     * Produces an opaque representation of Guacamole.Client state which can be
     * later imported through a call to importState(). This object is
     * effectively an independent, compressed snapshot of protocol and display
     * state. Invoking this function implicitly flushes the display.
     *
     * @param {function} callback
     *     Callback which should be invoked once the state object is ready. The
     *     state object will be passed to the callback as the sole parameter.
     *     This callback may be invoked immediately, or later as the display
     *     finishes rendering and becomes ready.
     */
    this.exportState = function exportState(callback) {

        // Start with empty state
        var state = {
            'currentState' : currentState,
            'currentTimestamp' : currentTimestamp,
            'layers' : {}
        };

        var layersSnapshot = {};

        // Make a copy of all current layers (protocol state)
        for (var key in layers) {
            layersSnapshot[key] = layers[key];
        }

        // Populate layers once data is available (display state, requires flush)
        display.flush(function populateLayers() {

            // Export each defined layer/buffer
            for (var key in layersSnapshot) {

                var index = parseInt(key);
                var layer = layersSnapshot[key];
                var canvas = layer.toCanvas();

                // Store layer/buffer dimensions
                var exportLayer = {
                    'width'  : layer.width,
                    'height' : layer.height
                };

                // Store layer/buffer image data, if it can be generated
                if (layer.width && layer.height)
                    exportLayer.url = canvas.toDataURL('image/png');

                // Add layer properties if not a buffer nor the default layer
                if (index > 0) {
                    exportLayer.x = layer.x;
                    exportLayer.y = layer.y;
                    exportLayer.z = layer.z;
                    exportLayer.alpha = layer.alpha;
                    exportLayer.matrix = layer.matrix;
                    exportLayer.parent = getLayerIndex(layer.parent);
                }

                // Store exported layer
                state.layers[key] = exportLayer;

            }

            // Invoke callback now that the state is ready
            callback(state);

        });

    };

    /**
     * Restores Guacamole.Client protocol and display state based on an opaque
     * object from a prior call to exportState(). The Guacamole.Client instance
     * used to export that state need not be the same as this instance.
     *
     * @param {Object} state
     *     An opaque representation of Guacamole.Client state from a prior call
     *     to exportState().
     *
     * @param {function} [callback]
     *     The function to invoke when state has finished being imported. This
     *     may happen immediately, or later as images within the provided state
     *     object are loaded.
     */
    this.importState = function importState(state, callback) {

        var key;
        var index;

        currentState = state.currentState;
        currentTimestamp = state.currentTimestamp;

        // Dispose of all layers
        for (key in layers) {
            index = parseInt(key);
            if (index > 0)
                display.dispose(layers[key]);
        }

        layers = {};

        // Import state of each layer/buffer
        for (key in state.layers) {

            index = parseInt(key);

            var importLayer = state.layers[key];
            var layer = getLayer(index);

            // Reset layer size
            display.resize(layer, importLayer.width, importLayer.height);

            // Initialize new layer if it has associated data
            if (importLayer.url) {
                display.setChannelMask(layer, Guacamole.Layer.SRC);
                display.draw(layer, 0, 0, importLayer.url);
            }

            // Set layer-specific properties if not a buffer nor the default layer
            if (index > 0 && importLayer.parent >= 0) {

                // Apply layer position and set parent
                var parent = getLayer(importLayer.parent);
                display.move(layer, parent, importLayer.x, importLayer.y, importLayer.z);

                // Set layer transparency
                display.shade(layer, importLayer.alpha);

                // Apply matrix transform
                var matrix = importLayer.matrix;
                display.distort(layer,
                    matrix[0], matrix[1], matrix[2],
                    matrix[3], matrix[4], matrix[5]);

            }

        }

        // Flush changes to display
        display.flush(callback);

    };

    /**
     * Returns the underlying display of this Guacamole.Client. The display
     * contains an Element which can be added to the DOM, causing the
     * display to become visible.
     * 
     * @return {Guacamole.Display} The underlying display of this
     *                             Guacamole.Client.
     */
    this.getDisplay = function() {
        return display;
    };

    /**
     * Sends the current size of the screen.
     * 
     * @param {Number} width The width of the screen.
     * @param {Number} height The height of the screen.
     */
    this.sendSize = function(width, height) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        tunnel.sendMessage("size", width, height);

    };

    /**
     * Sends a key event having the given properties as if the user
     * pressed or released a key.
     * 
     * @param {Boolean} pressed Whether the key is pressed (true) or released
     *                          (false).
     * @param {Number} keysym The keysym of the key being pressed or released.
     */
    this.sendKeyEvent = function(pressed, keysym) {
        // Do not send requests if not connected
        if (!isConnected())
            return;

        tunnel.sendMessage("key", keysym, pressed);
    };

    /**
     * Sends a mouse event having the properties provided by the given mouse
     * state.
     * 
     * @param {Guacamole.Mouse.State} mouseState The state of the mouse to send
     *                                           in the mouse event.
     */
    this.sendMouseState = function(mouseState) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        // Update client-side cursor
        display.moveCursor(
            Math.floor(mouseState.x),
            Math.floor(mouseState.y)
        );

        // Build mask
        var buttonMask = 0;
        if (mouseState.left)   buttonMask |= 1;
        if (mouseState.middle) buttonMask |= 2;
        if (mouseState.right)  buttonMask |= 4;
        if (mouseState.up)     buttonMask |= 8;
        if (mouseState.down)   buttonMask |= 16;

        // Send message
        tunnel.sendMessage("mouse", Math.floor(mouseState.x), Math.floor(mouseState.y), buttonMask);
    };

    /**
     * Allocates an available stream index and creates a new
     * Guacamole.OutputStream using that index, associating the resulting
     * stream with this Guacamole.Client. Note that this stream will not yet
     * exist as far as the other end of the Guacamole connection is concerned.
     * Streams exist within the Guacamole protocol only when referenced by an
     * instruction which creates the stream, such as a "clipboard", "file", or
     * "pipe" instruction.
     *
     * @returns {Guacamole.OutputStream}
     *     A new Guacamole.OutputStream with a newly-allocated index and
     *     associated with this Guacamole.Client.
     */
    this.createOutputStream = function createOutputStream() {

        // Allocate index
        var index = stream_indices.next();

        // Return new stream
        var stream = output_streams[index] = new Guacamole.OutputStream(guac_client, index);
        return stream;

    };

    /**
     * Opens a new audio stream for writing, where audio data having the give
     * mimetype will be sent along the returned stream. The instruction
     * necessary to create this stream will automatically be sent.
     *
     * @param {String} mimetype
     *     The mimetype of the audio data that will be sent along the returned
     *     stream.
     *
     * @return {Guacamole.OutputStream}
     *     The created audio stream.
     */
    this.createAudioStream = function(mimetype) {

        // Allocate and associate stream with audio metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("audio", stream.index, mimetype);
        return stream;

    };

    /**
     * Opens a new file for writing, having the given index, mimetype and
     * filename. The instruction necessary to create this stream will
     * automatically be sent.
     *
     * @param {String} mimetype The mimetype of the file being sent.
     * @param {String} filename The filename of the file being sent.
     * @return {Guacamole.OutputStream} The created file stream.
     */
    this.createFileStream = function(mimetype, filename) {

        // Allocate and associate stream with file metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("file", stream.index, mimetype, filename);
        return stream;

    };

    /**
     * Opens a new pipe for writing, having the given name and mimetype. The
     * instruction necessary to create this stream will automatically be sent.
     *
     * @param {String} mimetype The mimetype of the data being sent.
     * @param {String} name The name of the pipe.
     * @return {Guacamole.OutputStream} The created file stream.
     */
    this.createPipeStream = function(mimetype, name) {

        // Allocate and associate stream with pipe metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("pipe", stream.index, mimetype, name);
        return stream;

    };

    /**
     * Opens a new clipboard object for writing, having the given mimetype. The
     * instruction necessary to create this stream will automatically be sent.
     *
     * @param {String} mimetype The mimetype of the data being sent.
     * @param {String} name The name of the pipe.
     * @return {Guacamole.OutputStream} The created file stream.
     */
    this.createClipboardStream = function(mimetype) {

        // Allocate and associate stream with clipboard metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("clipboard", stream.index, mimetype);
        return stream;

    };

    /**
     * Opens a new argument value stream for writing, having the given
     * parameter name and mimetype, requesting that the connection parameter
     * with the given name be updated to the value described by the contents
     * of the following stream. The instruction necessary to create this stream
     * will automatically be sent.
     *
     * @param {String} mimetype
     *     The mimetype of the data being sent.
     *
     * @param {String} name
     *     The name of the connection parameter to attempt to update.
     *
     * @return {Guacamole.OutputStream}
     *     The created argument value stream.
     */
    this.createArgumentValueStream = function createArgumentValueStream(mimetype, name) {

        // Allocate and associate stream with argument value metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("argv", stream.index, mimetype, name);
        return stream;

    };

    /**
     * Creates a new output stream associated with the given object and having
     * the given mimetype and name. The legality of a mimetype and name is
     * dictated by the object itself. The instruction necessary to create this
     * stream will automatically be sent.
     *
     * @param {Number} index
     *     The index of the object for which the output stream is being
     *     created.
     *
     * @param {String} mimetype
     *     The mimetype of the data which will be sent to the output stream.
     *
     * @param {String} name
     *     The defined name of an output stream within the given object.
     *
     * @returns {Guacamole.OutputStream}
     *     An output stream which will write blobs to the named output stream
     *     of the given object.
     */
    this.createObjectOutputStream = function createObjectOutputStream(index, mimetype, name) {

        // Allocate and ssociate stream with object metadata
        var stream = guac_client.createOutputStream();
        tunnel.sendMessage("put", index, stream.index, mimetype, name);
        return stream;

    };

    /**
     * Requests read access to the input stream having the given name. If
     * successful, a new input stream will be created.
     *
     * @param {Number} index
     *     The index of the object from which the input stream is being
     *     requested.
     *
     * @param {String} name
     *     The name of the input stream to request.
     */
    this.requestObjectInputStream = function requestObjectInputStream(index, name) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        tunnel.sendMessage("get", index, name);
    };

    /**
     * Acknowledge receipt of a blob on the stream with the given index.
     * 
     * @param {Number} index The index of the stream associated with the
     *                       received blob.
     * @param {String} message A human-readable message describing the error
     *                         or status.
     * @param {Number} code The error code, if any, or 0 for success.
     */
    this.sendAck = function(index, message, code) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        tunnel.sendMessage("ack", index, message, code);
    };

    /**
     * Given the index of a file, writes a blob of data to that file.
     * 
     * @param {Number} index The index of the file to write to.
     * @param {String} data Base64-encoded data to write to the file.
     */
    this.sendBlob = function(index, data) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        tunnel.sendMessage("blob", index, data);
    };

    /**
     * Marks a currently-open stream as complete. The other end of the
     * Guacamole connection will be notified via an "end" instruction that the
     * stream is closed, and the index will be made available for reuse in
     * future streams.
     * 
     * @param {Number} index
     *     The index of the stream to end.
     */
    this.endStream = function(index) {

        // Do not send requests if not connected
        if (!isConnected())
            return;

        // Explicitly close stream by sending "end" instruction
        tunnel.sendMessage("end", index);

        // Free associated index and stream if they exist
        if (output_streams[index]) {
            stream_indices.free(index);
            delete output_streams[index];
        }

    };

    /**
     * Fired whenever the state of this Guacamole.Client changes.
     * 
     * @event
     * @param {Number} state The new state of the client.
     */
    this.onstatechange = null;

    /**
     * Fired when the remote client sends a name update.
     * 
     * @event
     * @param {String} name The new name of this client.
     */
    this.onname = null;

    /**
     * Fired when an error is reported by the remote client, and the connection
     * is being closed.
     * 
     * @event
     * @param {Guacamole.Status} status A status object which describes the
     *                                  error.
     */
    this.onerror = null;

    /**
     * Fired when a audio stream is created. The stream provided to this event
     * handler will contain its own event handlers for received data.
     *
     * @event
     * @param {Guacamole.InputStream} stream
     *     The stream that will receive audio data from the server.
     *
     * @param {String} mimetype
     *     The mimetype of the audio data which will be received.
     *
     * @return {Guacamole.AudioPlayer}
     *     An object which implements the Guacamole.AudioPlayer interface and
     *     has been initialied to play the data in the provided stream, or null
     *     if the built-in audio players of the Guacamole client should be
     *     used.
     */
    this.onaudio = null;

    /**
     * Fired when a video stream is created. The stream provided to this event
     * handler will contain its own event handlers for received data.
     *
     * @event
     * @param {Guacamole.InputStream} stream
     *     The stream that will receive video data from the server.
     *
     * @param {Guacamole.Display.VisibleLayer} layer
     *     The destination layer on which the received video data should be
     *     played. It is the responsibility of the Guacamole.VideoPlayer
     *     implementation to play the received data within this layer.
     *
     * @param {String} mimetype
     *     The mimetype of the video data which will be received.
     *
     * @return {Guacamole.VideoPlayer}
     *     An object which implements the Guacamole.VideoPlayer interface and
     *     has been initialied to play the data in the provided stream, or null
     *     if the built-in video players of the Guacamole client should be
     *     used.
     */
    this.onvideo = null;

    /**
     * Fired when the current value of a connection parameter is being exposed
     * by the server.
     *
     * @event
     * @param {Guacamole.InputStream} stream
     *     The stream that will receive connection parameter data from the
     *     server.
     *
     * @param {String} mimetype
     *     The mimetype of the data which will be received.
     *
     * @param {String} name
     *     The name of the connection parameter whose value is being exposed.
     */
    this.onargv = null;

    /**
     * Fired when the clipboard of the remote client is changing.
     * 
     * @event
     * @param {Guacamole.InputStream} stream The stream that will receive
     *                                       clipboard data from the server.
     * @param {String} mimetype The mimetype of the data which will be received.
     */
    this.onclipboard = null;

    /**
     * Fired when a file stream is created. The stream provided to this event
     * handler will contain its own event handlers for received data.
     * 
     * @event
     * @param {Guacamole.InputStream} stream The stream that will receive data
     *                                       from the server.
     * @param {String} mimetype The mimetype of the file received.
     * @param {String} filename The name of the file received.
     */
    this.onfile = null;

    /**
     * Fired when a filesystem object is created. The object provided to this
     * event handler will contain its own event handlers and functions for
     * requesting and handling data.
     *
     * @event
     * @param {Guacamole.Object} object
     *     The created filesystem object.
     *
     * @param {String} name
     *     The name of the filesystem.
     */
    this.onfilesystem = null;

    /**
     * Fired when a pipe stream is created. The stream provided to this event
     * handler will contain its own event handlers for received data;
     * 
     * @event
     * @param {Guacamole.InputStream} stream The stream that will receive data
     *                                       from the server.
     * @param {String} mimetype The mimetype of the data which will be received.
     * @param {String} name The name of the pipe.
     */
    this.onpipe = null;
    
    /**
     * Fired when a "required" instruction is received. A required instruction
     * indicates that additional parameters are required for the connection to
     * continue, such as user credentials.
     * 
     * @event
     * @param {String[]} parameters
     *      The names of the connection parameters that are required to be
     *      provided for the connection to continue.
     */
    this.onrequired = null;

    /**
     * Fired whenever a sync instruction is received from the server, indicating
     * that the server is finished processing any input from the client and
     * has sent any results.
     * 
     * @event
     * @param {Number} timestamp The timestamp associated with the sync
     *                           instruction.
     */
    this.onsync = null;

    /**
     * Returns the layer with the given index, creating it if necessary.
     * Positive indices refer to visible layers, an index of zero refers to
     * the default layer, and negative indices refer to buffers.
     *
     * @private
     * @param {Number} index
     *     The index of the layer to retrieve.
     *
     * @return {Guacamole.Display.VisibleLayer|Guacamole.Layer}
     *     The layer having the given index.
     */
    var getLayer = function getLayer(index) {

        // Get layer, create if necessary
        var layer = layers[index];
        if (!layer) {

            // Create layer based on index
            if (index === 0)
                layer = display.getDefaultLayer();
            else if (index > 0)
                layer = display.createLayer();
            else
                layer = display.createBuffer();
                
            // Add new layer
            layers[index] = layer;

        }

        return layer;

    };

    /**
     * Returns the index passed to getLayer() when the given layer was created.
     * Positive indices refer to visible layers, an index of zero refers to the
     * default layer, and negative indices refer to buffers.
     *
     * @param {Guacamole.Display.VisibleLayer|Guacamole.Layer} layer
     *     The layer whose index should be determined.
     *
     * @returns {Number}
     *     The index of the given layer, or null if no such layer is associated
     *     with this client.
     */
    var getLayerIndex = function getLayerIndex(layer) {

        // Avoid searching if there clearly is no such layer
        if (!layer)
            return null;

        // Search through each layer, returning the index of the given layer
        // once found
        for (var key in layers) {
            if (layer === layers[key])
                return parseInt(key);
        }

        // Otherwise, no such index
        return null;

    };

    function getParser(index) {

        var parser = parsers[index];

        // If parser not yet created, create it, and tie to the
        // oninstruction handler of the tunnel.
        if (parser == null) {
            parser = parsers[index] = new Guacamole.Parser();
            parser.oninstruction = tunnel.oninstruction;
        }

        return parser;

    }

    /**
     * Handlers for all defined layer properties.
     * @private
     */
    var layerPropertyHandlers = {

        "miter-limit": function(layer, value) {
            display.setMiterLimit(layer, parseFloat(value));
        }

    };
    
    /**
     * Handlers for all instruction opcodes receivable by a Guacamole protocol
     * client.
     * @private
     */
    var instructionHandlers = {

        "ack": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var reason = parameters[1];
            var code = parseInt(parameters[2]);

            // Get stream
            var stream = output_streams[stream_index];
            if (stream) {

                // Signal ack if handler defined
                if (stream.onack)
                    stream.onack(new Guacamole.Status(code, reason));

                // If code is an error, invalidate stream if not already
                // invalidated by onack handler
                if (code >= 0x0100 && output_streams[stream_index] === stream) {
                    stream_indices.free(stream_index);
                    delete output_streams[stream_index];
                }

            }

        },

        "arc": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var x = parseInt(parameters[1]);
            var y = parseInt(parameters[2]);
            var radius = parseInt(parameters[3]);
            var startAngle = parseFloat(parameters[4]);
            var endAngle = parseFloat(parameters[5]);
            var negative = parseInt(parameters[6]);

            display.arc(layer, x, y, radius, startAngle, endAngle, negative != 0);

        },

        "argv": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var mimetype = parameters[1];
            var name = parameters[2];

            // Create stream
            if (guac_client.onargv) {
                var stream = streams[stream_index] = new Guacamole.InputStream(guac_client, stream_index);
                guac_client.onargv(stream, mimetype, name);
            }

            // Otherwise, unsupported
            else
                guac_client.sendAck(stream_index, "Receiving argument values unsupported", 0x0100);

        },

        "audio": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var mimetype = parameters[1];

            // Create stream 
            var stream = streams[stream_index] =
                    new Guacamole.InputStream(guac_client, stream_index);

            // Get player instance via callback
            var audioPlayer = null;
            if (guac_client.onaudio)
                audioPlayer = guac_client.onaudio(stream, mimetype);

            // If unsuccessful, try to use a default implementation
            if (!audioPlayer)
                audioPlayer = Guacamole.AudioPlayer.getInstance(stream, mimetype);

            // If we have successfully retrieved an audio player, send success response
            if (audioPlayer) {
                audioPlayers[stream_index] = audioPlayer;
                guac_client.sendAck(stream_index, "OK", 0x0000);
            }

            // Otherwise, mimetype must be unsupported
            else
                guac_client.sendAck(stream_index, "BAD TYPE", 0x030F);

        },

        "blob": function(parameters) {

            // Get stream 
            var stream_index = parseInt(parameters[0]);
            var data = parameters[1];
            var stream = streams[stream_index];

            // Write data
            if (stream && stream.onblob)
                stream.onblob(data);

        },

        "body" : function handleBody(parameters) {

            // Get object
            var objectIndex = parseInt(parameters[0]);
            var object = objects[objectIndex];

            var streamIndex = parseInt(parameters[1]);
            var mimetype = parameters[2];
            var name = parameters[3];

            // Create stream if handler defined
            if (object && object.onbody) {
                var stream = streams[streamIndex] = new Guacamole.InputStream(guac_client, streamIndex);
                object.onbody(stream, mimetype, name);
            }

            // Otherwise, unsupported
            else
                guac_client.sendAck(streamIndex, "Receipt of body unsupported", 0x0100);

        },

        "cfill": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var r = parseInt(parameters[2]);
            var g = parseInt(parameters[3]);
            var b = parseInt(parameters[4]);
            var a = parseInt(parameters[5]);

            display.setChannelMask(layer, channelMask);
            display.fillColor(layer, r, g, b, a);

        },

        "clip": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.clip(layer);

        },

        "clipboard": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var mimetype = parameters[1];

            // Create stream 
            if (guac_client.onclipboard) {
                var stream = streams[stream_index] = new Guacamole.InputStream(guac_client, stream_index);
                guac_client.onclipboard(stream, mimetype);
            }

            // Otherwise, unsupported
            else
                guac_client.sendAck(stream_index, "Clipboard unsupported", 0x0100);

        },

        "close": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.close(layer);

        },

        "copy": function(parameters) {

            var srcL = getLayer(parseInt(parameters[0]));
            var srcX = parseInt(parameters[1]);
            var srcY = parseInt(parameters[2]);
            var srcWidth = parseInt(parameters[3]);
            var srcHeight = parseInt(parameters[4]);
            var channelMask = parseInt(parameters[5]);
            var dstL = getLayer(parseInt(parameters[6]));
            var dstX = parseInt(parameters[7]);
            var dstY = parseInt(parameters[8]);

            display.setChannelMask(dstL, channelMask);
            display.copy(srcL, srcX, srcY, srcWidth, srcHeight, 
                         dstL, dstX, dstY);

        },

        "cstroke": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var cap = lineCap[parseInt(parameters[2])];
            var join = lineJoin[parseInt(parameters[3])];
            var thickness = parseInt(parameters[4]);
            var r = parseInt(parameters[5]);
            var g = parseInt(parameters[6]);
            var b = parseInt(parameters[7]);
            var a = parseInt(parameters[8]);

            display.setChannelMask(layer, channelMask);
            display.strokeColor(layer, cap, join, thickness, r, g, b, a);

        },

        "cursor": function(parameters) {

            var cursorHotspotX = parseInt(parameters[0]);
            var cursorHotspotY = parseInt(parameters[1]);
            var srcL = getLayer(parseInt(parameters[2]));
            var srcX = parseInt(parameters[3]);
            var srcY = parseInt(parameters[4]);
            var srcWidth = parseInt(parameters[5]);
            var srcHeight = parseInt(parameters[6]);

            display.setCursor(cursorHotspotX, cursorHotspotY,
                              srcL, srcX, srcY, srcWidth, srcHeight);

        },

        "curve": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var cp1x = parseInt(parameters[1]);
            var cp1y = parseInt(parameters[2]);
            var cp2x = parseInt(parameters[3]);
            var cp2y = parseInt(parameters[4]);
            var x = parseInt(parameters[5]);
            var y = parseInt(parameters[6]);

            display.curveTo(layer, cp1x, cp1y, cp2x, cp2y, x, y);

        },

        "disconnect" : function handleDisconnect(parameters) {

            // Explicitly tear down connection
            guac_client.disconnect();

        },

        "dispose": function(parameters) {
            
            var layer_index = parseInt(parameters[0]);

            // If visible layer, remove from parent
            if (layer_index > 0) {

                // Remove from parent
                var layer = getLayer(layer_index);
                display.dispose(layer);

                // Delete reference
                delete layers[layer_index];

            }

            // If buffer, just delete reference
            else if (layer_index < 0)
                delete layers[layer_index];

            // Attempting to dispose the root layer currently has no effect.

        },

        "distort": function(parameters) {

            var layer_index = parseInt(parameters[0]);
            var a = parseFloat(parameters[1]);
            var b = parseFloat(parameters[2]);
            var c = parseFloat(parameters[3]);
            var d = parseFloat(parameters[4]);
            var e = parseFloat(parameters[5]);
            var f = parseFloat(parameters[6]);

            // Only valid for visible layers (not buffers)
            if (layer_index >= 0) {
                var layer = getLayer(layer_index);
                display.distort(layer, a, b, c, d, e, f);
            }

        },
 
        "error": function(parameters) {

            var reason = parameters[0];
            var code = parseInt(parameters[1]);

            // Call handler if defined
            if (guac_client.onerror)
                guac_client.onerror(new Guacamole.Status(code, reason));

            guac_client.disconnect();

        },

        "end": function(parameters) {

            var stream_index = parseInt(parameters[0]);

            // Get stream
            var stream = streams[stream_index];
            if (stream) {

                // Signal end of stream if handler defined
                if (stream.onend)
                    stream.onend();

                // Invalidate stream
                delete streams[stream_index];

            }

        },

        "file": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var mimetype = parameters[1];
            var filename = parameters[2];

            // Create stream 
            if (guac_client.onfile) {
                var stream = streams[stream_index] = new Guacamole.InputStream(guac_client, stream_index);
                guac_client.onfile(stream, mimetype, filename);
            }

            // Otherwise, unsupported
            else
                guac_client.sendAck(stream_index, "File transfer unsupported", 0x0100);

        },

        "filesystem" : function handleFilesystem(parameters) {

            var objectIndex = parseInt(parameters[0]);
            var name = parameters[1];

            // Create object, if supported
            if (guac_client.onfilesystem) {
                var object = objects[objectIndex] = new Guacamole.Object(guac_client, objectIndex);
                guac_client.onfilesystem(object, name);
            }

            // If unsupported, simply ignore the availability of the filesystem

        },

        "identity": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.setTransform(layer, 1, 0, 0, 1, 0, 0);

        },

        "img": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var channelMask = parseInt(parameters[1]);
            var layer = getLayer(parseInt(parameters[2]));
            var mimetype = parameters[3];
            var x = parseInt(parameters[4]);
            var y = parseInt(parameters[5]);

            // Create stream
            var stream = streams[stream_index] = new Guacamole.InputStream(guac_client, stream_index);

            // Draw received contents once decoded
            display.setChannelMask(layer, channelMask);
            display.drawStream(layer, x, y, stream, mimetype);

        },

        "jpeg": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var x = parseInt(parameters[2]);
            var y = parseInt(parameters[3]);
            var data = parameters[4];

            display.setChannelMask(layer, channelMask);
            display.draw(layer, x, y, "data:image/jpeg;base64," + data);

        },

        "lfill": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var srcLayer = getLayer(parseInt(parameters[2]));

            display.setChannelMask(layer, channelMask);
            display.fillLayer(layer, srcLayer);

        },

        "line": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var x = parseInt(parameters[1]);
            var y = parseInt(parameters[2]);

            display.lineTo(layer, x, y);

        },

        "lstroke": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var srcLayer = getLayer(parseInt(parameters[2]));

            display.setChannelMask(layer, channelMask);
            display.strokeLayer(layer, srcLayer);

        },

        "mouse" : function handleMouse(parameters) {

            var x = parseInt(parameters[0]);
            var y = parseInt(parameters[1]);

            // Display and move software cursor to received coordinates
            display.showCursor(true);
            display.moveCursor(x, y);

        },

        "move": function(parameters) {
            
            var layer_index = parseInt(parameters[0]);
            var parent_index = parseInt(parameters[1]);
            var x = parseInt(parameters[2]);
            var y = parseInt(parameters[3]);
            var z = parseInt(parameters[4]);

            // Only valid for non-default layers
            if (layer_index > 0 && parent_index >= 0) {
                var layer = getLayer(layer_index);
                var parent = getLayer(parent_index);
                display.move(layer, parent, x, y, z);
            }

        },

        "name": function(parameters) {
            if (guac_client.onname) guac_client.onname(parameters[0]);
        },

        "nest": function(parameters) {
            var parser = getParser(parseInt(parameters[0]));
            parser.receive(parameters[1]);
        },

        "pipe": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var mimetype = parameters[1];
            var name = parameters[2];

            // Create stream 
            if (guac_client.onpipe) {
                var stream = streams[stream_index] = new Guacamole.InputStream(guac_client, stream_index);
                guac_client.onpipe(stream, mimetype, name);
            }

            // Otherwise, unsupported
            else
                guac_client.sendAck(stream_index, "Named pipes unsupported", 0x0100);

        },

        "png": function(parameters) {

            var channelMask = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var x = parseInt(parameters[2]);
            var y = parseInt(parameters[3]);
            var data = parameters[4];

            display.setChannelMask(layer, channelMask);
            display.draw(layer, x, y, "data:image/png;base64," + data);

        },

        "pop": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.pop(layer);

        },

        "push": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.push(layer);

        },
 
        "rect": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var x = parseInt(parameters[1]);
            var y = parseInt(parameters[2]);
            var w = parseInt(parameters[3]);
            var h = parseInt(parameters[4]);

            display.rect(layer, x, y, w, h);

        },
                
        "required": function required(parameters) {
            if (guac_client.onrequired) guac_client.onrequired(parameters);
        },
        
        "reset": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));

            display.reset(layer);

        },
        
        "set": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var name = parameters[1];
            var value = parameters[2];

            // Call property handler if defined
            var handler = layerPropertyHandlers[name];
            if (handler)
                handler(layer, value);

        },

        "shade": function(parameters) {
            
            var layer_index = parseInt(parameters[0]);
            var a = parseInt(parameters[1]);

            // Only valid for visible layers (not buffers)
            if (layer_index >= 0) {
                var layer = getLayer(layer_index);
                display.shade(layer, a);
            }

        },

        "size": function(parameters) {

            var layer_index = parseInt(parameters[0]);
            var layer = getLayer(layer_index);
            var width = parseInt(parameters[1]);
            var height = parseInt(parameters[2]);

            display.resize(layer, width, height);

        },
        
        "start": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var x = parseInt(parameters[1]);
            var y = parseInt(parameters[2]);

            display.moveTo(layer, x, y);

        },

        "sync": function(parameters) {

            var timestamp = parseInt(parameters[0]);

            // Flush display, send sync when done
            display.flush(function displaySyncComplete() {

                // Synchronize all audio players
                for (var index in audioPlayers) {
                    var audioPlayer = audioPlayers[index];
                    if (audioPlayer)
                        audioPlayer.sync();
                }

                // Send sync response to server
                if (timestamp !== currentTimestamp) {
                    tunnel.sendMessage("sync", timestamp);
                    currentTimestamp = timestamp;
                }

            });

            // If received first update, no longer waiting.
            if (currentState === STATE_WAITING)
                setState(STATE_CONNECTED);

            // Call sync handler if defined
            if (guac_client.onsync)
                guac_client.onsync(timestamp);

        },

        "transfer": function(parameters) {

            var srcL = getLayer(parseInt(parameters[0]));
            var srcX = parseInt(parameters[1]);
            var srcY = parseInt(parameters[2]);
            var srcWidth = parseInt(parameters[3]);
            var srcHeight = parseInt(parameters[4]);
            var function_index = parseInt(parameters[5]);
            var dstL = getLayer(parseInt(parameters[6]));
            var dstX = parseInt(parameters[7]);
            var dstY = parseInt(parameters[8]);

            /* SRC */
            if (function_index === 0x3)
                display.put(srcL, srcX, srcY, srcWidth, srcHeight, 
                    dstL, dstX, dstY);

            /* Anything else that isn't a NO-OP */
            else if (function_index !== 0x5)
                display.transfer(srcL, srcX, srcY, srcWidth, srcHeight, 
                    dstL, dstX, dstY, Guacamole.Client.DefaultTransferFunction[function_index]);

        },

        "transform": function(parameters) {

            var layer = getLayer(parseInt(parameters[0]));
            var a = parseFloat(parameters[1]);
            var b = parseFloat(parameters[2]);
            var c = parseFloat(parameters[3]);
            var d = parseFloat(parameters[4]);
            var e = parseFloat(parameters[5]);
            var f = parseFloat(parameters[6]);

            display.transform(layer, a, b, c, d, e, f);

        },

        "undefine" : function handleUndefine(parameters) {

            // Get object
            var objectIndex = parseInt(parameters[0]);
            var object = objects[objectIndex];

            // Signal end of object definition
            if (object && object.onundefine)
                object.onundefine();

        },

        "video": function(parameters) {

            var stream_index = parseInt(parameters[0]);
            var layer = getLayer(parseInt(parameters[1]));
            var mimetype = parameters[2];

            // Create stream
            var stream = streams[stream_index] =
                    new Guacamole.InputStream(guac_client, stream_index);

            // Get player instance via callback
            var videoPlayer = null;
            if (guac_client.onvideo)
                videoPlayer = guac_client.onvideo(stream, layer, mimetype);

            // If unsuccessful, try to use a default implementation
            if (!videoPlayer)
                videoPlayer = Guacamole.VideoPlayer.getInstance(stream, layer, mimetype);

            // If we have successfully retrieved an video player, send success response
            if (videoPlayer) {
                videoPlayers[stream_index] = videoPlayer;
                guac_client.sendAck(stream_index, "OK", 0x0000);
            }

            // Otherwise, mimetype must be unsupported
            else
                guac_client.sendAck(stream_index, "BAD TYPE", 0x030F);

        }

    };

    tunnel.oninstruction = function(opcode, parameters) {

        var handler = instructionHandlers[opcode];
        if (handler)
            handler(parameters);

    };

    /**
     * Sends a disconnect instruction to the server and closes the tunnel.
     */
    this.disconnect = function() {

        // Only attempt disconnection not disconnected.
        if (currentState != STATE_DISCONNECTED
                && currentState != STATE_DISCONNECTING) {

            setState(STATE_DISCONNECTING);

            // Stop ping
            if (pingInterval)
                window.clearInterval(pingInterval);

            // Send disconnect message and disconnect
            tunnel.sendMessage("disconnect");
            tunnel.disconnect();
            setState(STATE_DISCONNECTED);

        }

    };
    
    /**
     * Connects the underlying tunnel of this Guacamole.Client, passing the
     * given arbitrary data to the tunnel during the connection process.
     *
     * @param data Arbitrary connection data to be sent to the underlying
     *             tunnel during the connection process.
     * @throws {Guacamole.Status} If an error occurs during connection.
     */
    this.connect = function(data) {

        setState(STATE_CONNECTING);

        try {
            tunnel.connect(data);
        }
        catch (status) {
            setState(STATE_IDLE);
            throw status;
        }

        // Ping every 5 seconds (ensure connection alive)
        pingInterval = window.setInterval(function() {
            tunnel.sendMessage("nop");
        }, 5000);

        setState(STATE_WAITING);
    };

};

/**
 * Map of all Guacamole binary raster operations to transfer functions.
 * @private
 */
Guacamole.Client.DefaultTransferFunction = {

    /* BLACK */
    0x0: function (src, dst) {
        dst.red = dst.green = dst.blue = 0x00;
    },

    /* WHITE */
    0xF: function (src, dst) {
        dst.red = dst.green = dst.blue = 0xFF;
    },

    /* SRC */
    0x3: function (src, dst) {
        dst.red   = src.red;
        dst.green = src.green;
        dst.blue  = src.blue;
        dst.alpha = src.alpha;
    },

    /* DEST (no-op) */
    0x5: function (src, dst) {
        // Do nothing
    },

    /* Invert SRC */
    0xC: function (src, dst) {
        dst.red   = 0xFF & ~src.red;
        dst.green = 0xFF & ~src.green;
        dst.blue  = 0xFF & ~src.blue;
        dst.alpha =  src.alpha;
    },
    
    /* Invert DEST */
    0xA: function (src, dst) {
        dst.red   = 0xFF & ~dst.red;
        dst.green = 0xFF & ~dst.green;
        dst.blue  = 0xFF & ~dst.blue;
    },

    /* AND */
    0x1: function (src, dst) {
        dst.red   =  ( src.red   &  dst.red);
        dst.green =  ( src.green &  dst.green);
        dst.blue  =  ( src.blue  &  dst.blue);
    },

    /* NAND */
    0xE: function (src, dst) {
        dst.red   = 0xFF & ~( src.red   &  dst.red);
        dst.green = 0xFF & ~( src.green &  dst.green);
        dst.blue  = 0xFF & ~( src.blue  &  dst.blue);
    },

    /* OR */
    0x7: function (src, dst) {
        dst.red   =  ( src.red   |  dst.red);
        dst.green =  ( src.green |  dst.green);
        dst.blue  =  ( src.blue  |  dst.blue);
    },

    /* NOR */
    0x8: function (src, dst) {
        dst.red   = 0xFF & ~( src.red   |  dst.red);
        dst.green = 0xFF & ~( src.green |  dst.green);
        dst.blue  = 0xFF & ~( src.blue  |  dst.blue);
    },

    /* XOR */
    0x6: function (src, dst) {
        dst.red   =  ( src.red   ^  dst.red);
        dst.green =  ( src.green ^  dst.green);
        dst.blue  =  ( src.blue  ^  dst.blue);
    },

    /* XNOR */
    0x9: function (src, dst) {
        dst.red   = 0xFF & ~( src.red   ^  dst.red);
        dst.green = 0xFF & ~( src.green ^  dst.green);
        dst.blue  = 0xFF & ~( src.blue  ^  dst.blue);
    },

    /* AND inverted source */
    0x4: function (src, dst) {
        dst.red   =  0xFF & (~src.red   &  dst.red);
        dst.green =  0xFF & (~src.green &  dst.green);
        dst.blue  =  0xFF & (~src.blue  &  dst.blue);
    },

    /* OR inverted source */
    0xD: function (src, dst) {
        dst.red   =  0xFF & (~src.red   |  dst.red);
        dst.green =  0xFF & (~src.green |  dst.green);
        dst.blue  =  0xFF & (~src.blue  |  dst.blue);
    },

    /* AND inverted destination */
    0x2: function (src, dst) {
        dst.red   =  0xFF & ( src.red   & ~dst.red);
        dst.green =  0xFF & ( src.green & ~dst.green);
        dst.blue  =  0xFF & ( src.blue  & ~dst.blue);
    },

    /* OR inverted destination */
    0xB: function (src, dst) {
        dst.red   =  0xFF & ( src.red   | ~dst.red);
        dst.green =  0xFF & ( src.green | ~dst.green);
        dst.blue  =  0xFF & ( src.blue  | ~dst.blue);
    }

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, returning
 * received blobs as a single data URI built over the course of the stream.
 * Note that this object will overwrite any installed event handlers on the
 * given Guacamole.InputStream.
 * 
 * @constructor
 * @param {Guacamole.InputStream} stream
 *     The stream that data will be read from.
 */
Guacamole.DataURIReader = function(stream, mimetype) {

    /**
     * Reference to this Guacamole.DataURIReader.
     * @private
     */
    var guac_reader = this;

    /**
     * Current data URI.
     *
     * @private
     * @type {String}
     */
    var uri = 'data:' + mimetype + ';base64,';

    // Receive blobs as array buffers
    stream.onblob = function dataURIReaderBlob(data) {

        // Currently assuming data will ALWAYS be safe to simply append. This
        // will not be true if the received base64 data encodes a number of
        // bytes that isn't a multiple of three (as base64 expands in a ratio
        // of exactly 3:4).
        uri += data;

    };

    // Simply call onend when end received
    stream.onend = function dataURIReaderEnd() {
        if (guac_reader.onend)
            guac_reader.onend();
    };

    /**
     * Returns the data URI of all data received through the underlying stream
     * thus far.
     *
     * @returns {String}
     *     The data URI of all data received through the underlying stream thus
     *     far.
     */
    this.getURI = function getURI() {
        return uri;
    };

    /**
     * Fired once this stream is finished and no further data will be written.
     *
     * @event
     */
    this.onend = null;

};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * The Guacamole display. The display does not deal with the Guacamole
 * protocol, and instead implements a set of graphical operations which
 * embody the set of operations present in the protocol. The order operations
 * are executed is guaranteed to be in the same order as their corresponding
 * functions are called.
 * 
 * @constructor
 */
Guacamole.Display = function() {

    /**
     * Reference to this Guacamole.Display.
     * @private
     */
    var guac_display = this;

    var displayWidth = 0;
    var displayHeight = 0;
    var displayScale = 1;

    // Create display
    var display = document.createElement("div");
    display.style.position = "relative";
    display.style.width = displayWidth + "px";
    display.style.height = displayHeight + "px";

    // Ensure transformations on display originate at 0,0
    display.style.transformOrigin =
    display.style.webkitTransformOrigin =
    display.style.MozTransformOrigin =
    display.style.OTransformOrigin =
    display.style.msTransformOrigin =
        "0 0";

    // Create default layer
    var default_layer = new Guacamole.Display.VisibleLayer(displayWidth, displayHeight);

    // Create cursor layer
    var cursor = new Guacamole.Display.VisibleLayer(0, 0);
    cursor.setChannelMask(Guacamole.Layer.SRC);

    // Add default layer and cursor to display
    display.appendChild(default_layer.getElement());
    display.appendChild(cursor.getElement());

    // Create bounding div 
    var bounds = document.createElement("div");
    bounds.style.position = "relative";
    bounds.style.width = (displayWidth*displayScale) + "px";
    bounds.style.height = (displayHeight*displayScale) + "px";

    // Add display to bounds
    bounds.appendChild(display);

    /**
     * The X coordinate of the hotspot of the mouse cursor. The hotspot is
     * the relative location within the image of the mouse cursor at which
     * each click occurs.
     * 
     * @type {Number}
     */
    this.cursorHotspotX = 0;

    /**
     * The Y coordinate of the hotspot of the mouse cursor. The hotspot is
     * the relative location within the image of the mouse cursor at which
     * each click occurs.
     * 
     * @type {Number}
     */
    this.cursorHotspotY = 0;

    /**
     * The current X coordinate of the local mouse cursor. This is not
     * necessarily the location of the actual mouse - it refers only to
     * the location of the cursor image within the Guacamole display, as
     * last set by moveCursor().
     * 
     * @type {Number}
     */
    this.cursorX = 0;

    /**
     * The current X coordinate of the local mouse cursor. This is not
     * necessarily the location of the actual mouse - it refers only to
     * the location of the cursor image within the Guacamole display, as
     * last set by moveCursor().
     * 
     * @type {Number}
     */
    this.cursorY = 0;

    /**
     * Fired when the default layer (and thus the entire Guacamole display)
     * is resized.
     * 
     * @event
     * @param {Number} width The new width of the Guacamole display.
     * @param {Number} height The new height of the Guacamole display.
     */
    this.onresize = null;

    /**
     * Fired whenever the local cursor image is changed. This can be used to
     * implement special handling of the client-side cursor, or to override
     * the default use of a software cursor layer.
     * 
     * @event
     * @param {HTMLCanvasElement} canvas The cursor image.
     * @param {Number} x The X-coordinate of the cursor hotspot.
     * @param {Number} y The Y-coordinate of the cursor hotspot.
     */
    this.oncursor = null;

    /**
     * The queue of all pending Tasks. Tasks will be run in order, with new
     * tasks added at the end of the queue and old tasks removed from the
     * front of the queue (FIFO). These tasks will eventually be grouped
     * into a Frame.
     * @private
     * @type {Task[]}
     */
    var tasks = [];

    /**
     * The queue of all frames. Each frame is a pairing of an array of tasks
     * and a callback which must be called when the frame is rendered.
     * @private
     * @type {Frame[]}
     */
    var frames = [];

    /**
     * Flushes all pending frames.
     * @private
     */
    function __flush_frames() {

        var rendered_frames = 0;

        // Draw all pending frames, if ready
        while (rendered_frames < frames.length) {

            var frame = frames[rendered_frames];
            if (!frame.isReady())
                break;

            frame.flush();
            rendered_frames++;

        } 

        // Remove rendered frames from array
        frames.splice(0, rendered_frames);

    }

    /**
     * An ordered list of tasks which must be executed atomically. Once
     * executed, an associated (and optional) callback will be called.
     *
     * @private
     * @constructor
     * @param {function} callback The function to call when this frame is
     *                            rendered.
     * @param {Task[]} tasks The set of tasks which must be executed to render
     *                       this frame.
     */
    function Frame(callback, tasks) {

        /**
         * Returns whether this frame is ready to be rendered. This function
         * returns true if and only if ALL underlying tasks are unblocked.
         * 
         * @returns {Boolean} true if all underlying tasks are unblocked,
         *                    false otherwise.
         */
        this.isReady = function() {

            // Search for blocked tasks
            for (var i=0; i < tasks.length; i++) {
                if (tasks[i].blocked)
                    return false;
            }

            // If no blocked tasks, the frame is ready
            return true;

        };

        /**
         * Renders this frame, calling the associated callback, if any, after
         * the frame is complete. This function MUST only be called when no
         * blocked tasks exist. Calling this function with blocked tasks
         * will result in undefined behavior.
         */
        this.flush = function() {

            // Draw all pending tasks.
            for (var i=0; i < tasks.length; i++)
                tasks[i].execute();

            // Call callback
            if (callback) callback();

        };

    }

    /**
     * A container for an task handler. Each operation which must be ordered
     * is associated with a Task that goes into a task queue. Tasks in this
     * queue are executed in order once their handlers are set, while Tasks 
     * without handlers block themselves and any following Tasks from running.
     *
     * @constructor
     * @private
     * @param {function} taskHandler The function to call when this task 
     *                               runs, if any.
     * @param {boolean} blocked Whether this task should start blocked.
     */
    function Task(taskHandler, blocked) {
       
        var task = this;
       
        /**
         * Whether this Task is blocked.
         * 
         * @type {boolean}
         */
        this.blocked = blocked;

        /**
         * Unblocks this Task, allowing it to run.
         */
        this.unblock = function() {
            if (task.blocked) {
                task.blocked = false;
                __flush_frames();
            }
        };

        /**
         * Calls the handler associated with this task IMMEDIATELY. This
         * function does not track whether this task is marked as blocked.
         * Enforcing the blocked status of tasks is up to the caller.
         */
        this.execute = function() {
            if (taskHandler) taskHandler();
        };

    }

    /**
     * Schedules a task for future execution. The given handler will execute
     * immediately after all previous tasks upon frame flush, unless this
     * task is blocked. If any tasks is blocked, the entire frame will not
     * render (and no tasks within will execute) until all tasks are unblocked.
     * 
     * @private
     * @param {function} handler The function to call when possible, if any.
     * @param {boolean} blocked Whether the task should start blocked.
     * @returns {Task} The Task created and added to the queue for future
     *                 running.
     */
    function scheduleTask(handler, blocked) {
        var task = new Task(handler, blocked);
        tasks.push(task);
        return task;
    }

    /**
     * Returns the element which contains the Guacamole display.
     * 
     * @return {Element} The element containing the Guacamole display.
     */
    this.getElement = function() {
        return bounds;
    };

    /**
     * Returns the width of this display.
     * 
     * @return {Number} The width of this display;
     */
    this.getWidth = function() {
        return displayWidth;
    };

    /**
     * Returns the height of this display.
     * 
     * @return {Number} The height of this display;
     */
    this.getHeight = function() {
        return displayHeight;
    };

    /**
     * Returns the default layer of this display. Each Guacamole display always
     * has at least one layer. Other layers can optionally be created within
     * this layer, but the default layer cannot be removed and is the absolute
     * ancestor of all other layers.
     * 
     * @return {Guacamole.Display.VisibleLayer} The default layer.
     */
    this.getDefaultLayer = function() {
        return default_layer;
    };

    /**
     * Returns the cursor layer of this display. Each Guacamole display contains
     * a layer for the image of the mouse cursor. This layer is a special case
     * and exists above all other layers, similar to the hardware mouse cursor.
     * 
     * @return {Guacamole.Display.VisibleLayer} The cursor layer.
     */
    this.getCursorLayer = function() {
        return cursor;
    };

    /**
     * Creates a new layer. The new layer will be a direct child of the default
     * layer, but can be moved to be a child of any other layer. Layers returned
     * by this function are visible.
     * 
     * @return {Guacamole.Display.VisibleLayer} The newly-created layer.
     */
    this.createLayer = function() {
        var layer = new Guacamole.Display.VisibleLayer(displayWidth, displayHeight);
        layer.move(default_layer, 0, 0, 0);
        return layer;
    };

    /**
     * Creates a new buffer. Buffers are invisible, off-screen surfaces. They
     * are implemented in the same manner as layers, but do not provide the
     * same nesting semantics.
     * 
     * @return {Guacamole.Layer} The newly-created buffer.
     */
    this.createBuffer = function() {
        var buffer = new Guacamole.Layer(0, 0);
        buffer.autosize = 1;
        return buffer;
    };

    /**
     * Flush all pending draw tasks, if possible, as a new frame. If the entire
     * frame is not ready, the flush will wait until all required tasks are
     * unblocked.
     * 
     * @param {function} callback The function to call when this frame is
     *                            flushed. This may happen immediately, or
     *                            later when blocked tasks become unblocked.
     */
    this.flush = function(callback) {

        // Add frame, reset tasks
        frames.push(new Frame(callback, tasks));
        tasks = [];

        // Attempt flush
        __flush_frames();

    };

    /**
     * Sets the hotspot and image of the mouse cursor displayed within the
     * Guacamole display.
     * 
     * @param {Number} hotspotX The X coordinate of the cursor hotspot.
     * @param {Number} hotspotY The Y coordinate of the cursor hotspot.
     * @param {Guacamole.Layer} layer The source layer containing the data which
     *                                should be used as the mouse cursor image.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      layer's coordinate space to copy data from.

     */
    this.setCursor = function(hotspotX, hotspotY, layer, srcx, srcy, srcw, srch) {
        scheduleTask(function __display_set_cursor() {

            // Set hotspot
            guac_display.cursorHotspotX = hotspotX;
            guac_display.cursorHotspotY = hotspotY;

            // Reset cursor size
            cursor.resize(srcw, srch);

            // Draw cursor to cursor layer
            cursor.copy(layer, srcx, srcy, srcw, srch, 0, 0);
            guac_display.moveCursor(guac_display.cursorX, guac_display.cursorY);

            // Fire cursor change event
            if (guac_display.oncursor)
                guac_display.oncursor(cursor.toCanvas(), hotspotX, hotspotY);

        });
    };

    /**
     * Sets whether the software-rendered cursor is shown. This cursor differs
     * from the hardware cursor in that it is built into the Guacamole.Display,
     * and relies on its own Guacamole layer to render.
     *
     * @param {Boolean} [shown=true] Whether to show the software cursor.
     */
    this.showCursor = function(shown) {

        var element = cursor.getElement();
        var parent = element.parentNode;

        // Remove from DOM if hidden
        if (shown === false) {
            if (parent)
                parent.removeChild(element);
        }

        // Otherwise, ensure cursor is child of display
        else if (parent !== display)
            display.appendChild(element);

    };

    /**
     * Sets the location of the local cursor to the given coordinates. For the
     * sake of responsiveness, this function performs its action immediately.
     * Cursor motion is not maintained within atomic frames.
     * 
     * @param {Number} x The X coordinate to move the cursor to.
     * @param {Number} y The Y coordinate to move the cursor to.
     */
    this.moveCursor = function(x, y) {

        // Move cursor layer
        cursor.translate(x - guac_display.cursorHotspotX,
                         y - guac_display.cursorHotspotY);

        // Update stored position
        guac_display.cursorX = x;
        guac_display.cursorY = y;

    };

    /**
     * Changes the size of the given Layer to the given width and height.
     * Resizing is only attempted if the new size provided is actually different
     * from the current size.
     * 
     * @param {Guacamole.Layer} layer The layer to resize.
     * @param {Number} width The new width.
     * @param {Number} height The new height.
     */
    this.resize = function(layer, width, height) {
        scheduleTask(function __display_resize() {

            layer.resize(width, height);

            // Resize display if default layer is resized
            if (layer === default_layer) {

                // Update (set) display size
                displayWidth = width;
                displayHeight = height;
                display.style.width = displayWidth + "px";
                display.style.height = displayHeight + "px";

                // Update bounds size
                bounds.style.width = (displayWidth*displayScale) + "px";
                bounds.style.height = (displayHeight*displayScale) + "px";

                // Notify of resize
                if (guac_display.onresize)
                    guac_display.onresize(width, height);

            }

        });
    };

    /**
     * Draws the specified image at the given coordinates. The image specified
     * must already be loaded.
     * 
     * @param {Guacamole.Layer} layer
     *     The layer to draw upon.
     *
     * @param {Number} x
     *     The destination X coordinate.
     *
     * @param {Number} y 
     *     The destination Y coordinate.
     *
     * @param {CanvasImageSource} image
     *     The image to draw. Note that this not a URL.
     */
    this.drawImage = function(layer, x, y, image) {
        scheduleTask(function __display_drawImage() {
            layer.drawImage(x, y, image);
        });
    };

    /**
     * Draws the image contained within the specified Blob at the given
     * coordinates. The Blob specified must already be populated with image
     * data.
     *
     * @param {Guacamole.Layer} layer
     *     The layer to draw upon.
     *
     * @param {Number} x
     *     The destination X coordinate.
     *
     * @param {Number} y
     *     The destination Y coordinate.
     *
     * @param {Blob} blob
     *     The Blob containing the image data to draw.
     */
    this.drawBlob = function(layer, x, y, blob) {

        var task;

        // Prefer createImageBitmap() over blob URLs if available
        if (window.createImageBitmap) {

            var bitmap;

            // Draw image once loaded
            task = scheduleTask(function drawImageBitmap() {
                layer.drawImage(x, y, bitmap);
            }, true);

            // Load image from provided blob
            window.createImageBitmap(blob).then(function bitmapLoaded(decoded) {
                bitmap = decoded;
                task.unblock();
            });

        }

        // Use blob URLs and the Image object if createImageBitmap() is
        // unavailable
        else {

            // Create URL for blob
            var url = URL.createObjectURL(blob);

            // Draw and free blob URL when ready
            task = scheduleTask(function __display_drawBlob() {

                // Draw the image only if it loaded without errors
                if (image.width && image.height)
                    layer.drawImage(x, y, image);

                // Blob URL no longer needed
                URL.revokeObjectURL(url);

            }, true);

            // Load image from URL
            var image = new Image();
            image.onload = task.unblock;
            image.onerror = task.unblock;
            image.src = url;

        }

    };

    /**
     * Draws the image within the given stream at the given coordinates. The
     * image will be loaded automatically, and this and any future operations
     * will wait for the image to finish loading. This function will
     * automatically choose an approriate method for reading and decoding the
     * given image stream, and should be preferred for received streams except
     * where manual decoding of the stream is unavoidable.
     *
     * @param {Guacamole.Layer} layer
     *     The layer to draw upon.
     *
     * @param {Number} x
     *     The destination X coordinate.
     *
     * @param {Number} y
     *     The destination Y coordinate.
     *
     * @param {Guacamole.InputStream} stream
     *     The stream along which image data will be received.
     *
     * @param {String} mimetype
     *     The mimetype of the image within the stream.
     */
    this.drawStream = function drawStream(layer, x, y, stream, mimetype) {

        // If createImageBitmap() is available, load the image as a blob so
        // that function can be used
        if (window.createImageBitmap) {
            var reader = new Guacamole.BlobReader(stream, mimetype);
            reader.onend = function drawImageBlob() {
                guac_display.drawBlob(layer, x, y, reader.getBlob());
            };
        }

        // Lacking createImageBitmap(), fall back to data URIs and the Image
        // object
        else {
            var reader = new Guacamole.DataURIReader(stream, mimetype);
            reader.onend = function drawImageDataURI() {
                guac_display.draw(layer, x, y, reader.getURI());
            };
        }

    };

    /**
     * Draws the image at the specified URL at the given coordinates. The image
     * will be loaded automatically, and this and any future operations will
     * wait for the image to finish loading.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     * @param {String} url The URL of the image to draw.
     */
    this.draw = function(layer, x, y, url) {

        var task = scheduleTask(function __display_draw() {

            // Draw the image only if it loaded without errors
            if (image.width && image.height)
                layer.drawImage(x, y, image);

        }, true);

        var image = new Image();
        image.onload = task.unblock;
        image.onerror = task.unblock;
        image.src = url;

    };

    /**
     * Plays the video at the specified URL within this layer. The video
     * will be loaded automatically, and this and any future operations will
     * wait for the video to finish loading. Future operations will not be
     * executed until the video finishes playing.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {String} mimetype The mimetype of the video to play.
     * @param {Number} duration The duration of the video in milliseconds.
     * @param {String} url The URL of the video to play.
     */
    this.play = function(layer, mimetype, duration, url) {

        // Start loading the video
        var video = document.createElement("video");
        video.type = mimetype;
        video.src = url;

        // Start copying frames when playing
        video.addEventListener("play", function() {
            
            function render_callback() {
                layer.drawImage(0, 0, video);
                if (!video.ended)
                    window.setTimeout(render_callback, 20);
            }
            
            render_callback();
            
        }, false);

        scheduleTask(video.play);

    };

    /**
     * Transfer a rectangle of image data from one Layer to this Layer using the
     * specified transfer function.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Guacamole.Layer} dstLayer The layer to draw upon.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     * @param {Function} transferFunction The transfer function to use to
     *                                    transfer data from source to
     *                                    destination.
     */
    this.transfer = function(srcLayer, srcx, srcy, srcw, srch, dstLayer, x, y, transferFunction) {
        scheduleTask(function __display_transfer() {
            dstLayer.transfer(srcLayer, srcx, srcy, srcw, srch, x, y, transferFunction);
        });
    };

    /**
     * Put a rectangle of image data from one Layer to this Layer directly
     * without performing any alpha blending. Simply copy the data.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Guacamole.Layer} dstLayer The layer to draw upon.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     */
    this.put = function(srcLayer, srcx, srcy, srcw, srch, dstLayer, x, y) {
        scheduleTask(function __display_put() {
            dstLayer.put(srcLayer, srcx, srcy, srcw, srch, x, y);
        });
    };

    /**
     * Copy a rectangle of image data from one Layer to this Layer. This
     * operation will copy exactly the image data that will be drawn once all
     * operations of the source Layer that were pending at the time this
     * function was called are complete. This operation will not alter the
     * size of the source Layer even if its autosize property is set to true.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Guacamole.Layer} dstLayer The layer to draw upon.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     */
    this.copy = function(srcLayer, srcx, srcy, srcw, srch, dstLayer, x, y) {
        scheduleTask(function __display_copy() {
            dstLayer.copy(srcLayer, srcx, srcy, srcw, srch, x, y);
        });
    };

    /**
     * Starts a new path at the specified point.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} x The X coordinate of the point to draw.
     * @param {Number} y The Y coordinate of the point to draw.
     */
    this.moveTo = function(layer, x, y) {
        scheduleTask(function __display_moveTo() {
            layer.moveTo(x, y);
        });
    };

    /**
     * Add the specified line to the current path.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} x The X coordinate of the endpoint of the line to draw.
     * @param {Number} y The Y coordinate of the endpoint of the line to draw.
     */
    this.lineTo = function(layer, x, y) {
        scheduleTask(function __display_lineTo() {
            layer.lineTo(x, y);
        });
    };

    /**
     * Add the specified arc to the current path.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} x The X coordinate of the center of the circle which
     *                   will contain the arc.
     * @param {Number} y The Y coordinate of the center of the circle which
     *                   will contain the arc.
     * @param {Number} radius The radius of the circle.
     * @param {Number} startAngle The starting angle of the arc, in radians.
     * @param {Number} endAngle The ending angle of the arc, in radians.
     * @param {Boolean} negative Whether the arc should be drawn in order of
     *                           decreasing angle.
     */
    this.arc = function(layer, x, y, radius, startAngle, endAngle, negative) {
        scheduleTask(function __display_arc() {
            layer.arc(x, y, radius, startAngle, endAngle, negative);
        });
    };

    /**
     * Starts a new path at the specified point.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} cp1x The X coordinate of the first control point.
     * @param {Number} cp1y The Y coordinate of the first control point.
     * @param {Number} cp2x The X coordinate of the second control point.
     * @param {Number} cp2y The Y coordinate of the second control point.
     * @param {Number} x The X coordinate of the endpoint of the curve.
     * @param {Number} y The Y coordinate of the endpoint of the curve.
     */
    this.curveTo = function(layer, cp1x, cp1y, cp2x, cp2y, x, y) {
        scheduleTask(function __display_curveTo() {
            layer.curveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        });
    };

    /**
     * Closes the current path by connecting the end point with the start
     * point (if any) with a straight line.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     */
    this.close = function(layer) {
        scheduleTask(function __display_close() {
            layer.close();
        });
    };

    /**
     * Add the specified rectangle to the current path.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} x The X coordinate of the upper-left corner of the
     *                   rectangle to draw.
     * @param {Number} y The Y coordinate of the upper-left corner of the
     *                   rectangle to draw.
     * @param {Number} w The width of the rectangle to draw.
     * @param {Number} h The height of the rectangle to draw.
     */
    this.rect = function(layer, x, y, w, h) {
        scheduleTask(function __display_rect() {
            layer.rect(x, y, w, h);
        });
    };

    /**
     * Clip all future drawing operations by the current path. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as fillColor()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} layer The layer to affect.
     */
    this.clip = function(layer) {
        scheduleTask(function __display_clip() {
            layer.clip();
        });
    };

    /**
     * Stroke the current path with the specified color. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {String} cap The line cap style. Can be "round", "square",
     *                     or "butt".
     * @param {String} join The line join style. Can be "round", "bevel",
     *                      or "miter".
     * @param {Number} thickness The line thickness in pixels.
     * @param {Number} r The red component of the color to fill.
     * @param {Number} g The green component of the color to fill.
     * @param {Number} b The blue component of the color to fill.
     * @param {Number} a The alpha component of the color to fill.
     */
    this.strokeColor = function(layer, cap, join, thickness, r, g, b, a) {
        scheduleTask(function __display_strokeColor() {
            layer.strokeColor(cap, join, thickness, r, g, b, a);
        });
    };

    /**
     * Fills the current path with the specified color. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Number} r The red component of the color to fill.
     * @param {Number} g The green component of the color to fill.
     * @param {Number} b The blue component of the color to fill.
     * @param {Number} a The alpha component of the color to fill.
     */
    this.fillColor = function(layer, r, g, b, a) {
        scheduleTask(function __display_fillColor() {
            layer.fillColor(r, g, b, a);
        });
    };

    /**
     * Stroke the current path with the image within the specified layer. The
     * image data will be tiled infinitely within the stroke. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {String} cap The line cap style. Can be "round", "square",
     *                     or "butt".
     * @param {String} join The line join style. Can be "round", "bevel",
     *                      or "miter".
     * @param {Number} thickness The line thickness in pixels.
     * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
     *                                   within the stroke.
     */
    this.strokeLayer = function(layer, cap, join, thickness, srcLayer) {
        scheduleTask(function __display_strokeLayer() {
            layer.strokeLayer(cap, join, thickness, srcLayer);
        });
    };

    /**
     * Fills the current path with the image within the specified layer. The
     * image data will be tiled infinitely within the stroke. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
     *                                   within the fill.
     */
    this.fillLayer = function(layer, srcLayer) {
        scheduleTask(function __display_fillLayer() {
            layer.fillLayer(srcLayer);
        });
    };

    /**
     * Push current layer state onto stack.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     */
    this.push = function(layer) {
        scheduleTask(function __display_push() {
            layer.push();
        });
    };

    /**
     * Pop layer state off stack.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     */
    this.pop = function(layer) {
        scheduleTask(function __display_pop() {
            layer.pop();
        });
    };

    /**
     * Reset the layer, clearing the stack, the current path, and any transform
     * matrix.
     * 
     * @param {Guacamole.Layer} layer The layer to draw upon.
     */
    this.reset = function(layer) {
        scheduleTask(function __display_reset() {
            layer.reset();
        });
    };

    /**
     * Sets the given affine transform (defined with six values from the
     * transform's matrix).
     * 
     * @param {Guacamole.Layer} layer The layer to modify.
     * @param {Number} a The first value in the affine transform's matrix.
     * @param {Number} b The second value in the affine transform's matrix.
     * @param {Number} c The third value in the affine transform's matrix.
     * @param {Number} d The fourth value in the affine transform's matrix.
     * @param {Number} e The fifth value in the affine transform's matrix.
     * @param {Number} f The sixth value in the affine transform's matrix.
     */
    this.setTransform = function(layer, a, b, c, d, e, f) {
        scheduleTask(function __display_setTransform() {
            layer.setTransform(a, b, c, d, e, f);
        });
    };

    /**
     * Applies the given affine transform (defined with six values from the
     * transform's matrix).
     * 
     * @param {Guacamole.Layer} layer The layer to modify.
     * @param {Number} a The first value in the affine transform's matrix.
     * @param {Number} b The second value in the affine transform's matrix.
     * @param {Number} c The third value in the affine transform's matrix.
     * @param {Number} d The fourth value in the affine transform's matrix.
     * @param {Number} e The fifth value in the affine transform's matrix.
     * @param {Number} f The sixth value in the affine transform's matrix.
     */
    this.transform = function(layer, a, b, c, d, e, f) {
        scheduleTask(function __display_transform() {
            layer.transform(a, b, c, d, e, f);
        });
    };

    /**
     * Sets the channel mask for future operations on this Layer.
     * 
     * The channel mask is a Guacamole-specific compositing operation identifier
     * with a single bit representing each of four channels (in order): source
     * image where destination transparent, source where destination opaque,
     * destination where source transparent, and destination where source
     * opaque.
     * 
     * @param {Guacamole.Layer} layer The layer to modify.
     * @param {Number} mask The channel mask for future operations on this
     *                      Layer.
     */
    this.setChannelMask = function(layer, mask) {
        scheduleTask(function __display_setChannelMask() {
            layer.setChannelMask(mask);
        });
    };

    /**
     * Sets the miter limit for stroke operations using the miter join. This
     * limit is the maximum ratio of the size of the miter join to the stroke
     * width. If this ratio is exceeded, the miter will not be drawn for that
     * joint of the path.
     * 
     * @param {Guacamole.Layer} layer The layer to modify.
     * @param {Number} limit The miter limit for stroke operations using the
     *                       miter join.
     */
    this.setMiterLimit = function(layer, limit) {
        scheduleTask(function __display_setMiterLimit() {
            layer.setMiterLimit(limit);
        });
    };

    /**
     * Removes the given layer container entirely, such that it is no longer
     * contained within its parent layer, if any.
     *
     * @param {Guacamole.Display.VisibleLayer} layer
     *     The layer being removed from its parent.
     */
    this.dispose = function dispose(layer) {
        scheduleTask(function disposeLayer() {
            layer.dispose();
        });
    };

    /**
     * Applies the given affine transform (defined with six values from the
     * transform's matrix) to the given layer.
     *
     * @param {Guacamole.Display.VisibleLayer} layer
     *     The layer being distorted.
     *
     * @param {Number} a
     *     The first value in the affine transform's matrix.
     *
     * @param {Number} b
     *     The second value in the affine transform's matrix.
     *
     * @param {Number} c
     *     The third value in the affine transform's matrix.
     *
     * @param {Number} d
     *     The fourth value in the affine transform's matrix.
     *
     * @param {Number} e
     *     The fifth value in the affine transform's matrix.
     *
     * @param {Number} f
     *     The sixth value in the affine transform's matrix.
     */
    this.distort = function distort(layer, a, b, c, d, e, f) {
        scheduleTask(function distortLayer() {
            layer.distort(a, b, c, d, e, f);
        });
    };

    /**
     * Moves the upper-left corner of the given layer to the given X and Y
     * coordinate, sets the Z stacking order, and reparents the layer
     * to the given parent layer.
     *
     * @param {Guacamole.Display.VisibleLayer} layer
     *     The layer being moved.
     *
     * @param {Guacamole.Display.VisibleLayer} parent
     *     The parent to set.
     *
     * @param {Number} x
     *     The X coordinate to move to.
     *
     * @param {Number} y
     *     The Y coordinate to move to.
     *
     * @param {Number} z
     *     The Z coordinate to move to.
     */
    this.move = function move(layer, parent, x, y, z) {
        scheduleTask(function moveLayer() {
            layer.move(parent, x, y, z);
        });
    };

    /**
     * Sets the opacity of the given layer to the given value, where 255 is
     * fully opaque and 0 is fully transparent.
     *
     * @param {Guacamole.Display.VisibleLayer} layer
     *     The layer whose opacity should be set.
     *
     * @param {Number} alpha
     *     The opacity to set.
     */
    this.shade = function shade(layer, alpha) {
        scheduleTask(function shadeLayer() {
            layer.shade(alpha);
        });
    };

    /**
     * Sets the scale of the client display element such that it renders at
     * a relatively smaller or larger size, without affecting the true
     * resolution of the display.
     *
     * @param {Number} scale The scale to resize to, where 1.0 is normal
     *                       size (1:1 scale).
     */
    this.scale = function(scale) {

        display.style.transform =
        display.style.WebkitTransform =
        display.style.MozTransform =
        display.style.OTransform =
        display.style.msTransform =

            "scale(" + scale + "," + scale + ")";

        displayScale = scale;

        // Update bounds size
        bounds.style.width = (displayWidth*displayScale) + "px";
        bounds.style.height = (displayHeight*displayScale) + "px";

    };

    /**
     * Returns the scale of the display.
     *
     * @return {Number} The scale of the display.
     */
    this.getScale = function() {
        return displayScale;
    };

    /**
     * Returns a canvas element containing the entire display, with all child
     * layers composited within.
     *
     * @return {HTMLCanvasElement} A new canvas element containing a copy of
     *                             the display.
     */
    this.flatten = function() {
       
        // Get destination canvas
        var canvas = document.createElement("canvas");
        canvas.width = default_layer.width;
        canvas.height = default_layer.height;

        var context = canvas.getContext("2d");

        // Returns sorted array of children
        function get_children(layer) {

            // Build array of children
            var children = [];
            for (var index in layer.children)
                children.push(layer.children[index]);

            // Sort
            children.sort(function children_comparator(a, b) {

                // Compare based on Z order
                var diff = a.z - b.z;
                if (diff !== 0)
                    return diff;

                // If Z order identical, use document order
                var a_element = a.getElement();
                var b_element = b.getElement();
                var position = b_element.compareDocumentPosition(a_element);

                if (position & Node.DOCUMENT_POSITION_PRECEDING) return -1;
                if (position & Node.DOCUMENT_POSITION_FOLLOWING) return  1;

                // Otherwise, assume same
                return 0;

            });

            // Done
            return children;

        }

        // Draws the contents of the given layer at the given coordinates
        function draw_layer(layer, x, y) {

            // Draw layer
            if (layer.width > 0 && layer.height > 0) {

                // Save and update alpha
                var initial_alpha = context.globalAlpha;
                context.globalAlpha *= layer.alpha / 255.0;

                // Copy data
                context.drawImage(layer.getCanvas(), x, y);

                // Draw all children
                var children = get_children(layer);
                for (var i=0; i<children.length; i++) {
                    var child = children[i];
                    draw_layer(child, x + child.x, y + child.y);
                }

                // Restore alpha
                context.globalAlpha = initial_alpha;

            }

        }

        // Draw default layer and all children
        draw_layer(default_layer, 0, 0);

        // Return new canvas copy
        return canvas;
        
    };

};

/**
 * Simple container for Guacamole.Layer, allowing layers to be easily
 * repositioned and nested. This allows certain operations to be accelerated
 * through DOM manipulation, rather than raster operations.
 * 
 * @constructor
 * @augments Guacamole.Layer
 * @param {Number} width The width of the Layer, in pixels. The canvas element
 *                       backing this Layer will be given this width.
 * @param {Number} height The height of the Layer, in pixels. The canvas element
 *                        backing this Layer will be given this height.
 */
Guacamole.Display.VisibleLayer = function(width, height) {

    Guacamole.Layer.apply(this, [width, height]);

    /**
     * Reference to this layer.
     * @private
     */
    var layer = this;

    /**
     * Identifier which uniquely identifies this layer. This is COMPLETELY
     * UNRELATED to the index of the underlying layer, which is specific
     * to the Guacamole protocol, and not relevant at this level.
     * 
     * @private
     * @type {Number}
     */
    this.__unique_id = Guacamole.Display.VisibleLayer.__next_id++;

    /**
     * The opacity of the layer container, where 255 is fully opaque and 0 is
     * fully transparent.
     */
    this.alpha = 0xFF;

    /**
     * X coordinate of the upper-left corner of this layer container within
     * its parent, in pixels.
     * @type {Number}
     */
    this.x = 0;

    /**
     * Y coordinate of the upper-left corner of this layer container within
     * its parent, in pixels.
     * @type {Number}
     */
    this.y = 0;

    /**
     * Z stacking order of this layer relative to other sibling layers.
     * @type {Number}
     */
    this.z = 0;

    /**
     * The affine transformation applied to this layer container. Each element
     * corresponds to a value from the transformation matrix, with the first
     * three values being the first row, and the last three values being the
     * second row. There are six values total.
     * 
     * @type {Number[]}
     */
    this.matrix = [1, 0, 0, 1, 0, 0];

    /**
     * The parent layer container of this layer, if any.
     * @type {Guacamole.Display.VisibleLayer}
     */
    this.parent = null;

    /**
     * Set of all children of this layer, indexed by layer index. This object
     * will have one property per child.
     */
    this.children = {};

    // Set layer position
    var canvas = layer.getCanvas();
    canvas.style.position = "absolute";
    canvas.style.left = "0px";
    canvas.style.top = "0px";

    // Create div with given size
    var div = document.createElement("div");
    div.appendChild(canvas);
    div.style.width = width + "px";
    div.style.height = height + "px";
    div.style.position = "absolute";
    div.style.left = "0px";
    div.style.top = "0px";
    div.style.overflow = "hidden";

    /**
     * Superclass resize() function.
     * @private
     */
    var __super_resize = this.resize;

    this.resize = function(width, height) {

        // Resize containing div
        div.style.width = width + "px";
        div.style.height = height + "px";

        __super_resize(width, height);

    };
  
    /**
     * Returns the element containing the canvas and any other elements
     * associated with this layer.
     * @returns {Element} The element containing this layer's canvas.
     */
    this.getElement = function() {
        return div;
    };

    /**
     * The translation component of this layer's transform.
     * @private
     */
    var translate = "translate(0px, 0px)"; // (0, 0)

    /**
     * The arbitrary matrix component of this layer's transform.
     * @private
     */
    var matrix = "matrix(1, 0, 0, 1, 0, 0)"; // Identity

    /**
     * Moves the upper-left corner of this layer to the given X and Y
     * coordinate.
     * 
     * @param {Number} x The X coordinate to move to.
     * @param {Number} y The Y coordinate to move to.
     */
    this.translate = function(x, y) {

        layer.x = x;
        layer.y = y;

        // Generate translation
        translate = "translate("
                        + x + "px,"
                        + y + "px)";

        // Set layer transform 
        div.style.transform =
        div.style.WebkitTransform =
        div.style.MozTransform =
        div.style.OTransform =
        div.style.msTransform =

            translate + " " + matrix;

    };

    /**
     * Moves the upper-left corner of this VisibleLayer to the given X and Y
     * coordinate, sets the Z stacking order, and reparents this VisibleLayer
     * to the given VisibleLayer.
     * 
     * @param {Guacamole.Display.VisibleLayer} parent The parent to set.
     * @param {Number} x The X coordinate to move to.
     * @param {Number} y The Y coordinate to move to.
     * @param {Number} z The Z coordinate to move to.
     */
    this.move = function(parent, x, y, z) {

        // Set parent if necessary
        if (layer.parent !== parent) {

            // Maintain relationship
            if (layer.parent)
                delete layer.parent.children[layer.__unique_id];
            layer.parent = parent;
            parent.children[layer.__unique_id] = layer;

            // Reparent element
            var parent_element = parent.getElement();
            parent_element.appendChild(div);

        }

        // Set location
        layer.translate(x, y);
        layer.z = z;
        div.style.zIndex = z;

    };

    /**
     * Sets the opacity of this layer to the given value, where 255 is fully
     * opaque and 0 is fully transparent.
     * 
     * @param {Number} a The opacity to set.
     */
    this.shade = function(a) {
        layer.alpha = a;
        div.style.opacity = a/255.0;
    };

    /**
     * Removes this layer container entirely, such that it is no longer
     * contained within its parent layer, if any.
     */
    this.dispose = function() {

        // Remove from parent container
        if (layer.parent) {
            delete layer.parent.children[layer.__unique_id];
            layer.parent = null;
        }

        // Remove from parent element
        if (div.parentNode)
            div.parentNode.removeChild(div);
        
    };

    /**
     * Applies the given affine transform (defined with six values from the
     * transform's matrix).
     * 
     * @param {Number} a The first value in the affine transform's matrix.
     * @param {Number} b The second value in the affine transform's matrix.
     * @param {Number} c The third value in the affine transform's matrix.
     * @param {Number} d The fourth value in the affine transform's matrix.
     * @param {Number} e The fifth value in the affine transform's matrix.
     * @param {Number} f The sixth value in the affine transform's matrix.
     */
    this.distort = function(a, b, c, d, e, f) {

        // Store matrix
        layer.matrix = [a, b, c, d, e, f];

        // Generate matrix transformation
        matrix =

            /* a c e
             * b d f
             * 0 0 1
             */
    
            "matrix(" + a + "," + b + "," + c + "," + d + "," + e + "," + f + ")";

        // Set layer transform 
        div.style.transform =
        div.style.WebkitTransform =
        div.style.MozTransform =
        div.style.OTransform =
        div.style.msTransform =

            translate + " " + matrix;

    };

};

/**
 * The next identifier to be assigned to the layer container. This identifier
 * uniquely identifies each VisibleLayer, but is unrelated to the index of
 * the layer, which exists at the protocol/client level only.
 * 
 * @private
 * @type {Number}
 */
Guacamole.Display.VisibleLayer.__next_id = 0;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A hidden input field which attempts to keep itself focused at all times,
 * except when another input field has been intentionally focused, whether
 * programatically or by the user. The actual underlying input field, returned
 * by getElement(), may be used as a reliable source of keyboard-related events,
 * particularly composition and input events which may require a focused input
 * field to be dispatched at all.
 *
 * @constructor
 */
Guacamole.InputSink = function InputSink() {

    /**
     * Reference to this instance of Guacamole.InputSink.
     *
     * @private
     * @type {Guacamole.InputSink}
     */
    var sink = this;

    /**
     * The underlying input field, styled to be invisible.
     *
     * @private
     * @type {Element}
     */
    var field = document.createElement('textarea');
    field.style.position   = 'fixed';
    field.style.outline    = 'none';
    field.style.border     = 'none';
    field.style.margin     = '0';
    field.style.padding    = '0';
    field.style.height     = '0';
    field.style.width      = '0';
    field.style.left       = '0';
    field.style.bottom     = '0';
    field.style.resize     = 'none';
    field.style.background = 'transparent';
    field.style.color      = 'transparent';

    // Keep field clear when modified via normal keypresses
    field.addEventListener("keypress", function clearKeypress(e) {
        field.value = '';
    }, false);

    // Keep field clear when modofied via composition events
    field.addEventListener("compositionend", function clearCompletedComposition(e) {
        if (e.data)
            field.value = '';
    }, false);

    // Keep field clear when modofied via input events
    field.addEventListener("input", function clearCompletedInput(e) {
        if (e.data && !e.isComposing)
            field.value = '';
    }, false);

    // Whenever focus is gained, automatically click to ensure cursor is
    // actually placed within the field (the field may simply be highlighted or
    // outlined otherwise)
    field.addEventListener("focus", function focusReceived() {
        window.setTimeout(function deferRefocus() {
            field.click();
            field.select();
        }, 0);
    }, true);

    /**
     * Attempts to focus the underlying input field. The focus attempt occurs
     * asynchronously, and may silently fail depending on browser restrictions.
     */
    this.focus = function focus() {
        window.setTimeout(function deferRefocus() {
            field.focus(); // Focus must be deferred to work reliably across browsers
        }, 0);
    };

    /**
     * Returns the underlying input field. This input field MUST be manually
     * added to the DOM for the Guacamole.InputSink to have any effect.
     *
     * @returns {Element}
     */
    this.getElement = function getElement() {
        return field;
    };

    // Automatically refocus input sink if part of DOM
    document.addEventListener("keydown", function refocusSink(e) {

        // Do not refocus if focus is on an input field
        var focused = document.activeElement;
        if (focused && focused !== document.body) {

            // Only consider focused input fields which are actually visible
            var rect = focused.getBoundingClientRect();
            if (rect.left + rect.width > 0 && rect.top + rect.height > 0)
                return;

        }

        // Refocus input sink instead of handling click
        sink.focus();

    }, true);

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * An input stream abstraction used by the Guacamole client to facilitate
 * transfer of files or other binary data.
 * 
 * @constructor
 * @param {Guacamole.Client} client The client owning this stream.
 * @param {Number} index The index of this stream.
 */
Guacamole.InputStream = function(client, index) {

    /**
     * Reference to this stream.
     * @private
     */
    var guac_stream = this;

    /**
     * The index of this stream.
     * @type {Number}
     */
    this.index = index;

    /**
     * Called when a blob of data is received.
     * 
     * @event
     * @param {String} data The received base64 data.
     */
    this.onblob = null;

    /**
     * Called when this stream is closed.
     * 
     * @event
     */
    this.onend = null;

    /**
     * Acknowledges the receipt of a blob.
     * 
     * @param {String} message A human-readable message describing the error
     *                         or status.
     * @param {Number} code The error code, if any, or 0 for success.
     */
    this.sendAck = function(message, code) {
        client.sendAck(guac_stream.index, message, code);
    };

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Integer pool which returns consistently increasing integers while integers
 * are in use, and previously-used integers when possible.
 * @constructor 
 */
Guacamole.IntegerPool = function() {

    /**
     * Reference to this integer pool.
     *
     * @private
     */
    var guac_pool = this;

    /**
     * Array of available integers.
     *
     * @private
     * @type {Number[]}
     */
    var pool = [];

    /**
     * The next integer to return if no more integers remain.
     * @type {Number}
     */
    this.next_int = 0;

    /**
     * Returns the next available integer in the pool. If possible, a previously
     * used integer will be returned.
     * 
     * @return {Number} The next available integer.
     */
    this.next = function() {

        // If free'd integers exist, return one of those
        if (pool.length > 0)
            return pool.shift();

        // Otherwise, return a new integer
        return guac_pool.next_int++;

    };

    /**
     * Frees the given integer, allowing it to be reused.
     * 
     * @param {Number} integer The integer to free.
     */
    this.free = function(integer) {
        pool.push(integer);
    };

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, assembling all
 * received blobs into a JavaScript object by appending them to each other, in
 * order, and decoding the result as JSON. Note that this object will overwrite
 * any installed event handlers on the given Guacamole.InputStream.
 * 
 * @constructor
 * @param {Guacamole.InputStream} stream
 *     The stream that JSON will be read from.
 */
Guacamole.JSONReader = function guacamoleJSONReader(stream) {

    /**
     * Reference to this Guacamole.JSONReader.
     *
     * @private
     * @type {Guacamole.JSONReader}
     */
    var guacReader = this;

    /**
     * Wrapped Guacamole.StringReader.
     *
     * @private
     * @type {Guacamole.StringReader}
     */
    var stringReader = new Guacamole.StringReader(stream);

    /**
     * All JSON read thus far.
     *
     * @private
     * @type {String}
     */
    var json = '';

    /**
     * Returns the current length of this Guacamole.JSONReader, in characters.
     *
     * @return {Number}
     *     The current length of this Guacamole.JSONReader.
     */
    this.getLength = function getLength() {
        return json.length;
    };

    /**
     * Returns the contents of this Guacamole.JSONReader as a JavaScript
     * object.
     *
     * @return {Object}
     *     The contents of this Guacamole.JSONReader, as parsed from the JSON
     *     contents of the input stream.
     */
    this.getJSON = function getJSON() {
        return JSON.parse(json);
    };

    // Append all received text
    stringReader.ontext = function ontext(text) {

        // Append received text
        json += text;

        // Call handler, if present
        if (guacReader.onprogress)
            guacReader.onprogress(text.length);

    };

    // Simply call onend when end received
    stringReader.onend = function onend() {
        if (guacReader.onend)
            guacReader.onend();
    };

    /**
     * Fired once for every blob of data received.
     * 
     * @event
     * @param {Number} length
     *     The number of characters received.
     */
    this.onprogress = null;

    /**
     * Fired once this stream is finished and no further data will be written.
     *
     * @event
     */
    this.onend = null;

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Provides cross-browser and cross-keyboard keyboard for a specific element.
 * Browser and keyboard layout variation is abstracted away, providing events
 * which represent keys as their corresponding X11 keysym.
 * 
 * @constructor
 * @param {Element|Document} [element]
 *    The Element to use to provide keyboard events. If omitted, at least one
 *    Element must be manually provided through the listenTo() function for
 *    the Guacamole.Keyboard instance to have any effect.
 */
Guacamole.Keyboard = function Keyboard(element) {

    /**
     * Reference to this Guacamole.Keyboard.
     * @private
     */
    var guac_keyboard = this;

    /**
     * An integer value which uniquely identifies this Guacamole.Keyboard
     * instance with respect to other Guacamole.Keyboard instances.
     *
     * @private
     * @type {Number}
     */
    var guacKeyboardID = Guacamole.Keyboard._nextID++;

    /**
     * The name of the property which is added to event objects via markEvent()
     * to note that they have already been handled by this Guacamole.Keyboard.
     *
     * @private
     * @constant
     * @type {String}
     */
    var EVENT_MARKER = '_GUAC_KEYBOARD_HANDLED_BY_' + guacKeyboardID;

    /**
     * Fired whenever the user presses a key with the element associated
     * with this Guacamole.Keyboard in focus.
     * 
     * @event
     * @param {Number} keysym The keysym of the key being pressed.
     * @return {Boolean} true if the key event should be allowed through to the
     *                   browser, false otherwise.
     */
    this.onkeydown = null;

    /**
     * Fired whenever the user releases a key with the element associated
     * with this Guacamole.Keyboard in focus.
     * 
     * @event
     * @param {Number} keysym The keysym of the key being released.
     */
    this.onkeyup = null;

    /**
     * Set of known platform-specific or browser-specific quirks which must be
     * accounted for to properly interpret key events, even if the only way to
     * reliably detect that quirk is to platform/browser-sniff.
     *
     * @private
     * @type {Object.<String, Boolean>}
     */
    var quirks = {

        /**
         * Whether keyup events are universally unreliable.
         *
         * @type {Boolean}
         */
        keyupUnreliable: false,

        /**
         * Whether the Alt key is actually a modifier for typable keys and is
         * thus never used for keyboard shortcuts.
         *
         * @type {Boolean}
         */
        altIsTypableOnly: false,

        /**
         * Whether we can rely on receiving a keyup event for the Caps Lock
         * key.
         *
         * @type {Boolean}
         */
        capsLockKeyupUnreliable: false

    };

    // Set quirk flags depending on platform/browser, if such information is
    // available
    if (navigator && navigator.platform) {

        // All keyup events are unreliable on iOS (sadly)
        if (navigator.platform.match(/ipad|iphone|ipod/i))
            quirks.keyupUnreliable = true;

        // The Alt key on Mac is never used for keyboard shortcuts, and the
        // Caps Lock key never dispatches keyup events
        else if (navigator.platform.match(/^mac/i)) {
            quirks.altIsTypableOnly = true;
            quirks.capsLockKeyupUnreliable = true;
        }

    }

    /**
     * A key event having a corresponding timestamp. This event is non-specific.
     * Its subclasses should be used instead when recording specific key
     * events.
     *
     * @private
     * @constructor
     */
    var KeyEvent = function() {

        /**
         * Reference to this key event.
         */
        var key_event = this;

        /**
         * An arbitrary timestamp in milliseconds, indicating this event's
         * position in time relative to other events.
         *
         * @type {Number}
         */
        this.timestamp = new Date().getTime();

        /**
         * Whether the default action of this key event should be prevented.
         *
         * @type {Boolean}
         */
        this.defaultPrevented = false;

        /**
         * The keysym of the key associated with this key event, as determined
         * by a best-effort guess using available event properties and keyboard
         * state.
         *
         * @type {Number}
         */
        this.keysym = null;

        /**
         * Whether the keysym value of this key event is known to be reliable.
         * If false, the keysym may still be valid, but it's only a best guess,
         * and future key events may be a better source of information.
         *
         * @type {Boolean}
         */
        this.reliable = false;

        /**
         * Returns the number of milliseconds elapsed since this event was
         * received.
         *
         * @return {Number} The number of milliseconds elapsed since this
         *                  event was received.
         */
        this.getAge = function() {
            return new Date().getTime() - key_event.timestamp;
        };

    };

    /**
     * Information related to the pressing of a key, which need not be a key
     * associated with a printable character. The presence or absence of any
     * information within this object is browser-dependent.
     *
     * @private
     * @constructor
     * @augments Guacamole.Keyboard.KeyEvent
     * @param {Number} keyCode The JavaScript key code of the key pressed.
     * @param {String} keyIdentifier The legacy DOM3 "keyIdentifier" of the key
     *                               pressed, as defined at:
     *                               http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
     * @param {String} key The standard name of the key pressed, as defined at:
     *                     http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     * @param {Number} location The location on the keyboard corresponding to
     *                          the key pressed, as defined at:
     *                          http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     */
    var KeydownEvent = function(keyCode, keyIdentifier, key, location) {

        // We extend KeyEvent
        KeyEvent.apply(this);

        /**
         * The JavaScript key code of the key pressed.
         *
         * @type {Number}
         */
        this.keyCode = keyCode;

        /**
         * The legacy DOM3 "keyIdentifier" of the key pressed, as defined at:
         * http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
         *
         * @type {String}
         */
        this.keyIdentifier = keyIdentifier;

        /**
         * The standard name of the key pressed, as defined at:
         * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
         * 
         * @type {String}
         */
        this.key = key;

        /**
         * The location on the keyboard corresponding to the key pressed, as
         * defined at:
         * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
         * 
         * @type {Number}
         */
        this.location = location;

        // If key is known from keyCode or DOM3 alone, use that
        this.keysym =  keysym_from_key_identifier(key, location)
                    || keysym_from_keycode(keyCode, location);

        /**
         * Whether the keyup following this keydown event is known to be
         * reliable. If false, we cannot rely on the keyup event to occur.
         *
         * @type {Boolean}
         */
        this.keyupReliable = !quirks.keyupUnreliable;

        // DOM3 and keyCode are reliable sources if the corresponding key is
        // not a printable key
        if (this.keysym && !isPrintable(this.keysym))
            this.reliable = true;

        // Use legacy keyIdentifier as a last resort, if it looks sane
        if (!this.keysym && key_identifier_sane(keyCode, keyIdentifier))
            this.keysym = keysym_from_key_identifier(keyIdentifier, location, guac_keyboard.modifiers.shift);

        // If a key is pressed while meta is held down, the keyup will
        // never be sent in Chrome (bug #108404)
        if (guac_keyboard.modifiers.meta && this.keysym !== 0xFFE7 && this.keysym !== 0xFFE8)
            this.keyupReliable = false;

        // We cannot rely on receiving keyup for Caps Lock on certain platforms
        else if (this.keysym === 0xFFE5 && quirks.capsLockKeyupUnreliable)
            this.keyupReliable = false;

        // Determine whether default action for Alt+combinations must be prevented
        var prevent_alt = !guac_keyboard.modifiers.ctrl && !quirks.altIsTypableOnly;

        // Determine whether default action for Ctrl+combinations must be prevented
        var prevent_ctrl = !guac_keyboard.modifiers.alt;

        // We must rely on the (potentially buggy) keyIdentifier if preventing
        // the default action is important
        if ((prevent_ctrl && guac_keyboard.modifiers.ctrl)
         || (prevent_alt  && guac_keyboard.modifiers.alt)
         || guac_keyboard.modifiers.meta
         || guac_keyboard.modifiers.hyper)
            this.reliable = true;

        // Record most recently known keysym by associated key code
        recentKeysym[keyCode] = this.keysym;

    };

    KeydownEvent.prototype = new KeyEvent();

    /**
     * Information related to the pressing of a key, which MUST be
     * associated with a printable character. The presence or absence of any
     * information within this object is browser-dependent.
     *
     * @private
     * @constructor
     * @augments Guacamole.Keyboard.KeyEvent
     * @param {Number} charCode The Unicode codepoint of the character that
     *                          would be typed by the key pressed.
     */
    var KeypressEvent = function(charCode) {

        // We extend KeyEvent
        KeyEvent.apply(this);

        /**
         * The Unicode codepoint of the character that would be typed by the
         * key pressed.
         *
         * @type {Number}
         */
        this.charCode = charCode;

        // Pull keysym from char code
        this.keysym = keysym_from_charcode(charCode);

        // Keypress is always reliable
        this.reliable = true;

    };

    KeypressEvent.prototype = new KeyEvent();

    /**
     * Information related to the pressing of a key, which need not be a key
     * associated with a printable character. The presence or absence of any
     * information within this object is browser-dependent.
     *
     * @private
     * @constructor
     * @augments Guacamole.Keyboard.KeyEvent
     * @param {Number} keyCode The JavaScript key code of the key released.
     * @param {String} keyIdentifier The legacy DOM3 "keyIdentifier" of the key
     *                               released, as defined at:
     *                               http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
     * @param {String} key The standard name of the key released, as defined at:
     *                     http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     * @param {Number} location The location on the keyboard corresponding to
     *                          the key released, as defined at:
     *                          http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     */
    var KeyupEvent = function(keyCode, keyIdentifier, key, location) {

        // We extend KeyEvent
        KeyEvent.apply(this);

        /**
         * The JavaScript key code of the key released.
         *
         * @type {Number}
         */
        this.keyCode = keyCode;

        /**
         * The legacy DOM3 "keyIdentifier" of the key released, as defined at:
         * http://www.w3.org/TR/2009/WD-DOM-Level-3-Events-20090908/#events-Events-KeyboardEvent
         *
         * @type {String}
         */
        this.keyIdentifier = keyIdentifier;

        /**
         * The standard name of the key released, as defined at:
         * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
         * 
         * @type {String}
         */
        this.key = key;

        /**
         * The location on the keyboard corresponding to the key released, as
         * defined at:
         * http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
         * 
         * @type {Number}
         */
        this.location = location;

        // If key is known from keyCode or DOM3 alone, use that
        this.keysym =  keysym_from_keycode(keyCode, location)
                    || keysym_from_key_identifier(key, location); // keyCode is still more reliable for keyup when dead keys are in use

        // Fall back to the most recently pressed keysym associated with the
        // keyCode if the inferred key doesn't seem to actually be pressed
        if (!guac_keyboard.pressed[this.keysym])
            this.keysym = recentKeysym[keyCode] || this.keysym;

        // Keyup is as reliable as it will ever be
        this.reliable = true;

    };

    KeyupEvent.prototype = new KeyEvent();

    /**
     * An array of recorded events, which can be instances of the private
     * KeydownEvent, KeypressEvent, and KeyupEvent classes.
     *
     * @private
     * @type {KeyEvent[]}
     */
    var eventLog = [];

    /**
     * Map of known JavaScript keycodes which do not map to typable characters
     * to their X11 keysym equivalents.
     * @private
     */
    var keycodeKeysyms = {
        8:   [0xFF08], // backspace
        9:   [0xFF09], // tab
        12:  [0xFF0B, 0xFF0B, 0xFF0B, 0xFFB5], // clear       / KP 5
        13:  [0xFF0D], // enter
        16:  [0xFFE1, 0xFFE1, 0xFFE2], // shift
        17:  [0xFFE3, 0xFFE3, 0xFFE4], // ctrl
        18:  [0xFFE9, 0xFFE9, 0xFE03], // alt
        19:  [0xFF13], // pause/break
        20:  [0xFFE5], // caps lock
        27:  [0xFF1B], // escape
        32:  [0x0020], // space
        33:  [0xFF55, 0xFF55, 0xFF55, 0xFFB9], // page up     / KP 9
        34:  [0xFF56, 0xFF56, 0xFF56, 0xFFB3], // page down   / KP 3
        35:  [0xFF57, 0xFF57, 0xFF57, 0xFFB1], // end         / KP 1
        36:  [0xFF50, 0xFF50, 0xFF50, 0xFFB7], // home        / KP 7
        37:  [0xFF51, 0xFF51, 0xFF51, 0xFFB4], // left arrow  / KP 4
        38:  [0xFF52, 0xFF52, 0xFF52, 0xFFB8], // up arrow    / KP 8
        39:  [0xFF53, 0xFF53, 0xFF53, 0xFFB6], // right arrow / KP 6
        40:  [0xFF54, 0xFF54, 0xFF54, 0xFFB2], // down arrow  / KP 2
        45:  [0xFF63, 0xFF63, 0xFF63, 0xFFB0], // insert      / KP 0
        46:  [0xFFFF, 0xFFFF, 0xFFFF, 0xFFAE], // delete      / KP decimal
        91:  [0xFFEB], // left window key (hyper_l)
        92:  [0xFF67], // right window key (menu key?)
        93:  null,     // select key
        96:  [0xFFB0], // KP 0
        97:  [0xFFB1], // KP 1
        98:  [0xFFB2], // KP 2
        99:  [0xFFB3], // KP 3
        100: [0xFFB4], // KP 4
        101: [0xFFB5], // KP 5
        102: [0xFFB6], // KP 6
        103: [0xFFB7], // KP 7
        104: [0xFFB8], // KP 8
        105: [0xFFB9], // KP 9
        106: [0xFFAA], // KP multiply
        107: [0xFFAB], // KP add
        109: [0xFFAD], // KP subtract
        110: [0xFFAE], // KP decimal
        111: [0xFFAF], // KP divide
        112: [0xFFBE], // f1
        113: [0xFFBF], // f2
        114: [0xFFC0], // f3
        115: [0xFFC1], // f4
        116: [0xFFC2], // f5
        117: [0xFFC3], // f6
        118: [0xFFC4], // f7
        119: [0xFFC5], // f8
        120: [0xFFC6], // f9
        121: [0xFFC7], // f10
        122: [0xFFC8], // f11
        123: [0xFFC9], // f12
        144: [0xFF7F], // num lock
        145: [0xFF14], // scroll lock
        225: [0xFE03]  // altgraph (iso_level3_shift)
    };

    /**
     * Map of known JavaScript keyidentifiers which do not map to typable
     * characters to their unshifted X11 keysym equivalents.
     * @private
     */
    var keyidentifier_keysym = {
        "Again": [0xFF66],
        "AllCandidates": [0xFF3D],
        "Alphanumeric": [0xFF30],
        "Alt": [0xFFE9, 0xFFE9, 0xFE03],
        "Attn": [0xFD0E],
        "AltGraph": [0xFE03],
        "ArrowDown": [0xFF54],
        "ArrowLeft": [0xFF51],
        "ArrowRight": [0xFF53],
        "ArrowUp": [0xFF52],
        "Backspace": [0xFF08],
        "CapsLock": [0xFFE5],
        "Cancel": [0xFF69],
        "Clear": [0xFF0B],
        "Convert": [0xFF21],
        "Copy": [0xFD15],
        "Crsel": [0xFD1C],
        "CrSel": [0xFD1C],
        "CodeInput": [0xFF37],
        "Compose": [0xFF20],
        "Control": [0xFFE3, 0xFFE3, 0xFFE4],
        "ContextMenu": [0xFF67],
        "Delete": [0xFFFF],
        "Down": [0xFF54],
        "End": [0xFF57],
        "Enter": [0xFF0D],
        "EraseEof": [0xFD06],
        "Escape": [0xFF1B],
        "Execute": [0xFF62],
        "Exsel": [0xFD1D],
        "ExSel": [0xFD1D],
        "F1": [0xFFBE],
        "F2": [0xFFBF],
        "F3": [0xFFC0],
        "F4": [0xFFC1],
        "F5": [0xFFC2],
        "F6": [0xFFC3],
        "F7": [0xFFC4],
        "F8": [0xFFC5],
        "F9": [0xFFC6],
        "F10": [0xFFC7],
        "F11": [0xFFC8],
        "F12": [0xFFC9],
        "F13": [0xFFCA],
        "F14": [0xFFCB],
        "F15": [0xFFCC],
        "F16": [0xFFCD],
        "F17": [0xFFCE],
        "F18": [0xFFCF],
        "F19": [0xFFD0],
        "F20": [0xFFD1],
        "F21": [0xFFD2],
        "F22": [0xFFD3],
        "F23": [0xFFD4],
        "F24": [0xFFD5],
        "Find": [0xFF68],
        "GroupFirst": [0xFE0C],
        "GroupLast": [0xFE0E],
        "GroupNext": [0xFE08],
        "GroupPrevious": [0xFE0A],
        "FullWidth": null,
        "HalfWidth": null,
        "HangulMode": [0xFF31],
        "Hankaku": [0xFF29],
        "HanjaMode": [0xFF34],
        "Help": [0xFF6A],
        "Hiragana": [0xFF25],
        "HiraganaKatakana": [0xFF27],
        "Home": [0xFF50],
        "Hyper": [0xFFED, 0xFFED, 0xFFEE],
        "Insert": [0xFF63],
        "JapaneseHiragana": [0xFF25],
        "JapaneseKatakana": [0xFF26],
        "JapaneseRomaji": [0xFF24],
        "JunjaMode": [0xFF38],
        "KanaMode": [0xFF2D],
        "KanjiMode": [0xFF21],
        "Katakana": [0xFF26],
        "Left": [0xFF51],
        "Meta": [0xFFE7, 0xFFE7, 0xFFE8],
        "ModeChange": [0xFF7E],
        "NumLock": [0xFF7F],
        "PageDown": [0xFF56],
        "PageUp": [0xFF55],
        "Pause": [0xFF13],
        "Play": [0xFD16],
        "PreviousCandidate": [0xFF3E],
        "PrintScreen": [0xFF61],
        "Redo": [0xFF66],
        "Right": [0xFF53],
        "RomanCharacters": null,
        "Scroll": [0xFF14],
        "Select": [0xFF60],
        "Separator": [0xFFAC],
        "Shift": [0xFFE1, 0xFFE1, 0xFFE2],
        "SingleCandidate": [0xFF3C],
        "Super": [0xFFEB, 0xFFEB, 0xFFEC],
        "Tab": [0xFF09],
        "UIKeyInputDownArrow": [0xFF54],
        "UIKeyInputEscape": [0xFF1B],
        "UIKeyInputLeftArrow": [0xFF51],
        "UIKeyInputRightArrow": [0xFF53],
        "UIKeyInputUpArrow": [0xFF52],
        "Up": [0xFF52],
        "Undo": [0xFF65],
        "Win": [0xFFEB],
        "Zenkaku": [0xFF28],
        "ZenkakuHankaku": [0xFF2A]
    };

    /**
     * All keysyms which should not repeat when held down.
     * @private
     */
    var no_repeat = {
        0xFE03: true, // ISO Level 3 Shift (AltGr)
        0xFFE1: true, // Left shift
        0xFFE2: true, // Right shift
        0xFFE3: true, // Left ctrl 
        0xFFE4: true, // Right ctrl 
        0xFFE5: true, // Caps Lock
        0xFFE7: true, // Left meta 
        0xFFE8: true, // Right meta 
        0xFFE9: true, // Left alt
        0xFFEA: true, // Right alt
        0xFFEB: true, // Left hyper
        0xFFEC: true  // Right hyper
    };

    /**
     * All modifiers and their states.
     */
    this.modifiers = new Guacamole.Keyboard.ModifierState();
        
    /**
     * The state of every key, indexed by keysym. If a particular key is
     * pressed, the value of pressed for that keysym will be true. If a key
     * is not currently pressed, it will not be defined. 
     */
    this.pressed = {};

    /**
     * The state of every key, indexed by keysym, for strictly those keys whose
     * status has been indirectly determined thorugh observation of other key
     * events. If a particular key is implicitly pressed, the value of
     * implicitlyPressed for that keysym will be true. If a key
     * is not currently implicitly pressed (the key is not pressed OR the state
     * of the key is explicitly known), it will not be defined.
     *
     * @private
     * @tyle {Object.<Number, Boolean>}
     */
    var implicitlyPressed = {};

    /**
     * The last result of calling the onkeydown handler for each key, indexed
     * by keysym. This is used to prevent/allow default actions for key events,
     * even when the onkeydown handler cannot be called again because the key
     * is (theoretically) still pressed.
     *
     * @private
     */
    var last_keydown_result = {};

    /**
     * The keysym most recently associated with a given keycode when keydown
     * fired. This object maps keycodes to keysyms.
     *
     * @private
     * @type {Object.<Number, Number>}
     */
    var recentKeysym = {};

    /**
     * Timeout before key repeat starts.
     * @private
     */
    var key_repeat_timeout = null;

    /**
     * Interval which presses and releases the last key pressed while that
     * key is still being held down.
     * @private
     */
    var key_repeat_interval = null;

    /**
     * Given an array of keysyms indexed by location, returns the keysym
     * for the given location, or the keysym for the standard location if
     * undefined.
     * 
     * @private
     * @param {Number[]} keysyms
     *     An array of keysyms, where the index of the keysym in the array is
     *     the location value.
     *
     * @param {Number} location
     *     The location on the keyboard corresponding to the key pressed, as
     *     defined at: http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     */
    var get_keysym = function get_keysym(keysyms, location) {

        if (!keysyms)
            return null;

        return keysyms[location] || keysyms[0];
    };

    /**
     * Returns true if the given keysym corresponds to a printable character,
     * false otherwise.
     *
     * @param {Number} keysym
     *     The keysym to check.
     *
     * @returns {Boolean}
     *     true if the given keysym corresponds to a printable character,
     *     false otherwise.
     */
    var isPrintable = function isPrintable(keysym) {

        // Keysyms with Unicode equivalents are printable
        return (keysym >= 0x00 && keysym <= 0xFF)
            || (keysym & 0xFFFF0000) === 0x01000000;

    };

    function keysym_from_key_identifier(identifier, location, shifted) {

        if (!identifier)
            return null;

        var typedCharacter;

        // If identifier is U+xxxx, decode Unicode character 
        var unicodePrefixLocation = identifier.indexOf("U+");
        if (unicodePrefixLocation >= 0) {
            var hex = identifier.substring(unicodePrefixLocation+2);
            typedCharacter = String.fromCharCode(parseInt(hex, 16));
        }

        // If single character and not keypad, use that as typed character
        else if (identifier.length === 1 && location !== 3)
            typedCharacter = identifier;

        // Otherwise, look up corresponding keysym
        else
            return get_keysym(keyidentifier_keysym[identifier], location);

        // Alter case if necessary
        if (shifted === true)
            typedCharacter = typedCharacter.toUpperCase();
        else if (shifted === false)
            typedCharacter = typedCharacter.toLowerCase();

        // Get codepoint
        var codepoint = typedCharacter.charCodeAt(0);
        return keysym_from_charcode(codepoint);

    }

    function isControlCharacter(codepoint) {
        return codepoint <= 0x1F || (codepoint >= 0x7F && codepoint <= 0x9F);
    }

    function keysym_from_charcode(codepoint) {

        // Keysyms for control characters
        if (isControlCharacter(codepoint)) return 0xFF00 | codepoint;

        // Keysyms for ASCII chars
        if (codepoint >= 0x0000 && codepoint <= 0x00FF)
            return codepoint;

        // Keysyms for Unicode
        if (codepoint >= 0x0100 && codepoint <= 0x10FFFF)
            return 0x01000000 | codepoint;

        return null;

    }

    function keysym_from_keycode(keyCode, location) {
        return get_keysym(keycodeKeysyms[keyCode], location);
    }

    /**
     * Heuristically detects if the legacy keyIdentifier property of
     * a keydown/keyup event looks incorrectly derived. Chrome, and
     * presumably others, will produce the keyIdentifier by assuming
     * the keyCode is the Unicode codepoint for that key. This is not
     * correct in all cases.
     *
     * @private
     * @param {Number} keyCode
     *     The keyCode from a browser keydown/keyup event.
     *
     * @param {String} keyIdentifier
     *     The legacy keyIdentifier from a browser keydown/keyup event.
     *
     * @returns {Boolean}
     *     true if the keyIdentifier looks sane, false if the keyIdentifier
     *     appears incorrectly derived or is missing entirely.
     */
    var key_identifier_sane = function key_identifier_sane(keyCode, keyIdentifier) {

        // Missing identifier is not sane
        if (!keyIdentifier)
            return false;

        // Assume non-Unicode keyIdentifier values are sane
        var unicodePrefixLocation = keyIdentifier.indexOf("U+");
        if (unicodePrefixLocation === -1)
            return true;

        // If the Unicode codepoint isn't identical to the keyCode,
        // then the identifier is likely correct
        var codepoint = parseInt(keyIdentifier.substring(unicodePrefixLocation+2), 16);
        if (keyCode !== codepoint)
            return true;

        // The keyCodes for A-Z and 0-9 are actually identical to their
        // Unicode codepoints
        if ((keyCode >= 65 && keyCode <= 90) || (keyCode >= 48 && keyCode <= 57))
            return true;

        // The keyIdentifier does NOT appear sane
        return false;

    };

    /**
     * Marks a key as pressed, firing the keydown event if registered. Key
     * repeat for the pressed key will start after a delay if that key is
     * not a modifier. The return value of this function depends on the
     * return value of the keydown event handler, if any.
     * 
     * @param {Number} keysym The keysym of the key to press.
     * @return {Boolean} true if event should NOT be canceled, false otherwise.
     */
    this.press = function(keysym) {

        // Don't bother with pressing the key if the key is unknown
        if (keysym === null) return;

        // Only press if released
        if (!guac_keyboard.pressed[keysym]) {

            // Mark key as pressed
            guac_keyboard.pressed[keysym] = true;

            // Send key event
            if (guac_keyboard.onkeydown) {
                var result = guac_keyboard.onkeydown(keysym);
                last_keydown_result[keysym] = result;

                // Stop any current repeat
                window.clearTimeout(key_repeat_timeout);
                window.clearInterval(key_repeat_interval);

                // Repeat after a delay as long as pressed
                if (!no_repeat[keysym])
                    key_repeat_timeout = window.setTimeout(function() {
                        key_repeat_interval = window.setInterval(function() {
                            guac_keyboard.onkeyup(keysym);
                            guac_keyboard.onkeydown(keysym);
                        }, 50);
                    }, 500);

                return result;
            }
        }

        // Return the last keydown result by default, resort to false if unknown
        return last_keydown_result[keysym] || false;

    };

    /**
     * Marks a key as released, firing the keyup event if registered.
     * 
     * @param {Number} keysym The keysym of the key to release.
     */
    this.release = function(keysym) {

        // Only release if pressed
        if (guac_keyboard.pressed[keysym]) {
            
            // Mark key as released
            delete guac_keyboard.pressed[keysym];
            delete implicitlyPressed[keysym];

            // Stop repeat
            window.clearTimeout(key_repeat_timeout);
            window.clearInterval(key_repeat_interval);

            // Send key event
            if (keysym !== null && guac_keyboard.onkeyup)
                guac_keyboard.onkeyup(keysym);

        }

    };

    /**
     * Presses and releases the keys necessary to type the given string of
     * text.
     *
     * @param {String} str
     *     The string to type.
     */
    this.type = function type(str) {

        // Press/release the key corresponding to each character in the string
        for (var i = 0; i < str.length; i++) {

            // Determine keysym of current character
            var codepoint = str.codePointAt ? str.codePointAt(i) : str.charCodeAt(i);
            var keysym = keysym_from_charcode(codepoint);

            // Press and release key for current character
            guac_keyboard.press(keysym);
            guac_keyboard.release(keysym);

        }

    };

    /**
     * Resets the state of this keyboard, releasing all keys, and firing keyup
     * events for each released key.
     */
    this.reset = function() {

        // Release all pressed keys
        for (var keysym in guac_keyboard.pressed)
            guac_keyboard.release(parseInt(keysym));

        // Clear event log
        eventLog = [];

    };

    /**
     * Given the remote and local state of a particular key, resynchronizes the
     * remote state of that key with the local state through pressing or
     * releasing keysyms.
     *
     * @private
     * @param {Boolean} remoteState
     *     Whether the key is currently pressed remotely.
     *
     * @param {Boolean} localState
     *     Whether the key is currently pressed remotely locally. If the state
     *     of the key is not known, this may be undefined.
     *
     * @param {Number[]} keysyms
     *     The keysyms which represent the key being updated.
     *
     * @param {KeyEvent} keyEvent
     *     Guacamole's current best interpretation of the key event being
     *     processed.
     */
    var updateModifierState = function updateModifierState(remoteState,
        localState, keysyms, keyEvent) {

        var i;

        // Do not trust changes in modifier state for events directly involving
        // that modifier: (1) the flag may erroneously be cleared despite
        // another version of the same key still being held and (2) the change
        // in flag may be due to the current event being processed, thus
        // updating things here is at best redundant and at worst incorrect
        if (keysyms.indexOf(keyEvent.keysym) !== -1)
            return;

        // Release all related keys if modifier is implicitly released
        if (remoteState && localState === false) {
            for (i = 0; i < keysyms.length; i++) {
                guac_keyboard.release(keysyms[i]);
            }
        }

        // Press if modifier is implicitly pressed
        else if (!remoteState && localState) {

            // Verify that modifier flag isn't already pressed or already set
            // due to another version of the same key being held down
            for (i = 0; i < keysyms.length; i++) {
                if (guac_keyboard.pressed[keysyms[i]])
                    return;
            }

            // Mark as implicitly pressed only if there is other information
            // within the key event relating to a different key. Some
            // platforms, such as iOS, will send essentially empty key events
            // for modifier keys, using only the modifier flags to signal the
            // identity of the key.
            var keysym = keysyms[0];
            if (keyEvent.keysym)
                implicitlyPressed[keysym] = true;

            guac_keyboard.press(keysym);

        }

    };

    /**
     * Given a keyboard event, updates the local modifier state and remote
     * key state based on the modifier flags within the event. This function
     * pays no attention to keycodes.
     *
     * @private
     * @param {KeyboardEvent} e
     *     The keyboard event containing the flags to update.
     *
     * @param {KeyEvent} keyEvent
     *     Guacamole's current best interpretation of the key event being
     *     processed.
     */
    var syncModifierStates = function syncModifierStates(e, keyEvent) {

        // Get state
        var state = Guacamole.Keyboard.ModifierState.fromKeyboardEvent(e);

        // Resync state of alt
        updateModifierState(guac_keyboard.modifiers.alt, state.alt, [
            0xFFE9, // Left alt
            0xFFEA, // Right alt
            0xFE03  // AltGr
        ], keyEvent);

        // Resync state of shift
        updateModifierState(guac_keyboard.modifiers.shift, state.shift, [
            0xFFE1, // Left shift
            0xFFE2  // Right shift
        ], keyEvent);

        // Resync state of ctrl
        updateModifierState(guac_keyboard.modifiers.ctrl, state.ctrl, [
            0xFFE3, // Left ctrl
            0xFFE4  // Right ctrl
        ], keyEvent);

        // Resync state of meta
        updateModifierState(guac_keyboard.modifiers.meta, state.meta, [
            0xFFE7, // Left meta
            0xFFE8  // Right meta
        ], keyEvent);

        // Resync state of hyper
        updateModifierState(guac_keyboard.modifiers.hyper, state.hyper, [
            0xFFEB, // Left hyper
            0xFFEC  // Right hyper
        ], keyEvent);

        // Update state
        guac_keyboard.modifiers = state;

    };

    /**
     * Returns whether all currently pressed keys were implicitly pressed. A
     * key is implicitly pressed if its status was inferred indirectly from
     * inspection of other key events.
     *
     * @private
     * @returns {Boolean}
     *     true if all currently pressed keys were implicitly pressed, false
     *     otherwise.
     */
    var isStateImplicit = function isStateImplicit() {

        for (var keysym in guac_keyboard.pressed) {
            if (!implicitlyPressed[keysym])
                return false;
        }

        return true;

    };

    /**
     * Reads through the event log, removing events from the head of the log
     * when the corresponding true key presses are known (or as known as they
     * can be).
     * 
     * @private
     * @return {Boolean} Whether the default action of the latest event should
     *                   be prevented.
     */
    function interpret_events() {

        // Do not prevent default if no event could be interpreted
        var handled_event = interpret_event();
        if (!handled_event)
            return false;

        // Interpret as much as possible
        var last_event;
        do {
            last_event = handled_event;
            handled_event = interpret_event();
        } while (handled_event !== null);

        // Reset keyboard state if we cannot expect to receive any further
        // keyup events
        if (isStateImplicit())
            guac_keyboard.reset();

        return last_event.defaultPrevented;

    }

    /**
     * Releases Ctrl+Alt, if both are currently pressed and the given keysym
     * looks like a key that may require AltGr.
     *
     * @private
     * @param {Number} keysym The key that was just pressed.
     */
    var release_simulated_altgr = function release_simulated_altgr(keysym) {

        // Both Ctrl+Alt must be pressed if simulated AltGr is in use
        if (!guac_keyboard.modifiers.ctrl || !guac_keyboard.modifiers.alt)
            return;

        // Assume [A-Z] never require AltGr
        if (keysym >= 0x0041 && keysym <= 0x005A)
            return;

        // Assume [a-z] never require AltGr
        if (keysym >= 0x0061 && keysym <= 0x007A)
            return;

        // Release Ctrl+Alt if the keysym is printable
        if (keysym <= 0xFF || (keysym & 0xFF000000) === 0x01000000) {
            guac_keyboard.release(0xFFE3); // Left ctrl 
            guac_keyboard.release(0xFFE4); // Right ctrl 
            guac_keyboard.release(0xFFE9); // Left alt
            guac_keyboard.release(0xFFEA); // Right alt
        }

    };

    /**
     * Reads through the event log, interpreting the first event, if possible,
     * and returning that event. If no events can be interpreted, due to a
     * total lack of events or the need for more events, null is returned. Any
     * interpreted events are automatically removed from the log.
     * 
     * @private
     * @return {KeyEvent}
     *     The first key event in the log, if it can be interpreted, or null
     *     otherwise.
     */
    var interpret_event = function interpret_event() {

        // Peek at first event in log
        var first = eventLog[0];
        if (!first)
            return null;

        // Keydown event
        if (first instanceof KeydownEvent) {

            var keysym = null;
            var accepted_events = [];

            // If event itself is reliable, no need to wait for other events
            if (first.reliable) {
                keysym = first.keysym;
                accepted_events = eventLog.splice(0, 1);
            }

            // If keydown is immediately followed by a keypress, use the indicated character
            else if (eventLog[1] instanceof KeypressEvent) {
                keysym = eventLog[1].keysym;
                accepted_events = eventLog.splice(0, 2);
            }

            // If keydown is immediately followed by anything else, then no
            // keypress can possibly occur to clarify this event, and we must
            // handle it now
            else if (eventLog[1]) {
                keysym = first.keysym;
                accepted_events = eventLog.splice(0, 1);
            }

            // Fire a key press if valid events were found
            if (accepted_events.length > 0) {

                if (keysym) {

                    // Fire event
                    release_simulated_altgr(keysym);
                    var defaultPrevented = !guac_keyboard.press(keysym);
                    recentKeysym[first.keyCode] = keysym;

                    // Release the key now if we cannot rely on the associated
                    // keyup event
                    if (!first.keyupReliable)
                        guac_keyboard.release(keysym);

                    // Record whether default was prevented
                    for (var i=0; i<accepted_events.length; i++)
                        accepted_events[i].defaultPrevented = defaultPrevented;

                }

                return first;

            }

        } // end if keydown

        // Keyup event
        else if (first instanceof KeyupEvent && !quirks.keyupUnreliable) {

            // Release specific key if known
            var keysym = first.keysym;
            if (keysym) {
                guac_keyboard.release(keysym);
                delete recentKeysym[first.keyCode];
                first.defaultPrevented = true;
            }

            // Otherwise, fall back to releasing all keys
            else {
                guac_keyboard.reset();
                return first;
            }

            return eventLog.shift();

        } // end if keyup

        // Ignore any other type of event (keypress by itself is invalid, and
        // unreliable keyup events should simply be dumped)
        else
            return eventLog.shift();

        // No event interpreted
        return null;

    };

    /**
     * Returns the keyboard location of the key associated with the given
     * keyboard event. The location differentiates key events which otherwise
     * have the same keycode, such as left shift vs. right shift.
     *
     * @private
     * @param {KeyboardEvent} e
     *     A JavaScript keyboard event, as received through the DOM via a
     *     "keydown", "keyup", or "keypress" handler.
     *
     * @returns {Number}
     *     The location of the key event on the keyboard, as defined at:
     *     http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent
     */
    var getEventLocation = function getEventLocation(e) {

        // Use standard location, if possible
        if ('location' in e)
            return e.location;

        // Failing that, attempt to use deprecated keyLocation
        if ('keyLocation' in e)
            return e.keyLocation;

        // If no location is available, assume left side
        return 0;

    };

    /**
     * Attempts to mark the given Event as having been handled by this
     * Guacamole.Keyboard. If the Event has already been marked as handled,
     * false is returned.
     *
     * @param {Event} e
     *     The Event to mark.
     *
     * @returns {Boolean}
     *     true if the given Event was successfully marked, false if the given
     *     Event was already marked.
     */
    var markEvent = function markEvent(e) {

        // Fail if event is already marked
        if (e[EVENT_MARKER])
            return false;

        // Mark event otherwise
        e[EVENT_MARKER] = true;
        return true;

    };

    /**
     * Attaches event listeners to the given Element, automatically translating
     * received key, input, and composition events into simple keydown/keyup
     * events signalled through this Guacamole.Keyboard's onkeydown and
     * onkeyup handlers.
     *
     * @param {Element|Document} element
     *     The Element to attach event listeners to for the sake of handling
     *     key or input events.
     */
    this.listenTo = function listenTo(element) {

        // When key pressed
        element.addEventListener("keydown", function(e) {

            // Only intercept if handler set
            if (!guac_keyboard.onkeydown) return;

            // Ignore events which have already been handled
            if (!markEvent(e)) return;

            var keyCode;
            if (window.event) keyCode = window.event.keyCode;
            else if (e.which) keyCode = e.which;

            // Fix modifier states
            var keydownEvent = new KeydownEvent(keyCode, e.keyIdentifier, e.key, getEventLocation(e));
            syncModifierStates(e, keydownEvent);

            // Ignore (but do not prevent) the "composition" keycode sent by some
            // browsers when an IME is in use (see: http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html)
            if (keyCode === 229)
                return;

            // Log event
            eventLog.push(keydownEvent);

            // Interpret as many events as possible, prevent default if indicated
            if (interpret_events())
                e.preventDefault();

        }, true);

        // When key pressed
        element.addEventListener("keypress", function(e) {

            // Only intercept if handler set
            if (!guac_keyboard.onkeydown && !guac_keyboard.onkeyup) return;

            // Ignore events which have already been handled
            if (!markEvent(e)) return;

            var charCode;
            if (window.event) charCode = window.event.keyCode;
            else if (e.which) charCode = e.which;

            // Fix modifier states
            var keypressEvent = new KeypressEvent(charCode);
            syncModifierStates(e, keypressEvent);

            // Log event
            eventLog.push(keypressEvent);

            // Interpret as many events as possible, prevent default if indicated
            if (interpret_events())
                e.preventDefault();

        }, true);

        // When key released
        element.addEventListener("keyup", function(e) {

            // Only intercept if handler set
            if (!guac_keyboard.onkeyup) return;

            // Ignore events which have already been handled
            if (!markEvent(e)) return;

            e.preventDefault();

            var keyCode;
            if (window.event) keyCode = window.event.keyCode;
            else if (e.which) keyCode = e.which;

            // Fix modifier states
            var keyupEvent = new KeyupEvent(keyCode, e.keyIdentifier, e.key, getEventLocation(e));
            syncModifierStates(e, keyupEvent);

            // Log event, call for interpretation
            eventLog.push(keyupEvent);
            interpret_events();

        }, true);

        /**
         * Handles the given "input" event, typing the data within the input text.
         * If the event is complete (text is provided), handling of "compositionend"
         * events is suspended, as such events may conflict with input events.
         *
         * @private
         * @param {InputEvent} e
         *     The "input" event to handle.
         */
        var handleInput = function handleInput(e) {

            // Only intercept if handler set
            if (!guac_keyboard.onkeydown && !guac_keyboard.onkeyup) return;

            // Ignore events which have already been handled
            if (!markEvent(e)) return;

            // Type all content written
            if (e.data && !e.isComposing) {
                element.removeEventListener("compositionend", handleComposition, false);
                guac_keyboard.type(e.data);
            }

        };

        /**
         * Handles the given "compositionend" event, typing the data within the
         * composed text. If the event is complete (composed text is provided),
         * handling of "input" events is suspended, as such events may conflict
         * with composition events.
         *
         * @private
         * @param {CompositionEvent} e
         *     The "compositionend" event to handle.
         */
        var handleComposition = function handleComposition(e) {

            // Only intercept if handler set
            if (!guac_keyboard.onkeydown && !guac_keyboard.onkeyup) return;

            // Ignore events which have already been handled
            if (!markEvent(e)) return;

            // Type all content written
            if (e.data) {
                element.removeEventListener("input", handleInput, false);
                guac_keyboard.type(e.data);
            }

        };

        // Automatically type text entered into the wrapped field
        element.addEventListener("input", handleInput, false);
        element.addEventListener("compositionend", handleComposition, false);

    };

    // Listen to given element, if any
    if (element)
        guac_keyboard.listenTo(element);

};

/**
 * The unique numerical identifier to assign to the next Guacamole.Keyboard
 * instance.
 *
 * @private
 * @type {Number}
 */
Guacamole.Keyboard._nextID = 0;

/**
 * The state of all supported keyboard modifiers.
 * @constructor
 */
Guacamole.Keyboard.ModifierState = function() {
    
    /**
     * Whether shift is currently pressed.
     * @type {Boolean}
     */
    this.shift = false;
    
    /**
     * Whether ctrl is currently pressed.
     * @type {Boolean}
     */
    this.ctrl = false;
    
    /**
     * Whether alt is currently pressed.
     * @type {Boolean}
     */
    this.alt = false;
    
    /**
     * Whether meta (apple key) is currently pressed.
     * @type {Boolean}
     */
    this.meta = false;

    /**
     * Whether hyper (windows key) is currently pressed.
     * @type {Boolean}
     */
    this.hyper = false;
    
};

/**
 * Returns the modifier state applicable to the keyboard event given.
 * 
 * @param {KeyboardEvent} e The keyboard event to read.
 * @returns {Guacamole.Keyboard.ModifierState} The current state of keyboard
 *                                             modifiers.
 */
Guacamole.Keyboard.ModifierState.fromKeyboardEvent = function(e) {
    
    var state = new Guacamole.Keyboard.ModifierState();

    // Assign states from old flags
    state.shift = e.shiftKey;
    state.ctrl  = e.ctrlKey;
    state.alt   = e.altKey;
    state.meta  = e.metaKey;

    // Use DOM3 getModifierState() for others
    if (e.getModifierState) {
        state.hyper = e.getModifierState("OS")
                   || e.getModifierState("Super")
                   || e.getModifierState("Hyper")
                   || e.getModifierState("Win");
    }

    return state;
    
};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract ordered drawing surface. Each Layer contains a canvas element and
 * provides simple drawing instructions for drawing to that canvas element,
 * however unlike the canvas element itself, drawing operations on a Layer are
 * guaranteed to run in order, even if such an operation must wait for an image
 * to load before completing.
 * 
 * @constructor
 * 
 * @param {Number} width The width of the Layer, in pixels. The canvas element
 *                       backing this Layer will be given this width.
 *                       
 * @param {Number} height The height of the Layer, in pixels. The canvas element
 *                        backing this Layer will be given this height.
 */
Guacamole.Layer = function(width, height) {

    /**
     * Reference to this Layer.
     * @private
     */
    var layer = this;

    /**
     * The number of pixels the width or height of a layer must change before
     * the underlying canvas is resized. The underlying canvas will be kept at
     * dimensions which are integer multiples of this factor.
     *
     * @private
     * @constant
     * @type Number
     */
    var CANVAS_SIZE_FACTOR = 64;

    /**
     * The canvas element backing this Layer.
     * @private
     */
    var canvas = document.createElement("canvas");

    /**
     * The 2D display context of the canvas element backing this Layer.
     * @private
     */
    var context = canvas.getContext("2d");
    context.save();

    /**
     * Whether the layer has not yet been drawn to. Once any draw operation
     * which affects the underlying canvas is invoked, this flag will be set to
     * false.
     *
     * @private
     * @type Boolean
     */
    var empty = true;

    /**
     * Whether a new path should be started with the next path drawing
     * operations.
     * @private
     */
    var pathClosed = true;

    /**
     * The number of states on the state stack.
     * 
     * Note that there will ALWAYS be one element on the stack, but that
     * element is not exposed. It is only used to reset the layer to its
     * initial state.
     * 
     * @private
     */
    var stackSize = 0;

    /**
     * Map of all Guacamole channel masks to HTML5 canvas composite operation
     * names. Not all channel mask combinations are currently implemented.
     * @private
     */
    var compositeOperation = {
     /* 0x0 NOT IMPLEMENTED */
        0x1: "destination-in",
        0x2: "destination-out",
     /* 0x3 NOT IMPLEMENTED */
        0x4: "source-in",
     /* 0x5 NOT IMPLEMENTED */
        0x6: "source-atop",
     /* 0x7 NOT IMPLEMENTED */
        0x8: "source-out",
        0x9: "destination-atop",
        0xA: "xor",
        0xB: "destination-over",
        0xC: "copy",
     /* 0xD NOT IMPLEMENTED */
        0xE: "source-over",
        0xF: "lighter"
    };

    /**
     * Resizes the canvas element backing this Layer. This function should only
     * be used internally.
     * 
     * @private
     * @param {Number} [newWidth=0]
     *     The new width to assign to this Layer.
     *
     * @param {Number} [newHeight=0]
     *     The new height to assign to this Layer.
     */
    var resize = function resize(newWidth, newHeight) {

        // Default size to zero
        newWidth = newWidth || 0;
        newHeight = newHeight || 0;

        // Calculate new dimensions of internal canvas
        var canvasWidth  = Math.ceil(newWidth  / CANVAS_SIZE_FACTOR) * CANVAS_SIZE_FACTOR;
        var canvasHeight = Math.ceil(newHeight / CANVAS_SIZE_FACTOR) * CANVAS_SIZE_FACTOR;

        // Resize only if canvas dimensions are actually changing
        if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {

            // Copy old data only if relevant and non-empty
            var oldData = null;
            if (!empty && canvas.width !== 0 && canvas.height !== 0) {

                // Create canvas and context for holding old data
                oldData = document.createElement("canvas");
                oldData.width = Math.min(layer.width, newWidth);
                oldData.height = Math.min(layer.height, newHeight);

                var oldDataContext = oldData.getContext("2d");

                // Copy image data from current
                oldDataContext.drawImage(canvas,
                        0, 0, oldData.width, oldData.height,
                        0, 0, oldData.width, oldData.height);

            }

            // Preserve composite operation
            var oldCompositeOperation = context.globalCompositeOperation;

            // Resize canvas
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Redraw old data, if any
            if (oldData)
                context.drawImage(oldData,
                    0, 0, oldData.width, oldData.height,
                    0, 0, oldData.width, oldData.height);

            // Restore composite operation
            context.globalCompositeOperation = oldCompositeOperation;

            // Acknowledge reset of stack (happens on resize of canvas)
            stackSize = 0;
            context.save();

        }

        // If the canvas size is not changing, manually force state reset
        else
            layer.reset();

        // Assign new layer dimensions
        layer.width = newWidth;
        layer.height = newHeight;

    };

    /**
     * Given the X and Y coordinates of the upper-left corner of a rectangle
     * and the rectangle's width and height, resize the backing canvas element
     * as necessary to ensure that the rectangle fits within the canvas
     * element's coordinate space. This function will only make the canvas
     * larger. If the rectangle already fits within the canvas element's
     * coordinate space, the canvas is left unchanged.
     * 
     * @private
     * @param {Number} x The X coordinate of the upper-left corner of the
     *                   rectangle to fit.
     * @param {Number} y The Y coordinate of the upper-left corner of the
     *                   rectangle to fit.
     * @param {Number} w The width of the the rectangle to fit.
     * @param {Number} h The height of the the rectangle to fit.
     */
    function fitRect(x, y, w, h) {
        
        // Calculate bounds
        var opBoundX = w + x;
        var opBoundY = h + y;
        
        // Determine max width
        var resizeWidth;
        if (opBoundX > layer.width)
            resizeWidth = opBoundX;
        else
            resizeWidth = layer.width;

        // Determine max height
        var resizeHeight;
        if (opBoundY > layer.height)
            resizeHeight = opBoundY;
        else
            resizeHeight = layer.height;

        // Resize if necessary
        layer.resize(resizeWidth, resizeHeight);

    }

    /**
     * Set to true if this Layer should resize itself to accomodate the
     * dimensions of any drawing operation, and false (the default) otherwise.
     * 
     * Note that setting this property takes effect immediately, and thus may
     * take effect on operations that were started in the past but have not
     * yet completed. If you wish the setting of this flag to only modify
     * future operations, you will need to make the setting of this flag an
     * operation with sync().
     * 
     * @example
     * // Set autosize to true for all future operations
     * layer.sync(function() {
     *     layer.autosize = true;
     * });
     * 
     * @type {Boolean}
     * @default false
     */
    this.autosize = false;

    /**
     * The current width of this layer.
     * @type {Number}
     */
    this.width = width;

    /**
     * The current height of this layer.
     * @type {Number}
     */
    this.height = height;

    /**
     * Returns the canvas element backing this Layer. Note that the dimensions
     * of the canvas may not exactly match those of the Layer, as resizing a
     * canvas while maintaining its state is an expensive operation.
     *
     * @returns {HTMLCanvasElement}
     *     The canvas element backing this Layer.
     */
    this.getCanvas = function getCanvas() {
        return canvas;
    };

    /**
     * Returns a new canvas element containing the same image as this Layer.
     * Unlike getCanvas(), the canvas element returned is guaranteed to have
     * the exact same dimensions as the Layer.
     *
     * @returns {HTMLCanvasElement}
     *     A new canvas element containing a copy of the image content this
     *     Layer.
     */
    this.toCanvas = function toCanvas() {

        // Create new canvas having same dimensions
        var canvas = document.createElement('canvas');
        canvas.width = layer.width;
        canvas.height = layer.height;

        // Copy image contents to new canvas
        var context = canvas.getContext('2d');
        context.drawImage(layer.getCanvas(), 0, 0);

        return canvas;

    };

    /**
     * Changes the size of this Layer to the given width and height. Resizing
     * is only attempted if the new size provided is actually different from
     * the current size.
     * 
     * @param {Number} newWidth The new width to assign to this Layer.
     * @param {Number} newHeight The new height to assign to this Layer.
     */
    this.resize = function(newWidth, newHeight) {
        if (newWidth !== layer.width || newHeight !== layer.height)
            resize(newWidth, newHeight);
    };

    /**
     * Draws the specified image at the given coordinates. The image specified
     * must already be loaded.
     * 
     * @param {Number} x
     *     The destination X coordinate.
     *
     * @param {Number} y
     *     The destination Y coordinate.
     *
     * @param {CanvasImageSource} image
     *     The image to draw. Note that this is not a URL.
     */
    this.drawImage = function(x, y, image) {
        if (layer.autosize) fitRect(x, y, image.width, image.height);
        context.drawImage(image, x, y);
        empty = false;
    };

    /**
     * Transfer a rectangle of image data from one Layer to this Layer using the
     * specified transfer function.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     * @param {Function} transferFunction The transfer function to use to
     *                                    transfer data from source to
     *                                    destination.
     */
    this.transfer = function(srcLayer, srcx, srcy, srcw, srch, x, y, transferFunction) {

        var srcCanvas = srcLayer.getCanvas();

        // If entire rectangle outside source canvas, stop
        if (srcx >= srcCanvas.width || srcy >= srcCanvas.height) return;

        // Otherwise, clip rectangle to area
        if (srcx + srcw > srcCanvas.width)
            srcw = srcCanvas.width - srcx;

        if (srcy + srch > srcCanvas.height)
            srch = srcCanvas.height - srcy;

        // Stop if nothing to draw.
        if (srcw === 0 || srch === 0) return;

        if (layer.autosize) fitRect(x, y, srcw, srch);

        // Get image data from src and dst
        var src = srcLayer.getCanvas().getContext("2d").getImageData(srcx, srcy, srcw, srch);
        var dst = context.getImageData(x , y, srcw, srch);

        // Apply transfer for each pixel
        for (var i=0; i<srcw*srch*4; i+=4) {

            // Get source pixel environment
            var src_pixel = new Guacamole.Layer.Pixel(
                src.data[i],
                src.data[i+1],
                src.data[i+2],
                src.data[i+3]
            );
                
            // Get destination pixel environment
            var dst_pixel = new Guacamole.Layer.Pixel(
                dst.data[i],
                dst.data[i+1],
                dst.data[i+2],
                dst.data[i+3]
            );

            // Apply transfer function
            transferFunction(src_pixel, dst_pixel);

            // Save pixel data
            dst.data[i  ] = dst_pixel.red;
            dst.data[i+1] = dst_pixel.green;
            dst.data[i+2] = dst_pixel.blue;
            dst.data[i+3] = dst_pixel.alpha;

        }

        // Draw image data
        context.putImageData(dst, x, y);
        empty = false;

    };

    /**
     * Put a rectangle of image data from one Layer to this Layer directly
     * without performing any alpha blending. Simply copy the data.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     */
    this.put = function(srcLayer, srcx, srcy, srcw, srch, x, y) {

        var srcCanvas = srcLayer.getCanvas();

        // If entire rectangle outside source canvas, stop
        if (srcx >= srcCanvas.width || srcy >= srcCanvas.height) return;

        // Otherwise, clip rectangle to area
        if (srcx + srcw > srcCanvas.width)
            srcw = srcCanvas.width - srcx;

        if (srcy + srch > srcCanvas.height)
            srch = srcCanvas.height - srcy;

        // Stop if nothing to draw.
        if (srcw === 0 || srch === 0) return;

        if (layer.autosize) fitRect(x, y, srcw, srch);

        // Get image data from src and dst
        var src = srcLayer.getCanvas().getContext("2d").getImageData(srcx, srcy, srcw, srch);
        context.putImageData(src, x, y);
        empty = false;

    };

    /**
     * Copy a rectangle of image data from one Layer to this Layer. This
     * operation will copy exactly the image data that will be drawn once all
     * operations of the source Layer that were pending at the time this
     * function was called are complete. This operation will not alter the
     * size of the source Layer even if its autosize property is set to true.
     * 
     * @param {Guacamole.Layer} srcLayer The Layer to copy image data from.
     * @param {Number} srcx The X coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcy The Y coordinate of the upper-left corner of the
     *                      rectangle within the source Layer's coordinate
     *                      space to copy data from.
     * @param {Number} srcw The width of the rectangle within the source Layer's
     *                      coordinate space to copy data from.
     * @param {Number} srch The height of the rectangle within the source
     *                      Layer's coordinate space to copy data from.
     * @param {Number} x The destination X coordinate.
     * @param {Number} y The destination Y coordinate.
     */
    this.copy = function(srcLayer, srcx, srcy, srcw, srch, x, y) {

        var srcCanvas = srcLayer.getCanvas();

        // If entire rectangle outside source canvas, stop
        if (srcx >= srcCanvas.width || srcy >= srcCanvas.height) return;

        // Otherwise, clip rectangle to area
        if (srcx + srcw > srcCanvas.width)
            srcw = srcCanvas.width - srcx;

        if (srcy + srch > srcCanvas.height)
            srch = srcCanvas.height - srcy;

        // Stop if nothing to draw.
        if (srcw === 0 || srch === 0) return;

        if (layer.autosize) fitRect(x, y, srcw, srch);
        context.drawImage(srcCanvas, srcx, srcy, srcw, srch, x, y, srcw, srch);
        empty = false;

    };

    /**
     * Starts a new path at the specified point.
     * 
     * @param {Number} x The X coordinate of the point to draw.
     * @param {Number} y The Y coordinate of the point to draw.
     */
    this.moveTo = function(x, y) {
        
        // Start a new path if current path is closed
        if (pathClosed) {
            context.beginPath();
            pathClosed = false;
        }
        
        if (layer.autosize) fitRect(x, y, 0, 0);
        context.moveTo(x, y);

    };

    /**
     * Add the specified line to the current path.
     * 
     * @param {Number} x The X coordinate of the endpoint of the line to draw.
     * @param {Number} y The Y coordinate of the endpoint of the line to draw.
     */
    this.lineTo = function(x, y) {
        
        // Start a new path if current path is closed
        if (pathClosed) {
            context.beginPath();
            pathClosed = false;
        }
        
        if (layer.autosize) fitRect(x, y, 0, 0);
        context.lineTo(x, y);
        
    };

    /**
     * Add the specified arc to the current path.
     * 
     * @param {Number} x The X coordinate of the center of the circle which
     *                   will contain the arc.
     * @param {Number} y The Y coordinate of the center of the circle which
     *                   will contain the arc.
     * @param {Number} radius The radius of the circle.
     * @param {Number} startAngle The starting angle of the arc, in radians.
     * @param {Number} endAngle The ending angle of the arc, in radians.
     * @param {Boolean} negative Whether the arc should be drawn in order of
     *                           decreasing angle.
     */
    this.arc = function(x, y, radius, startAngle, endAngle, negative) {
        
        // Start a new path if current path is closed
        if (pathClosed) {
            context.beginPath();
            pathClosed = false;
        }
        
        if (layer.autosize) fitRect(x, y, 0, 0);
        context.arc(x, y, radius, startAngle, endAngle, negative);
        
    };

    /**
     * Starts a new path at the specified point.
     * 
     * @param {Number} cp1x The X coordinate of the first control point.
     * @param {Number} cp1y The Y coordinate of the first control point.
     * @param {Number} cp2x The X coordinate of the second control point.
     * @param {Number} cp2y The Y coordinate of the second control point.
     * @param {Number} x The X coordinate of the endpoint of the curve.
     * @param {Number} y The Y coordinate of the endpoint of the curve.
     */
    this.curveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
        
        // Start a new path if current path is closed
        if (pathClosed) {
            context.beginPath();
            pathClosed = false;
        }
        
        if (layer.autosize) fitRect(x, y, 0, 0);
        context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        
    };

    /**
     * Closes the current path by connecting the end point with the start
     * point (if any) with a straight line.
     */
    this.close = function() {
        context.closePath();
        pathClosed = true;
    };

    /**
     * Add the specified rectangle to the current path.
     * 
     * @param {Number} x The X coordinate of the upper-left corner of the
     *                   rectangle to draw.
     * @param {Number} y The Y coordinate of the upper-left corner of the
     *                   rectangle to draw.
     * @param {Number} w The width of the rectangle to draw.
     * @param {Number} h The height of the rectangle to draw.
     */
    this.rect = function(x, y, w, h) {
            
        // Start a new path if current path is closed
        if (pathClosed) {
            context.beginPath();
            pathClosed = false;
        }
        
        if (layer.autosize) fitRect(x, y, w, h);
        context.rect(x, y, w, h);
        
    };

    /**
     * Clip all future drawing operations by the current path. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as fillColor()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     */
    this.clip = function() {

        // Set new clipping region
        context.clip();

        // Path now implicitly closed
        pathClosed = true;

    };

    /**
     * Stroke the current path with the specified color. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {String} cap The line cap style. Can be "round", "square",
     *                     or "butt".
     * @param {String} join The line join style. Can be "round", "bevel",
     *                      or "miter".
     * @param {Number} thickness The line thickness in pixels.
     * @param {Number} r The red component of the color to fill.
     * @param {Number} g The green component of the color to fill.
     * @param {Number} b The blue component of the color to fill.
     * @param {Number} a The alpha component of the color to fill.
     */
    this.strokeColor = function(cap, join, thickness, r, g, b, a) {

        // Stroke with color
        context.lineCap = cap;
        context.lineJoin = join;
        context.lineWidth = thickness;
        context.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + a/255.0 + ")";
        context.stroke();
        empty = false;

        // Path now implicitly closed
        pathClosed = true;

    };

    /**
     * Fills the current path with the specified color. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Number} r The red component of the color to fill.
     * @param {Number} g The green component of the color to fill.
     * @param {Number} b The blue component of the color to fill.
     * @param {Number} a The alpha component of the color to fill.
     */
    this.fillColor = function(r, g, b, a) {

        // Fill with color
        context.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a/255.0 + ")";
        context.fill();
        empty = false;

        // Path now implicitly closed
        pathClosed = true;

    };

    /**
     * Stroke the current path with the image within the specified layer. The
     * image data will be tiled infinitely within the stroke. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {String} cap The line cap style. Can be "round", "square",
     *                     or "butt".
     * @param {String} join The line join style. Can be "round", "bevel",
     *                      or "miter".
     * @param {Number} thickness The line thickness in pixels.
     * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
     *                                   within the stroke.
     */
    this.strokeLayer = function(cap, join, thickness, srcLayer) {

        // Stroke with image data
        context.lineCap = cap;
        context.lineJoin = join;
        context.lineWidth = thickness;
        context.strokeStyle = context.createPattern(
            srcLayer.getCanvas(),
            "repeat"
        );
        context.stroke();
        empty = false;

        // Path now implicitly closed
        pathClosed = true;

    };

    /**
     * Fills the current path with the image within the specified layer. The
     * image data will be tiled infinitely within the stroke. The current path
     * is implicitly closed. The current path can continue to be reused
     * for other operations (such as clip()) but a new path will be started
     * once a path drawing operation (path() or rect()) is used.
     * 
     * @param {Guacamole.Layer} srcLayer The layer to use as a repeating pattern
     *                                   within the fill.
     */
    this.fillLayer = function(srcLayer) {

        // Fill with image data 
        context.fillStyle = context.createPattern(
            srcLayer.getCanvas(),
            "repeat"
        );
        context.fill();
        empty = false;

        // Path now implicitly closed
        pathClosed = true;

    };

    /**
     * Push current layer state onto stack.
     */
    this.push = function() {

        // Save current state onto stack
        context.save();
        stackSize++;

    };

    /**
     * Pop layer state off stack.
     */
    this.pop = function() {

        // Restore current state from stack
        if (stackSize > 0) {
            context.restore();
            stackSize--;
        }

    };

    /**
     * Reset the layer, clearing the stack, the current path, and any transform
     * matrix.
     */
    this.reset = function() {

        // Clear stack
        while (stackSize > 0) {
            context.restore();
            stackSize--;
        }

        // Restore to initial state
        context.restore();
        context.save();

        // Clear path
        context.beginPath();
        pathClosed = false;

    };

    /**
     * Sets the given affine transform (defined with six values from the
     * transform's matrix).
     * 
     * @param {Number} a The first value in the affine transform's matrix.
     * @param {Number} b The second value in the affine transform's matrix.
     * @param {Number} c The third value in the affine transform's matrix.
     * @param {Number} d The fourth value in the affine transform's matrix.
     * @param {Number} e The fifth value in the affine transform's matrix.
     * @param {Number} f The sixth value in the affine transform's matrix.
     */
    this.setTransform = function(a, b, c, d, e, f) {
        context.setTransform(
            a, b, c,
            d, e, f
          /*0, 0, 1*/
        );
    };

    /**
     * Applies the given affine transform (defined with six values from the
     * transform's matrix).
     * 
     * @param {Number} a The first value in the affine transform's matrix.
     * @param {Number} b The second value in the affine transform's matrix.
     * @param {Number} c The third value in the affine transform's matrix.
     * @param {Number} d The fourth value in the affine transform's matrix.
     * @param {Number} e The fifth value in the affine transform's matrix.
     * @param {Number} f The sixth value in the affine transform's matrix.
     */
    this.transform = function(a, b, c, d, e, f) {
        context.transform(
            a, b, c,
            d, e, f
          /*0, 0, 1*/
        );
    };

    /**
     * Sets the channel mask for future operations on this Layer.
     * 
     * The channel mask is a Guacamole-specific compositing operation identifier
     * with a single bit representing each of four channels (in order): source
     * image where destination transparent, source where destination opaque,
     * destination where source transparent, and destination where source
     * opaque.
     * 
     * @param {Number} mask The channel mask for future operations on this
     *                      Layer.
     */
    this.setChannelMask = function(mask) {
        context.globalCompositeOperation = compositeOperation[mask];
    };

    /**
     * Sets the miter limit for stroke operations using the miter join. This
     * limit is the maximum ratio of the size of the miter join to the stroke
     * width. If this ratio is exceeded, the miter will not be drawn for that
     * joint of the path.
     * 
     * @param {Number} limit The miter limit for stroke operations using the
     *                       miter join.
     */
    this.setMiterLimit = function(limit) {
        context.miterLimit = limit;
    };

    // Initialize canvas dimensions
    resize(width, height);

    // Explicitly render canvas below other elements in the layer (such as
    // child layers). Chrome and others may fail to render layers properly
    // without this.
    canvas.style.zIndex = -1;

};

/**
 * Channel mask for the composite operation "rout".
 */
Guacamole.Layer.ROUT  = 0x2;

/**
 * Channel mask for the composite operation "atop".
 */
Guacamole.Layer.ATOP  = 0x6;

/**
 * Channel mask for the composite operation "xor".
 */
Guacamole.Layer.XOR   = 0xA;

/**
 * Channel mask for the composite operation "rover".
 */
Guacamole.Layer.ROVER = 0xB;

/**
 * Channel mask for the composite operation "over".
 */
Guacamole.Layer.OVER  = 0xE;

/**
 * Channel mask for the composite operation "plus".
 */
Guacamole.Layer.PLUS  = 0xF;

/**
 * Channel mask for the composite operation "rin".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.RIN   = 0x1;

/**
 * Channel mask for the composite operation "in".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.IN    = 0x4;

/**
 * Channel mask for the composite operation "out".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.OUT   = 0x8;

/**
 * Channel mask for the composite operation "ratop".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.RATOP = 0x9;

/**
 * Channel mask for the composite operation "src".
 * Beware that WebKit-based browsers may leave the contents of the destionation
 * layer where the source layer is transparent, despite the definition of this
 * operation.
 */
Guacamole.Layer.SRC   = 0xC;

/**
 * Represents a single pixel of image data. All components have a minimum value
 * of 0 and a maximum value of 255.
 * 
 * @constructor
 * 
 * @param {Number} r The red component of this pixel.
 * @param {Number} g The green component of this pixel.
 * @param {Number} b The blue component of this pixel.
 * @param {Number} a The alpha component of this pixel.
 */
Guacamole.Layer.Pixel = function(r, g, b, a) {

    /**
     * The red component of this pixel, where 0 is the minimum value,
     * and 255 is the maximum.
     */
    this.red   = r;

    /**
     * The green component of this pixel, where 0 is the minimum value,
     * and 255 is the maximum.
     */
    this.green = g;

    /**
     * The blue component of this pixel, where 0 is the minimum value,
     * and 255 is the maximum.
     */
    this.blue  = b;

    /**
     * The alpha component of this pixel, where 0 is the minimum value,
     * and 255 is the maximum.
     */
    this.alpha = a;

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Provides cross-browser mouse events for a given element. The events of
 * the given element are automatically populated with handlers that translate
 * mouse events into a non-browser-specific event provided by the
 * Guacamole.Mouse instance.
 * 
 * @constructor
 * @param {Element} element The Element to use to provide mouse events.
 */
Guacamole.Mouse = function(element) {

    /**
     * Reference to this Guacamole.Mouse.
     * @private
     */
    var guac_mouse = this;

    /**
     * The number of mousemove events to require before re-enabling mouse
     * event handling after receiving a touch event.
     */
    this.touchMouseThreshold = 3;

    /**
     * The minimum amount of pixels scrolled required for a single scroll button
     * click.
     */
    this.scrollThreshold = 53;

    /**
     * The number of pixels to scroll per line.
     */
    this.PIXELS_PER_LINE = 18;

    /**
     * The number of pixels to scroll per page.
     */
    this.PIXELS_PER_PAGE = this.PIXELS_PER_LINE * 16;

    /**
     * The current mouse state. The properties of this state are updated when
     * mouse events fire. This state object is also passed in as a parameter to
     * the handler of any mouse events.
     * 
     * @type {Guacamole.Mouse.State}
     */
    this.currentState = new Guacamole.Mouse.State(
        0, 0, 
        false, false, false, false, false
    );

    /**
     * Fired whenever the user presses a mouse button down over the element
     * associated with this Guacamole.Mouse.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousedown = null;

    /**
     * Fired whenever the user releases a mouse button down over the element
     * associated with this Guacamole.Mouse.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmouseup = null;

    /**
     * Fired whenever the user moves the mouse over the element associated with
     * this Guacamole.Mouse.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousemove = null;

    /**
     * Fired whenever the mouse leaves the boundaries of the element associated
     * with this Guacamole.Mouse.
     * 
     * @event
     */
	this.onmouseout = null;

    /**
     * Counter of mouse events to ignore. This decremented by mousemove, and
     * while non-zero, mouse events will have no effect.
     * @private
     */
    var ignore_mouse = 0;

    /**
     * Cumulative scroll delta amount. This value is accumulated through scroll
     * events and results in scroll button clicks if it exceeds a certain
     * threshold.
     *
     * @private
     */
    var scroll_delta = 0;

    function cancelEvent(e) {
        e.stopPropagation();
        if (e.preventDefault) e.preventDefault();
        e.returnValue = false;
    }

    // Block context menu so right-click gets sent properly
    element.addEventListener("contextmenu", function(e) {
        cancelEvent(e);
    }, false);

    element.addEventListener("mousemove", function(e) {

        cancelEvent(e);

        // If ignoring events, decrement counter
        if (ignore_mouse) {
            ignore_mouse--;
            return;
        }

        guac_mouse.currentState.fromClientPosition(element, e.clientX, e.clientY);

        if (guac_mouse.onmousemove)
            guac_mouse.onmousemove(guac_mouse.currentState);

    }, false);

    element.addEventListener("mousedown", function(e) {

        cancelEvent(e);

        // Do not handle if ignoring events
        if (ignore_mouse)
            return;

        switch (e.button) {
            case 0:
                guac_mouse.currentState.left = true;
                break;
            case 1:
                guac_mouse.currentState.middle = true;
                break;
            case 2:
                guac_mouse.currentState.right = true;
                break;
        }

        if (guac_mouse.onmousedown)
            guac_mouse.onmousedown(guac_mouse.currentState);

    }, false);

    element.addEventListener("mouseup", function(e) {

        cancelEvent(e);

        // Do not handle if ignoring events
        if (ignore_mouse)
            return;

        switch (e.button) {
            case 0:
                guac_mouse.currentState.left = false;
                break;
            case 1:
                guac_mouse.currentState.middle = false;
                break;
            case 2:
                guac_mouse.currentState.right = false;
                break;
        }

        if (guac_mouse.onmouseup)
            guac_mouse.onmouseup(guac_mouse.currentState);

    }, false);

    element.addEventListener("mouseout", function(e) {

        // Get parent of the element the mouse pointer is leaving
       	if (!e) e = window.event;

        // Check that mouseout is due to actually LEAVING the element
        var target = e.relatedTarget || e.toElement;
        while (target) {
            if (target === element)
                return;
            target = target.parentNode;
        }

        cancelEvent(e);

        // Release all buttons
        if (guac_mouse.currentState.left
            || guac_mouse.currentState.middle
            || guac_mouse.currentState.right) {

            guac_mouse.currentState.left = false;
            guac_mouse.currentState.middle = false;
            guac_mouse.currentState.right = false;

            if (guac_mouse.onmouseup)
                guac_mouse.onmouseup(guac_mouse.currentState);
        }

        // Fire onmouseout event
        if (guac_mouse.onmouseout)
            guac_mouse.onmouseout();

    }, false);

    // Override selection on mouse event element.
    element.addEventListener("selectstart", function(e) {
        cancelEvent(e);
    }, false);

    // Ignore all pending mouse events when touch events are the apparent source
    function ignorePendingMouseEvents() { ignore_mouse = guac_mouse.touchMouseThreshold; }

    element.addEventListener("touchmove",  ignorePendingMouseEvents, false);
    element.addEventListener("touchstart", ignorePendingMouseEvents, false);
    element.addEventListener("touchend",   ignorePendingMouseEvents, false);

    // Scroll wheel support
    function mousewheel_handler(e) {

        // Determine approximate scroll amount (in pixels)
        var delta = e.deltaY || -e.wheelDeltaY || -e.wheelDelta;

        // If successfully retrieved scroll amount, convert to pixels if not
        // already in pixels
        if (delta) {

            // Convert to pixels if delta was lines
            if (e.deltaMode === 1)
                delta = e.deltaY * guac_mouse.PIXELS_PER_LINE;

            // Convert to pixels if delta was pages
            else if (e.deltaMode === 2)
                delta = e.deltaY * guac_mouse.PIXELS_PER_PAGE;

        }

        // Otherwise, assume legacy mousewheel event and line scrolling
        else
            delta = e.detail * guac_mouse.PIXELS_PER_LINE;
        
        // Update overall delta
        scroll_delta += delta;

        // Up
        if (scroll_delta <= -guac_mouse.scrollThreshold) {

            // Repeatedly click the up button until insufficient delta remains
            do {

                if (guac_mouse.onmousedown) {
                    guac_mouse.currentState.up = true;
                    guac_mouse.onmousedown(guac_mouse.currentState);
                }

                if (guac_mouse.onmouseup) {
                    guac_mouse.currentState.up = false;
                    guac_mouse.onmouseup(guac_mouse.currentState);
                }

                scroll_delta += guac_mouse.scrollThreshold;

            } while (scroll_delta <= -guac_mouse.scrollThreshold);

            // Reset delta
            scroll_delta = 0;

        }

        // Down
        if (scroll_delta >= guac_mouse.scrollThreshold) {

            // Repeatedly click the down button until insufficient delta remains
            do {

                if (guac_mouse.onmousedown) {
                    guac_mouse.currentState.down = true;
                    guac_mouse.onmousedown(guac_mouse.currentState);
                }

                if (guac_mouse.onmouseup) {
                    guac_mouse.currentState.down = false;
                    guac_mouse.onmouseup(guac_mouse.currentState);
                }

                scroll_delta -= guac_mouse.scrollThreshold;

            } while (scroll_delta >= guac_mouse.scrollThreshold);

            // Reset delta
            scroll_delta = 0;

        }

        cancelEvent(e);

    }

    element.addEventListener('DOMMouseScroll', mousewheel_handler, false);
    element.addEventListener('mousewheel',     mousewheel_handler, false);
    element.addEventListener('wheel',          mousewheel_handler, false);

    /**
     * Whether the browser supports CSS3 cursor styling, including hotspot
     * coordinates.
     *
     * @private
     * @type {Boolean}
     */
    var CSS3_CURSOR_SUPPORTED = (function() {

        var div = document.createElement("div");

        // If no cursor property at all, then no support
        if (!("cursor" in div.style))
            return false;

        try {
            // Apply simple 1x1 PNG
            div.style.cursor = "url(data:image/png;base64,"
                             + "iVBORw0KGgoAAAANSUhEUgAAAAEAAAAB"
                             + "AQMAAAAl21bKAAAAA1BMVEX///+nxBvI"
                             + "AAAACklEQVQI12NgAAAAAgAB4iG8MwAA"
                             + "AABJRU5ErkJggg==) 0 0, auto";
        }
        catch (e) {
            return false;
        }

        // Verify cursor property is set to URL with hotspot
        return /\burl\([^()]*\)\s+0\s+0\b/.test(div.style.cursor || "");

    })();

    /**
     * Changes the local mouse cursor to the given canvas, having the given
     * hotspot coordinates. This affects styling of the element backing this
     * Guacamole.Mouse only, and may fail depending on browser support for
     * setting the mouse cursor.
     * 
     * If setting the local cursor is desired, it is up to the implementation
     * to do something else, such as use the software cursor built into
     * Guacamole.Display, if the local cursor cannot be set.
     *
     * @param {HTMLCanvasElement} canvas The cursor image.
     * @param {Number} x The X-coordinate of the cursor hotspot.
     * @param {Number} y The Y-coordinate of the cursor hotspot.
     * @return {Boolean} true if the cursor was successfully set, false if the
     *                   cursor could not be set for any reason.
     */
    this.setCursor = function(canvas, x, y) {

        // Attempt to set via CSS3 cursor styling
        if (CSS3_CURSOR_SUPPORTED) {
            var dataURL = canvas.toDataURL('image/png');
            element.style.cursor = "url(" + dataURL + ") " + x + " " + y + ", auto";
            return true;
        }

        // Otherwise, setting cursor failed
        return false;

    };

};

/**
 * Simple container for properties describing the state of a mouse.
 * 
 * @constructor
 * @param {Number} x The X position of the mouse pointer in pixels.
 * @param {Number} y The Y position of the mouse pointer in pixels.
 * @param {Boolean} left Whether the left mouse button is pressed. 
 * @param {Boolean} middle Whether the middle mouse button is pressed. 
 * @param {Boolean} right Whether the right mouse button is pressed. 
 * @param {Boolean} up Whether the up mouse button is pressed (the fourth
 *                     button, usually part of a scroll wheel). 
 * @param {Boolean} down Whether the down mouse button is pressed (the fifth
 *                       button, usually part of a scroll wheel). 
 */
Guacamole.Mouse.State = function(x, y, left, middle, right, up, down) {

    /**
     * Reference to this Guacamole.Mouse.State.
     * @private
     */
    var guac_state = this;

    /**
     * The current X position of the mouse pointer.
     * @type {Number}
     */
    this.x = x;

    /**
     * The current Y position of the mouse pointer.
     * @type {Number}
     */
    this.y = y;

    /**
     * Whether the left mouse button is currently pressed.
     * @type {Boolean}
     */
    this.left = left;

    /**
     * Whether the middle mouse button is currently pressed.
     * @type {Boolean}
     */
    this.middle = middle;

    /**
     * Whether the right mouse button is currently pressed.
     * @type {Boolean}
     */
    this.right = right;

    /**
     * Whether the up mouse button is currently pressed. This is the fourth
     * mouse button, associated with upward scrolling of the mouse scroll
     * wheel.
     * @type {Boolean}
     */
    this.up = up;

    /**
     * Whether the down mouse button is currently pressed. This is the fifth 
     * mouse button, associated with downward scrolling of the mouse scroll
     * wheel.
     * @type {Boolean}
     */
    this.down = down;

    /**
     * Updates the position represented within this state object by the given
     * element and clientX/clientY coordinates (commonly available within event
     * objects). Position is translated from clientX/clientY (relative to
     * viewport) to element-relative coordinates.
     * 
     * @param {Element} element The element the coordinates should be relative
     *                          to.
     * @param {Number} clientX The X coordinate to translate, viewport-relative.
     * @param {Number} clientY The Y coordinate to translate, viewport-relative.
     */
    this.fromClientPosition = function(element, clientX, clientY) {
    
        guac_state.x = clientX - element.offsetLeft;
        guac_state.y = clientY - element.offsetTop;

        // This is all JUST so we can get the mouse position within the element
        var parent = element.offsetParent;
        while (parent && !(parent === document.body)) {
            guac_state.x -= parent.offsetLeft - parent.scrollLeft;
            guac_state.y -= parent.offsetTop  - parent.scrollTop;

            parent = parent.offsetParent;
        }

        // Element ultimately depends on positioning within document body,
        // take document scroll into account. 
        if (parent) {
            var documentScrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;
            var documentScrollTop = document.body.scrollTop || document.documentElement.scrollTop;

            guac_state.x -= parent.offsetLeft - documentScrollLeft;
            guac_state.y -= parent.offsetTop  - documentScrollTop;
        }

    };

};

/**
 * Provides cross-browser relative touch event translation for a given element.
 * 
 * Touch events are translated into mouse events as if the touches occurred
 * on a touchpad (drag to push the mouse pointer, tap to click).
 * 
 * @constructor
 * @param {Element} element The Element to use to provide touch events.
 */
Guacamole.Mouse.Touchpad = function(element) {

    /**
     * Reference to this Guacamole.Mouse.Touchpad.
     * @private
     */
    var guac_touchpad = this;

    /**
     * The distance a two-finger touch must move per scrollwheel event, in
     * pixels.
     */
    this.scrollThreshold = 20 * (window.devicePixelRatio || 1);

    /**
     * The maximum number of milliseconds to wait for a touch to end for the
     * gesture to be considered a click.
     */
    this.clickTimingThreshold = 250;

    /**
     * The maximum number of pixels to allow a touch to move for the gesture to
     * be considered a click.
     */
    this.clickMoveThreshold = 10 * (window.devicePixelRatio || 1);

    /**
     * The current mouse state. The properties of this state are updated when
     * mouse events fire. This state object is also passed in as a parameter to
     * the handler of any mouse events.
     * 
     * @type {Guacamole.Mouse.State}
     */
    this.currentState = new Guacamole.Mouse.State(
        0, 0, 
        false, false, false, false, false
    );

    /**
     * Fired whenever a mouse button is effectively pressed. This can happen
     * as part of a "click" gesture initiated by the user by tapping one
     * or more fingers over the touchpad element, as part of a "scroll"
     * gesture initiated by dragging two fingers up or down, etc.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousedown = null;

    /**
     * Fired whenever a mouse button is effectively released. This can happen
     * as part of a "click" gesture initiated by the user by tapping one
     * or more fingers over the touchpad element, as part of a "scroll"
     * gesture initiated by dragging two fingers up or down, etc.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmouseup = null;

    /**
     * Fired whenever the user moves the mouse by dragging their finger over
     * the touchpad element.
     * 
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousemove = null;

    var touch_count = 0;
    var last_touch_x = 0;
    var last_touch_y = 0;
    var last_touch_time = 0;
    var pixels_moved = 0;

    var touch_buttons = {
        1: "left",
        2: "right",
        3: "middle"
    };

    var gesture_in_progress = false;
    var click_release_timeout = null;

    element.addEventListener("touchend", function(e) {
        
        e.preventDefault();
            
        // If we're handling a gesture AND this is the last touch
        if (gesture_in_progress && e.touches.length === 0) {
            
            var time = new Date().getTime();

            // Get corresponding mouse button
            var button = touch_buttons[touch_count];

            // If mouse already down, release anad clear timeout
            if (guac_touchpad.currentState[button]) {

                // Fire button up event
                guac_touchpad.currentState[button] = false;
                if (guac_touchpad.onmouseup)
                    guac_touchpad.onmouseup(guac_touchpad.currentState);

                // Clear timeout, if set
                if (click_release_timeout) {
                    window.clearTimeout(click_release_timeout);
                    click_release_timeout = null;
                }

            }

            // If single tap detected (based on time and distance)
            if (time - last_touch_time <= guac_touchpad.clickTimingThreshold
                    && pixels_moved < guac_touchpad.clickMoveThreshold) {

                // Fire button down event
                guac_touchpad.currentState[button] = true;
                if (guac_touchpad.onmousedown)
                    guac_touchpad.onmousedown(guac_touchpad.currentState);

                // Delay mouse up - mouse up should be canceled if
                // touchstart within timeout.
                click_release_timeout = window.setTimeout(function() {
                    
                    // Fire button up event
                    guac_touchpad.currentState[button] = false;
                    if (guac_touchpad.onmouseup)
                        guac_touchpad.onmouseup(guac_touchpad.currentState);
                    
                    // Gesture now over
                    gesture_in_progress = false;

                }, guac_touchpad.clickTimingThreshold);

            }

            // If we're not waiting to see if this is a click, stop gesture
            if (!click_release_timeout)
                gesture_in_progress = false;

        }

    }, false);

    element.addEventListener("touchstart", function(e) {

        e.preventDefault();

        // Track number of touches, but no more than three
        touch_count = Math.min(e.touches.length, 3);

        // Clear timeout, if set
        if (click_release_timeout) {
            window.clearTimeout(click_release_timeout);
            click_release_timeout = null;
        }

        // Record initial touch location and time for touch movement
        // and tap gestures
        if (!gesture_in_progress) {

            // Stop mouse events while touching
            gesture_in_progress = true;

            // Record touch location and time
            var starting_touch = e.touches[0];
            last_touch_x = starting_touch.clientX;
            last_touch_y = starting_touch.clientY;
            last_touch_time = new Date().getTime();
            pixels_moved = 0;

        }

    }, false);

    element.addEventListener("touchmove", function(e) {

        e.preventDefault();

        // Get change in touch location
        var touch = e.touches[0];
        var delta_x = touch.clientX - last_touch_x;
        var delta_y = touch.clientY - last_touch_y;

        // Track pixels moved
        pixels_moved += Math.abs(delta_x) + Math.abs(delta_y);

        // If only one touch involved, this is mouse move
        if (touch_count === 1) {

            // Calculate average velocity in Manhatten pixels per millisecond
            var velocity = pixels_moved / (new Date().getTime() - last_touch_time);

            // Scale mouse movement relative to velocity
            var scale = 1 + velocity;

            // Update mouse location
            guac_touchpad.currentState.x += delta_x*scale;
            guac_touchpad.currentState.y += delta_y*scale;

            // Prevent mouse from leaving screen

            if (guac_touchpad.currentState.x < 0)
                guac_touchpad.currentState.x = 0;
            else if (guac_touchpad.currentState.x >= element.offsetWidth)
                guac_touchpad.currentState.x = element.offsetWidth - 1;

            if (guac_touchpad.currentState.y < 0)
                guac_touchpad.currentState.y = 0;
            else if (guac_touchpad.currentState.y >= element.offsetHeight)
                guac_touchpad.currentState.y = element.offsetHeight - 1;

            // Fire movement event, if defined
            if (guac_touchpad.onmousemove)
                guac_touchpad.onmousemove(guac_touchpad.currentState);

            // Update touch location
            last_touch_x = touch.clientX;
            last_touch_y = touch.clientY;

        }

        // Interpret two-finger swipe as scrollwheel
        else if (touch_count === 2) {

            // If change in location passes threshold for scroll
            if (Math.abs(delta_y) >= guac_touchpad.scrollThreshold) {

                // Decide button based on Y movement direction
                var button;
                if (delta_y > 0) button = "down";
                else             button = "up";

                // Fire button down event
                guac_touchpad.currentState[button] = true;
                if (guac_touchpad.onmousedown)
                    guac_touchpad.onmousedown(guac_touchpad.currentState);

                // Fire button up event
                guac_touchpad.currentState[button] = false;
                if (guac_touchpad.onmouseup)
                    guac_touchpad.onmouseup(guac_touchpad.currentState);

                // Only update touch location after a scroll has been
                // detected
                last_touch_x = touch.clientX;
                last_touch_y = touch.clientY;

            }

        }

    }, false);

};

/**
 * Provides cross-browser absolute touch event translation for a given element.
 *
 * Touch events are translated into mouse events as if the touches occurred
 * on a touchscreen (tapping anywhere on the screen clicks at that point,
 * long-press to right-click).
 *
 * @constructor
 * @param {Element} element The Element to use to provide touch events.
 */
Guacamole.Mouse.Touchscreen = function(element) {

    /**
     * Reference to this Guacamole.Mouse.Touchscreen.
     * @private
     */
    var guac_touchscreen = this;

    /**
     * Whether a gesture is known to be in progress. If false, touch events
     * will be ignored.
     *
     * @private
     */
    var gesture_in_progress = false;

    /**
     * The start X location of a gesture.
     * @private
     */
    var gesture_start_x = null;

    /**
     * The start Y location of a gesture.
     * @private
     */
    var gesture_start_y = null;

    /**
     * The timeout associated with the delayed, cancellable click release.
     *
     * @private
     */
    var click_release_timeout = null;

    /**
     * The timeout associated with long-press for right click.
     *
     * @private
     */
    var long_press_timeout = null;

    /**
     * The distance a two-finger touch must move per scrollwheel event, in
     * pixels.
     */
    this.scrollThreshold = 20 * (window.devicePixelRatio || 1);

    /**
     * The maximum number of milliseconds to wait for a touch to end for the
     * gesture to be considered a click.
     */
    this.clickTimingThreshold = 250;

    /**
     * The maximum number of pixels to allow a touch to move for the gesture to
     * be considered a click.
     */
    this.clickMoveThreshold = 16 * (window.devicePixelRatio || 1);

    /**
     * The amount of time a press must be held for long press to be
     * detected.
     */
    this.longPressThreshold = 500;

    /**
     * The current mouse state. The properties of this state are updated when
     * mouse events fire. This state object is also passed in as a parameter to
     * the handler of any mouse events.
     *
     * @type {Guacamole.Mouse.State}
     */
    this.currentState = new Guacamole.Mouse.State(
        0, 0,
        false, false, false, false, false
    );

    /**
     * Fired whenever a mouse button is effectively pressed. This can happen
     * as part of a "mousedown" gesture initiated by the user by pressing one
     * finger over the touchscreen element, as part of a "scroll" gesture
     * initiated by dragging two fingers up or down, etc.
     *
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousedown = null;

    /**
     * Fired whenever a mouse button is effectively released. This can happen
     * as part of a "mouseup" gesture initiated by the user by removing the
     * finger pressed against the touchscreen element, or as part of a "scroll"
     * gesture initiated by dragging two fingers up or down, etc.
     *
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmouseup = null;

    /**
     * Fired whenever the user moves the mouse by dragging their finger over
     * the touchscreen element. Note that unlike Guacamole.Mouse.Touchpad,
     * dragging a finger over the touchscreen element will always cause
     * the mouse button to be effectively down, as if clicking-and-dragging.
     *
     * @event
     * @param {Guacamole.Mouse.State} state The current mouse state.
     */
	this.onmousemove = null;

    /**
     * Presses the given mouse button, if it isn't already pressed. Valid
     * button values are "left", "middle", "right", "up", and "down".
     *
     * @private
     * @param {String} button The mouse button to press.
     */
    function press_button(button) {
        if (!guac_touchscreen.currentState[button]) {
            guac_touchscreen.currentState[button] = true;
            if (guac_touchscreen.onmousedown)
                guac_touchscreen.onmousedown(guac_touchscreen.currentState);
        }
    }

    /**
     * Releases the given mouse button, if it isn't already released. Valid
     * button values are "left", "middle", "right", "up", and "down".
     *
     * @private
     * @param {String} button The mouse button to release.
     */
    function release_button(button) {
        if (guac_touchscreen.currentState[button]) {
            guac_touchscreen.currentState[button] = false;
            if (guac_touchscreen.onmouseup)
                guac_touchscreen.onmouseup(guac_touchscreen.currentState);
        }
    }

    /**
     * Clicks (presses and releases) the given mouse button. Valid button
     * values are "left", "middle", "right", "up", and "down".
     *
     * @private
     * @param {String} button The mouse button to click.
     */
    function click_button(button) {
        press_button(button);
        release_button(button);
    }

    /**
     * Moves the mouse to the given coordinates. These coordinates must be
     * relative to the browser window, as they will be translated based on
     * the touch event target's location within the browser window.
     *
     * @private
     * @param {Number} x The X coordinate of the mouse pointer.
     * @param {Number} y The Y coordinate of the mouse pointer.
     */
    function move_mouse(x, y) {
        guac_touchscreen.currentState.fromClientPosition(element, x, y);
        if (guac_touchscreen.onmousemove)
            guac_touchscreen.onmousemove(guac_touchscreen.currentState);
    }

    /**
     * Returns whether the given touch event exceeds the movement threshold for
     * clicking, based on where the touch gesture began.
     *
     * @private
     * @param {TouchEvent} e The touch event to check.
     * @return {Boolean} true if the movement threshold is exceeded, false
     *                   otherwise.
     */
    function finger_moved(e) {
        var touch = e.touches[0] || e.changedTouches[0];
        var delta_x = touch.clientX - gesture_start_x;
        var delta_y = touch.clientY - gesture_start_y;
        return Math.sqrt(delta_x*delta_x + delta_y*delta_y) >= guac_touchscreen.clickMoveThreshold;
    }

    /**
     * Begins a new gesture at the location of the first touch in the given
     * touch event.
     * 
     * @private
     * @param {TouchEvent} e The touch event beginning this new gesture.
     */
    function begin_gesture(e) {
        var touch = e.touches[0];
        gesture_in_progress = true;
        gesture_start_x = touch.clientX;
        gesture_start_y = touch.clientY;
    }

    /**
     * End the current gesture entirely. Wait for all touches to be done before
     * resuming gesture detection.
     * 
     * @private
     */
    function end_gesture() {
        window.clearTimeout(click_release_timeout);
        window.clearTimeout(long_press_timeout);
        gesture_in_progress = false;
    }

    element.addEventListener("touchend", function(e) {

        // Do not handle if no gesture
        if (!gesture_in_progress)
            return;

        // Ignore if more than one touch
        if (e.touches.length !== 0 || e.changedTouches.length !== 1) {
            end_gesture();
            return;
        }

        // Long-press, if any, is over
        window.clearTimeout(long_press_timeout);

        // Always release mouse button if pressed
        release_button("left");

        // If finger hasn't moved enough to cancel the click
        if (!finger_moved(e)) {

            e.preventDefault();

            // If not yet pressed, press and start delay release
            if (!guac_touchscreen.currentState.left) {

                var touch = e.changedTouches[0];
                move_mouse(touch.clientX, touch.clientY);
                press_button("left");

                // Release button after a delay, if not canceled
                click_release_timeout = window.setTimeout(function() {
                    release_button("left");
                    end_gesture();
                }, guac_touchscreen.clickTimingThreshold);

            }

        } // end if finger not moved

    }, false);

    element.addEventListener("touchstart", function(e) {

        // Ignore if more than one touch
        if (e.touches.length !== 1) {
            end_gesture();
            return;
        }

        e.preventDefault();

        // New touch begins a new gesture
        begin_gesture(e);

        // Keep button pressed if tap after left click
        window.clearTimeout(click_release_timeout);

        // Click right button if this turns into a long-press
        long_press_timeout = window.setTimeout(function() {
            var touch = e.touches[0];
            move_mouse(touch.clientX, touch.clientY);
            click_button("right");
            end_gesture();
        }, guac_touchscreen.longPressThreshold);

    }, false);

    element.addEventListener("touchmove", function(e) {

        // Do not handle if no gesture
        if (!gesture_in_progress)
            return;

        // Cancel long press if finger moved
        if (finger_moved(e))
            window.clearTimeout(long_press_timeout);

        // Ignore if more than one touch
        if (e.touches.length !== 1) {
            end_gesture();
            return;
        }

        // Update mouse position if dragging
        if (guac_touchscreen.currentState.left) {

            e.preventDefault();

            // Update state
            var touch = e.touches[0];
            move_mouse(touch.clientX, touch.clientY);

        }

    }, false);

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * The namespace used by the Guacamole JavaScript API. Absolutely all classes
 * defined by the Guacamole JavaScript API will be within this namespace.
 *
 * @namespace
 */
var Guacamole = Guacamole || {};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * An object used by the Guacamole client to house arbitrarily-many named
 * input and output streams.
 * 
 * @constructor
 * @param {Guacamole.Client} client
 *     The client owning this object.
 *
 * @param {Number} index
 *     The index of this object.
 */
Guacamole.Object = function guacamoleObject(client, index) {

    /**
     * Reference to this Guacamole.Object.
     *
     * @private
     * @type {Guacamole.Object}
     */
    var guacObject = this;

    /**
     * Map of stream name to corresponding queue of callbacks. The queue of
     * callbacks is guaranteed to be in order of request.
     *
     * @private
     * @type {Object.<String, Function[]>}
     */
    var bodyCallbacks = {};

    /**
     * Removes and returns the callback at the head of the callback queue for
     * the stream having the given name. If no such callbacks exist, null is
     * returned.
     *
     * @private
     * @param {String} name
     *     The name of the stream to retrieve a callback for.
     *
     * @returns {Function}
     *     The next callback associated with the stream having the given name,
     *     or null if no such callback exists.
     */
    var dequeueBodyCallback = function dequeueBodyCallback(name) {

        // If no callbacks defined, simply return null
        var callbacks = bodyCallbacks[name];
        if (!callbacks)
            return null;

        // Otherwise, pull off first callback, deleting the queue if empty
        var callback = callbacks.shift();
        if (callbacks.length === 0)
            delete bodyCallbacks[name];

        // Return found callback
        return callback;

    };

    /**
     * Adds the given callback to the tail of the callback queue for the stream
     * having the given name.
     *
     * @private
     * @param {String} name
     *     The name of the stream to associate with the given callback.
     *
     * @param {Function} callback
     *     The callback to add to the queue of the stream with the given name.
     */
    var enqueueBodyCallback = function enqueueBodyCallback(name, callback) {

        // Get callback queue by name, creating first if necessary
        var callbacks = bodyCallbacks[name];
        if (!callbacks) {
            callbacks = [];
            bodyCallbacks[name] = callbacks;
        }

        // Add callback to end of queue
        callbacks.push(callback);

    };

    /**
     * The index of this object.
     *
     * @type {Number}
     */
    this.index = index;

    /**
     * Called when this object receives the body of a requested input stream.
     * By default, all objects will invoke the callbacks provided to their
     * requestInputStream() functions based on the name of the stream
     * requested. This behavior can be overridden by specifying a different
     * handler here.
     *
     * @event
     * @param {Guacamole.InputStream} inputStream
     *     The input stream of the received body.
     *
     * @param {String} mimetype
     *     The mimetype of the data being received.
     *
     * @param {String} name
     *     The name of the stream whose body has been received.
     */
    this.onbody = function defaultBodyHandler(inputStream, mimetype, name) {

        // Call queued callback for the received body, if any
        var callback = dequeueBodyCallback(name);
        if (callback)
            callback(inputStream, mimetype);

    };

    /**
     * Called when this object is being undefined. Once undefined, no further
     * communication involving this object may occur.
     * 
     * @event
     */
    this.onundefine = null;

    /**
     * Requests read access to the input stream having the given name. If
     * successful, a new input stream will be created.
     *
     * @param {String} name
     *     The name of the input stream to request.
     *
     * @param {Function} [bodyCallback]
     *     The callback to invoke when the body of the requested input stream
     *     is received. This callback will be provided a Guacamole.InputStream
     *     and its mimetype as its two only arguments. If the onbody handler of
     *     this object is overridden, this callback will not be invoked.
     */
    this.requestInputStream = function requestInputStream(name, bodyCallback) {

        // Queue body callback if provided
        if (bodyCallback)
            enqueueBodyCallback(name, bodyCallback);

        // Send request for input stream
        client.requestObjectInputStream(guacObject.index, name);

    };

    /**
     * Creates a new output stream associated with this object and having the
     * given mimetype and name. The legality of a mimetype and name is dictated
     * by the object itself.
     *
     * @param {String} mimetype
     *     The mimetype of the data which will be sent to the output stream.
     *
     * @param {String} name
     *     The defined name of an output stream within this object.
     *
     * @returns {Guacamole.OutputStream}
     *     An output stream which will write blobs to the named output stream
     *     of this object.
     */
    this.createOutputStream = function createOutputStream(mimetype, name) {
        return client.createObjectOutputStream(guacObject.index, mimetype, name);
    };

};

/**
 * The reserved name denoting the root stream of any object. The contents of
 * the root stream MUST be a JSON map of stream name to mimetype.
 *
 * @constant
 * @type {String}
 */
Guacamole.Object.ROOT_STREAM = '/';

/**
 * The mimetype of a stream containing JSON which maps available stream names
 * to their corresponding mimetype. The root stream of a Guacamole.Object MUST
 * have this mimetype.
 *
 * @constant
 * @type {String}
 */
Guacamole.Object.STREAM_INDEX_MIMETYPE = 'application/vnd.glyptodon.guacamole.stream-index+json';

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Dynamic on-screen keyboard. Given the layout object for an on-screen
 * keyboard, this object will construct a clickable on-screen keyboard with its
 * own key events.
 *
 * @constructor
 * @param {Guacamole.OnScreenKeyboard.Layout} layout
 *     The layout of the on-screen keyboard to display.
 */
Guacamole.OnScreenKeyboard = function(layout) {

    /**
     * Reference to this Guacamole.OnScreenKeyboard.
     *
     * @private
     * @type {Guacamole.OnScreenKeyboard}
     */
    var osk = this;

    /**
     * Map of currently-set modifiers to the keysym associated with their
     * original press. When the modifier is cleared, this keysym must be
     * released.
     *
     * @private
     * @type {Object.<String, Number>}
     */
    var modifierKeysyms = {};

    /**
     * Map of all key names to their current pressed states. If a key is not
     * pressed, it may not be in this map at all, but all pressed keys will
     * have a corresponding mapping to true.
     *
     * @private
     * @type {Object.<String, Boolean>}
     */
    var pressed = {};

    /**
     * All scalable elements which are part of the on-screen keyboard. Each
     * scalable element is carefully controlled to ensure the interface layout
     * and sizing remains constant, even on browsers that would otherwise
     * experience rounding error due to unit conversions.
     *
     * @private
     * @type {ScaledElement[]}
     */
    var scaledElements = [];

    /**
     * Adds a CSS class to an element.
     * 
     * @private
     * @function
     * @param {Element} element
     *     The element to add a class to.
     *
     * @param {String} classname
     *     The name of the class to add.
     */
    var addClass = function addClass(element, classname) {

        // If classList supported, use that
        if (element.classList)
            element.classList.add(classname);

        // Otherwise, simply append the class
        else
            element.className += " " + classname;

    };

    /**
     * Removes a CSS class from an element.
     * 
     * @private
     * @function
     * @param {Element} element
     *     The element to remove a class from.
     *
     * @param {String} classname
     *     The name of the class to remove.
     */
    var removeClass = function removeClass(element, classname) {

        // If classList supported, use that
        if (element.classList)
            element.classList.remove(classname);

        // Otherwise, manually filter out classes with given name
        else {
            element.className = element.className.replace(/([^ ]+)[ ]*/g,
                function removeMatchingClasses(match, testClassname) {

                    // If same class, remove
                    if (testClassname === classname)
                        return "";

                    // Otherwise, allow
                    return match;
                    
                }
            );
        }

    };

    /**
     * Counter of mouse events to ignore. This decremented by mousemove, and
     * while non-zero, mouse events will have no effect.
     *
     * @private
     * @type {Number}
     */
    var ignoreMouse = 0;

    /**
     * Ignores all pending mouse events when touch events are the apparent
     * source. Mouse events are ignored until at least touchMouseThreshold
     * mouse events occur without corresponding touch events.
     *
     * @private
     */
    var ignorePendingMouseEvents = function ignorePendingMouseEvents() {
        ignoreMouse = osk.touchMouseThreshold;
    };

    /**
     * An element whose dimensions are maintained according to an arbitrary
     * scale. The conversion factor for these arbitrary units to pixels is
     * provided later via a call to scale().
     *
     * @private
     * @constructor
     * @param {Element} element
     *     The element whose scale should be maintained.
     *
     * @param {Number} width
     *     The width of the element, in arbitrary units, relative to other
     *     ScaledElements.
     *
     * @param {Number} height
     *     The height of the element, in arbitrary units, relative to other
     *     ScaledElements.
     *     
     * @param {Boolean} [scaleFont=false]
     *     Whether the line height and font size should be scaled as well.
     */
    var ScaledElement = function ScaledElement(element, width, height, scaleFont) {

        /**
         * The width of this ScaledElement, in arbitrary units, relative to
         * other ScaledElements.
         *
         * @type {Number}
         */
         this.width = width;

        /**
         * The height of this ScaledElement, in arbitrary units, relative to
         * other ScaledElements.
         *
         * @type {Number}
         */
         this.height = height;
 
        /**
         * Resizes the associated element, updating its dimensions according to
         * the given pixels per unit.
         *
         * @param {Number} pixels
         *     The number of pixels to assign per arbitrary unit.
         */
        this.scale = function(pixels) {

            // Scale element width/height
            element.style.width  = (width  * pixels) + "px";
            element.style.height = (height * pixels) + "px";

            // Scale font, if requested
            if (scaleFont) {
                element.style.lineHeight = (height * pixels) + "px";
                element.style.fontSize   = pixels + "px";
            }

        };

    };

    /**
     * Returns whether all modifiers having the given names are currently
     * active.
     *
     * @private
     * @param {String[]} names
     *     The names of all modifiers to test.
     *
     * @returns {Boolean}
     *     true if all specified modifiers are pressed, false otherwise.
     */
    var modifiersPressed = function modifiersPressed(names) {

        // If any required modifiers are not pressed, return false
        for (var i=0; i < names.length; i++) {

            // Test whether current modifier is pressed
            var name = names[i];
            if (!(name in modifierKeysyms))
                return false;

        }

        // Otherwise, all required modifiers are pressed
        return true;

    };

    /**
     * Returns the single matching Key object associated with the key of the
     * given name, where that Key object's requirements (such as pressed
     * modifiers) are all currently satisfied.
     *
     * @private
     * @param {String} keyName
     *     The name of the key to retrieve.
     *
     * @returns {Guacamole.OnScreenKeyboard.Key}
     *     The Key object associated with the given name, where that object's
     *     requirements are all currently satisfied, or null if no such Key
     *     can be found.
     */
    var getActiveKey = function getActiveKey(keyName) {

        // Get key array for given name
        var keys = osk.keys[keyName];
        if (!keys)
            return null;

        // Find last matching key
        for (var i = keys.length - 1; i >= 0; i--) {

            // Get candidate key
            var candidate = keys[i];

            // If all required modifiers are pressed, use that key
            if (modifiersPressed(candidate.requires))
                return candidate;

        }

        // No valid key
        return null;

    };

    /**
     * Presses the key having the given name, updating the associated key
     * element with the "guac-keyboard-pressed" CSS class. If the key is
     * already pressed, this function has no effect.
     *
     * @private
     * @param {String} keyName
     *     The name of the key to press.
     *
     * @param {String} keyElement
     *     The element associated with the given key.
     */
    var press = function press(keyName, keyElement) {

        // Press key if not yet pressed
        if (!pressed[keyName]) {

            addClass(keyElement, "guac-keyboard-pressed");

            // Get current key based on modifier state
            var key = getActiveKey(keyName);

            // Update modifier state
            if (key.modifier) {

                // Construct classname for modifier
                var modifierClass = "guac-keyboard-modifier-" + getCSSName(key.modifier);

                // Retrieve originally-pressed keysym, if modifier was already pressed
                var originalKeysym = modifierKeysyms[key.modifier];

                // Activate modifier if not pressed
                if (!originalKeysym) {
                    
                    addClass(keyboard, modifierClass);
                    modifierKeysyms[key.modifier] = key.keysym;
                    
                    // Send key event
                    if (osk.onkeydown)
                        osk.onkeydown(key.keysym);

                }

                // Deactivate if not pressed
                else {

                    removeClass(keyboard, modifierClass);
                    delete modifierKeysyms[key.modifier];
                    
                    // Send key event
                    if (osk.onkeyup)
                        osk.onkeyup(originalKeysym);

                }

            }

            // If not modifier, send key event now
            else if (osk.onkeydown)
                osk.onkeydown(key.keysym);

            // Mark key as pressed
            pressed[keyName] = true;

        }

    };

    /**
     * Releases the key having the given name, removing the
     * "guac-keyboard-pressed" CSS class from the associated element. If the
     * key is already released, this function has no effect.
     *
     * @private
     * @param {String} keyName
     *     The name of the key to release.
     *
     * @param {String} keyElement
     *     The element associated with the given key.
     */
    var release = function release(keyName, keyElement) {

        // Release key if currently pressed
        if (pressed[keyName]) {

            removeClass(keyElement, "guac-keyboard-pressed");

            // Get current key based on modifier state
            var key = getActiveKey(keyName);

            // Send key event if not a modifier key
            if (!key.modifier && osk.onkeyup)
                osk.onkeyup(key.keysym);

            // Mark key as released
            pressed[keyName] = false;

        }

    };

    // Create keyboard
    var keyboard = document.createElement("div");
    keyboard.className = "guac-keyboard";

    // Do not allow selection or mouse movement to propagate/register.
    keyboard.onselectstart =
    keyboard.onmousemove   =
    keyboard.onmouseup     =
    keyboard.onmousedown   = function handleMouseEvents(e) {

        // If ignoring events, decrement counter
        if (ignoreMouse)
            ignoreMouse--;

        e.stopPropagation();
        return false;

    };

    /**
     * The number of mousemove events to require before re-enabling mouse
     * event handling after receiving a touch event.
     *
     * @type {Number}
     */
    this.touchMouseThreshold = 3;

    /**
     * Fired whenever the user presses a key on this Guacamole.OnScreenKeyboard.
     * 
     * @event
     * @param {Number} keysym The keysym of the key being pressed.
     */
    this.onkeydown = null;

    /**
     * Fired whenever the user releases a key on this Guacamole.OnScreenKeyboard.
     * 
     * @event
     * @param {Number} keysym The keysym of the key being released.
     */
    this.onkeyup = null;

    /**
     * The keyboard layout provided at time of construction.
     *
     * @type {Guacamole.OnScreenKeyboard.Layout}
     */
    this.layout = new Guacamole.OnScreenKeyboard.Layout(layout);

    /**
     * Returns the element containing the entire on-screen keyboard.
     * @returns {Element} The element containing the entire on-screen keyboard.
     */
    this.getElement = function() {
        return keyboard;
    };

    /**
     * Resizes all elements within this Guacamole.OnScreenKeyboard such that
     * the width is close to but does not exceed the specified width. The
     * height of the keyboard is determined based on the width.
     * 
     * @param {Number} width The width to resize this Guacamole.OnScreenKeyboard
     *                       to, in pixels.
     */
    this.resize = function(width) {

        // Get pixel size of a unit
        var unit = Math.floor(width * 10 / osk.layout.width) / 10;

        // Resize all scaled elements
        for (var i=0; i<scaledElements.length; i++) {
            var scaledElement = scaledElements[i];
            scaledElement.scale(unit);
        }

    };

    /**
     * Given the name of a key and its corresponding definition, which may be
     * an array of keys objects, a number (keysym), a string (key title), or a
     * single key object, returns an array of key objects, deriving any missing
     * properties as needed, and ensuring the key name is defined.
     *
     * @private
     * @param {String} name
     *     The name of the key being coerced into an array of Key objects.
     *
     * @param {Number|String|Guacamole.OnScreenKeyboard.Key|Guacamole.OnScreenKeyboard.Key[]} object
     *     The object defining the behavior of the key having the given name,
     *     which may be the title of the key (a string), the keysym (a number),
     *     a single Key object, or an array of Key objects.
     *     
     * @returns {Guacamole.OnScreenKeyboard.Key[]}
     *     An array of all keys associated with the given name.
     */
    var asKeyArray = function asKeyArray(name, object) {

        // If already an array, just coerce into a true Key[] 
        if (object instanceof Array) {
            var keys = [];
            for (var i=0; i < object.length; i++) {
                keys.push(new Guacamole.OnScreenKeyboard.Key(object[i], name));
            }
            return keys;
        }

        // Derive key object from keysym if that's all we have
        if (typeof object === 'number') {
            return [new Guacamole.OnScreenKeyboard.Key({
                name   : name,
                keysym : object
            })];
        }

        // Derive key object from title if that's all we have
        if (typeof object === 'string') {
            return [new Guacamole.OnScreenKeyboard.Key({
                name  : name,
                title : object
            })];
        }

        // Otherwise, assume it's already a key object, just not an array
        return [new Guacamole.OnScreenKeyboard.Key(object, name)];

    };

    /**
     * Converts the rather forgiving key mapping allowed by
     * Guacamole.OnScreenKeyboard.Layout into a rigorous mapping of key name
     * to key definition, where the key definition is always an array of Key
     * objects.
     *
     * @private
     * @param {Object.<String, Number|String|Guacamole.OnScreenKeyboard.Key|Guacamole.OnScreenKeyboard.Key[]>} keys
     *     A mapping of key name to key definition, where the key definition is
     *     the title of the key (a string), the keysym (a number), a single
     *     Key object, or an array of Key objects.
     *
     * @returns {Object.<String, Guacamole.OnScreenKeyboard.Key[]>}
     *     A more-predictable mapping of key name to key definition, where the
     *     key definition is always simply an array of Key objects.
     */
    var getKeys = function getKeys(keys) {

        var keyArrays = {};

        // Coerce all keys into individual key arrays
        for (var name in layout.keys) {
            keyArrays[name] = asKeyArray(name, keys[name]);
        }

        return keyArrays;

    };

    /**
     * Map of all key names to their corresponding set of keys. Each key name
     * may correspond to multiple keys due to the effect of modifiers.
     *
     * @type {Object.<String, Guacamole.OnScreenKeyboard.Key[]>}
     */
    this.keys = getKeys(layout.keys);

    /**
     * Given an arbitrary string representing the name of some component of the
     * on-screen keyboard, returns a string formatted for use as a CSS class
     * name. The result will be lowercase. Word boundaries previously denoted
     * by CamelCase will be replaced by individual hyphens, as will all
     * contiguous non-alphanumeric characters.
     *
     * @private
     * @param {String} name
     *     An arbitrary string representing the name of some component of the
     *     on-screen keyboard.
     *
     * @returns {String}
     *     A string formatted for use as a CSS class name.
     */
    var getCSSName = function getCSSName(name) {

        // Convert name from possibly-CamelCase to hyphenated lowercase
        var cssName = name
               .replace(/([a-z])([A-Z])/g, '$1-$2')
               .replace(/[^A-Za-z0-9]+/g, '-')
               .toLowerCase();

        return cssName;

    };

    /**
     * Appends DOM elements to the given element as dictated by the layout
     * structure object provided. If a name is provided, an additional CSS
     * class, prepended with "guac-keyboard-", will be added to the top-level
     * element.
     * 
     * If the layout structure object is an array, all elements within that
     * array will be recursively appended as children of a group, and the
     * top-level element will be given the CSS class "guac-keyboard-group".
     *
     * If the layout structure object is an object, all properties within that
     * object will be recursively appended as children of a group, and the
     * top-level element will be given the CSS class "guac-keyboard-group". The
     * name of each property will be applied as the name of each child object
     * for the sake of CSS. Each property will be added in sorted order.
     *
     * If the layout structure object is a string, the key having that name
     * will be appended. The key will be given the CSS class
     * "guac-keyboard-key" and "guac-keyboard-key-NAME", where NAME is the name
     * of the key. If the name of the key is a single character, this will
     * first be transformed into the C-style hexadecimal literal for the
     * Unicode codepoint of that character. For example, the key "A" would
     * become "guac-keyboard-key-0x41".
     * 
     * If the layout structure object is a number, a gap of that size will be
     * inserted. The gap will be given the CSS class "guac-keyboard-gap", and
     * will be scaled according to the same size units as each key.
     *
     * @private
     * @param {Element} element
     *     The element to append elements to.
     *
     * @param {Array|Object|String|Number} object
     *     The layout structure object to use when constructing the elements to
     *     append.
     *
     * @param {String} [name]
     *     The name of the top-level element being appended, if any.
     */
    var appendElements = function appendElements(element, object, name) {

        var i;

        // Create div which will become the group or key
        var div = document.createElement('div');

        // Add class based on name, if name given
        if (name)
            addClass(div, 'guac-keyboard-' + getCSSName(name));

        // If an array, append each element
        if (object instanceof Array) {

            // Add group class
            addClass(div, 'guac-keyboard-group');

            // Append all elements of array
            for (i=0; i < object.length; i++)
                appendElements(div, object[i]);

        }

        // If an object, append each property value
        else if (object instanceof Object) {

            // Add group class
            addClass(div, 'guac-keyboard-group');

            // Append all children, sorted by name
            var names = Object.keys(object).sort();
            for (i=0; i < names.length; i++) {
                var name = names[i];
                appendElements(div, object[name], name);
            }

        }

        // If a number, create as a gap 
        else if (typeof object === 'number') {

            // Add gap class
            addClass(div, 'guac-keyboard-gap');

            // Maintain scale
            scaledElements.push(new ScaledElement(div, object, object));

        }

        // If a string, create as a key
        else if (typeof object === 'string') {

            // If key name is only one character, use codepoint for name
            var keyName = object;
            if (keyName.length === 1)
                keyName = '0x' + keyName.charCodeAt(0).toString(16);

            // Add key container class
            addClass(div, 'guac-keyboard-key-container');

            // Create key element which will contain all possible caps
            var keyElement = document.createElement('div');
            keyElement.className = 'guac-keyboard-key '
                                 + 'guac-keyboard-key-' + getCSSName(keyName);

            // Add all associated keys as caps within DOM
            var keys = osk.keys[object];
            if (keys) {
                for (i=0; i < keys.length; i++) {

                    // Get current key
                    var key = keys[i];

                    // Create cap element for key
                    var capElement = document.createElement('div');
                    capElement.className   = 'guac-keyboard-cap';
                    capElement.textContent = key.title;

                    // Add classes for any requirements
                    for (var j=0; j < key.requires.length; j++) {
                        var requirement = key.requires[j];
                        addClass(capElement, 'guac-keyboard-requires-' + getCSSName(requirement));
                        addClass(keyElement, 'guac-keyboard-uses-'     + getCSSName(requirement));
                    }

                    // Add cap to key within DOM
                    keyElement.appendChild(capElement);

                }
            }

            // Add key to DOM, maintain scale
            div.appendChild(keyElement);
            scaledElements.push(new ScaledElement(div, osk.layout.keyWidths[object] || 1, 1, true));

            /**
             * Handles a touch event which results in the pressing of an OSK
             * key. Touch events will result in mouse events being ignored for
             * touchMouseThreshold events.
             *
             * @private
             * @param {TouchEvent} e
             *     The touch event being handled.
             */
            var touchPress = function touchPress(e) {
                e.preventDefault();
                ignoreMouse = osk.touchMouseThreshold;
                press(object, keyElement);
            };

            /**
             * Handles a touch event which results in the release of an OSK
             * key. Touch events will result in mouse events being ignored for
             * touchMouseThreshold events.
             *
             * @private
             * @param {TouchEvent} e
             *     The touch event being handled.
             */
            var touchRelease = function touchRelease(e) {
                e.preventDefault();
                ignoreMouse = osk.touchMouseThreshold;
                release(object, keyElement);
            };

            /**
             * Handles a mouse event which results in the pressing of an OSK
             * key. If mouse events are currently being ignored, this handler
             * does nothing.
             *
             * @private
             * @param {MouseEvent} e
             *     The touch event being handled.
             */
            var mousePress = function mousePress(e) {
                e.preventDefault();
                if (ignoreMouse === 0)
                    press(object, keyElement);
            };

            /**
             * Handles a mouse event which results in the release of an OSK
             * key. If mouse events are currently being ignored, this handler
             * does nothing.
             *
             * @private
             * @param {MouseEvent} e
             *     The touch event being handled.
             */
            var mouseRelease = function mouseRelease(e) {
                e.preventDefault();
                if (ignoreMouse === 0)
                    release(object, keyElement);
            };

            // Handle touch events on key
            keyElement.addEventListener("touchstart", touchPress,   true);
            keyElement.addEventListener("touchend",   touchRelease, true);

            // Handle mouse events on key
            keyElement.addEventListener("mousedown", mousePress,   true);
            keyElement.addEventListener("mouseup",   mouseRelease, true);
            keyElement.addEventListener("mouseout",  mouseRelease, true);

        } // end if object is key name

        // Add newly-created group/key
        element.appendChild(div);

    };

    // Create keyboard layout in DOM
    appendElements(keyboard, layout.layout);

};

/**
 * Represents an entire on-screen keyboard layout, including all available
 * keys, their behaviors, and their relative position and sizing.
 *
 * @constructor
 * @param {Guacamole.OnScreenKeyboard.Layout|Object} template
 *     The object whose identically-named properties will be used to initialize
 *     the properties of this layout.
 */
Guacamole.OnScreenKeyboard.Layout = function(template) {

    /**
     * The language of keyboard layout, such as "en_US". This property is for
     * informational purposes only, but it is recommend to conform to the
     * [language code]_[country code] format.
     *
     * @type {String}
     */
    this.language = template.language;

    /**
     * The type of keyboard layout, such as "qwerty". This property is for
     * informational purposes only, and does not conform to any standard.
     *
     * @type {String}
     */
    this.type = template.type;

    /**
     * Map of key name to corresponding keysym, title, or key object. If only
     * the keysym or title is provided, the key object will be created
     * implicitly. In all cases, the name property of the key object will be
     * taken from the name given in the mapping.
     *
     * @type {Object.<String, Number|String|Guacamole.OnScreenKeyboard.Key|Guacamole.OnScreenKeyboard.Key[]>}
     */
    this.keys = template.keys;

    /**
     * Arbitrarily nested, arbitrarily grouped key names. The contents of the
     * layout will be traversed to produce an identically-nested grouping of
     * keys in the DOM tree. All strings will be transformed into their
     * corresponding sets of keys, while all objects and arrays will be
     * transformed into named groups and anonymous groups respectively. Any
     * numbers present will be transformed into gaps of that size, scaled
     * according to the same units as each key.
     *
     * @type {Object}
     */
    this.layout = template.layout;

    /**
     * The width of the entire keyboard, in arbitrary units. The width of each
     * key is relative to this width, as both width values are assumed to be in
     * the same units. The conversion factor between these units and pixels is
     * derived later via a call to resize() on the Guacamole.OnScreenKeyboard.
     *
     * @type {Number}
     */
    this.width = template.width;

    /**
     * The width of each key, in arbitrary units, relative to other keys in
     * this layout. The true pixel size of each key will be determined by the
     * overall size of the keyboard. If not defined here, the width of each
     * key will default to 1.
     *
     * @type {Object.<String, Number>}
     */
    this.keyWidths = template.keyWidths || {};

};

/**
 * Represents a single key, or a single possible behavior of a key. Each key
 * on the on-screen keyboard must have at least one associated
 * Guacamole.OnScreenKeyboard.Key, whether that key is explicitly defined or
 * implied, and may have multiple Guacamole.OnScreenKeyboard.Key if behavior
 * depends on modifier states.
 *
 * @constructor
 * @param {Guacamole.OnScreenKeyboard.Key|Object} template
 *     The object whose identically-named properties will be used to initialize
 *     the properties of this key.
 *     
 * @param {String} [name]
 *     The name to use instead of any name provided within the template, if
 *     any. If omitted, the name within the template will be used, assuming the
 *     template contains a name.
 */
Guacamole.OnScreenKeyboard.Key = function(template, name) {

    /**
     * The unique name identifying this key within the keyboard layout.
     *
     * @type {String}
     */
    this.name = name || template.name;

    /**
     * The human-readable title that will be displayed to the user within the
     * key. If not provided, this will be derived from the key name.
     *
     * @type {String}
     */
    this.title = template.title || this.name;

    /**
     * The keysym to be pressed/released when this key is pressed/released. If
     * not provided, this will be derived from the title if the title is a
     * single character.
     *
     * @type {Number}
     */
    this.keysym = template.keysym || (function deriveKeysym(title) {

        // Do not derive keysym if title is not exactly one character
        if (!title || title.length !== 1)
            return null;

        // For characters between U+0000 and U+00FF, the keysym is the codepoint
        var charCode = title.charCodeAt(0);
        if (charCode >= 0x0000 && charCode <= 0x00FF)
            return charCode;

        // For characters between U+0100 and U+10FFFF, the keysym is the codepoint or'd with 0x01000000
        if (charCode >= 0x0100 && charCode <= 0x10FFFF)
            return 0x01000000 | charCode;

        // Unable to derive keysym
        return null;

    })(this.title);

    /**
     * The name of the modifier set when the key is pressed and cleared when
     * this key is released, if any. The names of modifiers are distinct from
     * the names of keys; both the "RightShift" and "LeftShift" keys may set
     * the "shift" modifier, for example. By default, the key will affect no
     * modifiers.
     * 
     * @type {String}
     */
    this.modifier = template.modifier;

    /**
     * An array containing the names of each modifier required for this key to
     * have an effect. For example, a lowercase letter may require nothing,
     * while an uppercase letter would require "shift", assuming the Shift key
     * is named "shift" within the layout. By default, the key will require
     * no modifiers.
     *
     * @type {String[]}
     */
    this.requires = template.requires || [];

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract stream which can receive data.
 * 
 * @constructor
 * @param {Guacamole.Client} client The client owning this stream.
 * @param {Number} index The index of this stream.
 */
Guacamole.OutputStream = function(client, index) {

    /**
     * Reference to this stream.
     * @private
     */
    var guac_stream = this;

    /**
     * The index of this stream.
     * @type {Number}
     */
    this.index = index;

    /**
     * Fired whenever an acknowledgement is received from the server, indicating
     * that a stream operation has completed, or an error has occurred.
     * 
     * @event
     * @param {Guacamole.Status} status The status of the operation.
     */
    this.onack = null;

    /**
     * Writes the given base64-encoded data to this stream as a blob.
     * 
     * @param {String} data The base64-encoded data to send.
     */
    this.sendBlob = function(data) {
        client.sendBlob(guac_stream.index, data);
    };

    /**
     * Closes this stream.
     */
    this.sendEnd = function() {
        client.endStream(guac_stream.index);
    };

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Simple Guacamole protocol parser that invokes an oninstruction event when
 * full instructions are available from data received via receive().
 * 
 * @constructor
 */
Guacamole.Parser = function() {

    /**
     * Reference to this parser.
     * @private
     */
    var parser = this;

    /**
     * Current buffer of received data. This buffer grows until a full
     * element is available. After a full element is available, that element
     * is flushed into the element buffer.
     * 
     * @private
     */
    var buffer = "";

    /**
     * Buffer of all received, complete elements. After an entire instruction
     * is read, this buffer is flushed, and a new instruction begins.
     * 
     * @private
     */
    var element_buffer = [];

    // The location of the last element's terminator
    var element_end = -1;

    // Where to start the next length search or the next element
    var start_index = 0;

    /**
     * Appends the given instruction data packet to the internal buffer of
     * this Guacamole.Parser, executing all completed instructions at
     * the beginning of this buffer, if any.
     *
     * @param {String} packet The instruction data to receive.
     */
    this.receive = function(packet) {

        // Truncate buffer as necessary
        if (start_index > 4096 && element_end >= start_index) {

            buffer = buffer.substring(start_index);

            // Reset parse relative to truncation
            element_end -= start_index;
            start_index = 0;

        }

        // Append data to buffer
        buffer += packet;

        // While search is within currently received data
        while (element_end < buffer.length) {

            // If we are waiting for element data
            if (element_end >= start_index) {

                // We now have enough data for the element. Parse.
                var element = buffer.substring(start_index, element_end);
                var terminator = buffer.substring(element_end, element_end+1);

                // Add element to array
                element_buffer.push(element);

                // If last element, handle instruction
                if (terminator == ";") {

                    // Get opcode
                    var opcode = element_buffer.shift();

                    // Call instruction handler.
                    if (parser.oninstruction != null)
                        parser.oninstruction(opcode, element_buffer);

                    // Clear elements
                    element_buffer.length = 0;

                }
                else if (terminator != ',')
                    throw new Error("Illegal terminator.");

                // Start searching for length at character after
                // element terminator
                start_index = element_end + 1;

            }

            // Search for end of length
            var length_end = buffer.indexOf(".", start_index);
            if (length_end != -1) {

                // Parse length
                var length = parseInt(buffer.substring(element_end+1, length_end));
                if (isNaN(length))
                    throw new Error("Non-numeric character in element length.");

                // Calculate start of element
                start_index = length_end + 1;

                // Calculate location of element terminator
                element_end = start_index + length;

            }
            
            // If no period yet, continue search when more data
            // is received
            else {
                start_index = buffer.length;
                break;
            }

        } // end parse loop

    };

    /**
     * Fired once for every complete Guacamole instruction received, in order.
     * 
     * @event
     * @param {String} opcode The Guacamole instruction opcode.
     * @param {Array} parameters The parameters provided for the instruction,
     *                           if any.
     */
    this.oninstruction = null;

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A description of the format of raw PCM audio, such as that used by
 * Guacamole.RawAudioPlayer and Guacamole.RawAudioRecorder. This object
 * describes the number of bytes per sample, the number of channels, and the
 * overall sample rate.
 *
 * @constructor
 * @param {Guacamole.RawAudioFormat|Object} template
 *     The object whose properties should be copied into the corresponding
 *     properties of the new Guacamole.RawAudioFormat.
 */
Guacamole.RawAudioFormat = function RawAudioFormat(template) {

    /**
     * The number of bytes in each sample of audio data. This value is
     * independent of the number of channels.
     *
     * @type {Number}
     */
    this.bytesPerSample = template.bytesPerSample;

    /**
     * The number of audio channels (ie: 1 for mono, 2 for stereo).
     *
     * @type {Number}
     */
    this.channels = template.channels;

    /**
     * The number of samples per second, per channel.
     *
     * @type {Number}
     */
    this.rate = template.rate;

};

/**
 * Parses the given mimetype, returning a new Guacamole.RawAudioFormat
 * which describes the type of raw audio data represented by that mimetype. If
 * the mimetype is not a supported raw audio data mimetype, null is returned.
 *
 * @param {String} mimetype
 *     The audio mimetype to parse.
 *
 * @returns {Guacamole.RawAudioFormat}
 *     A new Guacamole.RawAudioFormat which describes the type of raw
 *     audio data represented by the given mimetype, or null if the given
 *     mimetype is not supported.
 */
Guacamole.RawAudioFormat.parse = function parseFormat(mimetype) {

    var bytesPerSample;

    // Rate is absolutely required - if null is still present later, the
    // mimetype must not be supported
    var rate = null;

    // Default for both "audio/L8" and "audio/L16" is one channel
    var channels = 1;

    // "audio/L8" has one byte per sample
    if (mimetype.substring(0, 9) === 'audio/L8;') {
        mimetype = mimetype.substring(9);
        bytesPerSample = 1;
    }

    // "audio/L16" has two bytes per sample
    else if (mimetype.substring(0, 10) === 'audio/L16;') {
        mimetype = mimetype.substring(10);
        bytesPerSample = 2;
    }

    // All other types are unsupported
    else
        return null;

    // Parse all parameters
    var parameters = mimetype.split(',');
    for (var i = 0; i < parameters.length; i++) {

        var parameter = parameters[i];

        // All parameters must have an equals sign separating name from value
        var equals = parameter.indexOf('=');
        if (equals === -1)
            return null;

        // Parse name and value from parameter string
        var name  = parameter.substring(0, equals);
        var value = parameter.substring(equals+1);

        // Handle each supported parameter
        switch (name) {

            // Number of audio channels
            case 'channels':
                channels = parseInt(value);
                break;

            // Sample rate
            case 'rate':
                rate = parseInt(value);
                break;

            // All other parameters are unsupported
            default:
                return null;

        }

    };

    // The rate parameter is required
    if (rate === null)
        return null;

    // Return parsed format details
    return new Guacamole.RawAudioFormat({
        bytesPerSample : bytesPerSample,
        channels       : channels,
        rate           : rate
    });

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A recording of a Guacamole session. Given a {@link Guacamole.Tunnel}, the
 * Guacamole.SessionRecording automatically handles incoming Guacamole
 * instructions, storing them for playback. Playback of the recording may be
 * controlled through function calls to the Guacamole.SessionRecording, even
 * while the recording has not yet finished being created or downloaded.
 *
 * @constructor
 * @param {Guacamole.Tunnel} tunnel
 *     The Guacamole.Tunnel from which the instructions of the recording should
 *     be read.
 */
Guacamole.SessionRecording = function SessionRecording(tunnel) {

    /**
     * Reference to this Guacamole.SessionRecording.
     *
     * @private
     * @type {Guacamole.SessionRecording}
     */
    var recording = this;

    /**
     * The minimum number of characters which must have been read between
     * keyframes.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var KEYFRAME_CHAR_INTERVAL = 16384;

    /**
     * The minimum number of milliseconds which must elapse between keyframes.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var KEYFRAME_TIME_INTERVAL = 5000;

    /**
     * The maximum amount of time to spend in any particular seek operation
     * before returning control to the main thread, in milliseconds. Seek
     * operations exceeding this amount of time will proceed asynchronously.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var MAXIMUM_SEEK_TIME = 5;

    /**
     * All frames parsed from the provided tunnel.
     *
     * @private
     * @type {Guacamole.SessionRecording._Frame[]}
     */
    var frames = [];

    /**
     * All instructions which have been read since the last frame was added to
     * the frames array.
     *
     * @private
     * @type {Guacamole.SessionRecording._Frame.Instruction[]}
     */
    var instructions = [];

    /**
     * The approximate number of characters which have been read from the
     * provided tunnel since the last frame was flagged for use as a keyframe.
     *
     * @private
     * @type {Number}
     */
    var charactersSinceLastKeyframe = 0;

    /**
     * The timestamp of the last frame which was flagged for use as a keyframe.
     * If no timestamp has yet been flagged, this will be 0.
     *
     * @private
     * @type {Number}
     */
    var lastKeyframeTimestamp = 0;

    /**
     * Tunnel which feeds arbitrary instructions to the client used by this
     * Guacamole.SessionRecording for playback of the session recording.
     *
     * @private
     * @type {Guacamole.SessionRecording._PlaybackTunnel}
     */
    var playbackTunnel = new Guacamole.SessionRecording._PlaybackTunnel();

    /**
     * Guacamole.Client instance used for visible playback of the session
     * recording.
     *
     * @private
     * @type {Guacamole.Client}
     */
    var playbackClient = new Guacamole.Client(playbackTunnel);

    /**
     * The current frame rendered within the playback client. If no frame is
     * yet rendered, this will be -1.
     *
     * @private
     * @type {Number}
     */
    var currentFrame = -1;

    /**
     * The timestamp of the frame when playback began, in milliseconds. If
     * playback is not in progress, this will be null.
     *
     * @private
     * @type {Number}
     */
    var startVideoTimestamp = null;

    /**
     * The real-world timestamp when playback began, in milliseconds. If
     * playback is not in progress, this will be null.
     *
     * @private
     * @type {Number}
     */
    var startRealTimestamp = null;

    /**
     * The ID of the timeout which will continue the in-progress seek
     * operation. If no seek operation is in progress, the ID stored here (if
     * any) will not be valid.
     *
     * @private
     * @type {Number}
     */
    var seekTimeout = null;

    // Start playback client connected
    playbackClient.connect();

    // Hide cursor unless mouse position is received
    playbackClient.getDisplay().showCursor(false);

    // Read instructions from provided tunnel, extracting each frame
    tunnel.oninstruction = function handleInstruction(opcode, args) {

        // Store opcode and arguments for received instruction
        var instruction = new Guacamole.SessionRecording._Frame.Instruction(opcode, args.slice());
        instructions.push(instruction);
        charactersSinceLastKeyframe += instruction.getSize();

        // Once a sync is received, store all instructions since the last
        // frame as a new frame
        if (opcode === 'sync') {

            // Parse frame timestamp from sync instruction
            var timestamp = parseInt(args[0]);

            // Add a new frame containing the instructions read since last frame
            var frame = new Guacamole.SessionRecording._Frame(timestamp, instructions);
            frames.push(frame);

            // This frame should eventually become a keyframe if enough data
            // has been processed and enough recording time has elapsed, or if
            // this is the absolute first frame
            if (frames.length === 1 || (charactersSinceLastKeyframe >= KEYFRAME_CHAR_INTERVAL
                    && timestamp - lastKeyframeTimestamp >= KEYFRAME_TIME_INTERVAL)) {
                frame.keyframe = true;
                lastKeyframeTimestamp = timestamp;
                charactersSinceLastKeyframe = 0;
            }

            // Clear set of instructions in preparation for next frame
            instructions = [];

            // Notify that additional content is available
            if (recording.onprogress)
                recording.onprogress(recording.getDuration());

        }

    };

    /**
     * Converts the given absolute timestamp to a timestamp which is relative
     * to the first frame in the recording.
     *
     * @private
     * @param {Number} timestamp
     *     The timestamp to convert to a relative timestamp.
     *
     * @returns {Number}
     *     The difference in milliseconds between the given timestamp and the
     *     first frame of the recording, or zero if no frames yet exist.
     */
    var toRelativeTimestamp = function toRelativeTimestamp(timestamp) {

        // If no frames yet exist, all timestamps are zero
        if (frames.length === 0)
            return 0;

        // Calculate timestamp relative to first frame
        return timestamp - frames[0].timestamp;

    };

    /**
     * Searches through the given region of frames for the frame having a
     * relative timestamp closest to the timestamp given.
     *
     * @private
     * @param {Number} minIndex
     *     The index of the first frame in the region (the frame having the
     *     smallest timestamp).
     *
     * @param {Number} maxIndex
     *     The index of the last frame in the region (the frame having the
     *     largest timestamp).
     *
     * @param {Number} timestamp
     *     The relative timestamp to search for, where zero denotes the first
     *     frame in the recording.
     *
     * @returns {Number}
     *     The index of the frame having a relative timestamp closest to the
     *     given value.
     */
    var findFrame = function findFrame(minIndex, maxIndex, timestamp) {

        // Do not search if the region contains only one element
        if (minIndex === maxIndex)
            return minIndex;

        // Split search region into two halves
        var midIndex = Math.floor((minIndex + maxIndex) / 2);
        var midTimestamp = toRelativeTimestamp(frames[midIndex].timestamp);

        // If timestamp is within lesser half, search again within that half
        if (timestamp < midTimestamp && midIndex > minIndex)
            return findFrame(minIndex, midIndex - 1, timestamp);

        // If timestamp is within greater half, search again within that half
        if (timestamp > midTimestamp && midIndex < maxIndex)
            return findFrame(midIndex + 1, maxIndex, timestamp);

        // Otherwise, we lucked out and found a frame with exactly the
        // desired timestamp
        return midIndex;

    };

    /**
     * Replays the instructions associated with the given frame, sending those
     * instructions to the playback client.
     *
     * @private
     * @param {Number} index
     *     The index of the frame within the frames array which should be
     *     replayed.
     */
    var replayFrame = function replayFrame(index) {

        var frame = frames[index];

        // Replay all instructions within the retrieved frame
        for (var i = 0; i < frame.instructions.length; i++) {
            var instruction = frame.instructions[i];
            playbackTunnel.receiveInstruction(instruction.opcode, instruction.args);
        }

        // Store client state if frame is flagged as a keyframe
        if (frame.keyframe && !frame.clientState) {
            playbackClient.exportState(function storeClientState(state) {
                frame.clientState = state;
            });
        }

    };

    /**
     * Moves the playback position to the given frame, resetting the state of
     * the playback client and replaying frames as necessary. The seek
     * operation will proceed asynchronously. If a seek operation is already in
     * progress, that seek is first aborted. The progress of the seek operation
     * can be observed through the onseek handler and the provided callback.
     *
     * @private
     * @param {Number} index
     *     The index of the frame which should become the new playback
     *     position.
     *
     * @param {function} callback
     *     The callback to invoke once the seek operation has completed.
     *
     * @param {Number} [delay=0]
     *     The number of milliseconds that the seek operation should be
     *     scheduled to take.
     */
    var seekToFrame = function seekToFrame(index, callback, delay) {

        // Abort any in-progress seek
        abortSeek();

        // Replay frames asynchronously
        seekTimeout = window.setTimeout(function continueSeek() {

            var startIndex;

            // Back up until startIndex represents current state
            for (startIndex = index; startIndex >= 0; startIndex--) {

                var frame = frames[startIndex];

                // If we've reached the current frame, startIndex represents
                // current state by definition
                if (startIndex === currentFrame)
                    break;

                // If frame has associated absolute state, make that frame the
                // current state
                if (frame.clientState) {
                    playbackClient.importState(frame.clientState);
                    break;
                }

            }

            // Advance to frame index after current state
            startIndex++;

            var startTime = new Date().getTime();

            // Replay any applicable incremental frames
            for (; startIndex <= index; startIndex++) {

                // Stop seeking if the operation is taking too long
                var currentTime = new Date().getTime();
                if (currentTime - startTime >= MAXIMUM_SEEK_TIME)
                    break;

                replayFrame(startIndex);
            }

            // Current frame is now at requested index
            currentFrame = startIndex - 1;

            // Notify of changes in position
            if (recording.onseek)
                recording.onseek(recording.getPosition());

            // If the seek operation has not yet completed, schedule continuation
            if (currentFrame !== index)
                seekToFrame(index, callback,
                    Math.max(delay - (new Date().getTime() - startTime), 0));

            // Notify that the requested seek has completed
            else
                callback();

        }, delay || 0);

    };

    /**
     * Aborts the seek operation currently in progress, if any. If no seek
     * operation is in progress, this function has no effect.
     *
     * @private
     */
    var abortSeek = function abortSeek() {
        window.clearTimeout(seekTimeout);
    };

    /**
     * Advances playback to the next frame in the frames array and schedules
     * playback of the frame following that frame based on their associated
     * timestamps. If no frames exist after the next frame, playback is paused.
     *
     * @private
     */
    var continuePlayback = function continuePlayback() {

        // If frames remain after advancing, schedule next frame
        if (currentFrame + 1 < frames.length) {

            // Pull the upcoming frame
            var next = frames[currentFrame + 1];

            // Calculate the real timestamp corresponding to when the next
            // frame begins
            var nextRealTimestamp = next.timestamp - startVideoTimestamp + startRealTimestamp;

            // Calculate the relative delay between the current time and
            // the next frame start
            var delay = Math.max(nextRealTimestamp - new Date().getTime(), 0);

            // Advance to next frame after enough time has elapsed
            seekToFrame(currentFrame + 1, function frameDelayElapsed() {
                continuePlayback();
            }, delay);

        }

        // Otherwise stop playback
        else
            recording.pause();

    };

    /**
     * Fired when new frames have become available while the recording is
     * being downloaded.
     *
     * @event
     * @param {Number} duration
     *     The new duration of the recording, in milliseconds.
     */
    this.onprogress = null;

    /**
     * Fired whenever playback of the recording has started.
     *
     * @event
     */
    this.onplay = null;

    /**
     * Fired whenever playback of the recording has been paused. This may
     * happen when playback is explicitly paused with a call to pause(), or
     * when playback is implicitly paused due to reaching the end of the
     * recording.
     *
     * @event
     */
    this.onpause = null;

    /**
     * Fired whenever the playback position within the recording changes.
     *
     * @event
     * @param {Number} position
     *     The new position within the recording, in milliseconds.
     */
    this.onseek = null;

    /**
     * Connects the underlying tunnel, beginning download of the Guacamole
     * session. Playback of the Guacamole session cannot occur until at least
     * one frame worth of instructions has been downloaded.
     *
     * @param {String} data
     *     The data to send to the tunnel when connecting.
     */
    this.connect = function connect(data) {
        tunnel.connect(data);
    };

    /**
     * Disconnects the underlying tunnel, stopping further download of the
     * Guacamole session.
     */
    this.disconnect = function disconnect() {
        tunnel.disconnect();
    };

    /**
     * Returns the underlying display of the Guacamole.Client used by this
     * Guacamole.SessionRecording for playback. The display contains an Element
     * which can be added to the DOM, causing the display (and thus playback of
     * the recording) to become visible.
     *
     * @return {Guacamole.Display}
     *     The underlying display of the Guacamole.Client used by this
     *     Guacamole.SessionRecording for playback.
     */
    this.getDisplay = function getDisplay() {
        return playbackClient.getDisplay();
    };

    /**
     * Returns whether playback is currently in progress.
     *
     * @returns {Boolean}
     *     true if playback is currently in progress, false otherwise.
     */
    this.isPlaying = function isPlaying() {
        return !!startVideoTimestamp;
    };

    /**
     * Returns the current playback position within the recording, in
     * milliseconds, where zero is the start of the recording.
     *
     * @returns {Number}
     *     The current playback position within the recording, in milliseconds.
     */
    this.getPosition = function getPosition() {

        // Position is simply zero if playback has not started at all
        if (currentFrame === -1)
            return 0;

        // Return current position as a millisecond timestamp relative to the
        // start of the recording
        return toRelativeTimestamp(frames[currentFrame].timestamp);

    };

    /**
     * Returns the duration of this recording, in milliseconds. If the
     * recording is still being downloaded, this value will gradually increase.
     *
     * @returns {Number}
     *     The duration of this recording, in milliseconds.
     */
    this.getDuration = function getDuration() {

        // If no frames yet exist, duration is zero
        if (frames.length === 0)
            return 0;

        // Recording duration is simply the timestamp of the last frame
        return toRelativeTimestamp(frames[frames.length - 1].timestamp);

    };

    /**
     * Begins continuous playback of the recording downloaded thus far.
     * Playback of the recording will continue until pause() is invoked or
     * until no further frames exist. Playback is initially paused when a
     * Guacamole.SessionRecording is created, and must be explicitly started
     * through a call to this function. If playback is already in progress,
     * this function has no effect. If a seek operation is in progress,
     * playback resumes at the current position, and the seek is aborted as if
     * completed.
     */
    this.play = function play() {

        // If playback is not already in progress and frames remain,
        // begin playback
        if (!recording.isPlaying() && currentFrame + 1 < frames.length) {

            // Notify that playback is starting
            if (recording.onplay)
                recording.onplay();

            // Store timestamp of playback start for relative scheduling of
            // future frames
            var next = frames[currentFrame + 1];
            startVideoTimestamp = next.timestamp;
            startRealTimestamp = new Date().getTime();

            // Begin playback of video
            continuePlayback();

        }

    };

    /**
     * Seeks to the given position within the recording. If the recording is
     * currently being played back, playback will continue after the seek is
     * performed. If the recording is currently paused, playback will be
     * paused after the seek is performed. If a seek operation is already in
     * progress, that seek is first aborted. The seek operation will proceed
     * asynchronously.
     *
     * @param {Number} position
     *     The position within the recording to seek to, in milliseconds.
     *
     * @param {function} [callback]
     *     The callback to invoke once the seek operation has completed.
     */
    this.seek = function seek(position, callback) {

        // Do not seek if no frames exist
        if (frames.length === 0)
            return;

        // Pause playback, preserving playback state
        var originallyPlaying = recording.isPlaying();
        recording.pause();

        // Perform seek
        seekToFrame(findFrame(0, frames.length - 1, position), function restorePlaybackState() {

            // Restore playback state
            if (originallyPlaying)
                recording.play();

            // Notify that seek has completed
            if (callback)
                callback();

        });

    };

    /**
     * Pauses playback of the recording, if playback is currently in progress.
     * If playback is not in progress, this function has no effect. If a seek
     * operation is in progress, the seek is aborted. Playback is initially
     * paused when a Guacamole.SessionRecording is created, and must be
     * explicitly started through a call to play().
     */
    this.pause = function pause() {

        // Abort any in-progress seek / playback
        abortSeek();

        // Stop playback only if playback is in progress
        if (recording.isPlaying()) {

            // Notify that playback is stopping
            if (recording.onpause)
                recording.onpause();

            // Playback is stopped
            startVideoTimestamp = null;
            startRealTimestamp = null;

        }

    };

};

/**
 * A single frame of Guacamole session data. Each frame is made up of the set
 * of instructions used to generate that frame, and the timestamp as dictated
 * by the "sync" instruction terminating the frame. Optionally, a frame may
 * also be associated with a snapshot of Guacamole client state, such that the
 * frame can be rendered without replaying all previous frames.
 *
 * @private
 * @constructor
 * @param {Number} timestamp
 *     The timestamp of this frame, as dictated by the "sync" instruction which
 *     terminates the frame.
 *
 * @param {Guacamole.SessionRecording._Frame.Instruction[]} instructions
 *     All instructions which are necessary to generate this frame relative to
 *     the previous frame in the Guacamole session.
 */
Guacamole.SessionRecording._Frame = function _Frame(timestamp, instructions) {

    /**
     * Whether this frame should be used as a keyframe if possible. This value
     * is purely advisory. The stored clientState must eventually be manually
     * set for the frame to be used as a keyframe. By default, frames are not
     * keyframes.
     *
     * @type {Boolean}
     * @default false
     */
    this.keyframe = false;

    /**
     * The timestamp of this frame, as dictated by the "sync" instruction which
     * terminates the frame.
     *
     * @type {Number}
     */
    this.timestamp = timestamp;

    /**
     * All instructions which are necessary to generate this frame relative to
     * the previous frame in the Guacamole session.
     *
     * @type {Guacamole.SessionRecording._Frame.Instruction[]}
     */
    this.instructions = instructions;

    /**
     * A snapshot of client state after this frame was rendered, as returned by
     * a call to exportState(). If no such snapshot has been taken, this will
     * be null.
     *
     * @type {Object}
     * @default null
     */
    this.clientState = null;

};

/**
 * A Guacamole protocol instruction. Each Guacamole protocol instruction is
 * made up of an opcode and set of arguments.
 *
 * @private
 * @constructor
 * @param {String} opcode
 *     The opcode of this Guacamole instruction.
 *
 * @param {String[]} args
 *     All arguments associated with this Guacamole instruction.
 */
Guacamole.SessionRecording._Frame.Instruction = function Instruction(opcode, args) {

    /**
     * Reference to this Guacamole.SessionRecording._Frame.Instruction.
     *
     * @private
     * @type {Guacamole.SessionRecording._Frame.Instruction}
     */
    var instruction = this;

    /**
     * The opcode of this Guacamole instruction.
     *
     * @type {String}
     */
    this.opcode = opcode;

    /**
     * All arguments associated with this Guacamole instruction.
     *
     * @type {String[]}
     */
    this.args = args;

    /**
     * Returns the approximate number of characters which make up this
     * instruction. This value is only approximate as it excludes the length
     * prefixes and various delimiters used by the Guacamole protocol; only
     * the content of the opcode and each argument is taken into account.
     *
     * @returns {Number}
     *     The approximate size of this instruction, in characters.
     */
    this.getSize = function getSize() {

        // Init with length of opcode
        var size = instruction.opcode.length;

        // Add length of all arguments
        for (var i = 0; i < instruction.args.length; i++)
            size += instruction.args[i].length;

        return size;

    };

};

/**
 * A read-only Guacamole.Tunnel implementation which streams instructions
 * received through explicit calls to its receiveInstruction() function.
 *
 * @private
 * @constructor
 * @augments {Guacamole.Tunnel}
 */
Guacamole.SessionRecording._PlaybackTunnel = function _PlaybackTunnel() {

    /**
     * Reference to this Guacamole.SessionRecording._PlaybackTunnel.
     *
     * @private
     * @type {Guacamole.SessionRecording._PlaybackTunnel}
     */
    var tunnel = this;

    this.connect = function connect(data) {
        // Do nothing
    };

    this.sendMessage = function sendMessage(elements) {
        // Do nothing
    };

    this.disconnect = function disconnect() {
        // Do nothing
    };

    /**
     * Invokes this tunnel's oninstruction handler, notifying users of this
     * tunnel (such as a Guacamole.Client instance) that an instruction has
     * been received. If the oninstruction handler has not been set, this
     * function has no effect.
     *
     * @param {String} opcode
     *     The opcode of the Guacamole instruction.
     *
     * @param {String[]} args
     *     All arguments associated with this Guacamole instruction.
     */
    this.receiveInstruction = function receiveInstruction(opcode, args) {
        if (tunnel.oninstruction)
            tunnel.oninstruction(opcode, args);
    };

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A Guacamole status. Each Guacamole status consists of a status code, defined
 * by the protocol, and an optional human-readable message, usually only
 * included for debugging convenience.
 *
 * @constructor
 * @param {Number} code
 *     The Guacamole status code, as defined by Guacamole.Status.Code.
 *
 * @param {String} [message]
 *     An optional human-readable message.
 */
Guacamole.Status = function(code, message) {

    /**
     * Reference to this Guacamole.Status.
     * @private
     */
    var guac_status = this;

    /**
     * The Guacamole status code.
     * @see Guacamole.Status.Code
     * @type {Number}
     */
    this.code = code;

    /**
     * An arbitrary human-readable message associated with this status, if any.
     * The human-readable message is not required, and is generally provided
     * for debugging purposes only. For user feedback, it is better to translate
     * the Guacamole status code into a message.
     * 
     * @type {String}
     */
    this.message = message;

    /**
     * Returns whether this status represents an error.
     * @returns {Boolean} true if this status represents an error, false
     *                    otherwise.
     */
    this.isError = function() {
        return guac_status.code < 0 || guac_status.code > 0x00FF;
    };

};

/**
 * Enumeration of all Guacamole status codes.
 */
Guacamole.Status.Code = {

    /**
     * The operation succeeded.
     *
     * @type {Number}
     */
    "SUCCESS": 0x0000,

    /**
     * The requested operation is unsupported.
     *
     * @type {Number}
     */
    "UNSUPPORTED": 0x0100,

    /**
     * The operation could not be performed due to an internal failure.
     *
     * @type {Number}
     */
    "SERVER_ERROR": 0x0200,

    /**
     * The operation could not be performed as the server is busy.
     *
     * @type {Number}
     */
    "SERVER_BUSY": 0x0201,

    /**
     * The operation could not be performed because the upstream server is not
     * responding.
     *
     * @type {Number}
     */
    "UPSTREAM_TIMEOUT": 0x0202,

    /**
     * The operation was unsuccessful due to an error or otherwise unexpected
     * condition of the upstream server.
     *
     * @type {Number}
     */
    "UPSTREAM_ERROR": 0x0203,

    /**
     * The operation could not be performed as the requested resource does not
     * exist.
     *
     * @type {Number}
     */
    "RESOURCE_NOT_FOUND": 0x0204,

    /**
     * The operation could not be performed as the requested resource is
     * already in use.
     *
     * @type {Number}
     */
    "RESOURCE_CONFLICT": 0x0205,

    /**
     * The operation could not be performed as the requested resource is now
     * closed.
     *
     * @type {Number}
     */
    "RESOURCE_CLOSED": 0x0206,

    /**
     * The operation could not be performed because the upstream server does
     * not appear to exist.
     *
     * @type {Number}
     */
    "UPSTREAM_NOT_FOUND": 0x0207,

    /**
     * The operation could not be performed because the upstream server is not
     * available to service the request.
     *
     * @type {Number}
     */
    "UPSTREAM_UNAVAILABLE": 0x0208,

    /**
     * The session within the upstream server has ended because it conflicted
     * with another session.
     *
     * @type {Number}
     */
    "SESSION_CONFLICT": 0x0209,

    /**
     * The session within the upstream server has ended because it appeared to
     * be inactive.
     *
     * @type {Number}
     */
    "SESSION_TIMEOUT": 0x020A,

    /**
     * The session within the upstream server has been forcibly terminated.
     *
     * @type {Number}
     */
    "SESSION_CLOSED": 0x020B,

    /**
     * The operation could not be performed because bad parameters were given.
     *
     * @type {Number}
     */
    "CLIENT_BAD_REQUEST": 0x0300,

    /**
     * Permission was denied to perform the operation, as the user is not yet
     * authorized (not yet logged in, for example).
     *
     * @type {Number}
     */
    "CLIENT_UNAUTHORIZED": 0x0301,

    /**
     * Permission was denied to perform the operation, and this permission will
     * not be granted even if the user is authorized.
     *
     * @type {Number}
     */
    "CLIENT_FORBIDDEN": 0x0303,

    /**
     * The client took too long to respond.
     *
     * @type {Number}
     */
    "CLIENT_TIMEOUT": 0x0308,

    /**
     * The client sent too much data.
     *
     * @type {Number}
     */
    "CLIENT_OVERRUN": 0x030D,

    /**
     * The client sent data of an unsupported or unexpected type.
     *
     * @type {Number}
     */
    "CLIENT_BAD_TYPE": 0x030F,

    /**
     * The operation failed because the current client is already using too
     * many resources.
     *
     * @type {Number}
     */
    "CLIENT_TOO_MANY": 0x031D

};

/**
 * Returns the Guacamole protocol status code which most closely
 * represents the given HTTP status code.
 *
 * @param {Number} status
 *     The HTTP status code to translate into a Guacamole protocol status
 *     code.
 *
 * @returns {Number}
 *     The Guacamole protocol status code which most closely represents the
 *     given HTTP status code.
 */
Guacamole.Status.Code.fromHTTPCode = function fromHTTPCode(status) {

    // Translate status codes with known equivalents
    switch (status) {

        // HTTP 400 - Bad request
        case 400:
            return Guacamole.Status.Code.CLIENT_BAD_REQUEST;

        // HTTP 403 - Forbidden
        case 403:
            return Guacamole.Status.Code.CLIENT_FORBIDDEN;

        // HTTP 404 - Resource not found
        case 404:
            return Guacamole.Status.Code.RESOURCE_NOT_FOUND;

        // HTTP 429 - Too many requests
        case 429:
            return Guacamole.Status.Code.CLIENT_TOO_MANY;

        // HTTP 503 - Server unavailable
        case 503:
            return Guacamole.Status.Code.SERVER_BUSY;

    }

    // Default all other codes to generic internal error
    return Guacamole.Status.Code.SERVER_ERROR;

};

/**
 * Returns the Guacamole protocol status code which most closely
 * represents the given WebSocket status code.
 *
 * @param {Number} code
 *     The WebSocket status code to translate into a Guacamole protocol
 *     status code.
 *
 * @returns {Number}
 *     The Guacamole protocol status code which most closely represents the
 *     given WebSocket status code.
 */
Guacamole.Status.Code.fromWebSocketCode = function fromWebSocketCode(code) {

    // Translate status codes with known equivalents
    switch (code) {

        // Successful disconnect (no error)
        case 1000: // Normal Closure
            return Guacamole.Status.Code.SUCCESS;

        // Codes which indicate the server is not reachable
        case 1006: // Abnormal Closure (also signalled by JavaScript when the connection cannot be opened in the first place)
        case 1015: // TLS Handshake
            return Guacamole.Status.Code.UPSTREAM_NOT_FOUND;

        // Codes which indicate the server is reachable but busy/unavailable
        case 1001: // Going Away
        case 1012: // Service Restart
        case 1013: // Try Again Later
        case 1014: // Bad Gateway
            return Guacamole.Status.Code.UPSTREAM_UNAVAILABLE;

    }

    // Default all other codes to generic internal error
    return Guacamole.Status.Code.SERVER_ERROR;

};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A reader which automatically handles the given input stream, returning
 * strictly text data. Note that this object will overwrite any installed event
 * handlers on the given Guacamole.InputStream.
 * 
 * @constructor
 * @param {Guacamole.InputStream} stream The stream that data will be read
 *                                       from.
 */
Guacamole.StringReader = function(stream) {

    /**
     * Reference to this Guacamole.InputStream.
     * @private
     */
    var guac_reader = this;

    /**
     * Wrapped Guacamole.ArrayBufferReader.
     * @private
     * @type {Guacamole.ArrayBufferReader}
     */
    var array_reader = new Guacamole.ArrayBufferReader(stream);

    /**
     * The number of bytes remaining for the current codepoint.
     *
     * @private
     * @type {Number}
     */
    var bytes_remaining = 0;

    /**
     * The current codepoint value, as calculated from bytes read so far.
     *
     * @private
     * @type {Number}
     */
    var codepoint = 0;

    /**
     * Decodes the given UTF-8 data into a Unicode string. The data may end in
     * the middle of a multibyte character.
     * 
     * @private
     * @param {ArrayBuffer} buffer Arbitrary UTF-8 data.
     * @return {String} A decoded Unicode string.
     */
    function __decode_utf8(buffer) {

        var text = "";

        var bytes = new Uint8Array(buffer);
        for (var i=0; i<bytes.length; i++) {

            // Get current byte
            var value = bytes[i];

            // Start new codepoint if nothing yet read
            if (bytes_remaining === 0) {

                // 1 byte (0xxxxxxx)
                if ((value | 0x7F) === 0x7F)
                    text += String.fromCharCode(value);

                // 2 byte (110xxxxx)
                else if ((value | 0x1F) === 0xDF) {
                    codepoint = value & 0x1F;
                    bytes_remaining = 1;
                }

                // 3 byte (1110xxxx)
                else if ((value | 0x0F )=== 0xEF) {
                    codepoint = value & 0x0F;
                    bytes_remaining = 2;
                }

                // 4 byte (11110xxx)
                else if ((value | 0x07) === 0xF7) {
                    codepoint = value & 0x07;
                    bytes_remaining = 3;
                }

                // Invalid byte
                else
                    text += "\uFFFD";

            }

            // Continue existing codepoint (10xxxxxx)
            else if ((value | 0x3F) === 0xBF) {

                codepoint = (codepoint << 6) | (value & 0x3F);
                bytes_remaining--;

                // Write codepoint if finished
                if (bytes_remaining === 0)
                    text += String.fromCharCode(codepoint);

            }

            // Invalid byte
            else {
                bytes_remaining = 0;
                text += "\uFFFD";
            }

        }

        return text;

    }

    // Receive blobs as strings
    array_reader.ondata = function(buffer) {

        // Decode UTF-8
        var text = __decode_utf8(buffer);

        // Call handler, if present
        if (guac_reader.ontext)
            guac_reader.ontext(text);

    };

    // Simply call onend when end received
    array_reader.onend = function() {
        if (guac_reader.onend)
            guac_reader.onend();
    };

    /**
     * Fired once for every blob of text data received.
     * 
     * @event
     * @param {String} text The data packet received.
     */
    this.ontext = null;

    /**
     * Fired once this stream is finished and no further data will be written.
     * @event
     */
    this.onend = null;

};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * A writer which automatically writes to the given output stream with text
 * data.
 * 
 * @constructor
 * @param {Guacamole.OutputStream} stream The stream that data will be written
 *                                        to.
 */
Guacamole.StringWriter = function(stream) {

    /**
     * Reference to this Guacamole.StringWriter.
     * @private
     */
    var guac_writer = this;

    /**
     * Wrapped Guacamole.ArrayBufferWriter.
     * @private
     * @type {Guacamole.ArrayBufferWriter}
     */
    var array_writer = new Guacamole.ArrayBufferWriter(stream);

    /**
     * Internal buffer for UTF-8 output.
     * @private
     */
    var buffer = new Uint8Array(8192);

    /**
     * The number of bytes currently in the buffer.
     * @private
     */
    var length = 0;

    // Simply call onack for acknowledgements
    array_writer.onack = function(status) {
        if (guac_writer.onack)
            guac_writer.onack(status);
    };

    /**
     * Expands the size of the underlying buffer by the given number of bytes,
     * updating the length appropriately.
     * 
     * @private
     * @param {Number} bytes The number of bytes to add to the underlying
     *                       buffer.
     */
    function __expand(bytes) {

        // Resize buffer if more space needed
        if (length+bytes >= buffer.length) {
            var new_buffer = new Uint8Array((length+bytes)*2);
            new_buffer.set(buffer);
            buffer = new_buffer;
        }

        length += bytes;

    }

    /**
     * Appends a single Unicode character to the current buffer, resizing the
     * buffer if necessary. The character will be encoded as UTF-8.
     * 
     * @private
     * @param {Number} codepoint The codepoint of the Unicode character to
     *                           append.
     */
    function __append_utf8(codepoint) {

        var mask;
        var bytes;

        // 1 byte
        if (codepoint <= 0x7F) {
            mask = 0x00;
            bytes = 1;
        }

        // 2 byte
        else if (codepoint <= 0x7FF) {
            mask = 0xC0;
            bytes = 2;
        }

        // 3 byte
        else if (codepoint <= 0xFFFF) {
            mask = 0xE0;
            bytes = 3;
        }

        // 4 byte
        else if (codepoint <= 0x1FFFFF) {
            mask = 0xF0;
            bytes = 4;
        }

        // If invalid codepoint, append replacement character
        else {
            __append_utf8(0xFFFD);
            return;
        }

        // Offset buffer by size
        __expand(bytes);
        var offset = length - 1;

        // Add trailing bytes, if any
        for (var i=1; i<bytes; i++) {
            buffer[offset--] = 0x80 | (codepoint & 0x3F);
            codepoint >>= 6;
        }

        // Set initial byte
        buffer[offset] = mask | codepoint;

    }

    /**
     * Encodes the given string as UTF-8, returning an ArrayBuffer containing
     * the resulting bytes.
     * 
     * @private
     * @param {String} text The string to encode as UTF-8.
     * @return {Uint8Array} The encoded UTF-8 data.
     */
    function __encode_utf8(text) {

        // Fill buffer with UTF-8
        for (var i=0; i<text.length; i++) {
            var codepoint = text.charCodeAt(i);
            __append_utf8(codepoint);
        }

        // Flush buffer
        if (length > 0) {
            var out_buffer = buffer.subarray(0, length);
            length = 0;
            return out_buffer;
        }

    }

    /**
     * Sends the given text.
     * 
     * @param {String} text The text to send.
     */
    this.sendText = function(text) {
        if (text.length)
            array_writer.sendData(__encode_utf8(text));
    };

    /**
     * Signals that no further text will be sent, effectively closing the
     * stream.
     */
    this.sendEnd = function() {
        array_writer.sendEnd();
    };

    /**
     * Fired for received data, if acknowledged by the server.
     * @event
     * @param {Guacamole.Status} status The status of the operation.
     */
    this.onack = null;

};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Core object providing abstract communication for Guacamole. This object
 * is a null implementation whose functions do nothing. Guacamole applications
 * should use {@link Guacamole.HTTPTunnel} instead, or implement their own tunnel based
 * on this one.
 * 
 * @constructor
 * @see Guacamole.HTTPTunnel
 */
Guacamole.Tunnel = function() {

    /**
     * Connect to the tunnel with the given optional data. This data is
     * typically used for authentication. The format of data accepted is
     * up to the tunnel implementation.
     * 
     * @param {String} data The data to send to the tunnel when connecting.
     */
    this.connect = function(data) {};
    
    /**
     * Disconnect from the tunnel.
     */
    this.disconnect = function() {};
    
    /**
     * Send the given message through the tunnel to the service on the other
     * side. All messages are guaranteed to be received in the order sent.
     * 
     * @param {...*} elements
     *     The elements of the message to send to the service on the other side
     *     of the tunnel.
     */
    this.sendMessage = function(elements) {};

    /**
     * Changes the stored numeric state of this tunnel, firing the onstatechange
     * event if the new state is different and a handler has been defined.
     *
     * @private
     * @param {Number} state
     *     The new state of this tunnel.
     */
    this.setState = function(state) {

        // Notify only if state changes
        if (state !== this.state) {
            this.state = state;
            if (this.onstatechange)
                this.onstatechange(state);
        }

    };

    /**
     * Changes the stored UUID that uniquely identifies this tunnel, firing the
     * onuuid event if a handler has been defined.
     *
     * @private
     * @param {String} uuid
     *     The new state of this tunnel.
     */
    this.setUUID = function setUUID(uuid) {
        this.uuid = uuid;
        if (this.onuuid)
            this.onuuid(uuid);
    };

    /**
     * Returns whether this tunnel is currently connected.
     *
     * @returns {Boolean}
     *     true if this tunnel is currently connected, false otherwise.
     */
    this.isConnected = function isConnected() {
        return this.state === Guacamole.Tunnel.State.OPEN
            || this.state === Guacamole.Tunnel.State.UNSTABLE;
    };

    /**
     * The current state of this tunnel.
     * 
     * @type {Number}
     */
    this.state = Guacamole.Tunnel.State.CONNECTING;

    /**
     * The maximum amount of time to wait for data to be received, in
     * milliseconds. If data is not received within this amount of time,
     * the tunnel is closed with an error. The default value is 15000.
     *
     * @type {Number}
     */
    this.receiveTimeout = 15000;

    /**
     * The amount of time to wait for data to be received before considering
     * the connection to be unstable, in milliseconds. If data is not received
     * within this amount of time, the tunnel status is updated to warn that
     * the connection appears unresponsive and may close. The default value is
     * 1500.
     * 
     * @type {Number}
     */
    this.unstableThreshold = 1500;

    /**
     * The UUID uniquely identifying this tunnel. If not yet known, this will
     * be null.
     *
     * @type {String}
     */
    this.uuid = null;

    /**
     * Fired when the UUID that uniquely identifies this tunnel is known.
     *
     * @event
     * @param {String}
     *     The UUID uniquely identifying this tunnel.
     */
    this.onuuid = null;

    /**
     * Fired whenever an error is encountered by the tunnel.
     * 
     * @event
     * @param {Guacamole.Status} status A status object which describes the
     *                                  error.
     */
    this.onerror = null;

    /**
     * Fired whenever the state of the tunnel changes.
     * 
     * @event
     * @param {Number} state The new state of the client.
     */
    this.onstatechange = null;

    /**
     * Fired once for every complete Guacamole instruction received, in order.
     * 
     * @event
     * @param {String} opcode The Guacamole instruction opcode.
     * @param {Array} parameters The parameters provided for the instruction,
     *                           if any.
     */
    this.oninstruction = null;

};

/**
 * The Guacamole protocol instruction opcode reserved for arbitrary internal
 * use by tunnel implementations. The value of this opcode is guaranteed to be
 * the empty string (""). Tunnel implementations may use this opcode for any
 * purpose. It is currently used by the HTTP tunnel to mark the end of the HTTP
 * response, and by the WebSocket tunnel to transmit the tunnel UUID and send
 * connection stability test pings/responses.
 *
 * @constant
 * @type {String}
 */
Guacamole.Tunnel.INTERNAL_DATA_OPCODE = '';

/**
 * All possible tunnel states.
 */
Guacamole.Tunnel.State = {

    /**
     * A connection is in pending. It is not yet known whether connection was
     * successful.
     * 
     * @type {Number}
     */
    "CONNECTING": 0,

    /**
     * Connection was successful, and data is being received.
     * 
     * @type {Number}
     */
    "OPEN": 1,

    /**
     * The connection is closed. Connection may not have been successful, the
     * tunnel may have been explicitly closed by either side, or an error may
     * have occurred.
     * 
     * @type {Number}
     */
    "CLOSED": 2,

    /**
     * The connection is open, but communication through the tunnel appears to
     * be disrupted, and the connection may close as a result.
     *
     * @type {Number}
     */
    "UNSTABLE" : 3

};

/**
 * Guacamole Tunnel implemented over HTTP via XMLHttpRequest.
 * 
 * @constructor
 * @augments Guacamole.Tunnel
 *
 * @param {String} tunnelURL
 *     The URL of the HTTP tunneling service.
 *
 * @param {Boolean} [crossDomain=false]
 *     Whether tunnel requests will be cross-domain, and thus must use CORS
 *     mechanisms and headers. By default, it is assumed that tunnel requests
 *     will be made to the same domain.
 *
 * @param {Object} [extraTunnelHeaders={}]
 *     Key value pairs containing the header names and values of any additional
 *     headers to be sent in tunnel requests. By default, no extra headers will
 *     be added.
 */
Guacamole.HTTPTunnel = function(tunnelURL, crossDomain, extraTunnelHeaders) {

    /**
     * Reference to this HTTP tunnel.
     * @private
     */
    var tunnel = this;

    var TUNNEL_CONNECT = tunnelURL + "?connect";
    var TUNNEL_READ    = tunnelURL + "?read:";
    var TUNNEL_WRITE   = tunnelURL + "?write:";

    var POLLING_ENABLED     = 1;
    var POLLING_DISABLED    = 0;

    // Default to polling - will be turned off automatically if not needed
    var pollingMode = POLLING_ENABLED;

    var sendingMessages = false;
    var outputMessageBuffer = "";

    // If requests are expected to be cross-domain, the cookie that the HTTP
    // tunnel depends on will only be sent if withCredentials is true
    var withCredentials = !!crossDomain;

    /**
     * The current receive timeout ID, if any.
     * @private
     */
    var receive_timeout = null;

    /**
     * The current connection stability timeout ID, if any.
     *
     * @private
     * @type {Number}
     */
    var unstableTimeout = null;

    /**
     * The current connection stability test ping interval ID, if any. This
     * will only be set upon successful connection.
     *
     * @private
     * @type {Number}
     */
    var pingInterval = null;

    /**
     * The number of milliseconds to wait between connection stability test
     * pings.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var PING_FREQUENCY = 500;

    /**
     * Additional headers to be sent in tunnel requests. This dictionary can be
     * populated with key/value header pairs to pass information such as authentication
     * tokens, etc.
     *
     * @private
     */
    var extraHeaders = extraTunnelHeaders || {};

    /**
     * Adds the configured additional headers to the given request.
     *
     * @param {XMLHttpRequest} request
     *     The request where the configured extra headers will be added.
     *
     * @param {Object} headers
     *     The headers to be added to the request.
     *
     * @private
     */
    function addExtraHeaders(request, headers) {
        for (var name in headers) {
            request.setRequestHeader(name, headers[name]);
        }
    }

    /**
     * Initiates a timeout which, if data is not received, causes the tunnel
     * to close with an error.
     * 
     * @private
     */
    function reset_timeout() {

        // Get rid of old timeouts (if any)
        window.clearTimeout(receive_timeout);
        window.clearTimeout(unstableTimeout);

        // Clear unstable status
        if (tunnel.state === Guacamole.Tunnel.State.UNSTABLE)
            tunnel.setState(Guacamole.Tunnel.State.OPEN);

        // Set new timeout for tracking overall connection timeout
        receive_timeout = window.setTimeout(function () {
            close_tunnel(new Guacamole.Status(Guacamole.Status.Code.UPSTREAM_TIMEOUT, "Server timeout."));
        }, tunnel.receiveTimeout);

        // Set new timeout for tracking suspected connection instability
        unstableTimeout = window.setTimeout(function() {
            tunnel.setState(Guacamole.Tunnel.State.UNSTABLE);
        }, tunnel.unstableThreshold);

    }

    /**
     * Closes this tunnel, signaling the given status and corresponding
     * message, which will be sent to the onerror handler if the status is
     * an error status.
     * 
     * @private
     * @param {Guacamole.Status} status The status causing the connection to
     *                                  close;
     */
    function close_tunnel(status) {

        // Get rid of old timeouts (if any)
        window.clearTimeout(receive_timeout);
        window.clearTimeout(unstableTimeout);

        // Cease connection test pings
        window.clearInterval(pingInterval);

        // Ignore if already closed
        if (tunnel.state === Guacamole.Tunnel.State.CLOSED)
            return;

        // If connection closed abnormally, signal error.
        if (status.code !== Guacamole.Status.Code.SUCCESS && tunnel.onerror) {

            // Ignore RESOURCE_NOT_FOUND if we've already connected, as that
            // only signals end-of-stream for the HTTP tunnel.
            if (tunnel.state === Guacamole.Tunnel.State.CONNECTING
                    || status.code !== Guacamole.Status.Code.RESOURCE_NOT_FOUND)
                tunnel.onerror(status);

        }

        // Reset output message buffer
        sendingMessages = false;

        // Mark as closed
        tunnel.setState(Guacamole.Tunnel.State.CLOSED);

    }


    this.sendMessage = function() {

        // Do not attempt to send messages if not connected
        if (!tunnel.isConnected())
            return;

        // Do not attempt to send empty messages
        if (arguments.length === 0)
            return;

        /**
         * Converts the given value to a length/string pair for use as an
         * element in a Guacamole instruction.
         * 
         * @private
         * @param value The value to convert.
         * @return {String} The converted value. 
         */
        function getElement(value) {
            var string = new String(value);
            return string.length + "." + string; 
        }

        // Initialized message with first element
        var message = getElement(arguments[0]);

        // Append remaining elements
        for (var i=1; i<arguments.length; i++)
            message += "," + getElement(arguments[i]);

        // Final terminator
        message += ";";

        // Add message to buffer
        outputMessageBuffer += message;

        // Send if not currently sending
        if (!sendingMessages)
            sendPendingMessages();

    };

    function sendPendingMessages() {

        // Do not attempt to send messages if not connected
        if (!tunnel.isConnected())
            return;

        if (outputMessageBuffer.length > 0) {

            sendingMessages = true;

            var message_xmlhttprequest = new XMLHttpRequest();
            message_xmlhttprequest.open("POST", TUNNEL_WRITE + tunnel.uuid);
            message_xmlhttprequest.withCredentials = withCredentials;
            addExtraHeaders(message_xmlhttprequest, extraHeaders);
            message_xmlhttprequest.setRequestHeader("Content-type", "application/octet-stream");

            // Once response received, send next queued event.
            message_xmlhttprequest.onreadystatechange = function() {
                if (message_xmlhttprequest.readyState === 4) {

                    reset_timeout();

                    // If an error occurs during send, handle it
                    if (message_xmlhttprequest.status !== 200)
                        handleHTTPTunnelError(message_xmlhttprequest);

                    // Otherwise, continue the send loop
                    else
                        sendPendingMessages();

                }
            };

            message_xmlhttprequest.send(outputMessageBuffer);
            outputMessageBuffer = ""; // Clear buffer

        }
        else
            sendingMessages = false;

    }

    function handleHTTPTunnelError(xmlhttprequest) {

        // Pull status code directly from headers provided by Guacamole
        var code = parseInt(xmlhttprequest.getResponseHeader("Guacamole-Status-Code"));
        if (code) {
            var message = xmlhttprequest.getResponseHeader("Guacamole-Error-Message");
            close_tunnel(new Guacamole.Status(code, message));
        }

        // Failing that, derive a Guacamole status code from the HTTP status
        // code provided by the browser
        else if (xmlhttprequest.status)
            close_tunnel(new Guacamole.Status(
                Guacamole.Status.Code.fromHTTPCode(xmlhttprequest.status),
                    xmlhttprequest.statusText));

        // Otherwise, assume server is unreachable
        else
            close_tunnel(new Guacamole.Status(Guacamole.Status.Code.UPSTREAM_NOT_FOUND));

    }

    function handleResponse(xmlhttprequest) {

        var interval = null;
        var nextRequest = null;

        var dataUpdateEvents = 0;

        // The location of the last element's terminator
        var elementEnd = -1;

        // Where to start the next length search or the next element
        var startIndex = 0;

        // Parsed elements
        var elements = new Array();

        function parseResponse() {

            // Do not handle responses if not connected
            if (!tunnel.isConnected()) {
                
                // Clean up interval if polling
                if (interval !== null)
                    clearInterval(interval);
                
                return;
            }

            // Do not parse response yet if not ready
            if (xmlhttprequest.readyState < 2) return;

            // Attempt to read status
            var status;
            try { status = xmlhttprequest.status; }

            // If status could not be read, assume successful.
            catch (e) { status = 200; }

            // Start next request as soon as possible IF request was successful
            if (!nextRequest && status === 200)
                nextRequest = makeRequest();

            // Parse stream when data is received and when complete.
            if (xmlhttprequest.readyState === 3 ||
                xmlhttprequest.readyState === 4) {

                reset_timeout();

                // Also poll every 30ms (some browsers don't repeatedly call onreadystatechange for new data)
                if (pollingMode === POLLING_ENABLED) {
                    if (xmlhttprequest.readyState === 3 && !interval)
                        interval = setInterval(parseResponse, 30);
                    else if (xmlhttprequest.readyState === 4 && interval)
                        clearInterval(interval);
                }

                // If canceled, stop transfer
                if (xmlhttprequest.status === 0) {
                    tunnel.disconnect();
                    return;
                }

                // Halt on error during request
                else if (xmlhttprequest.status !== 200) {
                    handleHTTPTunnelError(xmlhttprequest);
                    return;
                }

                // Attempt to read in-progress data
                var current;
                try { current = xmlhttprequest.responseText; }

                // Do not attempt to parse if data could not be read
                catch (e) { return; }

                // While search is within currently received data
                while (elementEnd < current.length) {

                    // If we are waiting for element data
                    if (elementEnd >= startIndex) {

                        // We now have enough data for the element. Parse.
                        var element = current.substring(startIndex, elementEnd);
                        var terminator = current.substring(elementEnd, elementEnd+1);

                        // Add element to array
                        elements.push(element);

                        // If last element, handle instruction
                        if (terminator === ";") {

                            // Get opcode
                            var opcode = elements.shift();

                            // Call instruction handler.
                            if (tunnel.oninstruction)
                                tunnel.oninstruction(opcode, elements);

                            // Clear elements
                            elements.length = 0;

                        }

                        // Start searching for length at character after
                        // element terminator
                        startIndex = elementEnd + 1;

                    }

                    // Search for end of length
                    var lengthEnd = current.indexOf(".", startIndex);
                    if (lengthEnd !== -1) {

                        // Parse length
                        var length = parseInt(current.substring(elementEnd+1, lengthEnd));

                        // If we're done parsing, handle the next response.
                        if (length === 0) {

                            // Clean up interval if polling
                            if (interval)
                                clearInterval(interval);
                           
                            // Clean up object
                            xmlhttprequest.onreadystatechange = null;
                            xmlhttprequest.abort();

                            // Start handling next request
                            if (nextRequest)
                                handleResponse(nextRequest);

                            // Done parsing
                            break;

                        }

                        // Calculate start of element
                        startIndex = lengthEnd + 1;

                        // Calculate location of element terminator
                        elementEnd = startIndex + length;

                    }
                    
                    // If no period yet, continue search when more data
                    // is received
                    else {
                        startIndex = current.length;
                        break;
                    }

                } // end parse loop

            }

        }

        // If response polling enabled, attempt to detect if still
        // necessary (via wrapping parseResponse())
        if (pollingMode === POLLING_ENABLED) {
            xmlhttprequest.onreadystatechange = function() {

                // If we receive two or more readyState==3 events,
                // there is no need to poll.
                if (xmlhttprequest.readyState === 3) {
                    dataUpdateEvents++;
                    if (dataUpdateEvents >= 2) {
                        pollingMode = POLLING_DISABLED;
                        xmlhttprequest.onreadystatechange = parseResponse;
                    }
                }

                parseResponse();
            };
        }

        // Otherwise, just parse
        else
            xmlhttprequest.onreadystatechange = parseResponse;

        parseResponse();

    }

    /**
     * Arbitrary integer, unique for each tunnel read request.
     * @private
     */
    var request_id = 0;

    function makeRequest() {

        // Make request, increment request ID
        var xmlhttprequest = new XMLHttpRequest();
        xmlhttprequest.open("GET", TUNNEL_READ + tunnel.uuid + ":" + (request_id++));
        xmlhttprequest.withCredentials = withCredentials;
        addExtraHeaders(xmlhttprequest, extraHeaders);
        xmlhttprequest.send(null);

        return xmlhttprequest;

    }

    this.connect = function(data) {

        // Start waiting for connect
        reset_timeout();

        // Mark the tunnel as connecting
        tunnel.setState(Guacamole.Tunnel.State.CONNECTING);

        // Start tunnel and connect
        var connect_xmlhttprequest = new XMLHttpRequest();
        connect_xmlhttprequest.onreadystatechange = function() {

            if (connect_xmlhttprequest.readyState !== 4)
                return;

            // If failure, throw error
            if (connect_xmlhttprequest.status !== 200) {
                handleHTTPTunnelError(connect_xmlhttprequest);
                return;
            }

            reset_timeout();

            // Get UUID from response
            tunnel.setUUID(connect_xmlhttprequest.responseText);

            // Mark as open
            tunnel.setState(Guacamole.Tunnel.State.OPEN);

            // Ping tunnel endpoint regularly to test connection stability
            pingInterval = setInterval(function sendPing() {
                tunnel.sendMessage("nop");
            }, PING_FREQUENCY);

            // Start reading data
            handleResponse(makeRequest());

        };

        connect_xmlhttprequest.open("POST", TUNNEL_CONNECT, true);
        connect_xmlhttprequest.withCredentials = withCredentials;
        addExtraHeaders(connect_xmlhttprequest, extraHeaders);
        connect_xmlhttprequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded; charset=UTF-8");
        connect_xmlhttprequest.send(data);

    };

    this.disconnect = function() {
        close_tunnel(new Guacamole.Status(Guacamole.Status.Code.SUCCESS, "Manually closed."));
    };

};

Guacamole.HTTPTunnel.prototype = new Guacamole.Tunnel();

/**
 * Guacamole Tunnel implemented over WebSocket via XMLHttpRequest.
 * 
 * @constructor
 * @augments Guacamole.Tunnel
 * @param {String} tunnelURL The URL of the WebSocket tunneling service.
 */
Guacamole.WebSocketTunnel = function(tunnelURL) {

    /**
     * Reference to this WebSocket tunnel.
     * @private
     */
    var tunnel = this;

    /**
     * The WebSocket used by this tunnel.
     * @private
     */
    var socket = null;

    /**
     * The current receive timeout ID, if any.
     * @private
     */
    var receive_timeout = null;

    /**
     * The current connection stability timeout ID, if any.
     *
     * @private
     * @type {Number}
     */
    var unstableTimeout = null;

    /**
     * The current connection stability test ping interval ID, if any. This
     * will only be set upon successful connection.
     *
     * @private
     * @type {Number}
     */
    var pingInterval = null;

    /**
     * The WebSocket protocol corresponding to the protocol used for the current
     * location.
     * @private
     */
    var ws_protocol = {
        "http:":  "ws:",
        "https:": "wss:"
    };

    /**
     * The number of milliseconds to wait between connection stability test
     * pings.
     *
     * @private
     * @constant
     * @type {Number}
     */
    var PING_FREQUENCY = 500;

    // Transform current URL to WebSocket URL

    // If not already a websocket URL
    if (   tunnelURL.substring(0, 3) !== "ws:"
        && tunnelURL.substring(0, 4) !== "wss:") {

        var protocol = ws_protocol[window.location.protocol];

        // If absolute URL, convert to absolute WS URL
        if (tunnelURL.substring(0, 1) === "/")
            tunnelURL =
                protocol
                + "//" + window.location.host
                + tunnelURL;

        // Otherwise, construct absolute from relative URL
        else {

            // Get path from pathname
            var slash = window.location.pathname.lastIndexOf("/");
            var path  = window.location.pathname.substring(0, slash + 1);

            // Construct absolute URL
            tunnelURL =
                protocol
                + "//" + window.location.host
                + path
                + tunnelURL;

        }

    }

    /**
     * Initiates a timeout which, if data is not received, causes the tunnel
     * to close with an error.
     * 
     * @private
     */
    function reset_timeout() {

        // Get rid of old timeouts (if any)
        window.clearTimeout(receive_timeout);
        window.clearTimeout(unstableTimeout);

        // Clear unstable status
        if (tunnel.state === Guacamole.Tunnel.State.UNSTABLE)
            tunnel.setState(Guacamole.Tunnel.State.OPEN);

        // Set new timeout for tracking overall connection timeout
        receive_timeout = window.setTimeout(function () {
            close_tunnel(new Guacamole.Status(Guacamole.Status.Code.UPSTREAM_TIMEOUT, "Server timeout."));
        }, tunnel.receiveTimeout);

        // Set new timeout for tracking suspected connection instability
        unstableTimeout = window.setTimeout(function() {
            tunnel.setState(Guacamole.Tunnel.State.UNSTABLE);
        }, tunnel.unstableThreshold);

    }

    /**
     * Closes this tunnel, signaling the given status and corresponding
     * message, which will be sent to the onerror handler if the status is
     * an error status.
     * 
     * @private
     * @param {Guacamole.Status} status The status causing the connection to
     *                                  close;
     */
    function close_tunnel(status) {

        // Get rid of old timeouts (if any)
        window.clearTimeout(receive_timeout);
        window.clearTimeout(unstableTimeout);

        // Cease connection test pings
        window.clearInterval(pingInterval);

        // Ignore if already closed
        if (tunnel.state === Guacamole.Tunnel.State.CLOSED)
            return;

        // If connection closed abnormally, signal error.
        if (status.code !== Guacamole.Status.Code.SUCCESS && tunnel.onerror)
            tunnel.onerror(status);

        // Mark as closed
        tunnel.setState(Guacamole.Tunnel.State.CLOSED);

        socket.close();

    }

    this.sendMessage = function(elements) {

        // Do not attempt to send messages if not connected
        if (!tunnel.isConnected())
            return;

        // Do not attempt to send empty messages
        if (arguments.length === 0)
            return;

        /**
         * Converts the given value to a length/string pair for use as an
         * element in a Guacamole instruction.
         * 
         * @private
         * @param value The value to convert.
         * @return {String} The converted value. 
         */
        function getElement(value) {
            var string = new String(value);
            return string.length + "." + string; 
        }

        // Initialized message with first element
        var message = getElement(arguments[0]);

        // Append remaining elements
        for (var i=1; i<arguments.length; i++)
            message += "," + getElement(arguments[i]);

        // Final terminator
        message += ";";

        socket.send(message);

    };

    this.connect = function(data) {

        reset_timeout();

        // Mark the tunnel as connecting
        tunnel.setState(Guacamole.Tunnel.State.CONNECTING);

        // Connect socket
        socket = new WebSocket(tunnelURL + "?" + data, "guacamole");

        socket.onopen = function(event) {
            reset_timeout();

            // Ping tunnel endpoint regularly to test connection stability
            pingInterval = setInterval(function sendPing() {
                tunnel.sendMessage(Guacamole.Tunnel.INTERNAL_DATA_OPCODE,
                    "ping", new Date().getTime());
            }, PING_FREQUENCY);

        };

        socket.onclose = function(event) {

            // Pull status code directly from closure reason provided by Guacamole
            if (event.reason)
                close_tunnel(new Guacamole.Status(parseInt(event.reason), event.reason));

            // Failing that, derive a Guacamole status code from the WebSocket
            // status code provided by the browser
            else if (event.code)
                close_tunnel(new Guacamole.Status(Guacamole.Status.Code.fromWebSocketCode(event.code)));

            // Otherwise, assume server is unreachable
            else
                close_tunnel(new Guacamole.Status(Guacamole.Status.Code.UPSTREAM_NOT_FOUND));

        };
        
        socket.onmessage = function(event) {

            reset_timeout();

            var message = event.data;
            var startIndex = 0;
            var elementEnd;

            var elements = [];

            do {

                // Search for end of length
                var lengthEnd = message.indexOf(".", startIndex);
                if (lengthEnd !== -1) {

                    // Parse length
                    var length = parseInt(message.substring(elementEnd+1, lengthEnd));

                    // Calculate start of element
                    startIndex = lengthEnd + 1;

                    // Calculate location of element terminator
                    elementEnd = startIndex + length;

                }
                
                // If no period, incomplete instruction.
                else
                    close_tunnel(new Guacamole.Status(Guacamole.Status.Code.SERVER_ERROR, "Incomplete instruction."));

                // We now have enough data for the element. Parse.
                var element = message.substring(startIndex, elementEnd);
                var terminator = message.substring(elementEnd, elementEnd+1);

                // Add element to array
                elements.push(element);

                // If last element, handle instruction
                if (terminator === ";") {

                    // Get opcode
                    var opcode = elements.shift();

                    // Update state and UUID when first instruction received
                    if (tunnel.uuid === null) {

                        // Associate tunnel UUID if received
                        if (opcode === Guacamole.Tunnel.INTERNAL_DATA_OPCODE)
                            tunnel.setUUID(elements[0]);

                        // Tunnel is now open and UUID is available
                        tunnel.setState(Guacamole.Tunnel.State.OPEN);

                    }

                    // Call instruction handler.
                    if (opcode !== Guacamole.Tunnel.INTERNAL_DATA_OPCODE && tunnel.oninstruction)
                        tunnel.oninstruction(opcode, elements);

                    // Clear elements
                    elements.length = 0;

                }

                // Start searching for length at character after
                // element terminator
                startIndex = elementEnd + 1;

            } while (startIndex < message.length);

        };

    };

    this.disconnect = function() {
        close_tunnel(new Guacamole.Status(Guacamole.Status.Code.SUCCESS, "Manually closed."));
    };

};

Guacamole.WebSocketTunnel.prototype = new Guacamole.Tunnel();

/**
 * Guacamole Tunnel which cycles between all specified tunnels until
 * no tunnels are left. Another tunnel is used if an error occurs but
 * no instructions have been received. If an instruction has been
 * received, or no tunnels remain, the error is passed directly out
 * through the onerror handler (if defined).
 * 
 * @constructor
 * @augments Guacamole.Tunnel
 * @param {...*} tunnelChain
 *     The tunnels to use, in order of priority.
 */
Guacamole.ChainedTunnel = function(tunnelChain) {

    /**
     * Reference to this chained tunnel.
     * @private
     */
    var chained_tunnel = this;

    /**
     * Data passed in via connect(), to be used for
     * wrapped calls to other tunnels' connect() functions.
     * @private
     */
    var connect_data;

    /**
     * Array of all tunnels passed to this ChainedTunnel through the
     * constructor arguments.
     * @private
     */
    var tunnels = [];

    /**
     * The tunnel committed via commit_tunnel(), if any, or null if no tunnel
     * has yet been committed.
     *
     * @private
     * @type {Guacamole.Tunnel}
     */
    var committedTunnel = null;

    // Load all tunnels into array
    for (var i=0; i<arguments.length; i++)
        tunnels.push(arguments[i]);

    /**
     * Sets the current tunnel.
     * 
     * @private
     * @param {Guacamole.Tunnel} tunnel The tunnel to set as the current tunnel.
     */
    function attach(tunnel) {

        // Set own functions to tunnel's functions
        chained_tunnel.disconnect  = tunnel.disconnect;
        chained_tunnel.sendMessage = tunnel.sendMessage;

        /**
         * Fails the currently-attached tunnel, attaching a new tunnel if
         * possible.
         *
         * @private
         * @param {Guacamole.Status} [status]
         *     An object representing the failure that occured in the
         *     currently-attached tunnel, if known.
         *
         * @return {Guacamole.Tunnel}
         *     The next tunnel, or null if there are no more tunnels to try or
         *     if no more tunnels should be tried.
         */
        var failTunnel = function failTunnel(status) {

            // Do not attempt to continue using next tunnel on server timeout
            if (status && status.code === Guacamole.Status.Code.UPSTREAM_TIMEOUT) {
                tunnels = [];
                return null;
            }

            // Get next tunnel
            var next_tunnel = tunnels.shift();

            // If there IS a next tunnel, try using it.
            if (next_tunnel) {
                tunnel.onerror = null;
                tunnel.oninstruction = null;
                tunnel.onstatechange = null;
                attach(next_tunnel);
            }

            return next_tunnel;

        };

        /**
         * Use the current tunnel from this point forward. Do not try any more
         * tunnels, even if the current tunnel fails.
         * 
         * @private
         */
        function commit_tunnel() {

            tunnel.onstatechange = chained_tunnel.onstatechange;
            tunnel.oninstruction = chained_tunnel.oninstruction;
            tunnel.onerror = chained_tunnel.onerror;
            tunnel.onuuid = chained_tunnel.onuuid;

            // Assign UUID if already known
            if (tunnel.uuid)
                chained_tunnel.setUUID(tunnel.uuid);

            committedTunnel = tunnel;

        }

        // Wrap own onstatechange within current tunnel
        tunnel.onstatechange = function(state) {

            switch (state) {

                // If open, use this tunnel from this point forward.
                case Guacamole.Tunnel.State.OPEN:
                    commit_tunnel();
                    if (chained_tunnel.onstatechange)
                        chained_tunnel.onstatechange(state);
                    break;

                // If closed, mark failure, attempt next tunnel
                case Guacamole.Tunnel.State.CLOSED:
                    if (!failTunnel() && chained_tunnel.onstatechange)
                        chained_tunnel.onstatechange(state);
                    break;
                
            }

        };

        // Wrap own oninstruction within current tunnel
        tunnel.oninstruction = function(opcode, elements) {

            // Accept current tunnel
            commit_tunnel();

            // Invoke handler
            if (chained_tunnel.oninstruction)
                chained_tunnel.oninstruction(opcode, elements);

        };

        // Attach next tunnel on error
        tunnel.onerror = function(status) {

            // Mark failure, attempt next tunnel
            if (!failTunnel(status) && chained_tunnel.onerror)
                chained_tunnel.onerror(status);

        };

        // Attempt connection
        tunnel.connect(connect_data);
        
    }

    this.connect = function(data) {
       
        // Remember connect data
        connect_data = data;

        // Get committed tunnel if exists or the first tunnel on the list
        var next_tunnel = committedTunnel ? committedTunnel : tunnels.shift();

        // Attach first tunnel
        if (next_tunnel)
            attach(next_tunnel);

        // If there IS no first tunnel, error
        else if (chained_tunnel.onerror)
            chained_tunnel.onerror(Guacamole.Status.Code.SERVER_ERROR, "No tunnels to try.");

    };
    
};

Guacamole.ChainedTunnel.prototype = new Guacamole.Tunnel();

/**
 * Guacamole Tunnel which replays a Guacamole protocol dump from a static file
 * received via HTTP. Instructions within the file are parsed and handled as
 * quickly as possible, while the file is being downloaded.
 *
 * @constructor
 * @augments Guacamole.Tunnel
 * @param {String} url
 *     The URL of a Guacamole protocol dump.
 *
 * @param {Boolean} [crossDomain=false]
 *     Whether tunnel requests will be cross-domain, and thus must use CORS
 *     mechanisms and headers. By default, it is assumed that tunnel requests
 *     will be made to the same domain.
 *
 * @param {Object} [extraTunnelHeaders={}]
 *     Key value pairs containing the header names and values of any additional
 *     headers to be sent in tunnel requests. By default, no extra headers will
 *     be added.
 */
Guacamole.StaticHTTPTunnel = function StaticHTTPTunnel(url, crossDomain, extraTunnelHeaders) {

    /**
     * Reference to this Guacamole.StaticHTTPTunnel.
     *
     * @private
     */
    var tunnel = this;

    /**
     * The current, in-progress HTTP request. If no request is currently in
     * progress, this will be null.
     *
     * @private
     * @type {XMLHttpRequest}
     */
    var xhr = null;

    /**
     * Additional headers to be sent in tunnel requests. This dictionary can be
     * populated with key/value header pairs to pass information such as authentication
     * tokens, etc.
     *
     * @private
     */
    var extraHeaders = extraTunnelHeaders || {};

    /**
     * Adds the configured additional headers to the given request.
     *
     * @param {XMLHttpRequest} request
     *     The request where the configured extra headers will be added.
     *
     * @param {Object} headers
     *     The headers to be added to the request.
     *
     * @private
     */
    function addExtraHeaders(request, headers) {
        for (var name in headers) {
            request.setRequestHeader(name, headers[name]);
        }
    }

    this.sendMessage = function sendMessage(elements) {
        // Do nothing
    };

    this.connect = function connect(data) {

        // Ensure any existing connection is killed
        tunnel.disconnect();

        // Connection is now starting
        tunnel.setState(Guacamole.Tunnel.State.CONNECTING);

        // Start a new connection
        xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.withCredentials = !!crossDomain;
        addExtraHeaders(xhr, extraHeaders);
        xhr.responseType = 'text';
        xhr.send(null);

        var offset = 0;

        // Create Guacamole protocol parser specifically for this connection
        var parser = new Guacamole.Parser();

        // Invoke tunnel's oninstruction handler for each parsed instruction
        parser.oninstruction = function instructionReceived(opcode, args) {
            if (tunnel.oninstruction)
                tunnel.oninstruction(opcode, args);
        };

        // Continuously parse received data
        xhr.onreadystatechange = function readyStateChanged() {

            // Parse while data is being received
            if (xhr.readyState === 3 || xhr.readyState === 4) {

                // Connection is open
                tunnel.setState(Guacamole.Tunnel.State.OPEN);

                var buffer = xhr.responseText;
                var length = buffer.length;

                // Parse only the portion of data which is newly received
                if (offset < length) {
                    parser.receive(buffer.substring(offset));
                    offset = length;
                }

            }

            // Clean up and close when done
            if (xhr.readyState === 4)
                tunnel.disconnect();

        };

        // Reset state and close upon error
        xhr.onerror = function httpError() {

            // Fail if file could not be downloaded via HTTP
            if (tunnel.onerror)
                tunnel.onerror(new Guacamole.Status(
                    Guacamole.Status.Code.fromHTTPCode(xhr.status), xhr.statusText));

            tunnel.disconnect();
        };

    };

    this.disconnect = function disconnect() {

        // Abort and dispose of XHR if a request is in progress
        if (xhr) {
            xhr.abort();
            xhr = null;
        }

        // Connection is now closed
        tunnel.setState(Guacamole.Tunnel.State.CLOSED);

    };

};

Guacamole.StaticHTTPTunnel.prototype = new Guacamole.Tunnel();

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * The unique ID of this version of the Guacamole JavaScript API. This ID will
 * be the version string of the guacamole-common-js Maven project, and can be
 * used in downstream applications as a sanity check that the proper version
 * of the APIs is being used (in case an older version is cached, for example).
 *
 * @type {String}
 */
Guacamole.API_VERSION = "1.3.0";

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Guacamole = Guacamole || {};

/**
 * Abstract video player which accepts, queues and plays back arbitrary video
 * data. It is up to implementations of this class to provide some means of
 * handling a provided Guacamole.InputStream and rendering the received data to
 * the provided Guacamole.Display.VisibleLayer. Data received along the
 * provided stream is to be played back immediately.
 *
 * @constructor
 */
Guacamole.VideoPlayer = function VideoPlayer() {

    /**
     * Notifies this Guacamole.VideoPlayer that all video up to the current
     * point in time has been given via the underlying stream, and that any
     * difference in time between queued video data and the current time can be
     * considered latency.
     */
    this.sync = function sync() {
        // Default implementation - do nothing
    };

};

/**
 * Determines whether the given mimetype is supported by any built-in
 * implementation of Guacamole.VideoPlayer, and thus will be properly handled
 * by Guacamole.VideoPlayer.getInstance().
 *
 * @param {String} mimetype
 *     The mimetype to check.
 *
 * @returns {Boolean}
 *     true if the given mimetype is supported by any built-in
 *     Guacamole.VideoPlayer, false otherwise.
 */
Guacamole.VideoPlayer.isSupportedType = function isSupportedType(mimetype) {

    // There are currently no built-in video players (and therefore no
    // supported types)
    return false;

};

/**
 * Returns a list of all mimetypes supported by any built-in
 * Guacamole.VideoPlayer, in rough order of priority. Beware that only the core
 * mimetypes themselves will be listed. Any mimetype parameters, even required
 * ones, will not be included in the list.
 *
 * @returns {String[]}
 *     A list of all mimetypes supported by any built-in Guacamole.VideoPlayer,
 *     excluding any parameters.
 */
Guacamole.VideoPlayer.getSupportedTypes = function getSupportedTypes() {

    // There are currently no built-in video players (and therefore no
    // supported types)
    return [];

};

/**
 * Returns an instance of Guacamole.VideoPlayer providing support for the given
 * video format. If support for the given video format is not available, null
 * is returned.
 *
 * @param {Guacamole.InputStream} stream
 *     The Guacamole.InputStream to read video data from.
 *
 * @param {Guacamole.Display.VisibleLayer} layer
 *     The destination layer in which this Guacamole.VideoPlayer should play
 *     the received video data.
 *
 * @param {String} mimetype
 *     The mimetype of the video data in the provided stream.
 *
 * @return {Guacamole.VideoPlayer}
 *     A Guacamole.VideoPlayer instance supporting the given mimetype and
 *     reading from the given stream, or null if support for the given mimetype
 *     is absent.
 */
Guacamole.VideoPlayer.getInstance = function getInstance(stream, layer, mimetype) {

    // There are currently no built-in video players
    return null;

};
module.exports = Guacamole;

/***/ }),

/***/ 5298:
/*!**************************!*\
  !*** ./Scripts/DnLib.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Greeter": function() { return /* binding */ Greeter; },
/* harmony export */   "TestClass2": function() { return /* binding */ TestClass2; },
/* harmony export */   "TestClass1": function() { return /* binding */ TestClass1; }
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var Greeter = /** @class */ (function () {
    function Greeter() {
    }
    Greeter.greet = function (message) {
        return "Hello, " + message + "!";
    };
    return Greeter;
}());

var TestClass2 = /** @class */ (function () {
    function TestClass2() {
    }
    TestClass2.Hello2 = function (message) {
        console.log("Hello " + message);
    };
    return TestClass2;
}());

var TestClass1 = /** @class */ (function () {
    function TestClass1() {
    }
    TestClass1.Hello = function (message) {
        console.log("Hello " + message);
    };
    TestClass1.SleepAsync = function (msec) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        setTimeout(function () {
                            resolve();
                        }, msec);
                    })];
            });
        });
    };
    TestClass1.HelloAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.log("start");
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < 20)) return [3 /*break*/, 4];
                        if (i >= 10) {
                            throw "This is Error !!!";
                        }
                        return [4 /*yield*/, this.SleepAsync(50)];
                    case 2:
                        _a.sent();
                        console.log("Neko_ 111 : " + i);
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4:
                        console.log("end");
                        return [2 /*return*/];
                }
            });
        });
    };
    return TestClass1;
}());



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!**************************!*\
  !*** ./Scripts/DnApp.ts ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tom": function() { return /* binding */ Tom; },
/* harmony export */   "default": function() { return /* binding */ sampleFunctionExported1; },
/* harmony export */   "TestFunc2": function() { return /* binding */ TestFunc2; }
/* harmony export */ });
/* harmony import */ var core_js_es_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/es/promise */ 7633);
/* harmony import */ var core_js_es_promise__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_es_promise__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _DnLib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DnLib */ 5298);
/* harmony import */ var guacamole_common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! guacamole-common-js */ 8943);
/* harmony import */ var guacamole_common_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(guacamole_common_js__WEBPACK_IMPORTED_MODULE_2__);



//import * as Guacamole from "./guacamole-common";
//console.log("Hello World");
//alert(Greeter.greet("world 021"));
_DnLib__WEBPACK_IMPORTED_MODULE_1__.TestClass2.Hello2("Inu");
_DnLib__WEBPACK_IMPORTED_MODULE_1__.TestClass1.Hello("Neko");
//TestFunc1();
function x() { }
function TestFunc1() {
    console.log("--a");
    var task = _DnLib__WEBPACK_IMPORTED_MODULE_1__.TestClass1.HelloAsync();
    task["catch"](function (x) {
        alert(x);
    });
    console.log("--b");
}
var Tom = /** @class */ (function () {
    function Tom() {
    }
    Tom.HtmlTest1 = function () {
        console.log("Tom Html test 1");
    };
    Tom.GuacamoleTest1 = function (display) {
        var tunnel = new (guacamole_common_js__WEBPACK_IMPORTED_MODULE_2___default().WebSocketTunnel)("Model.WebSocketUrl");
        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        tunnel.onerror = function (status) {
            console.log(status);
            alert("Tunnel Error Code: " + status.code);
        };
        // Instantiate client, using a WebSocket tunnel for communications.
        // @ts-ignore
        var guac = new (guacamole_common_js__WEBPACK_IMPORTED_MODULE_2___default().Client)(tunnel);
        // Add client to display div
        display.appendChild(guac.getDisplay().getElement());
        // Error handler
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        guac.onerror = function (status) {
            console.log(status);
            alert("Remote Desktop Error Code: " + status.code);
        };
        guac.connect("id=Model.SessionId");
        window.onunload = function () {
            guac.disconnect();
        };
    };
    return Tom;
}());

function sampleFunctionExported1() {
    console.log("sampleFunctionExported1");
}
function TestFunc2() {
    console.log("TestFunc2");
}

}();
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ib2dlL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWlzLWlvcy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS1pcy1ub2RlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWlzLXdlYm9zLXdlYmtpdC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9ob3N0LXJlcG9ydC1lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9taWNyb3Rhc2suanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtcHJvbWlzZS1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wZXJmb3JtLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Rhc2suanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYWdncmVnYXRlLWVycm9yLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovL0hvZ2UvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5hbGwtc2V0dGxlZC5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmFueS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmZpbmFsbHkuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vSG9nZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9Ib2dlLy4vbm9kZV9tb2R1bGVzL2d1YWNhbW9sZS1jb21tb24tanMvZGlzdC9ndWFjYW1vbGUtY29tbW9uLmpzIiwid2VicGFjazovL0hvZ2UvLi9TY3JpcHRzL0RuTGliLnRzIiwid2VicGFjazovL0hvZ2Uvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vSG9nZS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9Ib2dlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9Ib2dlL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vSG9nZS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL0hvZ2Uvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9Ib2dlLy4vU2NyaXB0cy9EbkFwcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7O0FDVkEsbUJBQU8sQ0FBQyw0Q0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyw2Q0FBbUM7QUFDM0MsbUJBQU8sQ0FBQyxvQ0FBMEI7QUFDbEMsbUJBQU8sQ0FBQyxnREFBc0M7QUFDOUMsbUJBQU8sQ0FBQyx3Q0FBOEI7QUFDdEMsbUJBQU8sQ0FBQyw0Q0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyw0Q0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyxzREFBNEM7QUFDcEQsV0FBVyxtQkFBTyxDQUFDLCtCQUFzQjs7QUFFekM7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7OztBQ0pBLGVBQWUsbUJBQU8sQ0FBQyxpQ0FBd0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7QUNOQSxzQkFBc0IsbUJBQU8sQ0FBQywwQ0FBZ0M7QUFDOUQsYUFBYSxtQkFBTyxDQUFDLG9DQUE0QjtBQUNqRCwyQkFBMkIsbUJBQU8sQ0FBQywrQ0FBcUM7O0FBRXhFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7O0FDSkEsZUFBZSxtQkFBTyxDQUFDLGlDQUF3Qjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0NBQStDO0FBQzlEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDs7QUFFdEQsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwr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O0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7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QUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGVBQWU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx5Q0FBeUMsK0NBQStDOztBQUV4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7O0FBRUEsU0FBUzs7QUFFVCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMseUJBQXlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1Qjs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyxpQkFBaUI7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFxQjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBZ0Q7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQixnQkFBZ0I7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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N0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsZ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6Qzs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU8sdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2g0YUE7SUFBQTtJQU1BLENBQUM7SUFKaUIsYUFBSyxHQUFuQixVQUFvQixPQUFlO1FBRS9CLE9BQU8sWUFBVSxPQUFPLE1BQUcsQ0FBQztJQUNoQyxDQUFDO0lBQ0wsY0FBQztBQUFELENBQUM7O0FBRUQ7SUFBQTtJQU1BLENBQUM7SUFKaUIsaUJBQU0sR0FBcEIsVUFBcUIsT0FBZTtRQUVoQyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBQ0wsaUJBQUM7QUFBRCxDQUFDOztBQUVEO0lBQUE7SUFtQ0EsQ0FBQztJQWpDaUIsZ0JBQUssR0FBbkIsVUFBb0IsT0FBZTtRQUUvQixPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRW1CLHFCQUFVLEdBQTlCLFVBQStCLElBQVk7OztnQkFFdkMsc0JBQU8sSUFBSSxPQUFPLENBQ2QsVUFBVSxPQUFPO3dCQUViLFVBQVUsQ0FBQzs0QkFFUCxPQUFPLEVBQUUsQ0FBQzt3QkFDZCxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7b0JBQ2IsQ0FBQyxDQUNKLEVBQUM7OztLQUVMO0lBRW1CLHFCQUFVLEdBQTlCOzs7Ozs7d0JBRUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQzt3QkFDWixDQUFDLEdBQUcsQ0FBQzs7OzZCQUFFLEVBQUMsR0FBRyxFQUFFO3dCQUVsQixJQUFJLENBQUMsSUFBSSxFQUFFLEVBQ1g7NEJBQ0ksTUFBTSxtQkFBbUIsQ0FBQzt5QkFDN0I7d0JBQ0QscUJBQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7O3dCQUF6QixTQUF5QixDQUFDO3dCQUMxQixPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsR0FBRyxDQUFDLENBQUMsQ0FBQzs7O3dCQVBaLENBQUMsRUFBRTs7O3dCQVMzQixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDOzs7OztLQUN0QjtJQUNMLGlCQUFDO0FBQUQsQ0FBQzs7Ozs7Ozs7VUNuREQ7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0EsY0FBYywwQkFBMEIsRUFBRTtXQUMxQyxjQUFjLGVBQWU7V0FDN0IsZ0NBQWdDLFlBQVk7V0FDNUM7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esd0NBQXdDLHlDQUF5QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBO1dBQ0EsQ0FBQyxJOzs7OztXQ1BELDZDQUE2Qyx3REFBd0QsRTs7Ozs7V0NBckc7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNONEI7QUFFOEI7QUFFZDtBQUM1QyxrREFBa0Q7QUFHbEQsNkJBQTZCO0FBRTdCLG9DQUFvQztBQUVwQyxxREFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN6QixvREFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUV6QixjQUFjO0FBRWQsU0FBUyxDQUFDLEtBQ1IsQ0FBQztBQUVILFNBQVMsU0FBUztJQUVkLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkIsSUFBTSxJQUFJLEdBQUcseURBQXFCLEVBQUUsQ0FBQztJQUNyQyxJQUFJLENBQUMsT0FBSyxFQUFDLFdBQUM7UUFFUixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDYixDQUFDLENBQUMsQ0FBQztJQUNILE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkIsQ0FBQztBQUVEO0lBQUE7SUF5Q0EsQ0FBQztJQXZDaUIsYUFBUyxHQUF2QjtRQUVJLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRWEsa0JBQWMsR0FBNUIsVUFBNkIsT0FBb0I7UUFFN0MsSUFBTSxNQUFNLEdBQUcsSUFBSSw0RUFBeUIsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBRW5FLGFBQWE7UUFDYiw4REFBOEQ7UUFDOUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxVQUFVLE1BQVc7WUFFbEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNwQixLQUFLLENBQUMscUJBQXFCLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9DLENBQUMsQ0FBQztRQUVGLG1FQUFtRTtRQUNuRSxhQUFhO1FBQ2IsSUFBTSxJQUFJLEdBQUcsSUFBSSxtRUFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUxQyw0QkFBNEI7UUFDNUIsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUVwRCxnQkFBZ0I7UUFDaEIsOERBQThEO1FBQzlELElBQUksQ0FBQyxPQUFPLEdBQUcsVUFBVSxNQUFXO1lBRWhDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDcEIsS0FBSyxDQUFDLDZCQUE2QixHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2RCxDQUFDLENBQUM7UUFFRixJQUFJLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFFbkMsTUFBTSxDQUFDLFFBQVEsR0FBRztZQUVkLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN0QixDQUFDO0lBQ0wsQ0FBQztJQUNMLFVBQUM7QUFBRCxDQUFDOztBQUVjLFNBQVMsdUJBQXVCO0lBRTNDLE9BQU8sQ0FBQyxHQUFHLENBQUMseUJBQXlCLENBQUMsQ0FBQztBQUMzQyxDQUFDO0FBRU0sU0FBUyxTQUFTO0lBRXJCLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDN0IsQ0FBQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJIb2dlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkhvZ2VcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLmFnZ3JlZ2F0ZS1lcnJvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnByb21pc2UnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMucHJvbWlzZS5hbGwtc2V0dGxlZCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5wcm9taXNlLmFueScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5wcm9taXNlLmZpbmFsbHknKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3InKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLlByb21pc2U7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhpdCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgJyArIChuYW1lID8gbmFtZSArICcgJyA6ICcnKSArICdpbnZvY2F0aW9uJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCcpO1xudmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3duLWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXModGFyZ2V0LCBrZXkpKSBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gIH1cbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XG4gIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSXRlcmF0b3JzQ29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpO1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuICAvLyBmaXggbmF0aXZlXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmICghSVNfUFVSRSAmJiBnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xuICAgICAgaWYgKElTX1BVUkUpIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcbiAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuYXRpdmVJdGVyYXRvci5jYWxsKHRoaXMpOyB9O1xuICB9XG5cbiAgLy8gZGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUlTX1BVUkUgfHwgRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IsIGRlZmF1bHRJdGVyYXRvcik7XG4gIH1cbiAgSXRlcmF0b3JzW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICByZWRlZmluZShJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSAkKHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuIiwidmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IC8oaXBob25lfGlwb2R8aXBhZCkuKmFwcGxld2Via2l0L2kudGVzdCh1c2VyQWdlbnQpO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3NvZihnbG9iYWwucHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuIiwidmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IC93ZWIwcyg/IS4qY2hyb21lKS9pLnRlc3QodXNlckFnZW50KTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50Jyk7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnM7XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgdmVyc2lvbiA9IG1hdGNoWzBdICsgbWF0Y2hbMV07XG59IGVsc2UgaWYgKHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9IG1hdGNoWzFdO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyc2lvbiAmJiArdmVyc2lvbjtcbiIsIi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgc2V0R2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwnKTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xudmFyIGlzRm9yY2VkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCcpO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLm5vVGFyZ2V0R2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBzZXRHbG9iYWwoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbFtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwidmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCk7XG4gICAgfTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT0gJ2Z1bmN0aW9uJyA/IHZhcmlhYmxlIDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKHBhdGhbbmFtZXNwYWNlXSkgfHwgYUZ1bmN0aW9uKGdsb2JhbFtuYW1lc3BhY2VdKVxuICAgIDogcGF0aFtuYW1lc3BhY2VdICYmIHBhdGhbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbFtuYW1lc3BhY2VdICYmIGdsb2JhbFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwidmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxubW9kdWxlLmV4cG9ydHMgPVxuICAvKiBnbG9iYWwgZ2xvYmFsVGhpcyAtLSBzYWZlICovXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgY29uc29sZSA9IGdsb2JhbC5jb25zb2xlO1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGNvbnNvbGUuZXJyb3IoYSkgOiBjb25zb2xlLmVycm9yKGEsIGIpO1xuICB9XG59O1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG52YXIgc3BsaXQgPSAnJy5zcGxpdDtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQuY2FsbChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gRnVuY3Rpb24udG9TdHJpbmc7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAodHlwZW9mIHN0b3JlLmluc3BlY3RTb3VyY2UgIT0gJ2Z1bmN0aW9uJykge1xuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcbiIsInZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBvYmplY3RIYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSBzdG9yZS5nZXQ7XG4gIHZhciB3bWhhcyA9IHN0b3JlLmhhcztcbiAgdmFyIHdtc2V0ID0gc3RvcmUuc2V0O1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQuY2FsbChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcy5jYWxsKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgZ2V0OiBnZXQsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UnKTtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBiaW5kKHVuYm91bmRGdW5jdGlvbiwgdGhhdCwgMSArIEFTX0VOVFJJRVMgKyBJTlRFUlJVUFRFRCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QodmFsdWUpO1xuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfSByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG4gIH07XG5cbiAgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKCdUYXJnZXQgaXMgbm90IGl0ZXJhYmxlJyk7XG4gICAgLy8gb3B0aW1pc2F0aW9uIGZvciBhcnJheSBpdGVyYXRvcnNcbiAgICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBjYWxsRm4oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgICB9XG4gICAgaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IG5leHQuY2FsbChpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG4gIHZhciByZXR1cm5NZXRob2QgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gIGlmIChyZXR1cm5NZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhbk9iamVjdChyZXR1cm5NZXRob2QuY2FsbChpdGVyYXRvcikpLnZhbHVlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbmlmICgoIUlTX1BVUkUgfHwgTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSB7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90YXNrJykuc2V0O1xudmFyIElTX0lPUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtaXMtaW9zJyk7XG52YXIgSVNfV0VCT1NfV0VCS0lUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy13ZWJvcy13ZWJraXQnKTtcbnZhciBJU19OT0RFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1ub2RlJyk7XG5cbnZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbi8vIE5vZGUuanMgMTEgc2hvd3MgRXhwZXJpbWVudGFsV2FybmluZyBvbiBnZXR0aW5nIGBxdWV1ZU1pY3JvdGFza2BcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsLCAncXVldWVNaWNyb3Rhc2snKTtcbnZhciBxdWV1ZU1pY3JvdGFzayA9IHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciAmJiBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IudmFsdWU7XG5cbnZhciBmbHVzaCwgaGVhZCwgbGFzdCwgbm90aWZ5LCB0b2dnbGUsIG5vZGUsIHByb21pc2UsIHRoZW47XG5cbi8vIG1vZGVybiBlbmdpbmVzIGhhdmUgcXVldWVNaWNyb3Rhc2sgbWV0aG9kXG5pZiAoIXF1ZXVlTWljcm90YXNrKSB7XG4gIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChJU19OT0RFICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIC8vIGFsc28gZXhjZXB0IFdlYk9TIFdlYmtpdCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODk4XG4gIGlmICghSVNfSU9TICYmICFJU19OT0RFICYmICFJU19XRUJPU19XRUJLSVQgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBkb2N1bWVudCkge1xuICAgIHRvZ2dsZSA9IHRydWU7XG4gICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgdGhlbiA9IHByb21pc2UudGhlbjtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGVuLmNhbGwocHJvbWlzZSwgZmx1c2gpO1xuICAgIH07XG4gIC8vIE5vZGUuanMgd2l0aG91dCBwcm9taXNlc1xuICB9IGVsc2UgaWYgKElTX05PREUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1ZXVlTWljcm90YXNrIHx8IGZ1bmN0aW9uIChmbikge1xuICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gIGlmICghaGVhZCkge1xuICAgIGhlYWQgPSB0YXNrO1xuICAgIG5vdGlmeSgpO1xuICB9IGxhc3QgPSB0YXNrO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLlByb21pc2U7XG4iLCJ2YXIgSVNfTk9ERSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtaXMtbm9kZScpO1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvKiBnbG9iYWwgU3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG4gIHJldHVybiAhU3ltYm9sLnNoYW0gJiZcbiAgICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgKElTX05PREUgPyBWOF9WRVJTSU9OID09PSAzOCA6IFY4X1ZFUlNJT04gPiAzNyAmJiBWOF9WRVJTSU9OIDwgNDEpO1xufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcblxudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn07XG5cbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaHRtbCcpO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFICovXG4gICAgYWN0aXZlWERvY3VtZW50ID0gZG9jdW1lbnQuZG9tYWluICYmIG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSBhY3RpdmVYRG9jdW1lbnQgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKTtcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBQcm9wZXJ0aWVzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xuXG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlRGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG5cbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsInZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXInKTtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbm1vZHVsZS5leHBvcnRzID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzJykuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXMoaGlkZGVuS2V5cywga2V5KSAmJiBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgIW5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAtLSBzYWZlICovXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICBzZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQ7XG4gICAgc2V0dGVyLmNhbGwodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0KE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIuY2FsbChPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG59O1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlLCB2YWx1ZTogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIHZhbHVlOiBlcnJvciB9O1xuICB9XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIG9wdGlvbnMpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gIHZhciBub1RhcmdldEdldCA9IG9wdGlvbnMgPyAhIW9wdGlvbnMubm9UYXJnZXRHZXQgOiBmYWxzZTtcbiAgdmFyIHN0YXRlO1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJyAmJiAhaGFzKHZhbHVlLCAnbmFtZScpKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkodmFsdWUsICduYW1lJywga2V5KTtcbiAgICB9XG4gICAgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gICAgaWYgKCFzdGF0ZS5zb3VyY2UpIHtcbiAgICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/IGtleSA6ICcnKTtcbiAgICB9XG4gIH1cbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2Ugc2V0R2xvYmFsKGtleSwgdmFsdWUpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICghdW5zYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgfSBlbHNlIGlmICghbm9UYXJnZXRHZXQgJiYgT1trZXldKSB7XG4gICAgc2ltcGxlID0gdHJ1ZTtcbiAgfVxuICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgZWxzZSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoTywga2V5LCB2YWx1ZSk7XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UodGhpcyk7XG59KTtcbiIsIi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShnbG9iYWwsIGtleSwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbFtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4oQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTXSkge1xuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShpdCwgVE9fU1RSSU5HX1RBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcblxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZTtcbiIsInZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjkuMScsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAyMSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29uc3RydWN0b3IgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBjb2RlUG9pbnRBdCwgYXQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HID8gUy5jaGFyQXQocG9zaXRpb24pIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklORyA/IFMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9odG1sJyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xudmFyIElTX0lPUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtaXMtaW9zJyk7XG52YXIgSVNfTk9ERSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtaXMtbm9kZScpO1xuXG52YXIgbG9jYXRpb24gPSBnbG9iYWwubG9jYXRpb247XG52YXIgc2V0ID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhciA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcblxudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBydW5uZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBydW4oaWQpO1xuICB9O1xufTtcblxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bihldmVudC5kYXRhKTtcbn07XG5cbnZhciBwb3N0ID0gZnVuY3Rpb24gKGlkKSB7XG4gIC8vIG9sZCBlbmdpbmVzIGhhdmUgbm90IGxvY2F0aW9uLm9yaWdpblxuICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdCk7XG59O1xuXG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldCB8fCAhY2xlYXIpIHtcbiAgc2V0ID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gc3BlYyByZXF1aXJlbWVudFxuICAgICAgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbikpLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXIgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAoSVNfTk9ERSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICAvLyBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzYyNFxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsICYmICFJU19JT1MpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGJpbmQocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKFxuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmXG4gICAgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiZcbiAgICAhZ2xvYmFsLmltcG9ydFNjcmlwdHMgJiZcbiAgICBsb2NhdGlvbiAmJiBsb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJlxuICAgICFmYWlscyhwb3N0KVxuICApIHtcbiAgICBkZWZlciA9IHBvc3Q7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bihpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQocnVubmVyKGlkKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGNsZWFyOiBjbGVhclxufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG4iLCIvLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuIiwidmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXIoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCJ2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIFBSRUZFUlJFRF9TVFJJTkcpIHtcbiAgaWYgKCFpc09iamVjdChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGlucHV0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIFN0cmluZyhrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyAoKytpZCArIHBvc3RmaXgpLnRvU3RyaW5nKDM2KTtcbn07XG4iLCJ2YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxuICAvKiBnbG9iYWwgU3ltYm9sIC0tIHNhZmUgKi9cbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCcpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkJyk7XG5cbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xudmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wgOiBTeW1ib2wgJiYgU3ltYm9sLndpdGhvdXRTZXR0ZXIgfHwgdWlkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MIHx8IHR5cGVvZiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPT0gJ3N0cmluZycpKSB7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzKFN5bWJvbCwgbmFtZSkpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbFtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xuICAgIH1cbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcblxudmFyICRBZ2dyZWdhdGVFcnJvciA9IGZ1bmN0aW9uIEFnZ3JlZ2F0ZUVycm9yKGVycm9ycywgbWVzc2FnZSkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIGlmICghKHRoYXQgaW5zdGFuY2VvZiAkQWdncmVnYXRlRXJyb3IpKSByZXR1cm4gbmV3ICRBZ2dyZWdhdGVFcnJvcihlcnJvcnMsIG1lc3NhZ2UpO1xuICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9lcnJvci1tZXNzYWdlIC0tIGV4cGVjdGVkXG4gICAgdGhhdCA9IHNldFByb3RvdHlwZU9mKG5ldyBFcnJvcih1bmRlZmluZWQpLCBnZXRQcm90b3R5cGVPZih0aGF0KSk7XG4gIH1cbiAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRoYXQsICdtZXNzYWdlJywgU3RyaW5nKG1lc3NhZ2UpKTtcbiAgdmFyIGVycm9yc0FycmF5ID0gW107XG4gIGl0ZXJhdGUoZXJyb3JzLCBlcnJvcnNBcnJheS5wdXNoLCB7IHRoYXQ6IGVycm9yc0FycmF5IH0pO1xuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkodGhhdCwgJ2Vycm9ycycsIGVycm9yc0FycmF5KTtcbiAgcmV0dXJuIHRoYXQ7XG59O1xuXG4kQWdncmVnYXRlRXJyb3IucHJvdG90eXBlID0gY3JlYXRlKEVycm9yLnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3RvcjogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDUsICRBZ2dyZWdhdGVFcnJvciksXG4gIG1lc3NhZ2U6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcig1LCAnJyksXG4gIG5hbWU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcig1LCAnQWdncmVnYXRlRXJyb3InKVxufSk7XG5cbi8vIGBBZ2dyZWdhdGVFcnJvcmAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWdncmVnYXRlLWVycm9yLWNvbnN0cnVjdG9yXG4kKHsgZ2xvYmFsOiB0cnVlIH0sIHtcbiAgQWdncmVnYXRlRXJyb3I6ICRBZ2dyZWdhdGVFcnJvclxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvcicpO1xuXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogdGFyZ2V0W2luZGV4XSwgZG9uZTogZmFsc2UgfTtcbiAgcmV0dXJuIHsgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGRvbmU6IGZhbHNlIH07XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3Rcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwidmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcnKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoIVRPX1NUUklOR19UQUdfU1VQUE9SVCkge1xuICByZWRlZmluZShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCB0b1N0cmluZywgeyB1bnNhZmU6IHRydWUgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BlcmZvcm0nKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcblxuLy8gYFByb21pc2UuYWxsU2V0dGxlZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsc2V0dGxlZFxuJCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlIH0sIHtcbiAgYWxsU2V0dGxlZDogZnVuY3Rpb24gYWxsU2V0dGxlZChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcm9taXNlUmVzb2x2ZSA9IGFGdW5jdGlvbihDLnJlc29sdmUpO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0geyBzdGF0dXM6ICdmdWxmaWxsZWQnLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHsgc3RhdHVzOiAncmVqZWN0ZWQnLCByZWFzb246IGVycm9yIH07XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BlcmZvcm0nKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcblxudmFyIFBST01JU0VfQU5ZX0VSUk9SID0gJ05vIG9uZSBwcm9taXNlIHJlc29sdmVkJztcblxuLy8gYFByb21pc2UuYW55YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5hbnlcbiQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSB9LCB7XG4gIGFueTogZnVuY3Rpb24gYW55KGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZihDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByb21pc2VSZXNvbHZlID0gYUZ1bmN0aW9uKEMucmVzb2x2ZSk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIHZhciBhbHJlYWR5UmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgdmFyIGFscmVhZHlSZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICBlcnJvcnMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgcHJvbWlzZVJlc29sdmUuY2FsbChDLCBwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5UmVqZWN0ZWQgfHwgYWxyZWFkeVJlc29sdmVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlSZWplY3RlZCB8fCBhbHJlYWR5UmVzb2x2ZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5UmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGVycm9yc1tpbmRleF0gPSBlcnJvcjtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZWplY3QobmV3IChnZXRCdWlsdEluKCdBZ2dyZWdhdGVFcnJvcicpKShlcnJvcnMsIFBST01JU0VfQU5ZX0VSUk9SKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZWplY3QobmV3IChnZXRCdWlsdEluKCdBZ2dyZWdhdGVFcnJvcicpKShlcnJvcnMsIFBST01JU0VfQU5ZX0VSUk9SKSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBOYXRpdmVQcm9taXNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1wcm9taXNlLWNvbnN0cnVjdG9yJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcblxuLy8gU2FmYXJpIGJ1ZyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjAwODI5XG52YXIgTk9OX0dFTkVSSUMgPSAhIU5hdGl2ZVByb21pc2UgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICBOYXRpdmVQcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddLmNhbGwoeyB0aGVuOiBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0gfSwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG4vLyBgUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmZpbmFsbHlcbiQoeyB0YXJnZXQ6ICdQcm9taXNlJywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogTk9OX0dFTkVSSUMgfSwge1xuICAnZmluYWxseSc6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBnZXRCdWlsdEluKCdQcm9taXNlJykpO1xuICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICAgIHJldHVybiB0aGlzLnRoZW4oXG4gICAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgICAgfSA6IG9uRmluYWxseSxcbiAgICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICAgIH0gOiBvbkZpbmFsbHlcbiAgICApO1xuICB9XG59KTtcblxuLy8gcGF0Y2ggbmF0aXZlIFByb21pc2UucHJvdG90eXBlIGZvciBuYXRpdmUgYXN5bmMgZnVuY3Rpb25zXG5pZiAoIUlTX1BVUkUgJiYgdHlwZW9mIE5hdGl2ZVByb21pc2UgPT0gJ2Z1bmN0aW9uJyAmJiAhTmF0aXZlUHJvbWlzZS5wcm90b3R5cGVbJ2ZpbmFsbHknXSkge1xuICByZWRlZmluZShOYXRpdmVQcm9taXNlLnByb3RvdHlwZSwgJ2ZpbmFsbHknLCBnZXRCdWlsdEluKCdQcm9taXNlJykucHJvdG90eXBlWydmaW5hbGx5J10pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgTmF0aXZlUHJvbWlzZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtcHJvbWlzZS1jb25zdHJ1Y3RvcicpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZScpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24nKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWljcm90YXNrJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgaG9zdFJlcG9ydEVycm9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9ob3N0LXJlcG9ydC1lcnJvcnMnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wZXJmb3JtJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGlzRm9yY2VkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX05PREUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLW5vZGUnKTtcbnZhciBWOF9WRVJTSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yID0gTmF0aXZlUHJvbWlzZTtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkZmV0Y2ggPSBnZXRCdWlsdEluKCdmZXRjaCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcbnZhciBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eTtcbnZhciBESVNQQVRDSF9FVkVOVCA9ICEhKGRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUV2ZW50ICYmIGdsb2JhbC5kaXNwYXRjaEV2ZW50KTtcbnZhciBOQVRJVkVfUkVKRUNUSU9OX0VWRU5UID0gdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nO1xudmFyIFVOSEFORExFRF9SRUpFQ1RJT04gPSAndW5oYW5kbGVkcmVqZWN0aW9uJztcbnZhciBSRUpFQ1RJT05fSEFORExFRCA9ICdyZWplY3Rpb25oYW5kbGVkJztcbnZhciBQRU5ESU5HID0gMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcbnZhciBIQU5ETEVEID0gMTtcbnZhciBVTkhBTkRMRUQgPSAyO1xudmFyIEludGVybmFsLCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgUHJvbWlzZVdyYXBwZXIsIG5hdGl2ZVRoZW47XG5cbnZhciBGT1JDRUQgPSBpc0ZvcmNlZChQUk9NSVNFLCBmdW5jdGlvbiAoKSB7XG4gIHZhciBHTE9CQUxfQ09SRV9KU19QUk9NSVNFID0gaW5zcGVjdFNvdXJjZShQcm9taXNlQ29uc3RydWN0b3IpICE9PSBTdHJpbmcoUHJvbWlzZUNvbnN0cnVjdG9yKTtcbiAgaWYgKCFHTE9CQUxfQ09SRV9KU19QUk9NSVNFKSB7XG4gICAgLy8gVjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAgIC8vIFdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgaWYgKFY4X1ZFUlNJT04gPT09IDY2KSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBVbmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgaWYgKCFJU19OT0RFICYmICFOQVRJVkVfUkVKRUNUSU9OX0VWRU5UKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBXZSBuZWVkIFByb21pc2UjZmluYWxseSBpbiB0aGUgcHVyZSB2ZXJzaW9uIGZvciBwcmV2ZW50aW5nIHByb3RvdHlwZSBwb2xsdXRpb25cbiAgaWYgKElTX1BVUkUgJiYgIVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGVbJ2ZpbmFsbHknXSkgcmV0dXJuIHRydWU7XG4gIC8vIFdlIGNhbid0IHVzZSBAQHNwZWNpZXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG4gIGlmIChWOF9WRVJTSU9OID49IDUxICYmIC9uYXRpdmUgY29kZS8udGVzdChQcm9taXNlQ29uc3RydWN0b3IpKSByZXR1cm4gZmFsc2U7XG4gIC8vIERldGVjdCBjb3JyZWN0bmVzcyBvZiBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZUNvbnN0cnVjdG9yLnJlc29sdmUoMSk7XG4gIHZhciBGYWtlUHJvbWlzZSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgZXhlYyhmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG4gIH07XG4gIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3IgPSB7fTtcbiAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBGYWtlUHJvbWlzZTtcbiAgcmV0dXJuICEocHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZSk7XG59KTtcblxudmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSBGT1JDRUQgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgUHJvbWlzZUNvbnN0cnVjdG9yLmFsbChpdGVyYWJsZSlbJ2NhdGNoJ10oZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChzdGF0ZSwgaXNSZWplY3QpIHtcbiAgaWYgKHN0YXRlLm5vdGlmaWVkKSByZXR1cm47XG4gIHN0YXRlLm5vdGlmaWVkID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gc3RhdGUucmVhY3Rpb25zO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICAgIHZhciBvayA9IHN0YXRlLnN0YXRlID09IEZVTEZJTExFRDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBjaGFpbltpbmRleCsrXTtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlamVjdGlvbiA9PT0gVU5IQU5ETEVEKSBvbkhhbmRsZVVuaGFuZGxlZChzdGF0ZSk7XG4gICAgICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBjYW4gdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLnJlYWN0aW9ucyA9IFtdO1xuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC5pbml0RXZlbnQobmFtZSwgZmFsc2UsIHRydWUpO1xuICAgIGdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSBlbHNlIGV2ZW50ID0geyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHJlYXNvbiB9O1xuICBpZiAoIU5BVElWRV9SRUpFQ1RJT05fRVZFTlQgJiYgKGhhbmRsZXIgPSBnbG9iYWxbJ29uJyArIG5hbWVdKSkgaGFuZGxlcihldmVudCk7XG4gIGVsc2UgaWYgKG5hbWUgPT09IFVOSEFORExFRF9SRUpFQ1RJT04pIGhvc3RSZXBvcnRFcnJvcnMoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHJlYXNvbik7XG59O1xuXG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICAgIHZhciBJU19VTkhBTkRMRUQgPSBpc1VuaGFuZGxlZChzdGF0ZSk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoSVNfVU5IQU5ETEVEKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKElTX05PREUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoVU5IQU5ETEVEX1JFSkVDVElPTiwgcHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSB8fCBpc1VuaGFuZGxlZChzdGF0ZSkgPyBVTkhBTkRMRUQgOiBIQU5ETEVEO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhyb3cgcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnJlamVjdGlvbiAhPT0gSEFORExFRCAmJiAhc3RhdGUucGFyZW50O1xufTtcblxudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICBpZiAoSVNfTk9ERSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoUkVKRUNUSU9OX0hBTkRMRUQsIHByb21pc2UsIHN0YXRlLnZhbHVlKTtcbiAgfSk7XG59O1xuXG52YXIgYmluZCA9IGZ1bmN0aW9uIChmbiwgc3RhdGUsIHVud3JhcCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgZm4oc3RhdGUsIHZhbHVlLCB1bndyYXApO1xuICB9O1xufTtcblxudmFyIGludGVybmFsUmVqZWN0ID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgc3RhdGUuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgbm90aWZ5KHN0YXRlLCB0cnVlKTtcbn07XG5cbnZhciBpbnRlcm5hbFJlc29sdmUgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICB0cnkge1xuICAgIGlmIChzdGF0ZS5mYWNhZGUgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsXG4gICAgICAgICAgICBiaW5kKGludGVybmFsUmVzb2x2ZSwgd3JhcHBlciwgc3RhdGUpLFxuICAgICAgICAgICAgYmluZChpbnRlcm5hbFJlamVjdCwgd3JhcHBlciwgc3RhdGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpbnRlcm5hbFJlamVjdCh3cmFwcGVyLCBlcnJvciwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHN0YXRlLnN0YXRlID0gRlVMRklMTEVEO1xuICAgICAgbm90aWZ5KHN0YXRlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGludGVybmFsUmVqZWN0KHsgZG9uZTogZmFsc2UgfSwgZXJyb3IsIHN0YXRlKTtcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmIChGT1JDRUQpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUHJvbWlzZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgUHJvbWlzZUNvbnN0cnVjdG9yLCBQUk9NSVNFKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZChpbnRlcm5hbFJlc29sdmUsIHN0YXRlKSwgYmluZChpbnRlcm5hbFJlamVjdCwgc3RhdGUpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaW50ZXJuYWxSZWplY3Qoc3RhdGUsIGVycm9yKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgdHlwZTogUFJPTUlTRSxcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgbm90aWZpZWQ6IGZhbHNlLFxuICAgICAgcGFyZW50OiBmYWxzZSxcbiAgICAgIHJlYWN0aW9uczogW10sXG4gICAgICByZWplY3Rpb246IGZhbHNlLFxuICAgICAgc3RhdGU6IFBFTkRJTkcsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKFByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgICAvLyBgUHJvbWlzZS5wcm90b3R5cGUudGhlbmAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS50aGVuXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgUHJvbWlzZUNvbnN0cnVjdG9yKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IElTX05PREUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLnBhcmVudCA9IHRydWU7XG4gICAgICBzdGF0ZS5yZWFjdGlvbnMucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAoc3RhdGUuc3RhdGUgIT0gUEVORElORykgbm90aWZ5KHN0YXRlLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIGBQcm9taXNlLnByb3RvdHlwZS5jYXRjaGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS5jYXRjaFxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHByb21pc2UpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gYmluZChpbnRlcm5hbFJlc29sdmUsIHN0YXRlKTtcbiAgICB0aGlzLnJlamVjdCA9IGJpbmQoaW50ZXJuYWxSZWplY3QsIHN0YXRlKTtcbiAgfTtcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gUHJvbWlzZUNvbnN0cnVjdG9yIHx8IEMgPT09IFByb21pc2VXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG5cbiAgaWYgKCFJU19QVVJFICYmIHR5cGVvZiBOYXRpdmVQcm9taXNlID09ICdmdW5jdGlvbicpIHtcbiAgICBuYXRpdmVUaGVuID0gTmF0aXZlUHJvbWlzZS5wcm90b3R5cGUudGhlbjtcblxuICAgIC8vIHdyYXAgbmF0aXZlIFByb21pc2UjdGhlbiBmb3IgbmF0aXZlIGFzeW5jIGZ1bmN0aW9uc1xuICAgIHJlZGVmaW5lKE5hdGl2ZVByb21pc2UucHJvdG90eXBlLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbmF0aXZlVGhlbi5jYWxsKHRoYXQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjQwXG4gICAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG5cbiAgICAvLyB3cmFwIGZldGNoIHJlc3VsdFxuICAgIGlmICh0eXBlb2YgJGZldGNoID09ICdmdW5jdGlvbicpICQoeyBnbG9iYWw6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICAgICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKGlucHV0IC8qICwgaW5pdCAqLykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoUHJvbWlzZUNvbnN0cnVjdG9yLCAkZmV0Y2guYXBwbHkoZ2xvYmFsLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4kKHsgZ2xvYmFsOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIFByb21pc2U6IFByb21pc2VDb25zdHJ1Y3RvclxufSk7XG5cbnNldFRvU3RyaW5nVGFnKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UsIHRydWUpO1xuc2V0U3BlY2llcyhQUk9NSVNFKTtcblxuUHJvbWlzZVdyYXBwZXIgPSBnZXRCdWlsdEluKFBST01JU0UpO1xuXG4vLyBzdGF0aWNzXG4kKHsgdGFyZ2V0OiBQUk9NSVNFLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIC8vIGBQcm9taXNlLnJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3RcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgY2FwYWJpbGl0eS5yZWplY3QuY2FsbCh1bmRlZmluZWQsIHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG4kKHsgdGFyZ2V0OiBQUk9NSVNFLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IElTX1BVUkUgfHwgRk9SQ0VEIH0sIHtcbiAgLy8gYFByb21pc2UucmVzb2x2ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZXNvbHZlXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShJU19QVVJFICYmIHRoaXMgPT09IFByb21pc2VXcmFwcGVyID8gUHJvbWlzZUNvbnN0cnVjdG9yIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuXG4kKHsgdGFyZ2V0OiBQUk9NSVNFLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9JVEVSQVRJT04gfSwge1xuICAvLyBgUHJvbWlzZS5hbGxgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhRnVuY3Rpb24oQy5yZXNvbHZlKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgJHByb21pc2VSZXNvbHZlLmNhbGwoQywgcHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyBgUHJvbWlzZS5yYWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJhY2VcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUZ1bmN0aW9uKEMucmVzb2x2ZSk7XG4gICAgICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAkcHJvbWlzZVJlc29sdmUuY2FsbChDLCBwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNoYXJBdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlJykuY2hhckF0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3InKTtcblxudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1RSSU5HX0lURVJBVE9SKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLUBAaXRlcmF0b3JcbmRlZmluZUl0ZXJhdG9yKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG4gICAgc3RyaW5nOiBTdHJpbmcoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pO1xuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIERPTUl0ZXJhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb20taXRlcmFibGVzJyk7XG52YXIgQXJyYXlJdGVyYXRvck1ldGhvZHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JNZXRob2RzLnZhbHVlcztcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdICE9PSBBcnJheVZhbHVlcykgdHJ5IHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSA9IEFycmF5VmFsdWVzO1xuICAgIH1cbiAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGVbVE9fU1RSSU5HX1RBR10pIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIH1cbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQSByZWFkZXIgd2hpY2ggYXV0b21hdGljYWxseSBoYW5kbGVzIHRoZSBnaXZlbiBpbnB1dCBzdHJlYW0sIHJldHVybmluZ1xyXG4gKiBzdHJpY3RseSByZWNlaXZlZCBwYWNrZXRzIGFzIGFycmF5IGJ1ZmZlcnMuIE5vdGUgdGhhdCB0aGlzIG9iamVjdCB3aWxsXHJcbiAqIG92ZXJ3cml0ZSBhbnkgaW5zdGFsbGVkIGV2ZW50IGhhbmRsZXJzIG9uIHRoZSBnaXZlbiBHdWFjYW1vbGUuSW5wdXRTdHJlYW0uXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuSW5wdXRTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIHRoYXQgZGF0YSB3aWxsIGJlIHJlYWRcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkFycmF5QnVmZmVyUmVhZGVyID0gZnVuY3Rpb24oc3RyZWFtKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuSW5wdXRTdHJlYW0uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY19yZWFkZXIgPSB0aGlzO1xyXG5cclxuICAgIC8vIFJlY2VpdmUgYmxvYnMgYXMgYXJyYXkgYnVmZmVyc1xyXG4gICAgc3RyZWFtLm9uYmxvYiA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0byBBcnJheUJ1ZmZlclxyXG4gICAgICAgIHZhciBiaW5hcnkgPSB3aW5kb3cuYXRvYihkYXRhKTtcclxuICAgICAgICB2YXIgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYmluYXJ5Lmxlbmd0aCk7XHJcbiAgICAgICAgdmFyIGJ1ZmZlclZpZXcgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxiaW5hcnkubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGJ1ZmZlclZpZXdbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbCBoYW5kbGVyLCBpZiBwcmVzZW50XHJcbiAgICAgICAgaWYgKGd1YWNfcmVhZGVyLm9uZGF0YSlcclxuICAgICAgICAgICAgZ3VhY19yZWFkZXIub25kYXRhKGFycmF5QnVmZmVyKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFNpbXBseSBjYWxsIG9uZW5kIHdoZW4gZW5kIHJlY2VpdmVkXHJcbiAgICBzdHJlYW0ub25lbmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoZ3VhY19yZWFkZXIub25lbmQpXHJcbiAgICAgICAgICAgIGd1YWNfcmVhZGVyLm9uZW5kKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgb25jZSBmb3IgZXZlcnkgYmxvYiBvZiBkYXRhIHJlY2VpdmVkLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciBUaGUgZGF0YSBwYWNrZXQgcmVjZWl2ZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25kYXRhID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIG9uY2UgdGhpcyBzdHJlYW0gaXMgZmluaXNoZWQgYW5kIG5vIGZ1cnRoZXIgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmVuZCA9IG51bGw7XHJcblxyXG59O1xuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIHdyaXRlciB3aGljaCBhdXRvbWF0aWNhbGx5IHdyaXRlcyB0byB0aGUgZ2l2ZW4gb3V0cHV0IHN0cmVhbSB3aXRoIGFyYml0cmFyeVxyXG4gKiBiaW5hcnkgZGF0YSwgc3VwcGxpZWQgYXMgQXJyYXlCdWZmZXJzLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLk91dHB1dFN0cmVhbX0gc3RyZWFtIFRoZSBzdHJlYW0gdGhhdCBkYXRhIHdpbGwgYmUgd3JpdHRlblxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0by5cclxuICovXHJcbkd1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLlN0cmluZ1dyaXRlci5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX3dyaXRlciA9IHRoaXM7XHJcblxyXG4gICAgLy8gU2ltcGx5IGNhbGwgb25hY2sgZm9yIGFja25vd2xlZGdlbWVudHNcclxuICAgIHN0cmVhbS5vbmFjayA9IGZ1bmN0aW9uKHN0YXR1cykge1xyXG4gICAgICAgIGlmIChndWFjX3dyaXRlci5vbmFjaylcclxuICAgICAgICAgICAgZ3VhY193cml0ZXIub25hY2soc3RhdHVzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoZSBnaXZlbiBkYXRhIGFzIGJhc2U2NCwgc2VuZGluZyBpdCBhcyBhIGJsb2IuIFRoZSBkYXRhIG11c3RcclxuICAgICAqIGJlIHNtYWxsIGVub3VnaCB0byBmaXQgaW50byBhIHNpbmdsZSBibG9iIGluc3RydWN0aW9uLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlcyBUaGUgZGF0YSB0byBzZW5kLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfX3NlbmRfYmxvYihieXRlcykge1xyXG5cclxuICAgICAgICB2YXIgYmluYXJ5ID0gXCJcIjtcclxuXHJcbiAgICAgICAgLy8gUHJvZHVjZSBiaW5hcnkgc3RyaW5nIGZyb20gYnl0ZXMgaW4gYnVmZmVyXHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGJ5dGVzLmJ5dGVMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xyXG5cclxuICAgICAgICAvLyBTZW5kIGFzIGJhc2U2NFxyXG4gICAgICAgIHN0cmVhbS5zZW5kQmxvYih3aW5kb3cuYnRvYShiaW5hcnkpKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBsZW5ndGggb2YgYW55IGJsb2Igc2VudCBieSB0aGlzIEd1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlcixcclxuICAgICAqIGluIGJ5dGVzLiBEYXRhIHNlbnQgdmlhXHJcbiAgICAgKiBbc2VuZERhdGEoKV17QGxpbmsgR3VhY2Ftb2xlLkFycmF5QnVmZmVyV3JpdGVyI3NlbmREYXRhfSB3aGljaCBleGNlZWRzXHJcbiAgICAgKiB0aGlzIGxlbmd0aCB3aWxsIGJlIHNwbGl0IGludG8gbXVsdGlwbGUgYmxvYnMuIEFzIHRoZSBHdWFjYW1vbGUgcHJvdG9jb2xcclxuICAgICAqIGxpbWl0cyB0aGUgbWF4aW11bSBzaXplIG9mIGFueSBpbnN0cnVjdGlvbiBvciBpbnN0cnVjdGlvbiBlbGVtZW50IHRvXHJcbiAgICAgKiA4MTkyIGJ5dGVzLCBhbmQgdGhlIGNvbnRlbnRzIG9mIGJsb2JzIHdpbGwgYmUgYmFzZTY0LWVuY29kZWQsIHRoaXMgdmFsdWVcclxuICAgICAqIHNob3VsZCBvbmx5IGJlIGluY3JlYXNlZCB3aXRoIGV4dHJlbWUgY2F1dGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQge0BsaW5rIEd1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlci5ERUZBVUxUX0JMT0JfTEVOR1RIfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJsb2JMZW5ndGggPSBHdWFjYW1vbGUuQXJyYXlCdWZmZXJXcml0ZXIuREVGQVVMVF9CTE9CX0xFTkdUSDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIHRoZSBnaXZlbiBkYXRhLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfFR5cGVkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gc2VuZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5kRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHJcbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XHJcblxyXG4gICAgICAgIC8vIElmIHNtYWxsIGVub3VnaCB0byBmaXQgaW50byBzaW5nbGUgaW5zdHJ1Y3Rpb24sIHNlbmQgYXMtaXNcclxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoIDw9IGd1YWNfd3JpdGVyLmJsb2JMZW5ndGgpXHJcbiAgICAgICAgICAgIF9fc2VuZF9ibG9iKGJ5dGVzKTtcclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZW5kIGFzIG11bHRpcGxlIGluc3RydWN0aW9uc1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQ9MDsgb2Zmc2V0PGJ5dGVzLmxlbmd0aDsgb2Zmc2V0ICs9IGd1YWNfd3JpdGVyLmJsb2JMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICBfX3NlbmRfYmxvYihieXRlcy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGd1YWNfd3JpdGVyLmJsb2JMZW5ndGgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpZ25hbHMgdGhhdCBubyBmdXJ0aGVyIHRleHQgd2lsbCBiZSBzZW50LCBlZmZlY3RpdmVseSBjbG9zaW5nIHRoZVxyXG4gICAgICogc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmRFbmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBzdHJlYW0uc2VuZEVuZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIGZvciByZWNlaXZlZCBkYXRhLCBpZiBhY2tub3dsZWRnZWQgYnkgdGhlIHNlcnZlci5cclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuU3RhdHVzfSBzdGF0dXMgVGhlIHN0YXR1cyBvZiB0aGUgb3BlcmF0aW9uLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uYWNrID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbWF4aW11bSBibG9iIGxlbmd0aCBmb3IgbmV3IEd1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlclxyXG4gKiBpbnN0YW5jZXMuXHJcbiAqXHJcbiAqIEBjb25zdGFudFxyXG4gKiBAdHlwZSB7TnVtYmVyfVxyXG4gKi9cclxuR3VhY2Ftb2xlLkFycmF5QnVmZmVyV3JpdGVyLkRFRkFVTFRfQkxPQl9MRU5HVEggPSA2MDQ4O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogTWFpbnRhaW5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBXZWIgQXVkaW8gQVBJIEF1ZGlvQ29udGV4dCBjbGFzcyxcclxuICogaW5zdGFudGlhdGluZyB0aGUgQXVkaW9Db250ZXh0IG9ubHkgaW4gcmVzcG9uc2UgdG8gdGhlIGZpcnN0IGNhbGwgdG9cclxuICogZ2V0QXVkaW9Db250ZXh0KCksIGFuZCBvbmx5IGlmIG5vIGV4aXN0aW5nIEF1ZGlvQ29udGV4dCBpbnN0YW5jZSBoYXMgYmVlblxyXG4gKiBwcm92aWRlZCB2aWEgdGhlIHNpbmdsZXRvbiBwcm9wZXJ0eS4gU3Vic2VxdWVudCBjYWxscyB0byBnZXRBdWRpb0NvbnRleHQoKVxyXG4gKiB3aWxsIHJldHVybiB0aGUgc2FtZSBpbnN0YW5jZS5cclxuICpcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxuR3VhY2Ftb2xlLkF1ZGlvQ29udGV4dEZhY3RvcnkgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIFdlYiBBdWRpbyBBUEkgQXVkaW9Db250ZXh0IG9iamVjdCwgb3IgbnVsbCBpZlxyXG4gICAgICogbm8gaW5zdGFuY2UgaGFzIHllcyBiZWVuIGNyZWF0ZWQuIFRoaXMgcHJvcGVydHkgbWF5IGJlIG1hbnVhbGx5IHNldCBpZlxyXG4gICAgICogeW91IHdpc2ggdG8gc3VwcGx5IHlvdXIgb3duIEF1ZGlvQ29udGV4dCBpbnN0YW5jZSwgYnV0IGNhcmUgbXVzdCBiZVxyXG4gICAgICogdGFrZW4gdG8gZG8gc28gYXMgZWFybHkgYXMgcG9zc2libGUuIEFzc2lnbm1lbnRzIHRvIHRoaXMgcHJvcGVydHkgd2lsbFxyXG4gICAgICogbm90IHJldHJvYWN0aXZlbHkgYWZmZWN0IHRoZSB2YWx1ZSByZXR1cm5lZCBieSBwcmV2aW91cyBjYWxscyB0b1xyXG4gICAgICogZ2V0QXVkaW9Db250ZXh0KCkuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge0F1ZGlvQ29udGV4dH1cclxuICAgICAqL1xyXG4gICAgJ3NpbmdsZXRvbicgOiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIFdlYiBBdWRpbyBBUEkgQXVkaW9Db250ZXh0IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtBdWRpb0NvbnRleHR9XHJcbiAgICAgKiAgICAgQSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBXZWIgQXVkaW8gQVBJIEF1ZGlvQ29udGV4dCBvYmplY3QsIG9yIG51bGxcclxuICAgICAqICAgICBpZiB0aGUgV2ViIEF1ZGlvIEFQSSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICovXHJcbiAgICAnZ2V0QXVkaW9Db250ZXh0JyA6IGZ1bmN0aW9uIGdldEF1ZGlvQ29udGV4dCgpIHtcclxuXHJcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gV2Via2l0LXNwZWNpZmljIEF1ZGlvQ29udGV4dCBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgIHZhciBBdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XHJcblxyXG4gICAgICAgIC8vIEdldCBuZXcgQXVkaW9Db250ZXh0IGluc3RhbmNlIGlmIFdlYiBBdWRpbyBBUEkgaXMgc3VwcG9ydGVkXHJcbiAgICAgICAgaWYgKEF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2UgaWYgbm9uZSB5ZXQgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICBpZiAoIUd1YWNhbW9sZS5BdWRpb0NvbnRleHRGYWN0b3J5LnNpbmdsZXRvbilcclxuICAgICAgICAgICAgICAgICAgICBHdWFjYW1vbGUuQXVkaW9Db250ZXh0RmFjdG9yeS5zaW5nbGV0b24gPSBuZXcgQXVkaW9Db250ZXh0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHNpbmdsZXRvbiBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEd1YWNhbW9sZS5BdWRpb0NvbnRleHRGYWN0b3J5LnNpbmdsZXRvbjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB1c2UgV2ViIEF1ZGlvIEFQSSBpZiBub3QgYWxsb3dlZCBieSBicm93c2VyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlYiBBdWRpbyBBUEkgbm90IHN1cHBvcnRlZFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBhdWRpbyBwbGF5ZXIgd2hpY2ggYWNjZXB0cywgcXVldWVzIGFuZCBwbGF5cyBiYWNrIGFyYml0cmFyeSBhdWRpb1xyXG4gKiBkYXRhLiBJdCBpcyB1cCB0byBpbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBjbGFzcyB0byBwcm92aWRlIHNvbWUgbWVhbnMgb2ZcclxuICogaGFuZGxpbmcgYSBwcm92aWRlZCBHdWFjYW1vbGUuSW5wdXRTdHJlYW0uIERhdGEgcmVjZWl2ZWQgYWxvbmcgdGhlIHByb3ZpZGVkXHJcbiAqIHN0cmVhbSBpcyB0byBiZSBwbGF5ZWQgYmFjayBpbW1lZGlhdGVseS5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5HdWFjYW1vbGUuQXVkaW9QbGF5ZXIgPSBmdW5jdGlvbiBBdWRpb1BsYXllcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vdGlmaWVzIHRoaXMgR3VhY2Ftb2xlLkF1ZGlvUGxheWVyIHRoYXQgYWxsIGF1ZGlvIHVwIHRvIHRoZSBjdXJyZW50XHJcbiAgICAgKiBwb2ludCBpbiB0aW1lIGhhcyBiZWVuIGdpdmVuIHZpYSB0aGUgdW5kZXJseWluZyBzdHJlYW0sIGFuZCB0aGF0IGFueVxyXG4gICAgICogZGlmZmVyZW5jZSBpbiB0aW1lIGJldHdlZW4gcXVldWVkIGF1ZGlvIGRhdGEgYW5kIHRoZSBjdXJyZW50IHRpbWUgY2FuIGJlXHJcbiAgICAgKiBjb25zaWRlcmVkIGxhdGVuY3kuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XHJcbiAgICAgICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiAtIGRvIG5vdGhpbmdcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gbWltZXR5cGUgaXMgc3VwcG9ydGVkIGJ5IGFueSBidWlsdC1pblxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBHdWFjYW1vbGUuQXVkaW9QbGF5ZXIsIGFuZCB0aHVzIHdpbGwgYmUgcHJvcGVybHkgaGFuZGxlZFxyXG4gKiBieSBHdWFjYW1vbGUuQXVkaW9QbGF5ZXIuZ2V0SW5zdGFuY2UoKS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAqICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2suXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKiAgICAgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbWltZXR5cGUgaXMgc3VwcG9ydGVkIGJ5IGFueSBidWlsdC1pblxyXG4gKiAgICAgR3VhY2Ftb2xlLkF1ZGlvUGxheWVyLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5HdWFjYW1vbGUuQXVkaW9QbGF5ZXIuaXNTdXBwb3J0ZWRUeXBlID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRUeXBlKG1pbWV0eXBlKSB7XHJcblxyXG4gICAgcmV0dXJuIEd1YWNhbW9sZS5SYXdBdWRpb1BsYXllci5pc1N1cHBvcnRlZFR5cGUobWltZXR5cGUpO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgbWltZXR5cGVzIHN1cHBvcnRlZCBieSBhbnkgYnVpbHQtaW5cclxuICogR3VhY2Ftb2xlLkF1ZGlvUGxheWVyLCBpbiByb3VnaCBvcmRlciBvZiBwcmlvcml0eS4gQmV3YXJlIHRoYXQgb25seSB0aGUgY29yZVxyXG4gKiBtaW1ldHlwZXMgdGhlbXNlbHZlcyB3aWxsIGJlIGxpc3RlZC4gQW55IG1pbWV0eXBlIHBhcmFtZXRlcnMsIGV2ZW4gcmVxdWlyZWRcclxuICogb25lcywgd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIGxpc3QuIEZvciBleGFtcGxlLCBcImF1ZGlvL0w4XCIgaXMgYVxyXG4gKiBzdXBwb3J0ZWQgcmF3IGF1ZGlvIG1pbWV0eXBlIHRoYXQgaXMgc3VwcG9ydGVkLCBidXQgaXQgaXMgaW52YWxpZCB3aXRob3V0XHJcbiAqIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gU29tZXRoaW5nIGxpa2UgXCJhdWRpby9MODtyYXRlPTQ0MTAwXCIgd291bGQgYmUgdmFsaWQsXHJcbiAqIGhvd2V2ZXIgKHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDg1NikuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtTdHJpbmdbXX1cclxuICogICAgIEEgbGlzdCBvZiBhbGwgbWltZXR5cGVzIHN1cHBvcnRlZCBieSBhbnkgYnVpbHQtaW4gR3VhY2Ftb2xlLkF1ZGlvUGxheWVyLFxyXG4gKiAgICAgZXhjbHVkaW5nIGFueSBwYXJhbWV0ZXJzLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkF1ZGlvUGxheWVyLmdldFN1cHBvcnRlZFR5cGVzID0gZnVuY3Rpb24gZ2V0U3VwcG9ydGVkVHlwZXMoKSB7XHJcblxyXG4gICAgcmV0dXJuIEd1YWNhbW9sZS5SYXdBdWRpb1BsYXllci5nZXRTdXBwb3J0ZWRUeXBlcygpO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIEd1YWNhbW9sZS5BdWRpb1BsYXllciBwcm92aWRpbmcgc3VwcG9ydCBmb3IgdGhlIGdpdmVuXHJcbiAqIGF1ZGlvIGZvcm1hdC4gSWYgc3VwcG9ydCBmb3IgdGhlIGdpdmVuIGF1ZGlvIGZvcm1hdCBpcyBub3QgYXZhaWxhYmxlLCBudWxsXHJcbiAqIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gc3RyZWFtXHJcbiAqICAgICBUaGUgR3VhY2Ftb2xlLklucHV0U3RyZWFtIHRvIHJlYWQgYXVkaW8gZGF0YSBmcm9tLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgYXVkaW8gZGF0YSBpbiB0aGUgcHJvdmlkZWQgc3RyZWFtLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtHdWFjYW1vbGUuQXVkaW9QbGF5ZXJ9XHJcbiAqICAgICBBIEd1YWNhbW9sZS5BdWRpb1BsYXllciBpbnN0YW5jZSBzdXBwb3J0aW5nIHRoZSBnaXZlbiBtaW1ldHlwZSBhbmRcclxuICogICAgIHJlYWRpbmcgZnJvbSB0aGUgZ2l2ZW4gc3RyZWFtLCBvciBudWxsIGlmIHN1cHBvcnQgZm9yIHRoZSBnaXZlbiBtaW1ldHlwZVxyXG4gKiAgICAgaXMgYWJzZW50LlxyXG4gKi9cclxuR3VhY2Ftb2xlLkF1ZGlvUGxheWVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0SW5zdGFuY2Uoc3RyZWFtLCBtaW1ldHlwZSkge1xyXG5cclxuICAgIC8vIFVzZSByYXcgYXVkaW8gcGxheWVyIGlmIHBvc3NpYmxlXHJcbiAgICBpZiAoR3VhY2Ftb2xlLlJhd0F1ZGlvUGxheWVyLmlzU3VwcG9ydGVkVHlwZShtaW1ldHlwZSkpXHJcbiAgICAgICAgcmV0dXJuIG5ldyBHdWFjYW1vbGUuUmF3QXVkaW9QbGF5ZXIoc3RyZWFtLCBtaW1ldHlwZSk7XHJcblxyXG4gICAgLy8gTm8gc3VwcG9ydCBmb3IgZ2l2ZW4gbWltZXR5cGVcclxuICAgIHJldHVybiBudWxsO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBHdWFjYW1vbGUuQXVkaW9QbGF5ZXIgcHJvdmlkaW5nIHN1cHBvcnQgZm9yIHJhdyBQQ00gZm9ybWF0XHJcbiAqIGF1ZGlvLiBUaGlzIHBsYXllciByZWxpZXMgb25seSBvbiB0aGUgV2ViIEF1ZGlvIEFQSSBhbmQgZG9lcyBub3QgcmVxdWlyZSBhbnlcclxuICogYnJvd3Nlci1sZXZlbCBzdXBwb3J0IGZvciBpdHMgYXVkaW8gZm9ybWF0cy5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhdWdtZW50cyBHdWFjYW1vbGUuQXVkaW9QbGF5ZXJcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuSW5wdXRTdHJlYW19IHN0cmVhbVxyXG4gKiAgICAgVGhlIEd1YWNhbW9sZS5JbnB1dFN0cmVhbSB0byByZWFkIGF1ZGlvIGRhdGEgZnJvbS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAqICAgICBUaGUgbWltZXR5cGUgb2YgdGhlIGF1ZGlvIGRhdGEgaW4gdGhlIHByb3ZpZGVkIHN0cmVhbSwgd2hpY2ggbXVzdCBiZSBhXHJcbiAqICAgICBcImF1ZGlvL0w4XCIgb3IgXCJhdWRpby9MMTZcIiBtaW1ldHlwZSB3aXRoIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzLCBzdWNoIGFzOlxyXG4gKiAgICAgXCJhdWRpby9MMTY7cmF0ZT00NDEwMCxjaGFubmVscz0yXCIuXHJcbiAqL1xyXG5HdWFjYW1vbGUuUmF3QXVkaW9QbGF5ZXIgPSBmdW5jdGlvbiBSYXdBdWRpb1BsYXllcihzdHJlYW0sIG1pbWV0eXBlKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZm9ybWF0IG9mIGF1ZGlvIHRoaXMgcGxheWVyIHdpbGwgZGVjb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLlJhd0F1ZGlvRm9ybWF0fVxyXG4gICAgICovXHJcbiAgICB2YXIgZm9ybWF0ID0gR3VhY2Ftb2xlLlJhd0F1ZGlvRm9ybWF0LnBhcnNlKG1pbWV0eXBlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGluc3RhbmNlIG9mIGEgV2ViIEF1ZGlvIEFQSSBBdWRpb0NvbnRleHQgb2JqZWN0LCBvciBudWxsIGlmIHRoZVxyXG4gICAgICogV2ViIEF1ZGlvIEFQSSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7QXVkaW9Db250ZXh0fVxyXG4gICAgICovXHJcbiAgICB2YXIgY29udGV4dCA9IEd1YWNhbW9sZS5BdWRpb0NvbnRleHRGYWN0b3J5LmdldEF1ZGlvQ29udGV4dCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGVhcmxpZXN0IHBvc3NpYmxlIHRpbWUgdGhhdCB0aGUgbmV4dCBwYWNrZXQgY291bGQgcGxheSB3aXRob3V0XHJcbiAgICAgKiBvdmVybGFwcGluZyBhbiBhbHJlYWR5LXBsYXlpbmcgcGFja2V0LCBpbiBzZWNvbmRzLiBOb3RlIHRoYXQgd2hpbGUgdGhpc1xyXG4gICAgICogdmFsdWUgaXMgaW4gc2Vjb25kcywgaXQgaXMgbm90IGFuIGludGVnZXIgdmFsdWUgYW5kIGhhcyBtaWNyb3NlY29uZFxyXG4gICAgICogcmVzb2x1dGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIG5leHRQYWNrZXRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEd1YWNhbW9sZS5BcnJheUJ1ZmZlclJlYWRlciB3cmFwcGVkIGFyb3VuZCB0aGUgYXVkaW8gaW5wdXQgc3RyZWFtXHJcbiAgICAgKiBwcm92aWRlZCB3aXRoIHRoaXMgR3VhY2Ftb2xlLlJhd0F1ZGlvUGxheWVyIHdhcyBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLkFycmF5QnVmZmVyUmVhZGVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgcmVhZGVyID0gbmV3IEd1YWNhbW9sZS5BcnJheUJ1ZmZlclJlYWRlcihzdHJlYW0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1pbmltdW0gc2l6ZSBvZiBhbiBhdWRpbyBwYWNrZXQgc3BsaXQgYnkgc3BsaXRBdWRpb1BhY2tldCgpLCBpblxyXG4gICAgICogc2Vjb25kcy4gQXVkaW8gcGFja2V0cyBzbWFsbGVyIHRoYW4gdGhpcyB3aWxsIG5vdCBiZSBzcGxpdCwgbm9yIHdpbGwgdGhlXHJcbiAgICAgKiBzcGxpdCByZXN1bHQgb2YgYSBsYXJnZXIgcGFja2V0IGV2ZXIgYmUgc21hbGxlciBpbiBzaXplIHRoYW4gdGhpc1xyXG4gICAgICogbWluaW11bS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgTUlOX1NQTElUX1NJWkUgPSAwLjAyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIGxhdGVuY3kgdG8gYWxsb3cgYmV0d2VlbiB0aGUgYnVmZmVyZWQgZGF0YSBzdHJlYW1cclxuICAgICAqIGFuZCB0aGUgcGxheWJhY2sgcG9zaXRpb24sIGluIHNlY29uZHMuIEluaXRpYWxseSwgdGhpcyBpcyBzZXQgdG9cclxuICAgICAqIHJvdWdobHkgb25lIHRoaXJkIG9mIGEgc2Vjb25kLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgbWF4TGF0ZW5jeSA9IDAuMztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0eXBlIG9mIHR5cGVkIGFycmF5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlcHJlc2VudCBlYWNoIGF1ZGlvIHBhY2tldFxyXG4gICAgICogaW50ZXJuYWxseS4gVGhpcyB3aWxsIGJlIGVpdGhlciBJbnQ4QXJyYXkgb3IgSW50MTZBcnJheSwgZGVwZW5kaW5nIG9uXHJcbiAgICAgKiB3aGV0aGVyIHRoZSByYXcgYXVkaW8gZm9ybWF0IGlzIDgtYml0IG9yIDE2LWJpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBTYW1wbGVBcnJheSA9IChmb3JtYXQuYnl0ZXNQZXJTYW1wbGUgPT09IDEpID8gd2luZG93LkludDhBcnJheSA6IHdpbmRvdy5JbnQxNkFycmF5O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gYWJzb2x1dGUgdmFsdWUgb2YgYW55IHNhbXBsZSB3aXRoaW4gYSByYXcgYXVkaW8gcGFja2V0XHJcbiAgICAgKiByZWNlaXZlZCBieSB0aGlzIGF1ZGlvIHBsYXllci4gVGhpcyBkZXBlbmRzIG9ubHkgb24gdGhlIHNpemUgb2YgZWFjaFxyXG4gICAgICogc2FtcGxlLCBhbmQgd2lsbCBiZSAxMjggZm9yIDgtYml0IGF1ZGlvIGFuZCAzMjc2OCBmb3IgMTYtYml0IGF1ZGlvLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgbWF4U2FtcGxlVmFsdWUgPSAoZm9ybWF0LmJ5dGVzUGVyU2FtcGxlID09PSAxKSA/IDEyOCA6IDMyNzY4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHF1ZXVlIG9mIGFsbCBwZW5kaW5nIGF1ZGlvIHBhY2tldHMsIGFzIGFuIGFycmF5IG9mIHNhbXBsZSBhcnJheXMuXHJcbiAgICAgKiBBdWRpbyBwYWNrZXRzIHdoaWNoIGFyZSBwZW5kaW5nIHBsYXliYWNrIHdpbGwgYmUgYWRkZWQgdG8gdGhpcyBxdWV1ZSBmb3JcclxuICAgICAqIGZ1cnRoZXIgbWFuaXB1bGF0aW9uIHByaW9yIHRvIHNjaGVkdWxpbmcgdmlhIHRoZSBXZWIgQXVkaW8gQVBJLiBPbmNlIGFuXHJcbiAgICAgKiBhdWRpbyBwYWNrZXQgbGVhdmVzIHRoaXMgcXVldWUgYW5kIGlzIHNjaGVkdWxlZCB2aWEgdGhlIFdlYiBBdWRpbyBBUEksXHJcbiAgICAgKiBubyBmdXJ0aGVyIG1vZGlmaWNhdGlvbnMgY2FuIGJlIG1hZGUgdG8gdGhhdCBwYWNrZXQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtTYW1wbGVBcnJheVtdfVxyXG4gICAgICovXHJcbiAgICB2YXIgcGFja2V0UXVldWUgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIGF1ZGlvIHBhY2tldHMsIHJldHVybnMgYSBzaW5nbGUgYXVkaW8gcGFja2V0XHJcbiAgICAgKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRob3NlIHBhY2tldHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U2FtcGxlQXJyYXlbXX0gcGFja2V0c1xyXG4gICAgICogICAgIFRoZSBhcnJheSBvZiBhdWRpbyBwYWNrZXRzIHRvIGNvbmNhdGVuYXRlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTYW1wbGVBcnJheX1cclxuICAgICAqICAgICBBIHNpbmdsZSBhdWRpbyBwYWNrZXQgY29udGFpbmluZyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgZ2l2ZW5cclxuICAgICAqICAgICBhdWRpbyBwYWNrZXRzLiBJZiBubyBwYWNrZXRzIGFyZSBwcm92aWRlZCwgdGhpcyB3aWxsIGJlIHVuZGVmaW5lZC5cclxuICAgICAqL1xyXG4gICAgdmFyIGpvaW5BdWRpb1BhY2tldHMgPSBmdW5jdGlvbiBqb2luQXVkaW9QYWNrZXRzKHBhY2tldHMpIHtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IGJvdGhlciBqb2luaW5nIGlmIG9uZSBvciBmZXdlciBwYWNrZXRzIGFyZSBpbiB0aGUgcXVldWVcclxuICAgICAgICBpZiAocGFja2V0cy5sZW5ndGggPD0gMSlcclxuICAgICAgICAgICAgcmV0dXJuIHBhY2tldHNbMF07XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB0b3RhbCBzYW1wbGUgbGVuZ3RoIG9mIHRoZSBlbnRpcmUgcXVldWVcclxuICAgICAgICB2YXIgdG90YWxMZW5ndGggPSAwO1xyXG4gICAgICAgIHBhY2tldHMuZm9yRWFjaChmdW5jdGlvbiBhZGRQYWNrZXRMZW5ndGhzKHBhY2tldCkge1xyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBwYWNrZXQubGVuZ3RoO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgZWFjaCBwYWNrZXQgd2l0aGluIHF1ZXVlXHJcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIGpvaW5lZCA9IG5ldyBTYW1wbGVBcnJheSh0b3RhbExlbmd0aCk7XHJcbiAgICAgICAgcGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uIGFwcGVuZFBhY2tldChwYWNrZXQpIHtcclxuICAgICAgICAgICAgam9pbmVkLnNldChwYWNrZXQsIG9mZnNldCk7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBwYWNrZXQubGVuZ3RoO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gam9pbmVkO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHNpbmdsZSBwYWNrZXQgb2YgYXVkaW8gZGF0YSwgc3BsaXRzIG9mZiBhbiBhcmJpdHJhcnkgbGVuZ3RoIG9mXHJcbiAgICAgKiBhdWRpbyBkYXRhIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGF0IHBhY2tldCwgcmV0dXJuaW5nIHRoZSBzcGxpdCByZXN1bHRcclxuICAgICAqIGFzIGFuIGFycmF5IG9mIHR3byBwYWNrZXRzLiBUaGUgc3BsaXQgbG9jYXRpb24gaXMgZGV0ZXJtaW5lZCB0aHJvdWdoIGFuXHJcbiAgICAgKiBhbGdvcml0aG0gaW50ZW5kZWQgdG8gbWluaW1pemUgdGhlIGxpa2xpaG9vZCBvZiBhdWRpYmxlIGNsaWNraW5nIGJldHdlZW5cclxuICAgICAqIHBhY2tldHMuIElmIG5vIHN1Y2ggc3BsaXQgbG9jYXRpb24gaXMgcG9zc2libGUsIGFuIGFycmF5IGNvbnRhaW5pbmcgb25seVxyXG4gICAgICogdGhlIG9yaWdpbmFsbHktcHJvdmlkZWQgYXVkaW8gcGFja2V0IGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1NhbXBsZUFycmF5fSBkYXRhXHJcbiAgICAgKiAgICAgVGhlIGF1ZGlvIHBhY2tldCB0byBzcGxpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7U2FtcGxlQXJyYXlbXX1cclxuICAgICAqICAgICBBbiBhcnJheSBvZiBhdWRpbyBwYWNrZXRzIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBzcGxpdHRpbmcgdGhlXHJcbiAgICAgKiAgICAgcHJvdmlkZWQgYXVkaW8gcGFja2V0LiBJZiBzcGxpdHRpbmcgaXMgcG9zc2libGUsIHRoaXMgYXJyYXkgd2lsbFxyXG4gICAgICogICAgIGNvbnRhaW4gdHdvIHBhY2tldHMuIElmIHNwbGl0dGluZyBpcyBub3QgcG9zc2libGUsIHRoaXMgYXJyYXkgd2lsbFxyXG4gICAgICogICAgIGNvbnRhaW4gb25seSB0aGUgb3JpZ2luYWxseS1wcm92aWRlZCBwYWNrZXQuXHJcbiAgICAgKi9cclxuICAgIHZhciBzcGxpdEF1ZGlvUGFja2V0ID0gZnVuY3Rpb24gc3BsaXRBdWRpb1BhY2tldChkYXRhKSB7XHJcblxyXG4gICAgICAgIHZhciBtaW5WYWx1ZSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgdmFyIG9wdGltYWxTcGxpdExlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHdob2xlIHNhbXBsZXMgaW4gdGhlIHByb3ZpZGVkIGF1ZGlvIHBhY2tldCBBTkRcclxuICAgICAgICAvLyBpbiB0aGUgbWluaW11bSBwb3NzaWJsZSBzcGxpdCBwYWNrZXRcclxuICAgICAgICB2YXIgc2FtcGxlcyA9IE1hdGguZmxvb3IoZGF0YS5sZW5ndGggLyBmb3JtYXQuY2hhbm5lbHMpO1xyXG4gICAgICAgIHZhciBtaW5TcGxpdFNhbXBsZXMgPSBNYXRoLmZsb29yKGZvcm1hdC5yYXRlICogTUlOX1NQTElUX1NJWkUpO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGJlZ2lubmluZyBvZiB0aGUgXCJlbmRcIiBvZiB0aGUgYXVkaW8gcGFja2V0XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgIGZvcm1hdC5jaGFubmVscyAqIG1pblNwbGl0U2FtcGxlcyxcclxuICAgICAgICAgICAgZm9ybWF0LmNoYW5uZWxzICogKHNhbXBsZXMgLSBtaW5TcGxpdFNhbXBsZXMpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gRm9yIGFsbCBzYW1wbGVzIGF0IHRoZSBlbmQgb2YgdGhlIGdpdmVuIHBhY2tldCwgZmluZCBhIHBvaW50IHdoZXJlXHJcbiAgICAgICAgLy8gdGhlIHBlcmNlcHRpYmxlIHZvbHVtZSBhY3Jvc3MgYWxsIGNoYW5uZWxzIGlzIGxvd2VzdCAoYW5kIHRodXMgaXNcclxuICAgICAgICAvLyB0aGUgb3B0aW1hbCBwb2ludCB0byBzcGxpdClcclxuICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSBzdGFydDsgb2Zmc2V0IDwgZGF0YS5sZW5ndGg7IG9mZnNldCArPSBmb3JtYXQuY2hhbm5lbHMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc3VtIG9mIGFsbCB2YWx1ZXMgYWNyb3NzIGFsbCBjaGFubmVscyAodGhlIHJlc3VsdFxyXG4gICAgICAgICAgICAvLyB3aWxsIGJlIHByb3BvcnRpb25hbCB0byB0aGUgYXZlcmFnZSB2b2x1bWUgb2YgYSBzYW1wbGUpXHJcbiAgICAgICAgICAgIHZhciB0b3RhbFZhbHVlID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBmb3JtYXQuY2hhbm5lbHM7IGNoYW5uZWwrKykge1xyXG4gICAgICAgICAgICAgICAgdG90YWxWYWx1ZSArPSBNYXRoLmFicyhkYXRhW29mZnNldCArIGNoYW5uZWxdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgc21hbGxlc3QgYXZlcmFnZSB2YWx1ZSB0aHVzIGZhciwgc2V0IHRoZSBzcGxpdFxyXG4gICAgICAgICAgICAvLyBsZW5ndGggc3VjaCB0aGF0IHRoZSBmaXJzdCBwYWNrZXQgZW5kcyB3aXRoIHRoZSBjdXJyZW50IHNhbXBsZVxyXG4gICAgICAgICAgICBpZiAodG90YWxWYWx1ZSA8PSBtaW5WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW1hbFNwbGl0TGVuZ3RoID0gb2Zmc2V0ICsgZm9ybWF0LmNoYW5uZWxzO1xyXG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSB0b3RhbFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgcGFja2V0IGlzIG5vdCBzcGxpdCwgcmV0dXJuIHRoZSBzdXBwbGllZCBwYWNrZXQgdW50b3VjaGVkXHJcbiAgICAgICAgaWYgKG9wdGltYWxTcGxpdExlbmd0aCA9PT0gZGF0YS5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBbZGF0YV07XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgc3BsaXQgdGhlIHBhY2tldCBpbnRvIHR3byBuZXcgcGFja2V0cyBhY2NvcmRpbmcgdG8gdGhlXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlZCBvcHRpbWFsIHNwbGl0IGxlbmd0aFxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5ldyBTYW1wbGVBcnJheShkYXRhLmJ1ZmZlci5zbGljZSgwLCBvcHRpbWFsU3BsaXRMZW5ndGggKiBmb3JtYXQuYnl0ZXNQZXJTYW1wbGUpKSxcclxuICAgICAgICAgICAgbmV3IFNhbXBsZUFycmF5KGRhdGEuYnVmZmVyLnNsaWNlKG9wdGltYWxTcGxpdExlbmd0aCAqIGZvcm1hdC5ieXRlc1BlclNhbXBsZSkpXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHVzaGVzIHRoZSBnaXZlbiBwYWNrZXQgb2YgYXVkaW8gZGF0YSBvbnRvIHRoZSBwbGF5YmFjayBxdWV1ZS4gVW5saWtlXHJcbiAgICAgKiBvdGhlciBwcml2YXRlIGZ1bmN0aW9ucyB3aXRoaW4gR3VhY2Ftb2xlLlJhd0F1ZGlvUGxheWVyLCB0aGUgdHlwZSBvZiB0aGVcclxuICAgICAqIEFycmF5QnVmZmVyIHBhY2tldCBvZiBhdWRpbyBkYXRhIGhlcmUgbmVlZCBub3QgYmUgc3BlY2lmaWMgdG8gdGhlIHR5cGVcclxuICAgICAqIG9mIGF1ZGlvIChhcyB3aXRoIFNhbXBsZUFycmF5KS4gVGhlIEFycmF5QnVmZmVyIHR5cGUgcHJvdmlkZWQgYnkgYVxyXG4gICAgICogR3VhY2Ftb2xlLkFycmF5QnVmZmVyUmVhZGVyLCBmb3IgZXhhbXBsZSwgaXMgc3VmZmljaWVudC4gQW55IG5lY2Vzc2FyeVxyXG4gICAgICogY29udmVyc2lvbnMgd2lsbCBiZSBwZXJmb3JtZWQgYXV0b21hdGljYWxseSBpbnRlcm5hbGx5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXHJcbiAgICAgKiAgICAgQSByYXcgcGFja2V0IG9mIGF1ZGlvIGRhdGEgdGhhdCBzaG91bGQgYmUgcHVzaGVkIG9udG8gdGhlIGF1ZGlvXHJcbiAgICAgKiAgICAgcGxheWJhY2sgcXVldWUuXHJcbiAgICAgKi9cclxuICAgIHZhciBwdXNoQXVkaW9QYWNrZXQgPSBmdW5jdGlvbiBwdXNoQXVkaW9QYWNrZXQoZGF0YSkge1xyXG4gICAgICAgIHBhY2tldFF1ZXVlLnB1c2gobmV3IFNhbXBsZUFycmF5KGRhdGEpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGlmdHMgb2ZmIGFuZCByZXR1cm5zIGEgcGFja2V0IG9mIGF1ZGlvIGRhdGEgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZVxyXG4gICAgICogcGxheWJhY2sgcXVldWUuIFRoZSBsZW5ndGggb2YgdGhpcyBhdWRpbyBwYWNrZXQgaXMgZGV0ZXJtaW5lZFxyXG4gICAgICogZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIHRoZSBjbGljay1yZWR1Y3Rpb24gYWxnb3JpdGhtIGltcGxlbWVudGVkIGJ5XHJcbiAgICAgKiBzcGxpdEF1ZGlvUGFja2V0KCkuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtTYW1wbGVBcnJheX1cclxuICAgICAqICAgICBBIHBhY2tldCBvZiBhdWRpbyBkYXRhIHB1bGxlZCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBsYXliYWNrXHJcbiAgICAgKiAgICAgcXVldWUuXHJcbiAgICAgKi9cclxuICAgIHZhciBzaGlmdEF1ZGlvUGFja2V0ID0gZnVuY3Rpb24gc2hpZnRBdWRpb1BhY2tldCgpIHtcclxuXHJcbiAgICAgICAgLy8gRmxhdHRlbiBkYXRhIGluIHBhY2tldCBxdWV1ZVxyXG4gICAgICAgIHZhciBkYXRhID0gam9pbkF1ZGlvUGFja2V0cyhwYWNrZXRRdWV1ZSk7XHJcbiAgICAgICAgaWYgKCFkYXRhKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gUHVsbCBhbiBhcHByb3ByaWF0ZSBhbW91bnQgb2YgZGF0YSBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcclxuICAgICAgICBwYWNrZXRRdWV1ZSA9IHNwbGl0QXVkaW9QYWNrZXQoZGF0YSk7XHJcbiAgICAgICAgZGF0YSA9IHBhY2tldFF1ZXVlLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gYXVkaW8gcGFja2V0IGludG8gYW4gQXVkaW9CdWZmZXIsIHJlYWR5IGZvciBwbGF5YmFja1xyXG4gICAgICogYnkgdGhlIFdlYiBBdWRpbyBBUEkuIFVubGlrZSB0aGUgcmF3IGF1ZGlvIHBhY2tldHMgcmVjZWl2ZWQgYnkgdGhpc1xyXG4gICAgICogYXVkaW8gcGxheWVyLCBBdWRpb0J1ZmZlcnMgcmVxdWlyZSBmbG9hdGluZyBwb2ludCBzYW1wbGVzIGFuZCBhcmUgc3BsaXRcclxuICAgICAqIGludG8gaXNvbGF0ZWQgcGxhbmVzIG9mIGNoYW5uZWwtc3BlY2lmaWMgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTYW1wbGVBcnJheX0gZGF0YVxyXG4gICAgICogICAgIFRoZSByYXcgYXVkaW8gcGFja2V0IHRoYXQgc2hvdWxkIGJlIGNvbnZlcnRlZCBpbnRvIGEgV2ViIEF1ZGlvIEFQSVxyXG4gICAgICogICAgIEF1ZGlvQnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtBdWRpb0J1ZmZlcn1cclxuICAgICAqICAgICBBIG5ldyBXZWIgQXVkaW8gQVBJIEF1ZGlvQnVmZmVyIGNvbnRhaW5pbmcgdGhlIHByb3ZpZGVkIGF1ZGlvIGRhdGEsXHJcbiAgICAgKiAgICAgY29udmVydGVkIHRvIHRoZSBmb3JtYXQgdXNlZCBieSB0aGUgV2ViIEF1ZGlvIEFQSS5cclxuICAgICAqL1xyXG4gICAgdmFyIHRvQXVkaW9CdWZmZXIgPSBmdW5jdGlvbiB0b0F1ZGlvQnVmZmVyKGRhdGEpIHtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIG51bWJlciBvZiBzYW1wbGVzXHJcbiAgICAgICAgdmFyIHNhbXBsZXMgPSBkYXRhLmxlbmd0aCAvIGZvcm1hdC5jaGFubmVscztcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGV4YWN0bHkgd2hlbiBwYWNrZXQgQ0FOIHBsYXlcclxuICAgICAgICB2YXIgcGFja2V0VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICAgICAgaWYgKG5leHRQYWNrZXRUaW1lIDwgcGFja2V0VGltZSlcclxuICAgICAgICAgICAgbmV4dFBhY2tldFRpbWUgPSBwYWNrZXRUaW1lO1xyXG5cclxuICAgICAgICAvLyBHZXQgYXVkaW8gYnVmZmVyIGZvciBzcGVjaWZpZWQgZm9ybWF0XHJcbiAgICAgICAgdmFyIGF1ZGlvQnVmZmVyID0gY29udGV4dC5jcmVhdGVCdWZmZXIoZm9ybWF0LmNoYW5uZWxzLCBzYW1wbGVzLCBmb3JtYXQucmF0ZSk7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgZWFjaCBjaGFubmVsXHJcbiAgICAgICAgZm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBmb3JtYXQuY2hhbm5lbHM7IGNoYW5uZWwrKykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGF1ZGlvRGF0YSA9IGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWwpO1xyXG5cclxuICAgICAgICAgICAgLy8gRmlsbCBhdWRpbyBidWZmZXIgd2l0aCBkYXRhIGZvciBjaGFubmVsXHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBjaGFubmVsO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXVkaW9EYXRhW2ldID0gZGF0YVtvZmZzZXRdIC8gbWF4U2FtcGxlVmFsdWU7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZm9ybWF0LmNoYW5uZWxzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGF1ZGlvQnVmZmVyO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gRGVmZXIgcGxheWJhY2sgb2YgcmVjZWl2ZWQgYXVkaW8gcGFja2V0cyBzbGlnaHRseVxyXG4gICAgcmVhZGVyLm9uZGF0YSA9IGZ1bmN0aW9uIHBsYXlSZWNlaXZlZEF1ZGlvKGRhdGEpIHtcclxuXHJcbiAgICAgICAgLy8gUHVzaCByZWNlaXZlZCBzYW1wbGVzIG9udG8gcXVldWVcclxuICAgICAgICBwdXNoQXVkaW9QYWNrZXQobmV3IFNhbXBsZUFycmF5KGRhdGEpKTtcclxuXHJcbiAgICAgICAgLy8gU2hpZnQgb2ZmIGFuIGFyYml0cmFyeSBwYWNrZXQgb2YgYXVkaW8gZGF0YSBmcm9tIHRoZSBxdWV1ZSAodGhpcyBtYXlcclxuICAgICAgICAvLyBiZSBkaWZmZXJlbnQgaW4gc2l6ZSBmcm9tIHRoZSBwYWNrZXQganVzdCBwdXNoZWQpXHJcbiAgICAgICAgdmFyIHBhY2tldCA9IHNoaWZ0QXVkaW9QYWNrZXQoKTtcclxuICAgICAgICBpZiAoIXBhY2tldClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgZXhhY3RseSB3aGVuIHBhY2tldCBDQU4gcGxheVxyXG4gICAgICAgIHZhciBwYWNrZXRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZTtcclxuICAgICAgICBpZiAobmV4dFBhY2tldFRpbWUgPCBwYWNrZXRUaW1lKVxyXG4gICAgICAgICAgICBuZXh0UGFja2V0VGltZSA9IHBhY2tldFRpbWU7XHJcblxyXG4gICAgICAgIC8vIFNldCB1cCBidWZmZXIgc291cmNlXHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IGNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgc291cmNlLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XHJcblxyXG4gICAgICAgIC8vIFVzZSBub3RlT24oKSBpbnN0ZWFkIG9mIHN0YXJ0KCkgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgaWYgKCFzb3VyY2Uuc3RhcnQpXHJcbiAgICAgICAgICAgIHNvdXJjZS5zdGFydCA9IHNvdXJjZS5ub3RlT247XHJcblxyXG4gICAgICAgIC8vIFNjaGVkdWxlIHBhY2tldFxyXG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSB0b0F1ZGlvQnVmZmVyKHBhY2tldCk7XHJcbiAgICAgICAgc291cmNlLnN0YXJ0KG5leHRQYWNrZXRUaW1lKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRpbWVsaW5lIGJ5IGR1cmF0aW9uIG9mIHNjaGVkdWxlZCBwYWNrZXRcclxuICAgICAgICBuZXh0UGFja2V0VGltZSArPSBwYWNrZXQubGVuZ3RoIC8gZm9ybWF0LmNoYW5uZWxzIC8gZm9ybWF0LnJhdGU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKiogQG92ZXJyaWRlICovXHJcbiAgICB0aGlzLnN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgZWxhcHNlZCB0aW1lIHNpbmNlIGxhc3Qgc3luY1xyXG4gICAgICAgIHZhciBub3cgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xyXG5cclxuICAgICAgICAvLyBSZXNjaGVkdWxlIGZ1dHVyZSBwbGF5YmFjayB0aW1lIHN1Y2ggdGhhdCBwbGF5YmFjayBsYXRlbmN5IGlzXHJcbiAgICAgICAgLy8gYm91bmRlZCB3aXRoaW4gYSByZWFzb25hYmxlIGxhdGVuY3kgdGhyZXNob2xkXHJcbiAgICAgICAgbmV4dFBhY2tldFRpbWUgPSBNYXRoLm1pbihuZXh0UGFja2V0VGltZSwgbm93ICsgbWF4TGF0ZW5jeSk7XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5HdWFjYW1vbGUuUmF3QXVkaW9QbGF5ZXIucHJvdG90eXBlID0gbmV3IEd1YWNhbW9sZS5BdWRpb1BsYXllcigpO1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gbWltZXR5cGUgaXMgc3VwcG9ydGVkIGJ5XHJcbiAqIEd1YWNhbW9sZS5SYXdBdWRpb1BsYXllci5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAqICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2suXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKiAgICAgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbWltZXR5cGUgaXMgc3VwcG9ydGVkIGJ5IEd1YWNhbW9sZS5SYXdBdWRpb1BsYXllcixcclxuICogICAgIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbkd1YWNhbW9sZS5SYXdBdWRpb1BsYXllci5pc1N1cHBvcnRlZFR5cGUgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZFR5cGUobWltZXR5cGUpIHtcclxuXHJcbiAgICAvLyBObyBzdXBwb3J0ZWQgdHlwZXMgaWYgbm8gV2ViIEF1ZGlvIEFQSVxyXG4gICAgaWYgKCFHdWFjYW1vbGUuQXVkaW9Db250ZXh0RmFjdG9yeS5nZXRBdWRpb0NvbnRleHQoKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuIEd1YWNhbW9sZS5SYXdBdWRpb0Zvcm1hdC5wYXJzZShtaW1ldHlwZSkgIT09IG51bGw7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBtaW1ldHlwZXMgc3VwcG9ydGVkIGJ5IEd1YWNhbW9sZS5SYXdBdWRpb1BsYXllci4gT25seVxyXG4gKiB0aGUgY29yZSBtaW1ldHlwZXMgdGhlbXNlbHZlcyB3aWxsIGJlIGxpc3RlZC4gQW55IG1pbWV0eXBlIHBhcmFtZXRlcnMsIGV2ZW5cclxuICogcmVxdWlyZWQgb25lcywgd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIGxpc3QuIEZvciBleGFtcGxlLCBcImF1ZGlvL0w4XCIgaXNcclxuICogYSByYXcgYXVkaW8gbWltZXR5cGUgdGhhdCBtYXkgYmUgc3VwcG9ydGVkLCBidXQgaXQgaXMgaW52YWxpZCB3aXRob3V0XHJcbiAqIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gU29tZXRoaW5nIGxpa2UgXCJhdWRpby9MODtyYXRlPTQ0MTAwXCIgd291bGQgYmUgdmFsaWQsXHJcbiAqIGhvd2V2ZXIgKHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDg1NikuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtTdHJpbmdbXX1cclxuICogICAgIEEgbGlzdCBvZiBhbGwgbWltZXR5cGVzIHN1cHBvcnRlZCBieSBHdWFjYW1vbGUuUmF3QXVkaW9QbGF5ZXIsIGV4Y2x1ZGluZ1xyXG4gKiAgICAgYW55IHBhcmFtZXRlcnMuIElmIHRoZSBuZWNlc3NhcnkgSmF2YVNjcmlwdCBBUElzIGZvciBwbGF5aW5nIHJhdyBhdWRpb1xyXG4gKiAgICAgYXJlIGFic2VudCwgdGhpcyBsaXN0IHdpbGwgYmUgZW1wdHkuXHJcbiAqL1xyXG5HdWFjYW1vbGUuUmF3QXVkaW9QbGF5ZXIuZ2V0U3VwcG9ydGVkVHlwZXMgPSBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRUeXBlcygpIHtcclxuXHJcbiAgICAvLyBObyBzdXBwb3J0ZWQgdHlwZXMgaWYgbm8gV2ViIEF1ZGlvIEFQSVxyXG4gICAgaWYgKCFHdWFjYW1vbGUuQXVkaW9Db250ZXh0RmFjdG9yeS5nZXRBdWRpb0NvbnRleHQoKSlcclxuICAgICAgICByZXR1cm4gW107XHJcblxyXG4gICAgLy8gV2Ugc3VwcG9ydCA4LWJpdCBhbmQgMTYtYml0IHJhdyBQQ01cclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgJ2F1ZGlvL0w4JyxcclxuICAgICAgICAnYXVkaW8vTDE2J1xyXG4gICAgXTtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBhdWRpbyByZWNvcmRlciB3aGljaCBzdHJlYW1zIGFyYml0cmFyeSBhdWRpbyBkYXRhIHRvIGFuIHVuZGVybHlpbmdcclxuICogR3VhY2Ftb2xlLk91dHB1dFN0cmVhbS4gSXQgaXMgdXAgdG8gaW1wbGVtZW50YXRpb25zIG9mIHRoaXMgY2xhc3MgdG8gcHJvdmlkZVxyXG4gKiBzb21lIG1lYW5zIG9mIGhhbmRsaW5nIHRoaXMgR3VhY2Ftb2xlLk91dHB1dFN0cmVhbS4gRGF0YSBwcm9kdWNlZCBieSB0aGVcclxuICogcmVjb3JkZXIgaXMgdG8gYmUgc2VudCBhbG9uZyB0aGUgcHJvdmlkZWQgc3RyZWFtIGltbWVkaWF0ZWx5LlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbkd1YWNhbW9sZS5BdWRpb1JlY29yZGVyID0gZnVuY3Rpb24gQXVkaW9SZWNvcmRlcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHdoaWNoIGlzIGludm9rZWQgd2hlbiB0aGUgYXVkaW8gcmVjb3JkaW5nIHByb2Nlc3MgaGFzIHN0b3BwZWRcclxuICAgICAqIGFuZCB0aGUgdW5kZXJseWluZyBHdWFjYW1vbGUgc3RyZWFtIGhhcyBiZWVuIGNsb3NlZCBub3JtYWxseS4gQXVkaW8gd2lsbFxyXG4gICAgICogb25seSByZXN1bWUgcmVjb3JkaW5nIGlmIGEgbmV3IEd1YWNhbW9sZS5BdWRpb1JlY29yZGVyIGlzIHN0YXJ0ZWQuIFRoaXNcclxuICAgICAqIEd1YWNhbW9sZS5BdWRpb1JlY29yZGVyIGluc3RhbmNlIE1BWSBOT1QgYmUgcmV1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uY2xvc2UgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgd2hpY2ggaXMgaW52b2tlZCB3aGVuIHRoZSBhdWRpbyByZWNvcmRpbmcgcHJvY2VzcyBjYW5ub3RcclxuICAgICAqIGNvbnRpbnVlIGR1ZSB0byBhbiBlcnJvciwgaWYgaXQgaGFzIHN0YXJ0ZWQgYXQgYWxsLiBUaGUgdW5kZXJseWluZ1xyXG4gICAgICogR3VhY2Ftb2xlIHN0cmVhbSBpcyBhdXRvbWF0aWNhbGx5IGNsb3NlZC4gRnV0dXJlIGF0dGVtcHRzIHRvIHJlY29yZFxyXG4gICAgICogYXVkaW8gc2hvdWxkIG5vdCBiZSBtYWRlLCBhbmQgdGhpcyBHdWFjYW1vbGUuQXVkaW9SZWNvcmRlciBpbnN0YW5jZVxyXG4gICAgICogTUFZIE5PVCBiZSByZXVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHRoaXMub25lcnJvciA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gbWltZXR5cGUgaXMgc3VwcG9ydGVkIGJ5IGFueSBidWlsdC1pblxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBHdWFjYW1vbGUuQXVkaW9SZWNvcmRlciwgYW5kIHRodXMgd2lsbCBiZSBwcm9wZXJseSBoYW5kbGVkXHJcbiAqIGJ5IEd1YWNhbW9sZS5BdWRpb1JlY29yZGVyLmdldEluc3RhbmNlKCkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gKiAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICogICAgIHRydWUgaWYgdGhlIGdpdmVuIG1pbWV0eXBlIGlzIHN1cHBvcnRlZCBieSBhbnkgYnVpbHQtaW5cclxuICogICAgIEd1YWNhbW9sZS5BdWRpb1JlY29yZGVyLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5HdWFjYW1vbGUuQXVkaW9SZWNvcmRlci5pc1N1cHBvcnRlZFR5cGUgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZFR5cGUobWltZXR5cGUpIHtcclxuXHJcbiAgICByZXR1cm4gR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIuaXNTdXBwb3J0ZWRUeXBlKG1pbWV0eXBlKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIG1pbWV0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IGJ1aWx0LWluXHJcbiAqIEd1YWNhbW9sZS5BdWRpb1JlY29yZGVyLCBpbiByb3VnaCBvcmRlciBvZiBwcmlvcml0eS4gQmV3YXJlIHRoYXQgb25seSB0aGVcclxuICogY29yZSBtaW1ldHlwZXMgdGhlbXNlbHZlcyB3aWxsIGJlIGxpc3RlZC4gQW55IG1pbWV0eXBlIHBhcmFtZXRlcnMsIGV2ZW5cclxuICogcmVxdWlyZWQgb25lcywgd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIGxpc3QuIEZvciBleGFtcGxlLCBcImF1ZGlvL0w4XCIgaXNcclxuICogYSBzdXBwb3J0ZWQgcmF3IGF1ZGlvIG1pbWV0eXBlIHRoYXQgaXMgc3VwcG9ydGVkLCBidXQgaXQgaXMgaW52YWxpZCB3aXRob3V0XHJcbiAqIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gU29tZXRoaW5nIGxpa2UgXCJhdWRpby9MODtyYXRlPTQ0MTAwXCIgd291bGQgYmUgdmFsaWQsXHJcbiAqIGhvd2V2ZXIgKHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDg1NikuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtTdHJpbmdbXX1cclxuICogICAgIEEgbGlzdCBvZiBhbGwgbWltZXR5cGVzIHN1cHBvcnRlZCBieSBhbnkgYnVpbHQtaW5cclxuICogICAgIEd1YWNhbW9sZS5BdWRpb1JlY29yZGVyLCBleGNsdWRpbmcgYW55IHBhcmFtZXRlcnMuXHJcbiAqL1xyXG5HdWFjYW1vbGUuQXVkaW9SZWNvcmRlci5nZXRTdXBwb3J0ZWRUeXBlcyA9IGZ1bmN0aW9uIGdldFN1cHBvcnRlZFR5cGVzKCkge1xyXG5cclxuICAgIHJldHVybiBHdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlci5nZXRTdXBwb3J0ZWRUeXBlcygpO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIEd1YWNhbW9sZS5BdWRpb1JlY29yZGVyIHByb3ZpZGluZyBzdXBwb3J0IGZvciB0aGVcclxuICogZ2l2ZW4gYXVkaW8gZm9ybWF0LiBJZiBzdXBwb3J0IGZvciB0aGUgZ2l2ZW4gYXVkaW8gZm9ybWF0IGlzIG5vdCBhdmFpbGFibGUsXHJcbiAqIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLk91dHB1dFN0cmVhbX0gc3RyZWFtXHJcbiAqICAgICBUaGUgR3VhY2Ftb2xlLk91dHB1dFN0cmVhbSB0byBzZW5kIGF1ZGlvIGRhdGEgdGhyb3VnaC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAqICAgICBUaGUgbWltZXR5cGUgb2YgdGhlIGF1ZGlvIGRhdGEgdG8gYmUgc2VudCBhbG9uZyB0aGUgcHJvdmlkZWQgc3RyZWFtLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtHdWFjYW1vbGUuQXVkaW9SZWNvcmRlcn1cclxuICogICAgIEEgR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXIgaW5zdGFuY2Ugc3VwcG9ydGluZyB0aGUgZ2l2ZW4gbWltZXR5cGUgYW5kXHJcbiAqICAgICB3cml0aW5nIHRvIHRoZSBnaXZlbiBzdHJlYW0sIG9yIG51bGwgaWYgc3VwcG9ydCBmb3IgdGhlIGdpdmVuIG1pbWV0eXBlXHJcbiAqICAgICBpcyBhYnNlbnQuXHJcbiAqL1xyXG5HdWFjYW1vbGUuQXVkaW9SZWNvcmRlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldEluc3RhbmNlKHN0cmVhbSwgbWltZXR5cGUpIHtcclxuXHJcbiAgICAvLyBVc2UgcmF3IGF1ZGlvIHJlY29yZGVyIGlmIHBvc3NpYmxlXHJcbiAgICBpZiAoR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIuaXNTdXBwb3J0ZWRUeXBlKG1pbWV0eXBlKSlcclxuICAgICAgICByZXR1cm4gbmV3IEd1YWNhbW9sZS5SYXdBdWRpb1JlY29yZGVyKHN0cmVhbSwgbWltZXR5cGUpO1xyXG5cclxuICAgIC8vIE5vIHN1cHBvcnQgZm9yIGdpdmVuIG1pbWV0eXBlXHJcbiAgICByZXR1cm4gbnVsbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgR3VhY2Ftb2xlLkF1ZGlvUmVjb3JkZXIgcHJvdmlkaW5nIHN1cHBvcnQgZm9yIHJhdyBQQ01cclxuICogZm9ybWF0IGF1ZGlvLiBUaGlzIHJlY29yZGVyIHJlbGllcyBvbmx5IG9uIHRoZSBXZWIgQXVkaW8gQVBJIGFuZCBkb2VzIG5vdFxyXG4gKiByZXF1aXJlIGFueSBicm93c2VyLWxldmVsIHN1cHBvcnQgZm9yIGl0cyBhdWRpbyBmb3JtYXRzLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1Z21lbnRzIEd1YWNhbW9sZS5BdWRpb1JlY29yZGVyXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLk91dHB1dFN0cmVhbX0gc3RyZWFtXHJcbiAqICAgICBUaGUgR3VhY2Ftb2xlLk91dHB1dFN0cmVhbSB0byB3cml0ZSBhdWRpbyBkYXRhIHRvLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgYXVkaW8gZGF0YSB0byBzZW5kIGFsb25nIHRoZSBwcm92aWRlZCBzdHJlYW0sIHdoaWNoXHJcbiAqICAgICBtdXN0IGJlIGEgXCJhdWRpby9MOFwiIG9yIFwiYXVkaW8vTDE2XCIgbWltZXR5cGUgd2l0aCBuZWNlc3NhcnkgcGFyYW1ldGVycyxcclxuICogICAgIHN1Y2ggYXM6IFwiYXVkaW8vTDE2O3JhdGU9NDQxMDAsY2hhbm5lbHM9MlwiLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIgPSBmdW5jdGlvbiBSYXdBdWRpb1JlY29yZGVyKHN0cmVhbSwgbWltZXR5cGUpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIFJhd0F1ZGlvUmVjb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIHJlY29yZGVyID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzaXplIG9mIGF1ZGlvIGJ1ZmZlciB0byByZXF1ZXN0IGZyb20gdGhlIFdlYiBBdWRpbyBBUEkgd2hlblxyXG4gICAgICogcmVjb3JkaW5nIG9yIHByb2Nlc3NpbmcgYXVkaW8sIGluIHNhbXBsZS1mcmFtZXMuIFRoaXMgbXVzdCBiZSBhIHBvd2VyIG9mXHJcbiAgICAgKiB0d28gYmV0d2VlbiAyNTYgYW5kIDE2Mzg0IGluY2x1c2l2ZSwgYXMgcmVxdWlyZWQgYnlcclxuICAgICAqIEF1ZGlvQ29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoKS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgQlVGRkVSX1NJWkUgPSAyMDQ4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpbmRvdyBzaXplIHRvIHVzZSB3aGVuIGFwcGx5aW5nIExhbmN6b3MgaW50ZXJwb2xhdGlvbiwgY29tbW9ubHlcclxuICAgICAqIGRlbm90ZWQgYnkgdGhlIHZhcmlhYmxlIFwiYVwiLlxyXG4gICAgICogU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYW5jem9zX3Jlc2FtcGxpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnRhbnRcclxuICAgICAqIEB0eXBlIE51bWJlclxyXG4gICAgICovXHJcbiAgICB2YXIgTEFOQ1pPU19XSU5ET1dfU0laRSA9IDM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZm9ybWF0IG9mIGF1ZGlvIHRoaXMgcmVjb3JkZXIgd2lsbCBlbmNvZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuUmF3QXVkaW9Gb3JtYXR9XHJcbiAgICAgKi9cclxuICAgIHZhciBmb3JtYXQgPSBHdWFjYW1vbGUuUmF3QXVkaW9Gb3JtYXQucGFyc2UobWltZXR5cGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW5zdGFuY2Ugb2YgYSBXZWIgQXVkaW8gQVBJIEF1ZGlvQ29udGV4dCBvYmplY3QsIG9yIG51bGwgaWYgdGhlXHJcbiAgICAgKiBXZWIgQXVkaW8gQVBJIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtBdWRpb0NvbnRleHR9XHJcbiAgICAgKi9cclxuICAgIHZhciBjb250ZXh0ID0gR3VhY2Ftb2xlLkF1ZGlvQ29udGV4dEZhY3RvcnkuZ2V0QXVkaW9Db250ZXh0KCk7XHJcblxyXG4gICAgLy8gU29tZSBicm93c2VycyBkbyBub3QgaW1wbGVtZW50IG5hdmlnYXRvci5tZWRpYURldmljZXMgLSB0aGlzXHJcbiAgICAvLyBzaGltcyBpbiB0aGlzIGZ1bmN0aW9uYWxpdHkgdG8gZW5zdXJlIGNvZGUgY29tcGF0aWJpbGl0eS5cclxuICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcylcclxuICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzID0ge307XHJcblxyXG4gICAgLy8gQnJvd3NlcnMgdGhhdCBlaXRoZXIgZG8gbm90IGltcGxlbWVudCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXHJcbiAgICAvLyBhdCBhbGwgb3IgZG8gbm90IGltcGxlbWVudCBpdCBjb21wbGV0ZWx5IG5lZWQgdGhlIGdldFVzZXJNZWRpYVxyXG4gICAgLy8gbWV0aG9kIGRlZmluZWQuICBUaGlzIHNoaW1zIGluIHRoaXMgZnVuY3Rpb24gYnkgZGV0ZWN0aW5nXHJcbiAgICAvLyBvbmUgb2YgdGhlIHN1cHBvcnRlZCBsZWdhY3kgbWV0aG9kcy5cclxuICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpXHJcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSAobmF2aWdhdG9yLmdldFVzZXJNZWRpYVxyXG4gICAgICAgICAgICAgICAgfHwgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYVxyXG4gICAgICAgICAgICAgICAgfHwgbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYVxyXG4gICAgICAgICAgICAgICAgfHwgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhKS5iaW5kKG5hdmlnYXRvcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHdWFjYW1vbGUuQXJyYXlCdWZmZXJXcml0ZXIgd3JhcHBlZCBhcm91bmQgdGhlIGF1ZGlvIG91dHB1dCBzdHJlYW1cclxuICAgICAqIHByb3ZpZGVkIHdoZW4gdGhpcyBHdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlciB3YXMgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIHdyaXRlciA9IG5ldyBHdWFjYW1vbGUuQXJyYXlCdWZmZXJXcml0ZXIoc3RyZWFtKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0eXBlIG9mIHR5cGVkIGFycmF5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlcHJlc2VudCBlYWNoIGF1ZGlvIHBhY2tldFxyXG4gICAgICogaW50ZXJuYWxseS4gVGhpcyB3aWxsIGJlIGVpdGhlciBJbnQ4QXJyYXkgb3IgSW50MTZBcnJheSwgZGVwZW5kaW5nIG9uXHJcbiAgICAgKiB3aGV0aGVyIHRoZSByYXcgYXVkaW8gZm9ybWF0IGlzIDgtYml0IG9yIDE2LWJpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBTYW1wbGVBcnJheSA9IChmb3JtYXQuYnl0ZXNQZXJTYW1wbGUgPT09IDEpID8gd2luZG93LkludDhBcnJheSA6IHdpbmRvdy5JbnQxNkFycmF5O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gYWJzb2x1dGUgdmFsdWUgb2YgYW55IHNhbXBsZSB3aXRoaW4gYSByYXcgYXVkaW8gcGFja2V0IHNlbnRcclxuICAgICAqIGJ5IHRoaXMgYXVkaW8gcmVjb3JkZXIuIFRoaXMgZGVwZW5kcyBvbmx5IG9uIHRoZSBzaXplIG9mIGVhY2ggc2FtcGxlLFxyXG4gICAgICogYW5kIHdpbGwgYmUgMTI4IGZvciA4LWJpdCBhdWRpbyBhbmQgMzI3NjggZm9yIDE2LWJpdCBhdWRpby5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIG1heFNhbXBsZVZhbHVlID0gKGZvcm1hdC5ieXRlc1BlclNhbXBsZSA9PT0gMSkgPyAxMjggOiAzMjc2ODtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgYXVkaW8gc2FtcGxlcyByZWFkIGZyb20gdGhlIGxvY2FsIGF1ZGlvIGlucHV0IGRldmljZVxyXG4gICAgICogb3ZlciB0aGUgbGlmZSBvZiB0aGlzIGF1ZGlvIHJlY29yZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgcmVhZFNhbXBsZXMgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRvdGFsIG51bWJlciBvZiBhdWRpbyBzYW1wbGVzIHdyaXR0ZW4gdG8gdGhlIHVuZGVybHlpbmcgR3VhY2Ftb2xlXHJcbiAgICAgKiBjb25uZWN0aW9uIG92ZXIgdGhlIGxpZmUgb2YgdGhpcyBhdWRpbyByZWNvcmRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIHdyaXR0ZW5TYW1wbGVzID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhdWRpbyBzdHJlYW0gcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXIsIGlmIGFsbG93ZWQuIElmIG5vIHN0cmVhbSBoYXNcclxuICAgICAqIHlldCBiZWVuIHJlY2VpdmVkLCB0aGlzIHdpbGwgYmUgbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSBNZWRpYVN0cmVhbVxyXG4gICAgICovXHJcbiAgICB2YXIgbWVkaWFTdHJlYW0gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNvdXJjZSBub2RlIHByb3ZpZGluZyBhY2Nlc3MgdG8gdGhlIGxvY2FsIGF1ZGlvIGlucHV0IGRldmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge01lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlfVxyXG4gICAgICovXHJcbiAgICB2YXIgc291cmNlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzY3JpcHQgcHJvY2Vzc2luZyBub2RlIHdoaWNoIHJlY2VpdmVzIGF1ZGlvIGlucHV0IGZyb20gdGhlIG1lZGlhXHJcbiAgICAgKiBzdHJlYW0gc291cmNlIG5vZGUgYXMgaW5kaXZpZHVhbCBhdWRpbyBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7U2NyaXB0UHJvY2Vzc29yTm9kZX1cclxuICAgICAqL1xyXG4gICAgdmFyIHByb2Nlc3NvciA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbm9ybWFsaXplZCBzaW5jIGZ1bmN0aW9uLiBUaGUgbm9ybWFsaXplZCBzaW5jIGZ1bmN0aW9uIGlzIGRlZmluZWQgYXNcclxuICAgICAqIDEgZm9yIHg9MCBhbmQgc2luKFBJICogeCkgLyAoUEkgKiB4KSBmb3IgYWxsIG90aGVyIHZhbHVlcyBvZiB4LlxyXG4gICAgICpcclxuICAgICAqIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2luY19mdW5jdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogICAgIFRoZSBwb2ludCBhdCB3aGljaCB0aGUgbm9ybWFsaXplZCBzaW5jIGZ1bmN0aW9uIHNob3VsZCBiZSBjb21wdXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogICAgIFRoZSB2YWx1ZSBvZiB0aGUgbm9ybWFsaXplZCBzaW5jIGZ1bmN0aW9uIGF0IHguXHJcbiAgICAgKi9cclxuICAgIHZhciBzaW5jID0gZnVuY3Rpb24gc2luYyh4KSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSB2YWx1ZSBvZiBzaW5jKDApIGlzIGRlZmluZWQgYXMgMVxyXG4gICAgICAgIGlmICh4ID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBub3JtbGl6ZWQgc2luYyh4KSBpcyBzaW4oUEkgKiB4KSAvIChQSSAqIHgpXHJcbiAgICAgICAgdmFyIHBpWCA9IE1hdGguUEkgKiB4O1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNpbihwaVgpIC8gcGlYO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgTGFuY3pvcyBrZXJuYWwgYXQgcG9pbnQgeCBmb3IgYSBnaXZlbiB3aW5kb3dcclxuICAgICAqIHNpemUuIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFuY3pvc19yZXNhbXBsaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiAgICAgVGhlIHBvaW50IGF0IHdoaWNoIHRoZSB2YWx1ZSBvZiB0aGUgTGFuY3pvcyBrZXJuZWwgc2hvdWxkIGJlXHJcbiAgICAgKiAgICAgY29tcHV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFcclxuICAgICAqICAgICBUaGUgd2luZG93IHNpemUgdG8gdXNlIGZvciB0aGUgTGFuY3pvcyBrZXJuZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqICAgICBUaGUgdmFsdWUgb2YgdGhlIExhbmN6b3Mga2VybmVsIGF0IHRoZSBnaXZlbiBwb2ludCBmb3IgdGhlIGdpdmVuXHJcbiAgICAgKiAgICAgd2luZG93IHNpemUuXHJcbiAgICAgKi9cclxuICAgIHZhciBsYW5jem9zID0gZnVuY3Rpb24gbGFuY3pvcyh4LCBhKSB7XHJcblxyXG4gICAgICAgIC8vIExhbmN6b3MgaXMgc2luYyh4KSAqIHNpbmMoeCAvIGEpIGZvciAtYSA8IHggPCBhIC4uLlxyXG4gICAgICAgIGlmICgtYSA8IHggJiYgeCA8IGEpXHJcbiAgICAgICAgICAgIHJldHVybiBzaW5jKHgpICogc2luYyh4IC8gYSk7XHJcblxyXG4gICAgICAgIC8vIC4uLiBhbmQgMCBvdGhlcndpc2VcclxuICAgICAgICByZXR1cm4gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgdmFsdWUgb2YgdGhlIHdhdmVmb3JtIHJlcHJlc2VudGVkIGJ5IHRoZSBhdWRpbyBkYXRhIGF0XHJcbiAgICAgKiB0aGUgZ2l2ZW4gbG9jYXRpb24uIElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgZGV0ZXJtaW5lZCBleGFjdGx5IGFzIGl0IGRvZXNcclxuICAgICAqIG5vdCBjb3JyZXNwb25kIHRvIGFuIGV4YWN0IHNhbXBsZSB3aXRoaW4gdGhlIGF1ZGlvIGRhdGEsIHRoZSB2YWx1ZSB3aWxsXHJcbiAgICAgKiBiZSBkZXJpdmVkIHRocm91Z2ggaW50ZXJwb2xhdGluZyBuZWFyYnkgc2FtcGxlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGF1ZGlvRGF0YVxyXG4gICAgICogICAgIEFuIGFycmF5IG9mIGF1ZGlvIGRhdGEsIGFzIHJldHVybmVkIGJ5IEF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKCkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRcclxuICAgICAqICAgICBUaGUgcmVsYXRpdmUgbG9jYXRpb24gd2l0aGluIHRoZSB3YXZlZm9ybSBmcm9tIHdoaWNoIHRoZSB2YWx1ZVxyXG4gICAgICogICAgIHNob3VsZCBiZSByZXRyaWV2ZWQsIHJlcHJlc2VudGVkIGFzIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW5cclxuICAgICAqICAgICAwIGFuZCAxIGluY2x1c2l2ZSwgd2hlcmUgMCByZXByZXNlbnRzIHRoZSBlYXJsaWVzdCBwb2ludCBpbiB0aW1lIGFuZFxyXG4gICAgICogICAgIDEgcmVwcmVzZW50cyB0aGUgbGF0ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiAgICAgVGhlIHZhbHVlIG9mIHRoZSB3YXZlZm9ybSBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHZhciBpbnRlcnBvbGF0ZVNhbXBsZSA9IGZ1bmN0aW9uIGdldFZhbHVlQXQoYXVkaW9EYXRhLCB0KSB7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgWzAsIDFdIHJhbmdlIHRvIFswLCBhdWRpb0RhdGEubGVuZ3RoIC0gMV1cclxuICAgICAgICB2YXIgaW5kZXggPSAoYXVkaW9EYXRhLmxlbmd0aCAtIDEpICogdDtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBmb3IgdGhlIHN1bW1hdGlvbiB1c2VkIGJ5IHRoZVxyXG4gICAgICAgIC8vIExhbmN6b3MgaW50ZXJwb2xhdGlvbiBhbGdvcml0aG0gKHNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFuY3pvc19yZXNhbXBsaW5nKVxyXG4gICAgICAgIHZhciBzdGFydCA9IE1hdGguZmxvb3IoaW5kZXgpIC0gTEFOQ1pPU19XSU5ET1dfU0laRSArIDE7XHJcbiAgICAgICAgdmFyIGVuZCA9IE1hdGguZmxvb3IoaW5kZXgpICsgTEFOQ1pPU19XSU5ET1dfU0laRTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB2YWx1ZSBvZiB0aGUgTGFuY3pvcyBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIGZvciB0aGVcclxuICAgICAgICAvLyByZXF1aXJlZCByYW5nZVxyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gKz0gKGF1ZGlvRGF0YVtpXSB8fCAwKSAqIGxhbmN6b3MoaW5kZXggLSBpLCBMQU5DWk9TX1dJTkRPV19TSVpFKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdW07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBnaXZlbiBBdWRpb0J1ZmZlciBpbnRvIGFuIGF1ZGlvIHBhY2tldCwgcmVhZHkgZm9yIHN0cmVhbWluZ1xyXG4gICAgICogYWxvbmcgdGhlIHVuZGVybHlpbmcgb3V0cHV0IHN0cmVhbS4gVW5saWtlIHRoZSByYXcgYXVkaW8gcGFja2V0cyB1c2VkIGJ5XHJcbiAgICAgKiB0aGlzIGF1ZGlvIHJlY29yZGVyLCBBdWRpb0J1ZmZlcnMgcmVxdWlyZSBmbG9hdGluZyBwb2ludCBzYW1wbGVzIGFuZCBhcmVcclxuICAgICAqIHNwbGl0IGludG8gaXNvbGF0ZWQgcGxhbmVzIG9mIGNoYW5uZWwtc3BlY2lmaWMgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gYXVkaW9CdWZmZXJcclxuICAgICAqICAgICBUaGUgV2ViIEF1ZGlvIEFQSSBBdWRpb0J1ZmZlciB0aGF0IHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYSByYXdcclxuICAgICAqICAgICBhdWRpbyBwYWNrZXQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1NhbXBsZUFycmF5fVxyXG4gICAgICogICAgIEEgbmV3IHJhdyBhdWRpbyBwYWNrZXQgY29udGFpbmluZyB0aGUgYXVkaW8gZGF0YSBmcm9tIHRoZSBwcm92aWRlZFxyXG4gICAgICogICAgIEF1ZGlvQnVmZmVyLlxyXG4gICAgICovXHJcbiAgICB2YXIgdG9TYW1wbGVBcnJheSA9IGZ1bmN0aW9uIHRvU2FtcGxlQXJyYXkoYXVkaW9CdWZmZXIpIHtcclxuXHJcbiAgICAgICAgLy8gVHJhY2sgb3ZlcmFsbCBhbW91bnQgb2YgZGF0YSByZWFkXHJcbiAgICAgICAgdmFyIGluU2FtcGxlcyA9IGF1ZGlvQnVmZmVyLmxlbmd0aDtcclxuICAgICAgICByZWFkU2FtcGxlcyArPSBpblNhbXBsZXM7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIHNhbXBsZXMgdGhhdCBzaG91bGQgYmUgd3JpdHRlbiBhcyBvZlxyXG4gICAgICAgIC8vIHRoZSBhdWRpbyBkYXRhIGp1c3QgcmVjZWl2ZWQgYW5kIGFkanVzdCB0aGUgc2l6ZSBvZiB0aGUgb3V0cHV0XHJcbiAgICAgICAgLy8gcGFja2V0IGFjY29yZGluZ2x5XHJcbiAgICAgICAgdmFyIGV4cGVjdGVkV3JpdHRlblNhbXBsZXMgPSBNYXRoLnJvdW5kKHJlYWRTYW1wbGVzICogZm9ybWF0LnJhdGUgLyBhdWRpb0J1ZmZlci5zYW1wbGVSYXRlKTtcclxuICAgICAgICB2YXIgb3V0U2FtcGxlcyA9IGV4cGVjdGVkV3JpdHRlblNhbXBsZXMgLSB3cml0dGVuU2FtcGxlcztcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIG51bWJlciBvZiBzYW1wbGVzIHdyaXR0ZW5cclxuICAgICAgICB3cml0dGVuU2FtcGxlcyArPSBvdXRTYW1wbGVzO1xyXG5cclxuICAgICAgICAvLyBHZXQgYXJyYXkgZm9yIHJhdyBQQ00gc3RvcmFnZVxyXG4gICAgICAgIHZhciBkYXRhID0gbmV3IFNhbXBsZUFycmF5KG91dFNhbXBsZXMgKiBmb3JtYXQuY2hhbm5lbHMpO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGVhY2ggY2hhbm5lbFxyXG4gICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgZm9ybWF0LmNoYW5uZWxzOyBjaGFubmVsKyspIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhdWRpb0RhdGEgPSBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbGwgYXJyYXkgd2l0aCBkYXRhIGZyb20gYXVkaW8gYnVmZmVyIGNoYW5uZWxcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGNoYW5uZWw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0U2FtcGxlczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSBpbnRlcnBvbGF0ZVNhbXBsZShhdWRpb0RhdGEsIGkgLyAob3V0U2FtcGxlcyAtIDEpKSAqIG1heFNhbXBsZVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZvcm1hdC5jaGFubmVscztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXRVc2VyTWVkaWEoKSBjYWxsYmFjayB3aGljaCBoYW5kbGVzIHN1Y2Nlc3NmdWwgcmV0cmlldmFsIG9mIGFuXHJcbiAgICAgKiBhdWRpbyBzdHJlYW0gKHN1Y2Nlc3NmdWwgc3RhcnQgb2YgcmVjb3JkaW5nKS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXHJcbiAgICAgKiAgICAgQSBNZWRpYVN0cmVhbSB3aGljaCBwcm92aWRlcyBhY2Nlc3MgdG8gYXVkaW8gZGF0YSByZWFkIGZyb20gdGhlXHJcbiAgICAgKiAgICAgdXNlcidzIGxvY2FsIGF1ZGlvIGlucHV0IGRldmljZS5cclxuICAgICAqL1xyXG4gICAgdmFyIHN0cmVhbVJlY2VpdmVkID0gZnVuY3Rpb24gc3RyZWFtUmVjZWl2ZWQoc3RyZWFtKSB7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBwcm9jZXNzaW5nIG5vZGUgd2hpY2ggcmVjZWl2ZXMgYXBwcm9wcmlhdGVseS1zaXplZCBhdWRpbyBidWZmZXJzXHJcbiAgICAgICAgcHJvY2Vzc29yID0gY29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoQlVGRkVSX1NJWkUsIGZvcm1hdC5jaGFubmVscywgZm9ybWF0LmNoYW5uZWxzKTtcclxuICAgICAgICBwcm9jZXNzb3IuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBibG9icyB3aGVuIGF1ZGlvIGJ1ZmZlcnMgYXJlIHJlY2VpdmVkXHJcbiAgICAgICAgcHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2Vzc0F1ZGlvKGUpIHtcclxuICAgICAgICAgICAgd3JpdGVyLnNlbmREYXRhKHRvU2FtcGxlQXJyYXkoZS5pbnB1dEJ1ZmZlcikuYnVmZmVyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDb25uZWN0IHByb2Nlc3Npbmcgbm9kZSB0byB1c2VyJ3MgYXVkaW8gaW5wdXQgc291cmNlXHJcbiAgICAgICAgc291cmNlID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pO1xyXG4gICAgICAgIHNvdXJjZS5jb25uZWN0KHByb2Nlc3Nvcik7XHJcblxyXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZXhwbGljaXRseSByZXN1bWUgQXVkaW9Db250ZXh0LCBhcyBpdCBtYXkgYmUgcGF1c2VkXHJcbiAgICAgICAgLy8gYnkgZGVmYXVsdFxyXG4gICAgICAgIGlmIChjb250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJylcclxuICAgICAgICAgICAgY29udGV4dC5yZXN1bWUoKTtcclxuXHJcbiAgICAgICAgLy8gU2F2ZSBzdHJlYW0gZm9yIGxhdGVyIGNsZWFudXBcclxuICAgICAgICBtZWRpYVN0cmVhbSA9IHN0cmVhbTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0VXNlck1lZGlhKCkgY2FsbGJhY2sgd2hpY2ggaGFuZGxlcyBhdWRpbyByZWNvcmRpbmcgZGVuaWFsLiBUaGVcclxuICAgICAqIHVuZGVybHlpbmcgR3VhY2Ftb2xlIG91dHB1dCBzdHJlYW0gaXMgY2xvc2VkLCBhbmQgdGhlIGZhaWx1cmUgdG9cclxuICAgICAqIHJlY29yZCBpcyBub3RlZCB1c2luZyBvbmVycm9yLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBzdHJlYW1EZW5pZWQgPSBmdW5jdGlvbiBzdHJlYW1EZW5pZWQoKSB7XHJcblxyXG4gICAgICAgIC8vIFNpbXBseSBlbmQgc3RyZWFtIGlmIGF1ZGlvIGFjY2VzcyBpcyBub3QgYWxsb3dlZFxyXG4gICAgICAgIHdyaXRlci5zZW5kRW5kKCk7XHJcblxyXG4gICAgICAgIC8vIE5vdGlmeSBvZiBjbG9zdXJlXHJcbiAgICAgICAgaWYgKHJlY29yZGVyLm9uZXJyb3IpXHJcbiAgICAgICAgICAgIHJlY29yZGVyLm9uZXJyb3IoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdHMgYWNjZXNzIHRvIHRoZSB1c2VyJ3MgbWljcm9waG9uZSBhbmQgYmVnaW5zIGNhcHR1cmluZyBhdWRpby4gQWxsXHJcbiAgICAgKiByZWNlaXZlZCBhdWRpbyBkYXRhIGlzIHJlc2FtcGxlZCBhcyBuZWNlc3NhcnkgYW5kIGZvcndhcmRlZCB0byB0aGVcclxuICAgICAqIEd1YWNhbW9sZSBzdHJlYW0gdW5kZXJseWluZyB0aGlzIEd1YWNhbW9sZS5SYXdBdWRpb1JlY29yZGVyLiBUaGlzXHJcbiAgICAgKiBmdW5jdGlvbiBtdXN0IGJlIGludm9rZWQgT05MWSBPTkNFIHBlciBpbnN0YW5jZSBvZlxyXG4gICAgICogR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGJlZ2luQXVkaW9DYXB0dXJlID0gZnVuY3Rpb24gYmVnaW5BdWRpb0NhcHR1cmUoKSB7XHJcblxyXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcmV0cmlldmUgYW4gYXVkaW8gaW5wdXQgc3RyZWFtIGZyb20gdGhlIGJyb3dzZXJcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcclxuICAgICAgICAgICAgJ2F1ZGlvJyA6IHRydWVcclxuICAgICAgICB9LCBzdHJlYW1SZWNlaXZlZCwgc3RyZWFtRGVuaWVkKTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIHN0cmVhbSBjcmVhdGlvbi9yZWplY3Rpb24gdmlhIFByb21pc2UgZm9yIG5ld2VyIHZlcnNpb25zIG9mXHJcbiAgICAgICAgLy8gZ2V0VXNlck1lZGlhKClcclxuICAgICAgICBpZiAocHJvbWlzZSAmJiBwcm9taXNlLnRoZW4pXHJcbiAgICAgICAgICAgIHByb21pc2UudGhlbihzdHJlYW1SZWNlaXZlZCwgc3RyZWFtRGVuaWVkKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgY2FwdHVyaW5nIGF1ZGlvLCBpZiB0aGUgY2FwdHVyZSBoYXMgc3RhcnRlZCwgZnJlZWluZyBhbGwgYXNzb2NpYXRlZFxyXG4gICAgICogcmVzb3VyY2VzLiBJZiB0aGUgY2FwdHVyZSBoYXMgbm90IHN0YXJ0ZWQsIHRoaXMgZnVuY3Rpb24gc2ltcGx5IGVuZHMgdGhlXHJcbiAgICAgKiB1bmRlcmx5aW5nIEd1YWNhbW9sZSBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHN0b3BBdWRpb0NhcHR1cmUgPSBmdW5jdGlvbiBzdG9wQXVkaW9DYXB0dXJlKCkge1xyXG5cclxuICAgICAgICAvLyBEaXNjb25uZWN0IG1lZGlhIHNvdXJjZSBub2RlIGZyb20gc2NyaXB0IHByb2Nlc3NvclxyXG4gICAgICAgIGlmIChzb3VyY2UpXHJcbiAgICAgICAgICAgIHNvdXJjZS5kaXNjb25uZWN0KCk7XHJcblxyXG4gICAgICAgIC8vIERpc2Nvbm5lY3QgYXNzb2NpYXRlZCBzY3JpcHQgcHJvY2Vzc29yIG5vZGVcclxuICAgICAgICBpZiAocHJvY2Vzc29yKVxyXG4gICAgICAgICAgICBwcm9jZXNzb3IuZGlzY29ubmVjdCgpO1xyXG5cclxuICAgICAgICAvLyBTdG9wIGNhcHR1cmVcclxuICAgICAgICBpZiAobWVkaWFTdHJlYW0pIHtcclxuICAgICAgICAgICAgdmFyIHRyYWNrcyA9IG1lZGlhU3RyZWFtLmdldFRyYWNrcygpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHRyYWNrc1tpXS5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgcmVmZXJlbmNlcyB0byBub3ctdW5uZWVkZWQgY29tcG9uZW50c1xyXG4gICAgICAgIHByb2Nlc3NvciA9IG51bGw7XHJcbiAgICAgICAgc291cmNlID0gbnVsbDtcclxuICAgICAgICBtZWRpYVN0cmVhbSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIEVuZCBzdHJlYW1cclxuICAgICAgICB3cml0ZXIuc2VuZEVuZCgpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gT25jZSBhdWRpbyBzdHJlYW0gaXMgc3VjY2Vzc2Z1bGx5IG9wZW4sIHJlcXVlc3QgYW5kIGJlZ2luIHJlYWRpbmcgYXVkaW9cclxuICAgIHdyaXRlci5vbmFjayA9IGZ1bmN0aW9uIGF1ZGlvU3RyZWFtQWNrbm93bGVkZ2VkKHN0YXR1cykge1xyXG5cclxuICAgICAgICAvLyBCZWdpbiBjYXB0dXJlIGlmIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgYW5kIG5vdCB5ZXQgc3RhcnRlZFxyXG4gICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlNVQ0NFU1MgJiYgIW1lZGlhU3RyZWFtKVxyXG4gICAgICAgICAgICBiZWdpbkF1ZGlvQ2FwdHVyZSgpO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2Ugc3RvcCBjYXB0dXJlIGFuZCBjZWFzZSBoYW5kbGluZyBhbnkgZnVydGhlciBhY2tzXHJcbiAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTdG9wIGNhcHR1cmluZyBhdWRpb1xyXG4gICAgICAgICAgICBzdG9wQXVkaW9DYXB0dXJlKCk7XHJcbiAgICAgICAgICAgIHdyaXRlci5vbmFjayA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyBOb3RpZnkgaWYgc3RyZWFtIGhhcyBjbG9zZWQgbm9ybWFsbHlcclxuICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBHdWFjYW1vbGUuU3RhdHVzLkNvZGUuUkVTT1VSQ0VfQ0xPU0VEKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkZXIub25jbG9zZSlcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmRlci5vbmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBub3RpZnkgb2YgY2xvc3VyZSBkdWUgdG8gZXJyb3JcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkZXIub25lcnJvcilcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmRlci5vbmVycm9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIucHJvdG90eXBlID0gbmV3IEd1YWNhbW9sZS5BdWRpb1JlY29yZGVyKCk7XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBtaW1ldHlwZSBpcyBzdXBwb3J0ZWQgYnlcclxuICogR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gKiAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICogICAgIHRydWUgaWYgdGhlIGdpdmVuIG1pbWV0eXBlIGlzIHN1cHBvcnRlZCBieSBHdWFjYW1vbGUuUmF3QXVkaW9SZWNvcmRlcixcclxuICogICAgIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbkd1YWNhbW9sZS5SYXdBdWRpb1JlY29yZGVyLmlzU3VwcG9ydGVkVHlwZSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkVHlwZShtaW1ldHlwZSkge1xyXG5cclxuICAgIC8vIE5vIHN1cHBvcnRlZCB0eXBlcyBpZiBubyBXZWIgQXVkaW8gQVBJXHJcbiAgICBpZiAoIUd1YWNhbW9sZS5BdWRpb0NvbnRleHRGYWN0b3J5LmdldEF1ZGlvQ29udGV4dCgpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICByZXR1cm4gR3VhY2Ftb2xlLlJhd0F1ZGlvRm9ybWF0LnBhcnNlKG1pbWV0eXBlKSAhPT0gbnVsbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIG1pbWV0eXBlcyBzdXBwb3J0ZWQgYnkgR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIuIE9ubHlcclxuICogdGhlIGNvcmUgbWltZXR5cGVzIHRoZW1zZWx2ZXMgd2lsbCBiZSBsaXN0ZWQuIEFueSBtaW1ldHlwZSBwYXJhbWV0ZXJzLCBldmVuXHJcbiAqIHJlcXVpcmVkIG9uZXMsIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBsaXN0LiBGb3IgZXhhbXBsZSwgXCJhdWRpby9MOFwiIGlzXHJcbiAqIGEgcmF3IGF1ZGlvIG1pbWV0eXBlIHRoYXQgbWF5IGJlIHN1cHBvcnRlZCwgYnV0IGl0IGlzIGludmFsaWQgd2l0aG91dFxyXG4gKiBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIFNvbWV0aGluZyBsaWtlIFwiYXVkaW8vTDg7cmF0ZT00NDEwMFwiIHdvdWxkIGJlIHZhbGlkLFxyXG4gKiBob3dldmVyIChzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ4NTYpLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nW119XHJcbiAqICAgICBBIGxpc3Qgb2YgYWxsIG1pbWV0eXBlcyBzdXBwb3J0ZWQgYnkgR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIsXHJcbiAqICAgICBleGNsdWRpbmcgYW55IHBhcmFtZXRlcnMuIElmIHRoZSBuZWNlc3NhcnkgSmF2YVNjcmlwdCBBUElzIGZvciByZWNvcmRpbmdcclxuICogICAgIHJhdyBhdWRpbyBhcmUgYWJzZW50LCB0aGlzIGxpc3Qgd2lsbCBiZSBlbXB0eS5cclxuICovXHJcbkd1YWNhbW9sZS5SYXdBdWRpb1JlY29yZGVyLmdldFN1cHBvcnRlZFR5cGVzID0gZnVuY3Rpb24gZ2V0U3VwcG9ydGVkVHlwZXMoKSB7XHJcblxyXG4gICAgLy8gTm8gc3VwcG9ydGVkIHR5cGVzIGlmIG5vIFdlYiBBdWRpbyBBUElcclxuICAgIGlmICghR3VhY2Ftb2xlLkF1ZGlvQ29udGV4dEZhY3RvcnkuZ2V0QXVkaW9Db250ZXh0KCkpXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG5cclxuICAgIC8vIFdlIHN1cHBvcnQgOC1iaXQgYW5kIDE2LWJpdCByYXcgUENNXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgICdhdWRpby9MOCcsXHJcbiAgICAgICAgJ2F1ZGlvL0wxNidcclxuICAgIF07XHJcblxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQSByZWFkZXIgd2hpY2ggYXV0b21hdGljYWxseSBoYW5kbGVzIHRoZSBnaXZlbiBpbnB1dCBzdHJlYW0sIGFzc2VtYmxpbmcgYWxsXHJcbiAqIHJlY2VpdmVkIGJsb2JzIGludG8gYSBzaW5nbGUgYmxvYiBieSBhcHBlbmRpbmcgdGhlbSB0byBlYWNoIG90aGVyIGluIG9yZGVyLlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBvYmplY3Qgd2lsbCBvdmVyd3JpdGUgYW55IGluc3RhbGxlZCBldmVudCBoYW5kbGVycyBvbiB0aGVcclxuICogZ2l2ZW4gR3VhY2Ftb2xlLklucHV0U3RyZWFtLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLklucHV0U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSB0aGF0IGRhdGEgd2lsbCBiZSByZWFkXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbS5cclxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlIFRoZSBtaW1ldHlwZSBvZiB0aGUgYmxvYiBiZWluZyBidWlsdC5cclxuICovXHJcbkd1YWNhbW9sZS5CbG9iUmVhZGVyID0gZnVuY3Rpb24oc3RyZWFtLCBtaW1ldHlwZSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLklucHV0U3RyZWFtLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNfcmVhZGVyID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsZW5ndGggb2YgdGhpcyBHdWFjYW1vbGUuSW5wdXRTdHJlYW0gaW4gYnl0ZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgbGVuZ3RoID0gMDtcclxuXHJcbiAgICAvLyBHZXQgYmxvYiBidWlsZGVyXHJcbiAgICB2YXIgYmxvYl9idWlsZGVyO1xyXG4gICAgaWYgICAgICAod2luZG93LkJsb2JCdWlsZGVyKSAgICAgICBibG9iX2J1aWxkZXIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcclxuICAgIGVsc2UgaWYgKHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlcikgYmxvYl9idWlsZGVyID0gbmV3IFdlYktpdEJsb2JCdWlsZGVyKCk7XHJcbiAgICBlbHNlIGlmICh3aW5kb3cuTW96QmxvYkJ1aWxkZXIpICAgIGJsb2JfYnVpbGRlciA9IG5ldyBNb3pCbG9iQnVpbGRlcigpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGJsb2JfYnVpbGRlciA9IG5ldyAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmxvYnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8qKiBAaWdub3JlICovXHJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgYmxvYnMucHVzaChuZXcgQmxvYihbZGF0YV0sIHtcInR5cGVcIjogbWltZXR5cGV9KSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKiogQGlnbm9yZSAqL1xyXG4gICAgICAgICAgICB0aGlzLmdldEJsb2IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihibG9icywge1widHlwZVwiOiBtaW1ldHlwZX0pO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9KSgpO1xyXG5cclxuICAgIC8vIEFwcGVuZCByZWNlaXZlZCBibG9ic1xyXG4gICAgc3RyZWFtLm9uYmxvYiA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0byBBcnJheUJ1ZmZlclxyXG4gICAgICAgIHZhciBiaW5hcnkgPSB3aW5kb3cuYXRvYihkYXRhKTtcclxuICAgICAgICB2YXIgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYmluYXJ5Lmxlbmd0aCk7XHJcbiAgICAgICAgdmFyIGJ1ZmZlclZpZXcgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxiaW5hcnkubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGJ1ZmZlclZpZXdbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcclxuXHJcbiAgICAgICAgYmxvYl9idWlsZGVyLmFwcGVuZChhcnJheUJ1ZmZlcik7XHJcbiAgICAgICAgbGVuZ3RoICs9IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIENhbGwgaGFuZGxlciwgaWYgcHJlc2VudFxyXG4gICAgICAgIGlmIChndWFjX3JlYWRlci5vbnByb2dyZXNzKVxyXG4gICAgICAgICAgICBndWFjX3JlYWRlci5vbnByb2dyZXNzKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG5cclxuICAgICAgICAvLyBTZW5kIHN1Y2Nlc3MgcmVzcG9uc2VcclxuICAgICAgICBzdHJlYW0uc2VuZEFjayhcIk9LXCIsIDB4MDAwMCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTaW1wbHkgY2FsbCBvbmVuZCB3aGVuIGVuZCByZWNlaXZlZFxyXG4gICAgc3RyZWFtLm9uZW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGd1YWNfcmVhZGVyLm9uZW5kKVxyXG4gICAgICAgICAgICBndWFjX3JlYWRlci5vbmVuZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoaXMgR3VhY2Ftb2xlLklucHV0U3RyZWFtLCBpbiBieXRlcy5cclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoaXMgR3VhY2Ftb2xlLklucHV0U3RyZWFtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBsZW5ndGg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhpcyBHdWFjYW1vbGUuQmxvYlJlYWRlciBhcyBhIEJsb2IuXHJcbiAgICAgKiBAcmV0dXJuIHtCbG9ifSBUaGUgY29udGVudHMgb2YgdGhpcyBHdWFjYW1vbGUuQmxvYlJlYWRlci5cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRCbG9iID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGJsb2JfYnVpbGRlci5nZXRCbG9iKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgb25jZSBmb3IgZXZlcnkgYmxvYiBvZiBkYXRhIHJlY2VpdmVkLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBieXRlcyByZWNlaXZlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbnByb2dyZXNzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIG9uY2UgdGhpcyBzdHJlYW0gaXMgZmluaXNoZWQgYW5kIG5vIGZ1cnRoZXIgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmVuZCA9IG51bGw7XHJcblxyXG59O1xuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIHdyaXRlciB3aGljaCBhdXRvbWF0aWNhbGx5IHdyaXRlcyB0byB0aGUgZ2l2ZW4gb3V0cHV0IHN0cmVhbSB3aXRoIHRoZVxyXG4gKiBjb250ZW50cyBvZiBwcm92aWRlZCBCbG9iIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5PdXRwdXRTdHJlYW19IHN0cmVhbVxyXG4gKiAgICAgVGhlIHN0cmVhbSB0aGF0IGRhdGEgd2lsbCBiZSB3cml0dGVuIHRvLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkJsb2JXcml0ZXIgPSBmdW5jdGlvbiBCbG9iV3JpdGVyKHN0cmVhbSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLkJsb2JXcml0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuQmxvYldyaXRlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNXcml0ZXIgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JhcHBlZCBHdWFjYW1vbGUuQXJyYXlCdWZmZXJXcml0ZXIgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHNlbmQgYW55XHJcbiAgICAgKiBwcm92aWRlZCBmaWxlIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuQXJyYXlCdWZmZXJXcml0ZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBhcnJheUJ1ZmZlcldyaXRlciA9IG5ldyBHdWFjYW1vbGUuQXJyYXlCdWZmZXJXcml0ZXIoc3RyZWFtKTtcclxuXHJcbiAgICAvLyBJbml0aWFsbHksIHNpbXBseSBjYWxsIG9uYWNrIGZvciBhY2tub3dsZWRnZW1lbnRzXHJcbiAgICBhcnJheUJ1ZmZlcldyaXRlci5vbmFjayA9IGZ1bmN0aW9uKHN0YXR1cykge1xyXG4gICAgICAgIGlmIChndWFjV3JpdGVyLm9uYWNrKVxyXG4gICAgICAgICAgICBndWFjV3JpdGVyLm9uYWNrKHN0YXR1cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnJvd3Nlci1pbmRlcGVuZGVudCBpbXBsZW1lbnRhdGlvbiBvZiBCbG9iLnNsaWNlKCkgd2hpY2ggdXNlcyBhbiBlbmRcclxuICAgICAqIG9mZnNldCB0byBkZXRlcm1pbmUgdGhlIHNwYW4gb2YgdGhlIHJlc3VsdGluZyBzbGljZSwgcmF0aGVyIHRoYW4gYVxyXG4gICAgICogbGVuZ3RoLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2JcclxuICAgICAqICAgICBUaGUgQmxvYiB0byBzbGljZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcclxuICAgICAqICAgICBUaGUgc3RhcnRpbmcgb2Zmc2V0IG9mIHRoZSBzbGljZSwgaW4gYnl0ZXMsIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kXHJcbiAgICAgKiAgICAgVGhlIGVuZGluZyBvZmZzZXQgb2YgdGhlIHNsaWNlLCBpbiBieXRlcywgZXhjbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtCbG9ifVxyXG4gICAgICogICAgIEEgQmxvYiBjb250YWluaW5nIHRoZSBkYXRhIHdpdGhpbiB0aGUgZ2l2ZW4gQmxvYiBzdGFydGluZyBhdFxyXG4gICAgICogICAgIDxjb2RlPnN0YXJ0PC9jb2RlPiBhbmQgZW5kaW5nIGF0IDxjb2RlPmVuZCAtIDE8L2NvZGU+LlxyXG4gICAgICovXHJcbiAgICB2YXIgc2xpY2UgPSBmdW5jdGlvbiBzbGljZShibG9iLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIC8vIFVzZSBwcmVmaXhlZCBpbXBsZW1lbnRhdGlvbnMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgdmFyIHNsaWNlSW1wbGVtZW50YXRpb24gPSAoXHJcbiAgICAgICAgICAgICAgICBibG9iLnNsaWNlXHJcbiAgICAgICAgICAgICB8fCBibG9iLndlYmtpdFNsaWNlXHJcbiAgICAgICAgICAgICB8fCBibG9iLm1velNsaWNlXHJcbiAgICAgICAgKS5iaW5kKGJsb2IpO1xyXG5cclxuICAgICAgICB2YXIgbGVuZ3RoID0gZW5kIC0gc3RhcnQ7XHJcblxyXG4gICAgICAgIC8vIFRoZSBvbGQgQmxvYi5zbGljZSgpIHdhcyBsZW5ndGgtYmFzZWQgKG5vdCBlbmQtYmFzZWQpLiBUcnkgdGhlXHJcbiAgICAgICAgLy8gbGVuZ3RoIHZlcnNpb24gZmlyc3QsIGlmIHRoZSB0d28gY2FsbHMgYXJlIG5vdCBlcXVpdmFsZW50LlxyXG4gICAgICAgIGlmIChsZW5ndGggIT09IGVuZCkge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlc3VsdCBvZiB0aGUgc2xpY2UoKSBjYWxsIG1hdGNoZXMgdGhlIGV4cGVjdGVkIGxlbmd0aCxcclxuICAgICAgICAgICAgLy8gdHJ1c3QgdGhhdCByZXN1bHQuIEl0IG11c3QgYmUgY29ycmVjdC5cclxuICAgICAgICAgICAgdmFyIHNsaWNlUmVzdWx0ID0gc2xpY2VJbXBsZW1lbnRhdGlvbihzdGFydCwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKHNsaWNlUmVzdWx0LnNpemUgPT09IGxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiBzbGljZVJlc3VsdDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB0aGUgbW9zdC1yZWNlbnQgc3RhbmRhcmQ6IGVuZC1iYXNlZCBzbGljZSgpXHJcbiAgICAgICAgcmV0dXJuIHNsaWNlSW1wbGVtZW50YXRpb24oc3RhcnQsIGVuZCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIHRoZSBjb250ZW50cyBvZiB0aGUgZ2l2ZW4gYmxvYiBvdmVyIHRoZSB1bmRlcmx5aW5nIHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2JcclxuICAgICAqICAgICBUaGUgYmxvYiB0byBzZW5kLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmRCbG9iID0gZnVuY3Rpb24gc2VuZEJsb2IoYmxvYikge1xyXG5cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgdGhlIG5leHQgY2h1bmsgb2YgdGhlIGJsb2IgcHJvdmlkZWQgdG9cclxuICAgICAgICAgKiBbc2VuZEJsb2IoKV17QGxpbmsgR3VhY2Ftb2xlLkJsb2JXcml0ZXIjc2VuZEJsb2J9LiBUaGUgY2h1bmsgaXRzZWxmXHJcbiAgICAgICAgICogaXMgcmVhZCBhc3luY2hyb25vdXNseSwgYW5kIHdpbGwgbm90IGJlIGF2YWlsYWJsZSB1bnRpbFxyXG4gICAgICAgICAqIHJlYWRlci5vbmxvYWQgZmlyZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciByZWFkTmV4dENodW5rID0gZnVuY3Rpb24gcmVhZE5leHRDaHVuaygpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vIGZ1cnRoZXIgY2h1bmtzIHJlbWFpbiwgaW5mb3JtIG9mIGNvbXBsZXRpb24gYW5kIHN0b3BcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA+PSBibG9iLnNpemUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJlIGNvbXBsZXRpb24gZXZlbnQgZm9yIGNvbXBsZXRlZCBibG9iXHJcbiAgICAgICAgICAgICAgICBpZiAoZ3VhY1dyaXRlci5vbmNvbXBsZXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIGd1YWNXcml0ZXIub25jb21wbGV0ZShibG9iKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBObyBmdXJ0aGVyIGNodW5rcyB0byByZWFkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPYnRhaW4gcmVmZXJlbmNlIHRvIG5leHQgY2h1bmsgYXMgYSBuZXcgYmxvYlxyXG4gICAgICAgICAgICB2YXIgY2h1bmsgPSBzbGljZShibG9iLCBvZmZzZXQsIG9mZnNldCArIGFycmF5QnVmZmVyV3JpdGVyLmJsb2JMZW5ndGgpO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gYXJyYXlCdWZmZXJXcml0ZXIuYmxvYkxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcmVhZCB0aGUgYmxvYiBjb250ZW50cyByZXByZXNlbnRlZCBieSB0aGUgYmxvYiBpbnRvXHJcbiAgICAgICAgICAgIC8vIGEgbmV3IGFycmF5IGJ1ZmZlclxyXG4gICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoY2h1bmspO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBTZW5kIGVhY2ggY2h1bmsgb3ZlciB0aGUgc3RyZWFtLCBjb250aW51ZSByZWFkaW5nIHRoZSBuZXh0IGNodW5rXHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIGNodW5rTG9hZENvbXBsZXRlKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gU2VuZCB0aGUgc3VjY2Vzc2Z1bGx5LXJlYWQgY2h1bmtcclxuICAgICAgICAgICAgYXJyYXlCdWZmZXJXcml0ZXIuc2VuZERhdGEocmVhZGVyLnJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb250aW51ZSBzZW5kaW5nIG1vcmUgY2h1bmtzIGFmdGVyIHRoZSBsYXRlc3QgY2h1bmsgaXNcclxuICAgICAgICAgICAgLy8gYWNrbm93bGVkZ2VkXHJcbiAgICAgICAgICAgIGFycmF5QnVmZmVyV3JpdGVyLm9uYWNrID0gZnVuY3Rpb24gc2VuZE1vcmVDaHVua3Moc3RhdHVzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGd1YWNXcml0ZXIub25hY2spXHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY1dyaXRlci5vbmFjayhzdGF0dXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFib3J0IHRyYW5zZmVyIGlmIGFuIGVycm9yIG9jY3Vyc1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5pc0Vycm9yKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEluZm9ybSBvZiBibG9iIHVwbG9hZCBwcm9ncmVzcyB2aWEgcHJvZ3Jlc3MgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoZ3VhY1dyaXRlci5vbnByb2dyZXNzKVxyXG4gICAgICAgICAgICAgICAgICAgIGd1YWNXcml0ZXIub25wcm9ncmVzcyhibG9iLCBvZmZzZXQgLSBhcnJheUJ1ZmZlcldyaXRlci5ibG9iTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBRdWV1ZSB0aGUgbmV4dCBjaHVuayBmb3IgcmVhZGluZ1xyXG4gICAgICAgICAgICAgICAgcmVhZE5leHRDaHVuaygpO1xyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSWYgYW4gZXJyb3IgcHJldmVudHMgZnVydGhlciByZWFkaW5nLCBpbmZvcm0gb2YgZXJyb3IgYW5kIHN0b3BcclxuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uIGNodW5rTG9hZEZhaWxlZCgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpcmUgZXJyb3IgZXZlbnQsIGluY2x1ZGluZyB0aGUgY29udGV4dCBvZiB0aGUgZXJyb3JcclxuICAgICAgICAgICAgaWYgKGd1YWNXcml0ZXIub25lcnJvcilcclxuICAgICAgICAgICAgICAgIGd1YWNXcml0ZXIub25lcnJvcihibG9iLCBvZmZzZXQsIHJlYWRlci5lcnJvcik7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEJlZ2luIHJlYWRpbmcgdGhlIGZpcnN0IGNodW5rXHJcbiAgICAgICAgcmVhZE5leHRDaHVuaygpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduYWxzIHRoYXQgbm8gZnVydGhlciB0ZXh0IHdpbGwgYmUgc2VudCwgZWZmZWN0aXZlbHkgY2xvc2luZyB0aGVcclxuICAgICAqIHN0cmVhbS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5kRW5kID0gZnVuY3Rpb24gc2VuZEVuZCgpIHtcclxuICAgICAgICBhcnJheUJ1ZmZlcldyaXRlci5zZW5kRW5kKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgZm9yIHJlY2VpdmVkIGRhdGEsIGlmIGFja25vd2xlZGdlZCBieSB0aGUgc2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuU3RhdHVzfSBzdGF0dXNcclxuICAgICAqICAgICBUaGUgc3RhdHVzIG9mIHRoZSBvcGVyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25hY2sgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgcmVhZGluZyBhIGJsb2IgcGFzc2VkIHRvXHJcbiAgICAgKiBbc2VuZEJsb2IoKV17QGxpbmsgR3VhY2Ftb2xlLkJsb2JXcml0ZXIjc2VuZEJsb2J9LiBUaGUgdHJhbnNmZXIgZm9yIHRoZVxyXG4gICAgICogdGhlIGdpdmVuIGJsb2Igd2lsbCBjZWFzZSwgYnV0IHRoZSBzdHJlYW0gd2lsbCByZW1haW4gb3Blbi5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxyXG4gICAgICogICAgIFRoZSBibG9iIHRoYXQgd2FzIGJlaW5nIHJlYWQgd2hlbiB0aGUgZXJyb3Igb2NjdXJyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxyXG4gICAgICogICAgIFRoZSBvZmZzZXQgb2YgdGhlIGZhaWxlZCByZWFkIGF0dGVtcHQgd2l0aGluIHRoZSBibG9iLCBpbiBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0RPTUVycm9yfSBlcnJvclxyXG4gICAgICogICAgIFRoZSBlcnJvciB0aGF0IG9jY3VycmVkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgZm9yIGVhY2ggc3VjY2Vzc2Z1bGx5LXJlYWQgY2h1bmsgb2YgZGF0YSBhcyBhIGJsb2IgaXMgYmVpbmcgc2VudFxyXG4gICAgICogdmlhIFtzZW5kQmxvYigpXXtAbGluayBHdWFjYW1vbGUuQmxvYldyaXRlciNzZW5kQmxvYn0uXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2JcclxuICAgICAqICAgICBUaGUgYmxvYiB0aGF0IGlzIGJlaW5nIHJlYWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxyXG4gICAgICogICAgIFRoZSBvZmZzZXQgb2YgdGhlIHJlYWQgdGhhdCBqdXN0IHN1Y2NlZWRlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbnByb2dyZXNzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW4gYSBibG9iIHBhc3NlZCB0b1xyXG4gICAgICogW3NlbmRCbG9iKClde0BsaW5rIEd1YWNhbW9sZS5CbG9iV3JpdGVyI3NlbmRCbG9ifSBoYXMgZmluaXNoZWQgYmVpbmdcclxuICAgICAqIHNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2JcclxuICAgICAqICAgICBUaGUgYmxvYiB0aGF0IHdhcyBzZW50LlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uY29tcGxldGUgPSBudWxsO1xyXG5cclxufTtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEd1YWNhbW9sZSBwcm90b2NvbCBjbGllbnQuIEdpdmVuIGEge0BsaW5rIEd1YWNhbW9sZS5UdW5uZWx9LFxyXG4gKiBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgaW5jb21pbmcgYW5kIG91dGdvaW5nIEd1YWNhbW9sZSBpbnN0cnVjdGlvbnMgdmlhIHRoZVxyXG4gKiBwcm92aWRlZCB0dW5uZWwsIHVwZGF0aW5nIGl0cyBkaXNwbGF5IHVzaW5nIG9uZSBvciBtb3JlIGNhbnZhcyBlbGVtZW50cy5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5UdW5uZWx9IHR1bm5lbCBUaGUgdHVubmVsIHRvIHVzZSB0byBzZW5kIGFuZCByZWNlaXZlXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEd1YWNhbW9sZSBpbnN0cnVjdGlvbnMuXHJcbiAqL1xyXG5HdWFjYW1vbGUuQ2xpZW50ID0gZnVuY3Rpb24odHVubmVsKSB7XHJcblxyXG4gICAgdmFyIGd1YWNfY2xpZW50ID0gdGhpcztcclxuXHJcbiAgICB2YXIgU1RBVEVfSURMRSAgICAgICAgICA9IDA7XHJcbiAgICB2YXIgU1RBVEVfQ09OTkVDVElORyAgICA9IDE7XHJcbiAgICB2YXIgU1RBVEVfV0FJVElORyAgICAgICA9IDI7XHJcbiAgICB2YXIgU1RBVEVfQ09OTkVDVEVEICAgICA9IDM7XHJcbiAgICB2YXIgU1RBVEVfRElTQ09OTkVDVElORyA9IDQ7XHJcbiAgICB2YXIgU1RBVEVfRElTQ09OTkVDVEVEICA9IDU7XHJcblxyXG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IFNUQVRFX0lETEU7XHJcbiAgICBcclxuICAgIHZhciBjdXJyZW50VGltZXN0YW1wID0gMDtcclxuICAgIHZhciBwaW5nSW50ZXJ2YWwgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRpb24gZnJvbSBHdWFjYW1vbGUgcHJvdG9jb2wgbGluZSBjYXBzIHRvIExheWVyIGxpbmUgY2Fwcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBsaW5lQ2FwID0ge1xyXG4gICAgICAgIDA6IFwiYnV0dFwiLFxyXG4gICAgICAgIDE6IFwicm91bmRcIixcclxuICAgICAgICAyOiBcInNxdWFyZVwiXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRpb24gZnJvbSBHdWFjYW1vbGUgcHJvdG9jb2wgbGluZSBjYXBzIHRvIExheWVyIGxpbmUgY2Fwcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBsaW5lSm9pbiA9IHtcclxuICAgICAgICAwOiBcImJldmVsXCIsXHJcbiAgICAgICAgMTogXCJtaXRlclwiLFxyXG4gICAgICAgIDI6IFwicm91bmRcIlxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB1bmRlcmx5aW5nIEd1YWNhbW9sZSBkaXNwbGF5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLkRpc3BsYXl9XHJcbiAgICAgKi9cclxuICAgIHZhciBkaXNwbGF5ID0gbmV3IEd1YWNhbW9sZS5EaXNwbGF5KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgYXZhaWxhYmxlIGxheWVycyBhbmQgYnVmZmVyc1xyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxOdW1iZXIsIChHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ8R3VhY2Ftb2xlLkxheWVyKT59XHJcbiAgICAgKi9cclxuICAgIHZhciBsYXllcnMgPSB7fTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgYXVkaW8gcGxheWVycyBjdXJyZW50bHkgaW4gdXNlIGJ5IHRoZSBjbGllbnQuIEluaXRpYWxseSwgdGhpcyB3aWxsXHJcbiAgICAgKiBiZSBlbXB0eSwgYnV0IGF1ZGlvIHBsYXllcnMgbWF5IGJlIGFsbG9jYXRlZCBieSB0aGUgc2VydmVyIHVwb24gcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge09iamVjdC48TnVtYmVyLCBHdWFjYW1vbGUuQXVkaW9QbGF5ZXI+fVxyXG4gICAgICovXHJcbiAgICB2YXIgYXVkaW9QbGF5ZXJzID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgdmlkZW8gcGxheWVycyBjdXJyZW50bHkgaW4gdXNlIGJ5IHRoZSBjbGllbnQuIEluaXRpYWxseSwgdGhpcyB3aWxsXHJcbiAgICAgKiBiZSBlbXB0eSwgYnV0IHZpZGVvIHBsYXllcnMgbWF5IGJlIGFsbG9jYXRlZCBieSB0aGUgc2VydmVyIHVwb24gcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge09iamVjdC48TnVtYmVyLCBHdWFjYW1vbGUuVmlkZW9QbGF5ZXI+fVxyXG4gICAgICovXHJcbiAgICB2YXIgdmlkZW9QbGF5ZXJzID0ge307XHJcblxyXG4gICAgLy8gTm8gaW5pdGlhbCBwYXJzZXJzXHJcbiAgICB2YXIgcGFyc2VycyA9IFtdO1xyXG5cclxuICAgIC8vIE5vIGluaXRpYWwgc3RyZWFtcyBcclxuICAgIHZhciBzdHJlYW1zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgY3VycmVudCBvYmplY3RzLiBUaGUgaW5kZXggb2YgZWFjaCBvYmplY3QgaXMgZGljdGF0ZWQgYnkgdGhlXHJcbiAgICAgKiBHdWFjYW1vbGUgc2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLk9iamVjdFtdfVxyXG4gICAgICovXHJcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xyXG5cclxuICAgIC8vIFBvb2wgb2YgYXZhaWxhYmxlIHN0cmVhbSBpbmRpY2VzXHJcbiAgICB2YXIgc3RyZWFtX2luZGljZXMgPSBuZXcgR3VhY2Ftb2xlLkludGVnZXJQb29sKCk7XHJcblxyXG4gICAgLy8gQXJyYXkgb2YgYWxsb2NhdGVkIG91dHB1dCBzdHJlYW1zIGJ5IGluZGV4XHJcbiAgICB2YXIgb3V0cHV0X3N0cmVhbXMgPSBbXTtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGlmIChzdGF0ZSAhPSBjdXJyZW50U3RhdGUpIHtcclxuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGlmIChndWFjX2NsaWVudC5vbnN0YXRlY2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgZ3VhY19jbGllbnQub25zdGF0ZWNoYW5nZShjdXJyZW50U3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0Nvbm5lY3RlZCgpIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudFN0YXRlID09IFNUQVRFX0NPTk5FQ1RFRFxyXG4gICAgICAgICAgICB8fCBjdXJyZW50U3RhdGUgPT0gU1RBVEVfV0FJVElORztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2R1Y2VzIGFuIG9wYXF1ZSByZXByZXNlbnRhdGlvbiBvZiBHdWFjYW1vbGUuQ2xpZW50IHN0YXRlIHdoaWNoIGNhbiBiZVxyXG4gICAgICogbGF0ZXIgaW1wb3J0ZWQgdGhyb3VnaCBhIGNhbGwgdG8gaW1wb3J0U3RhdGUoKS4gVGhpcyBvYmplY3QgaXNcclxuICAgICAqIGVmZmVjdGl2ZWx5IGFuIGluZGVwZW5kZW50LCBjb21wcmVzc2VkIHNuYXBzaG90IG9mIHByb3RvY29sIGFuZCBkaXNwbGF5XHJcbiAgICAgKiBzdGF0ZS4gSW52b2tpbmcgdGhpcyBmdW5jdGlvbiBpbXBsaWNpdGx5IGZsdXNoZXMgdGhlIGRpc3BsYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAqICAgICBDYWxsYmFjayB3aGljaCBzaG91bGQgYmUgaW52b2tlZCBvbmNlIHRoZSBzdGF0ZSBvYmplY3QgaXMgcmVhZHkuIFRoZVxyXG4gICAgICogICAgIHN0YXRlIG9iamVjdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgYXMgdGhlIHNvbGUgcGFyYW1ldGVyLlxyXG4gICAgICogICAgIFRoaXMgY2FsbGJhY2sgbWF5IGJlIGludm9rZWQgaW1tZWRpYXRlbHksIG9yIGxhdGVyIGFzIHRoZSBkaXNwbGF5XHJcbiAgICAgKiAgICAgZmluaXNoZXMgcmVuZGVyaW5nIGFuZCBiZWNvbWVzIHJlYWR5LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmV4cG9ydFN0YXRlID0gZnVuY3Rpb24gZXhwb3J0U3RhdGUoY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBlbXB0eSBzdGF0ZVxyXG4gICAgICAgIHZhciBzdGF0ZSA9IHtcclxuICAgICAgICAgICAgJ2N1cnJlbnRTdGF0ZScgOiBjdXJyZW50U3RhdGUsXHJcbiAgICAgICAgICAgICdjdXJyZW50VGltZXN0YW1wJyA6IGN1cnJlbnRUaW1lc3RhbXAsXHJcbiAgICAgICAgICAgICdsYXllcnMnIDoge31cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgbGF5ZXJzU25hcHNob3QgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgYWxsIGN1cnJlbnQgbGF5ZXJzIChwcm90b2NvbCBzdGF0ZSlcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIGxheWVyc1NuYXBzaG90W2tleV0gPSBsYXllcnNba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBvcHVsYXRlIGxheWVycyBvbmNlIGRhdGEgaXMgYXZhaWxhYmxlIChkaXNwbGF5IHN0YXRlLCByZXF1aXJlcyBmbHVzaClcclxuICAgICAgICBkaXNwbGF5LmZsdXNoKGZ1bmN0aW9uIHBvcHVsYXRlTGF5ZXJzKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gRXhwb3J0IGVhY2ggZGVmaW5lZCBsYXllci9idWZmZXJcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGxheWVyc1NuYXBzaG90KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoa2V5KTtcclxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1NuYXBzaG90W2tleV07XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gbGF5ZXIudG9DYW52YXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBsYXllci9idWZmZXIgZGltZW5zaW9uc1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cG9ydExheWVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCcgIDogbGF5ZXIud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCcgOiBsYXllci5oZWlnaHRcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgbGF5ZXIvYnVmZmVyIGltYWdlIGRhdGEsIGlmIGl0IGNhbiBiZSBnZW5lcmF0ZWRcclxuICAgICAgICAgICAgICAgIGlmIChsYXllci53aWR0aCAmJiBsYXllci5oZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0TGF5ZXIudXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGxheWVyIHByb3BlcnRpZXMgaWYgbm90IGEgYnVmZmVyIG5vciB0aGUgZGVmYXVsdCBsYXllclxyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydExheWVyLnggPSBsYXllci54O1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydExheWVyLnkgPSBsYXllci55O1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydExheWVyLnogPSBsYXllci56O1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydExheWVyLmFscGhhID0gbGF5ZXIuYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0TGF5ZXIubWF0cml4ID0gbGF5ZXIubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydExheWVyLnBhcmVudCA9IGdldExheWVySW5kZXgobGF5ZXIucGFyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBleHBvcnRlZCBsYXllclxyXG4gICAgICAgICAgICAgICAgc3RhdGUubGF5ZXJzW2tleV0gPSBleHBvcnRMYXllcjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEludm9rZSBjYWxsYmFjayBub3cgdGhhdCB0aGUgc3RhdGUgaXMgcmVhZHlcclxuICAgICAgICAgICAgY2FsbGJhY2soc3RhdGUpO1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzdG9yZXMgR3VhY2Ftb2xlLkNsaWVudCBwcm90b2NvbCBhbmQgZGlzcGxheSBzdGF0ZSBiYXNlZCBvbiBhbiBvcGFxdWVcclxuICAgICAqIG9iamVjdCBmcm9tIGEgcHJpb3IgY2FsbCB0byBleHBvcnRTdGF0ZSgpLiBUaGUgR3VhY2Ftb2xlLkNsaWVudCBpbnN0YW5jZVxyXG4gICAgICogdXNlZCB0byBleHBvcnQgdGhhdCBzdGF0ZSBuZWVkIG5vdCBiZSB0aGUgc2FtZSBhcyB0aGlzIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gICAgICogICAgIEFuIG9wYXF1ZSByZXByZXNlbnRhdGlvbiBvZiBHdWFjYW1vbGUuQ2xpZW50IHN0YXRlIGZyb20gYSBwcmlvciBjYWxsXHJcbiAgICAgKiAgICAgdG8gZXhwb3J0U3RhdGUoKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdXHJcbiAgICAgKiAgICAgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHN0YXRlIGhhcyBmaW5pc2hlZCBiZWluZyBpbXBvcnRlZC4gVGhpc1xyXG4gICAgICogICAgIG1heSBoYXBwZW4gaW1tZWRpYXRlbHksIG9yIGxhdGVyIGFzIGltYWdlcyB3aXRoaW4gdGhlIHByb3ZpZGVkIHN0YXRlXHJcbiAgICAgKiAgICAgb2JqZWN0IGFyZSBsb2FkZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW1wb3J0U3RhdGUgPSBmdW5jdGlvbiBpbXBvcnRTdGF0ZShzdGF0ZSwgY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgdmFyIGtleTtcclxuICAgICAgICB2YXIgaW5kZXg7XHJcblxyXG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IHN0YXRlLmN1cnJlbnRTdGF0ZTtcclxuICAgICAgICBjdXJyZW50VGltZXN0YW1wID0gc3RhdGUuY3VycmVudFRpbWVzdGFtcDtcclxuXHJcbiAgICAgICAgLy8gRGlzcG9zZSBvZiBhbGwgbGF5ZXJzXHJcbiAgICAgICAgZm9yIChrZXkgaW4gbGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gMClcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkuZGlzcG9zZShsYXllcnNba2V5XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsYXllcnMgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gSW1wb3J0IHN0YXRlIG9mIGVhY2ggbGF5ZXIvYnVmZmVyXHJcbiAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUubGF5ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KGtleSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW1wb3J0TGF5ZXIgPSBzdGF0ZS5sYXllcnNba2V5XTtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIoaW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzZXQgbGF5ZXIgc2l6ZVxyXG4gICAgICAgICAgICBkaXNwbGF5LnJlc2l6ZShsYXllciwgaW1wb3J0TGF5ZXIud2lkdGgsIGltcG9ydExheWVyLmhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIG5ldyBsYXllciBpZiBpdCBoYXMgYXNzb2NpYXRlZCBkYXRhXHJcbiAgICAgICAgICAgIGlmIChpbXBvcnRMYXllci51cmwpIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkuc2V0Q2hhbm5lbE1hc2sobGF5ZXIsIEd1YWNhbW9sZS5MYXllci5TUkMpO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5kcmF3KGxheWVyLCAwLCAwLCBpbXBvcnRMYXllci51cmwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgbGF5ZXItc3BlY2lmaWMgcHJvcGVydGllcyBpZiBub3QgYSBidWZmZXIgbm9yIHRoZSBkZWZhdWx0IGxheWVyXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgaW1wb3J0TGF5ZXIucGFyZW50ID49IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBsYXllciBwb3NpdGlvbiBhbmQgc2V0IHBhcmVudFxyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGdldExheWVyKGltcG9ydExheWVyLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5Lm1vdmUobGF5ZXIsIHBhcmVudCwgaW1wb3J0TGF5ZXIueCwgaW1wb3J0TGF5ZXIueSwgaW1wb3J0TGF5ZXIueik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGxheWVyIHRyYW5zcGFyZW5jeVxyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5zaGFkZShsYXllciwgaW1wb3J0TGF5ZXIuYWxwaGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IG1hdHJpeCB0cmFuc2Zvcm1cclxuICAgICAgICAgICAgICAgIHZhciBtYXRyaXggPSBpbXBvcnRMYXllci5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmRpc3RvcnQobGF5ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFsyXSxcclxuICAgICAgICAgICAgICAgICAgICBtYXRyaXhbM10sIG1hdHJpeFs0XSwgbWF0cml4WzVdKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGbHVzaCBjaGFuZ2VzIHRvIGRpc3BsYXlcclxuICAgICAgICBkaXNwbGF5LmZsdXNoKGNhbGxiYWNrKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBkaXNwbGF5IG9mIHRoaXMgR3VhY2Ftb2xlLkNsaWVudC4gVGhlIGRpc3BsYXlcclxuICAgICAqIGNvbnRhaW5zIGFuIEVsZW1lbnQgd2hpY2ggY2FuIGJlIGFkZGVkIHRvIHRoZSBET00sIGNhdXNpbmcgdGhlXHJcbiAgICAgKiBkaXNwbGF5IHRvIGJlY29tZSB2aXNpYmxlLlxyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJuIHtHdWFjYW1vbGUuRGlzcGxheX0gVGhlIHVuZGVybHlpbmcgZGlzcGxheSBvZiB0aGlzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR3VhY2Ftb2xlLkNsaWVudC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXREaXNwbGF5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpc3BsYXk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgc2NyZWVuLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBzY3JlZW4uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5kU2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IHNlbmQgcmVxdWVzdHMgaWYgbm90IGNvbm5lY3RlZFxyXG4gICAgICAgIGlmICghaXNDb25uZWN0ZWQoKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB0dW5uZWwuc2VuZE1lc3NhZ2UoXCJzaXplXCIsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyBhIGtleSBldmVudCBoYXZpbmcgdGhlIGdpdmVuIHByb3BlcnRpZXMgYXMgaWYgdGhlIHVzZXJcclxuICAgICAqIHByZXNzZWQgb3IgcmVsZWFzZWQgYSBrZXkuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlc3NlZCBXaGV0aGVyIHRoZSBrZXkgaXMgcHJlc3NlZCAodHJ1ZSkgb3IgcmVsZWFzZWRcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAoZmFsc2UpLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtleXN5bSBUaGUga2V5c3ltIG9mIHRoZSBrZXkgYmVpbmcgcHJlc3NlZCBvciByZWxlYXNlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5kS2V5RXZlbnQgPSBmdW5jdGlvbihwcmVzc2VkLCBrZXlzeW0pIHtcclxuICAgICAgICAvLyBEbyBub3Qgc2VuZCByZXF1ZXN0cyBpZiBub3QgY29ubmVjdGVkXHJcbiAgICAgICAgaWYgKCFpc0Nvbm5lY3RlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcImtleVwiLCBrZXlzeW0sIHByZXNzZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIGEgbW91c2UgZXZlbnQgaGF2aW5nIHRoZSBwcm9wZXJ0aWVzIHByb3ZpZGVkIGJ5IHRoZSBnaXZlbiBtb3VzZVxyXG4gICAgICogc3RhdGUuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLk1vdXNlLlN0YXRlfSBtb3VzZVN0YXRlIFRoZSBzdGF0ZSBvZiB0aGUgbW91c2UgdG8gc2VuZFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIG1vdXNlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmRNb3VzZVN0YXRlID0gZnVuY3Rpb24obW91c2VTdGF0ZSkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3Qgc2VuZCByZXF1ZXN0cyBpZiBub3QgY29ubmVjdGVkXHJcbiAgICAgICAgaWYgKCFpc0Nvbm5lY3RlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBjbGllbnQtc2lkZSBjdXJzb3JcclxuICAgICAgICBkaXNwbGF5Lm1vdmVDdXJzb3IoXHJcbiAgICAgICAgICAgIE1hdGguZmxvb3IobW91c2VTdGF0ZS54KSxcclxuICAgICAgICAgICAgTWF0aC5mbG9vcihtb3VzZVN0YXRlLnkpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQnVpbGQgbWFza1xyXG4gICAgICAgIHZhciBidXR0b25NYXNrID0gMDtcclxuICAgICAgICBpZiAobW91c2VTdGF0ZS5sZWZ0KSAgIGJ1dHRvbk1hc2sgfD0gMTtcclxuICAgICAgICBpZiAobW91c2VTdGF0ZS5taWRkbGUpIGJ1dHRvbk1hc2sgfD0gMjtcclxuICAgICAgICBpZiAobW91c2VTdGF0ZS5yaWdodCkgIGJ1dHRvbk1hc2sgfD0gNDtcclxuICAgICAgICBpZiAobW91c2VTdGF0ZS51cCkgICAgIGJ1dHRvbk1hc2sgfD0gODtcclxuICAgICAgICBpZiAobW91c2VTdGF0ZS5kb3duKSAgIGJ1dHRvbk1hc2sgfD0gMTY7XHJcblxyXG4gICAgICAgIC8vIFNlbmQgbWVzc2FnZVxyXG4gICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcIm1vdXNlXCIsIE1hdGguZmxvb3IobW91c2VTdGF0ZS54KSwgTWF0aC5mbG9vcihtb3VzZVN0YXRlLnkpLCBidXR0b25NYXNrKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgYW4gYXZhaWxhYmxlIHN0cmVhbSBpbmRleCBhbmQgY3JlYXRlcyBhIG5ld1xyXG4gICAgICogR3VhY2Ftb2xlLk91dHB1dFN0cmVhbSB1c2luZyB0aGF0IGluZGV4LCBhc3NvY2lhdGluZyB0aGUgcmVzdWx0aW5nXHJcbiAgICAgKiBzdHJlYW0gd2l0aCB0aGlzIEd1YWNhbW9sZS5DbGllbnQuIE5vdGUgdGhhdCB0aGlzIHN0cmVhbSB3aWxsIG5vdCB5ZXRcclxuICAgICAqIGV4aXN0IGFzIGZhciBhcyB0aGUgb3RoZXIgZW5kIG9mIHRoZSBHdWFjYW1vbGUgY29ubmVjdGlvbiBpcyBjb25jZXJuZWQuXHJcbiAgICAgKiBTdHJlYW1zIGV4aXN0IHdpdGhpbiB0aGUgR3VhY2Ftb2xlIHByb3RvY29sIG9ubHkgd2hlbiByZWZlcmVuY2VkIGJ5IGFuXHJcbiAgICAgKiBpbnN0cnVjdGlvbiB3aGljaCBjcmVhdGVzIHRoZSBzdHJlYW0sIHN1Y2ggYXMgYSBcImNsaXBib2FyZFwiLCBcImZpbGVcIiwgb3JcclxuICAgICAqIFwicGlwZVwiIGluc3RydWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtHdWFjYW1vbGUuT3V0cHV0U3RyZWFtfVxyXG4gICAgICogICAgIEEgbmV3IEd1YWNhbW9sZS5PdXRwdXRTdHJlYW0gd2l0aCBhIG5ld2x5LWFsbG9jYXRlZCBpbmRleCBhbmRcclxuICAgICAqICAgICBhc3NvY2lhdGVkIHdpdGggdGhpcyBHdWFjYW1vbGUuQ2xpZW50LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNyZWF0ZU91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uIGNyZWF0ZU91dHB1dFN0cmVhbSgpIHtcclxuXHJcbiAgICAgICAgLy8gQWxsb2NhdGUgaW5kZXhcclxuICAgICAgICB2YXIgaW5kZXggPSBzdHJlYW1faW5kaWNlcy5uZXh0KCk7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBuZXcgc3RyZWFtXHJcbiAgICAgICAgdmFyIHN0cmVhbSA9IG91dHB1dF9zdHJlYW1zW2luZGV4XSA9IG5ldyBHdWFjYW1vbGUuT3V0cHV0U3RyZWFtKGd1YWNfY2xpZW50LCBpbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBuZXcgYXVkaW8gc3RyZWFtIGZvciB3cml0aW5nLCB3aGVyZSBhdWRpbyBkYXRhIGhhdmluZyB0aGUgZ2l2ZVxyXG4gICAgICogbWltZXR5cGUgd2lsbCBiZSBzZW50IGFsb25nIHRoZSByZXR1cm5lZCBzdHJlYW0uIFRoZSBpbnN0cnVjdGlvblxyXG4gICAgICogbmVjZXNzYXJ5IHRvIGNyZWF0ZSB0aGlzIHN0cmVhbSB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgc2VudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICAgICAqICAgICBUaGUgbWltZXR5cGUgb2YgdGhlIGF1ZGlvIGRhdGEgdGhhdCB3aWxsIGJlIHNlbnQgYWxvbmcgdGhlIHJldHVybmVkXHJcbiAgICAgKiAgICAgc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0d1YWNhbW9sZS5PdXRwdXRTdHJlYW19XHJcbiAgICAgKiAgICAgVGhlIGNyZWF0ZWQgYXVkaW8gc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNyZWF0ZUF1ZGlvU3RyZWFtID0gZnVuY3Rpb24obWltZXR5cGUpIHtcclxuXHJcbiAgICAgICAgLy8gQWxsb2NhdGUgYW5kIGFzc29jaWF0ZSBzdHJlYW0gd2l0aCBhdWRpbyBtZXRhZGF0YVxyXG4gICAgICAgIHZhciBzdHJlYW0gPSBndWFjX2NsaWVudC5jcmVhdGVPdXRwdXRTdHJlYW0oKTtcclxuICAgICAgICB0dW5uZWwuc2VuZE1lc3NhZ2UoXCJhdWRpb1wiLCBzdHJlYW0uaW5kZXgsIG1pbWV0eXBlKTtcclxuICAgICAgICByZXR1cm4gc3RyZWFtO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBhIG5ldyBmaWxlIGZvciB3cml0aW5nLCBoYXZpbmcgdGhlIGdpdmVuIGluZGV4LCBtaW1ldHlwZSBhbmRcclxuICAgICAqIGZpbGVuYW1lLiBUaGUgaW5zdHJ1Y3Rpb24gbmVjZXNzYXJ5IHRvIGNyZWF0ZSB0aGlzIHN0cmVhbSB3aWxsXHJcbiAgICAgKiBhdXRvbWF0aWNhbGx5IGJlIHNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlIFRoZSBtaW1ldHlwZSBvZiB0aGUgZmlsZSBiZWluZyBzZW50LlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIFRoZSBmaWxlbmFtZSBvZiB0aGUgZmlsZSBiZWluZyBzZW50LlxyXG4gICAgICogQHJldHVybiB7R3VhY2Ftb2xlLk91dHB1dFN0cmVhbX0gVGhlIGNyZWF0ZWQgZmlsZSBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3JlYXRlRmlsZVN0cmVhbSA9IGZ1bmN0aW9uKG1pbWV0eXBlLCBmaWxlbmFtZSkge1xyXG5cclxuICAgICAgICAvLyBBbGxvY2F0ZSBhbmQgYXNzb2NpYXRlIHN0cmVhbSB3aXRoIGZpbGUgbWV0YWRhdGFcclxuICAgICAgICB2YXIgc3RyZWFtID0gZ3VhY19jbGllbnQuY3JlYXRlT3V0cHV0U3RyZWFtKCk7XHJcbiAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwiZmlsZVwiLCBzdHJlYW0uaW5kZXgsIG1pbWV0eXBlLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBuZXcgcGlwZSBmb3Igd3JpdGluZywgaGF2aW5nIHRoZSBnaXZlbiBuYW1lIGFuZCBtaW1ldHlwZS4gVGhlXHJcbiAgICAgKiBpbnN0cnVjdGlvbiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoaXMgc3RyZWFtIHdpbGwgYXV0b21hdGljYWxseSBiZSBzZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZSBUaGUgbWltZXR5cGUgb2YgdGhlIGRhdGEgYmVpbmcgc2VudC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwaXBlLlxyXG4gICAgICogQHJldHVybiB7R3VhY2Ftb2xlLk91dHB1dFN0cmVhbX0gVGhlIGNyZWF0ZWQgZmlsZSBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3JlYXRlUGlwZVN0cmVhbSA9IGZ1bmN0aW9uKG1pbWV0eXBlLCBuYW1lKSB7XHJcblxyXG4gICAgICAgIC8vIEFsbG9jYXRlIGFuZCBhc3NvY2lhdGUgc3RyZWFtIHdpdGggcGlwZSBtZXRhZGF0YVxyXG4gICAgICAgIHZhciBzdHJlYW0gPSBndWFjX2NsaWVudC5jcmVhdGVPdXRwdXRTdHJlYW0oKTtcclxuICAgICAgICB0dW5uZWwuc2VuZE1lc3NhZ2UoXCJwaXBlXCIsIHN0cmVhbS5pbmRleCwgbWltZXR5cGUsIG5hbWUpO1xyXG4gICAgICAgIHJldHVybiBzdHJlYW07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW5zIGEgbmV3IGNsaXBib2FyZCBvYmplY3QgZm9yIHdyaXRpbmcsIGhhdmluZyB0aGUgZ2l2ZW4gbWltZXR5cGUuIFRoZVxyXG4gICAgICogaW5zdHJ1Y3Rpb24gbmVjZXNzYXJ5IHRvIGNyZWF0ZSB0aGlzIHN0cmVhbSB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgc2VudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGUgVGhlIG1pbWV0eXBlIG9mIHRoZSBkYXRhIGJlaW5nIHNlbnQuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGlwZS5cclxuICAgICAqIEByZXR1cm4ge0d1YWNhbW9sZS5PdXRwdXRTdHJlYW19IFRoZSBjcmVhdGVkIGZpbGUgc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNyZWF0ZUNsaXBib2FyZFN0cmVhbSA9IGZ1bmN0aW9uKG1pbWV0eXBlKSB7XHJcblxyXG4gICAgICAgIC8vIEFsbG9jYXRlIGFuZCBhc3NvY2lhdGUgc3RyZWFtIHdpdGggY2xpcGJvYXJkIG1ldGFkYXRhXHJcbiAgICAgICAgdmFyIHN0cmVhbSA9IGd1YWNfY2xpZW50LmNyZWF0ZU91dHB1dFN0cmVhbSgpO1xyXG4gICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcImNsaXBib2FyZFwiLCBzdHJlYW0uaW5kZXgsIG1pbWV0eXBlKTtcclxuICAgICAgICByZXR1cm4gc3RyZWFtO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBhIG5ldyBhcmd1bWVudCB2YWx1ZSBzdHJlYW0gZm9yIHdyaXRpbmcsIGhhdmluZyB0aGUgZ2l2ZW5cclxuICAgICAqIHBhcmFtZXRlciBuYW1lIGFuZCBtaW1ldHlwZSwgcmVxdWVzdGluZyB0aGF0IHRoZSBjb25uZWN0aW9uIHBhcmFtZXRlclxyXG4gICAgICogd2l0aCB0aGUgZ2l2ZW4gbmFtZSBiZSB1cGRhdGVkIHRvIHRoZSB2YWx1ZSBkZXNjcmliZWQgYnkgdGhlIGNvbnRlbnRzXHJcbiAgICAgKiBvZiB0aGUgZm9sbG93aW5nIHN0cmVhbS4gVGhlIGluc3RydWN0aW9uIG5lY2Vzc2FyeSB0byBjcmVhdGUgdGhpcyBzdHJlYW1cclxuICAgICAqIHdpbGwgYXV0b21hdGljYWxseSBiZSBzZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gICAgICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgZGF0YSBiZWluZyBzZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgKiAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbm5lY3Rpb24gcGFyYW1ldGVyIHRvIGF0dGVtcHQgdG8gdXBkYXRlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0d1YWNhbW9sZS5PdXRwdXRTdHJlYW19XHJcbiAgICAgKiAgICAgVGhlIGNyZWF0ZWQgYXJndW1lbnQgdmFsdWUgc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNyZWF0ZUFyZ3VtZW50VmFsdWVTdHJlYW0gPSBmdW5jdGlvbiBjcmVhdGVBcmd1bWVudFZhbHVlU3RyZWFtKG1pbWV0eXBlLCBuYW1lKSB7XHJcblxyXG4gICAgICAgIC8vIEFsbG9jYXRlIGFuZCBhc3NvY2lhdGUgc3RyZWFtIHdpdGggYXJndW1lbnQgdmFsdWUgbWV0YWRhdGFcclxuICAgICAgICB2YXIgc3RyZWFtID0gZ3VhY19jbGllbnQuY3JlYXRlT3V0cHV0U3RyZWFtKCk7XHJcbiAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwiYXJndlwiLCBzdHJlYW0uaW5kZXgsIG1pbWV0eXBlLCBuYW1lKTtcclxuICAgICAgICByZXR1cm4gc3RyZWFtO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG91dHB1dCBzdHJlYW0gYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBvYmplY3QgYW5kIGhhdmluZ1xyXG4gICAgICogdGhlIGdpdmVuIG1pbWV0eXBlIGFuZCBuYW1lLiBUaGUgbGVnYWxpdHkgb2YgYSBtaW1ldHlwZSBhbmQgbmFtZSBpc1xyXG4gICAgICogZGljdGF0ZWQgYnkgdGhlIG9iamVjdCBpdHNlbGYuIFRoZSBpbnN0cnVjdGlvbiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoaXNcclxuICAgICAqIHN0cmVhbSB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgc2VudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuICAgICAqICAgICBUaGUgaW5kZXggb2YgdGhlIG9iamVjdCBmb3Igd2hpY2ggdGhlIG91dHB1dCBzdHJlYW0gaXMgYmVpbmdcclxuICAgICAqICAgICBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gICAgICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgZGF0YSB3aGljaCB3aWxsIGJlIHNlbnQgdG8gdGhlIG91dHB1dCBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAqICAgICBUaGUgZGVmaW5lZCBuYW1lIG9mIGFuIG91dHB1dCBzdHJlYW0gd2l0aGluIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0d1YWNhbW9sZS5PdXRwdXRTdHJlYW19XHJcbiAgICAgKiAgICAgQW4gb3V0cHV0IHN0cmVhbSB3aGljaCB3aWxsIHdyaXRlIGJsb2JzIHRvIHRoZSBuYW1lZCBvdXRwdXQgc3RyZWFtXHJcbiAgICAgKiAgICAgb2YgdGhlIGdpdmVuIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jcmVhdGVPYmplY3RPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbiBjcmVhdGVPYmplY3RPdXRwdXRTdHJlYW0oaW5kZXgsIG1pbWV0eXBlLCBuYW1lKSB7XHJcblxyXG4gICAgICAgIC8vIEFsbG9jYXRlIGFuZCBzc29jaWF0ZSBzdHJlYW0gd2l0aCBvYmplY3QgbWV0YWRhdGFcclxuICAgICAgICB2YXIgc3RyZWFtID0gZ3VhY19jbGllbnQuY3JlYXRlT3V0cHV0U3RyZWFtKCk7XHJcbiAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwicHV0XCIsIGluZGV4LCBzdHJlYW0uaW5kZXgsIG1pbWV0eXBlLCBuYW1lKTtcclxuICAgICAgICByZXR1cm4gc3RyZWFtO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0cyByZWFkIGFjY2VzcyB0byB0aGUgaW5wdXQgc3RyZWFtIGhhdmluZyB0aGUgZ2l2ZW4gbmFtZS4gSWZcclxuICAgICAqIHN1Y2Nlc3NmdWwsIGEgbmV3IGlucHV0IHN0cmVhbSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XHJcbiAgICAgKiAgICAgVGhlIGluZGV4IG9mIHRoZSBvYmplY3QgZnJvbSB3aGljaCB0aGUgaW5wdXQgc3RyZWFtIGlzIGJlaW5nXHJcbiAgICAgKiAgICAgcmVxdWVzdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgKiAgICAgVGhlIG5hbWUgb2YgdGhlIGlucHV0IHN0cmVhbSB0byByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlcXVlc3RPYmplY3RJbnB1dFN0cmVhbSA9IGZ1bmN0aW9uIHJlcXVlc3RPYmplY3RJbnB1dFN0cmVhbShpbmRleCwgbmFtZSkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3Qgc2VuZCByZXF1ZXN0cyBpZiBub3QgY29ubmVjdGVkXHJcbiAgICAgICAgaWYgKCFpc0Nvbm5lY3RlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcImdldFwiLCBpbmRleCwgbmFtZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWNrbm93bGVkZ2UgcmVjZWlwdCBvZiBhIGJsb2Igb24gdGhlIHN0cmVhbSB3aXRoIHRoZSBnaXZlbiBpbmRleC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgc3RyZWFtIGFzc29jaWF0ZWQgd2l0aCB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZCBibG9iLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgQSBodW1hbi1yZWFkYWJsZSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGVycm9yXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBvciBzdGF0dXMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgZXJyb3IgY29kZSwgaWYgYW55LCBvciAwIGZvciBzdWNjZXNzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmRBY2sgPSBmdW5jdGlvbihpbmRleCwgbWVzc2FnZSwgY29kZSkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3Qgc2VuZCByZXF1ZXN0cyBpZiBub3QgY29ubmVjdGVkXHJcbiAgICAgICAgaWYgKCFpc0Nvbm5lY3RlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcImFja1wiLCBpbmRleCwgbWVzc2FnZSwgY29kZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gdGhlIGluZGV4IG9mIGEgZmlsZSwgd3JpdGVzIGEgYmxvYiBvZiBkYXRhIHRvIHRoYXQgZmlsZS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZmlsZSB0byB3cml0ZSB0by5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIEJhc2U2NC1lbmNvZGVkIGRhdGEgdG8gd3JpdGUgdG8gdGhlIGZpbGUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VuZEJsb2IgPSBmdW5jdGlvbihpbmRleCwgZGF0YSkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3Qgc2VuZCByZXF1ZXN0cyBpZiBub3QgY29ubmVjdGVkXHJcbiAgICAgICAgaWYgKCFpc0Nvbm5lY3RlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcImJsb2JcIiwgaW5kZXgsIGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcmtzIGEgY3VycmVudGx5LW9wZW4gc3RyZWFtIGFzIGNvbXBsZXRlLiBUaGUgb3RoZXIgZW5kIG9mIHRoZVxyXG4gICAgICogR3VhY2Ftb2xlIGNvbm5lY3Rpb24gd2lsbCBiZSBub3RpZmllZCB2aWEgYW4gXCJlbmRcIiBpbnN0cnVjdGlvbiB0aGF0IHRoZVxyXG4gICAgICogc3RyZWFtIGlzIGNsb3NlZCwgYW5kIHRoZSBpbmRleCB3aWxsIGJlIG1hZGUgYXZhaWxhYmxlIGZvciByZXVzZSBpblxyXG4gICAgICogZnV0dXJlIHN0cmVhbXMuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gICAgICogICAgIFRoZSBpbmRleCBvZiB0aGUgc3RyZWFtIHRvIGVuZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5lbmRTdHJlYW0gPSBmdW5jdGlvbihpbmRleCkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3Qgc2VuZCByZXF1ZXN0cyBpZiBub3QgY29ubmVjdGVkXHJcbiAgICAgICAgaWYgKCFpc0Nvbm5lY3RlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIEV4cGxpY2l0bHkgY2xvc2Ugc3RyZWFtIGJ5IHNlbmRpbmcgXCJlbmRcIiBpbnN0cnVjdGlvblxyXG4gICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcImVuZFwiLCBpbmRleCk7XHJcblxyXG4gICAgICAgIC8vIEZyZWUgYXNzb2NpYXRlZCBpbmRleCBhbmQgc3RyZWFtIGlmIHRoZXkgZXhpc3RcclxuICAgICAgICBpZiAob3V0cHV0X3N0cmVhbXNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgIHN0cmVhbV9pbmRpY2VzLmZyZWUoaW5kZXgpO1xyXG4gICAgICAgICAgICBkZWxldGUgb3V0cHV0X3N0cmVhbXNbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHN0YXRlIG9mIHRoaXMgR3VhY2Ftb2xlLkNsaWVudCBjaGFuZ2VzLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0ZSBUaGUgbmV3IHN0YXRlIG9mIHRoZSBjbGllbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25zdGF0ZWNoYW5nZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSByZW1vdGUgY2xpZW50IHNlbmRzIGEgbmFtZSB1cGRhdGUuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5ldyBuYW1lIG9mIHRoaXMgY2xpZW50LlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9ubmFtZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIGFuIGVycm9yIGlzIHJlcG9ydGVkIGJ5IHRoZSByZW1vdGUgY2xpZW50LCBhbmQgdGhlIGNvbm5lY3Rpb25cclxuICAgICAqIGlzIGJlaW5nIGNsb3NlZC5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5TdGF0dXN9IHN0YXR1cyBBIHN0YXR1cyBvYmplY3Qgd2hpY2ggZGVzY3JpYmVzIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25lcnJvciA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIGEgYXVkaW8gc3RyZWFtIGlzIGNyZWF0ZWQuIFRoZSBzdHJlYW0gcHJvdmlkZWQgdG8gdGhpcyBldmVudFxyXG4gICAgICogaGFuZGxlciB3aWxsIGNvbnRhaW4gaXRzIG93biBldmVudCBoYW5kbGVycyBmb3IgcmVjZWl2ZWQgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLklucHV0U3RyZWFtfSBzdHJlYW1cclxuICAgICAqICAgICBUaGUgc3RyZWFtIHRoYXQgd2lsbCByZWNlaXZlIGF1ZGlvIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gICAgICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgYXVkaW8gZGF0YSB3aGljaCB3aWxsIGJlIHJlY2VpdmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0d1YWNhbW9sZS5BdWRpb1BsYXllcn1cclxuICAgICAqICAgICBBbiBvYmplY3Qgd2hpY2ggaW1wbGVtZW50cyB0aGUgR3VhY2Ftb2xlLkF1ZGlvUGxheWVyIGludGVyZmFjZSBhbmRcclxuICAgICAqICAgICBoYXMgYmVlbiBpbml0aWFsaWVkIHRvIHBsYXkgdGhlIGRhdGEgaW4gdGhlIHByb3ZpZGVkIHN0cmVhbSwgb3IgbnVsbFxyXG4gICAgICogICAgIGlmIHRoZSBidWlsdC1pbiBhdWRpbyBwbGF5ZXJzIG9mIHRoZSBHdWFjYW1vbGUgY2xpZW50IHNob3VsZCBiZVxyXG4gICAgICogICAgIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25hdWRpbyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIGEgdmlkZW8gc3RyZWFtIGlzIGNyZWF0ZWQuIFRoZSBzdHJlYW0gcHJvdmlkZWQgdG8gdGhpcyBldmVudFxyXG4gICAgICogaGFuZGxlciB3aWxsIGNvbnRhaW4gaXRzIG93biBldmVudCBoYW5kbGVycyBmb3IgcmVjZWl2ZWQgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLklucHV0U3RyZWFtfSBzdHJlYW1cclxuICAgICAqICAgICBUaGUgc3RyZWFtIHRoYXQgd2lsbCByZWNlaXZlIHZpZGVvIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkRpc3BsYXkuVmlzaWJsZUxheWVyfSBsYXllclxyXG4gICAgICogICAgIFRoZSBkZXN0aW5hdGlvbiBsYXllciBvbiB3aGljaCB0aGUgcmVjZWl2ZWQgdmlkZW8gZGF0YSBzaG91bGQgYmVcclxuICAgICAqICAgICBwbGF5ZWQuIEl0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgR3VhY2Ftb2xlLlZpZGVvUGxheWVyXHJcbiAgICAgKiAgICAgaW1wbGVtZW50YXRpb24gdG8gcGxheSB0aGUgcmVjZWl2ZWQgZGF0YSB3aXRoaW4gdGhpcyBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICAgICAqICAgICBUaGUgbWltZXR5cGUgb2YgdGhlIHZpZGVvIGRhdGEgd2hpY2ggd2lsbCBiZSByZWNlaXZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtHdWFjYW1vbGUuVmlkZW9QbGF5ZXJ9XHJcbiAgICAgKiAgICAgQW4gb2JqZWN0IHdoaWNoIGltcGxlbWVudHMgdGhlIEd1YWNhbW9sZS5WaWRlb1BsYXllciBpbnRlcmZhY2UgYW5kXHJcbiAgICAgKiAgICAgaGFzIGJlZW4gaW5pdGlhbGllZCB0byBwbGF5IHRoZSBkYXRhIGluIHRoZSBwcm92aWRlZCBzdHJlYW0sIG9yIG51bGxcclxuICAgICAqICAgICBpZiB0aGUgYnVpbHQtaW4gdmlkZW8gcGxheWVycyBvZiB0aGUgR3VhY2Ftb2xlIGNsaWVudCBzaG91bGQgYmVcclxuICAgICAqICAgICB1c2VkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9udmlkZW8gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIGNvbm5lY3Rpb24gcGFyYW1ldGVyIGlzIGJlaW5nIGV4cG9zZWRcclxuICAgICAqIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gc3RyZWFtXHJcbiAgICAgKiAgICAgVGhlIHN0cmVhbSB0aGF0IHdpbGwgcmVjZWl2ZSBjb25uZWN0aW9uIHBhcmFtZXRlciBkYXRhIGZyb20gdGhlXHJcbiAgICAgKiAgICAgc2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gICAgICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgZGF0YSB3aGljaCB3aWxsIGJlIHJlY2VpdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgKiAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbm5lY3Rpb24gcGFyYW1ldGVyIHdob3NlIHZhbHVlIGlzIGJlaW5nIGV4cG9zZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25hcmd2ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGNsaXBib2FyZCBvZiB0aGUgcmVtb3RlIGNsaWVudCBpcyBjaGFuZ2luZy5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gc3RyZWFtIFRoZSBzdHJlYW0gdGhhdCB3aWxsIHJlY2VpdmVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcGJvYXJkIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlIFRoZSBtaW1ldHlwZSBvZiB0aGUgZGF0YSB3aGljaCB3aWxsIGJlIHJlY2VpdmVkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uY2xpcGJvYXJkID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW4gYSBmaWxlIHN0cmVhbSBpcyBjcmVhdGVkLiBUaGUgc3RyZWFtIHByb3ZpZGVkIHRvIHRoaXMgZXZlbnRcclxuICAgICAqIGhhbmRsZXIgd2lsbCBjb250YWluIGl0cyBvd24gZXZlbnQgaGFuZGxlcnMgZm9yIHJlY2VpdmVkIGRhdGEuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuSW5wdXRTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIHRoYXQgd2lsbCByZWNlaXZlIGRhdGFcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlIFRoZSBtaW1ldHlwZSBvZiB0aGUgZmlsZSByZWNlaXZlZC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSByZWNlaXZlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmZpbGUgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiBhIGZpbGVzeXN0ZW0gb2JqZWN0IGlzIGNyZWF0ZWQuIFRoZSBvYmplY3QgcHJvdmlkZWQgdG8gdGhpc1xyXG4gICAgICogZXZlbnQgaGFuZGxlciB3aWxsIGNvbnRhaW4gaXRzIG93biBldmVudCBoYW5kbGVycyBhbmQgZnVuY3Rpb25zIGZvclxyXG4gICAgICogcmVxdWVzdGluZyBhbmQgaGFuZGxpbmcgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLk9iamVjdH0gb2JqZWN0XHJcbiAgICAgKiAgICAgVGhlIGNyZWF0ZWQgZmlsZXN5c3RlbSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUgZmlsZXN5c3RlbS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmZpbGVzeXN0ZW0gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiBhIHBpcGUgc3RyZWFtIGlzIGNyZWF0ZWQuIFRoZSBzdHJlYW0gcHJvdmlkZWQgdG8gdGhpcyBldmVudFxyXG4gICAgICogaGFuZGxlciB3aWxsIGNvbnRhaW4gaXRzIG93biBldmVudCBoYW5kbGVycyBmb3IgcmVjZWl2ZWQgZGF0YTtcclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gc3RyZWFtIFRoZSBzdHJlYW0gdGhhdCB3aWxsIHJlY2VpdmUgZGF0YVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGUgVGhlIG1pbWV0eXBlIG9mIHRoZSBkYXRhIHdoaWNoIHdpbGwgYmUgcmVjZWl2ZWQuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGlwZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbnBpcGUgPSBudWxsO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW4gYSBcInJlcXVpcmVkXCIgaW5zdHJ1Y3Rpb24gaXMgcmVjZWl2ZWQuIEEgcmVxdWlyZWQgaW5zdHJ1Y3Rpb25cclxuICAgICAqIGluZGljYXRlcyB0aGF0IGFkZGl0aW9uYWwgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQgZm9yIHRoZSBjb25uZWN0aW9uIHRvXHJcbiAgICAgKiBjb250aW51ZSwgc3VjaCBhcyB1c2VyIGNyZWRlbnRpYWxzLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHBhcmFtZXRlcnNcclxuICAgICAqICAgICAgVGhlIG5hbWVzIG9mIHRoZSBjb25uZWN0aW9uIHBhcmFtZXRlcnMgdGhhdCBhcmUgcmVxdWlyZWQgdG8gYmVcclxuICAgICAqICAgICAgcHJvdmlkZWQgZm9yIHRoZSBjb25uZWN0aW9uIHRvIGNvbnRpbnVlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9ucmVxdWlyZWQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgYSBzeW5jIGluc3RydWN0aW9uIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciwgaW5kaWNhdGluZ1xyXG4gICAgICogdGhhdCB0aGUgc2VydmVyIGlzIGZpbmlzaGVkIHByb2Nlc3NpbmcgYW55IGlucHV0IGZyb20gdGhlIGNsaWVudCBhbmRcclxuICAgICAqIGhhcyBzZW50IGFueSByZXN1bHRzLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBhc3NvY2lhdGVkIHdpdGggdGhlIHN5bmNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25zeW5jID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGluZGV4LCBjcmVhdGluZyBpdCBpZiBuZWNlc3NhcnkuXHJcbiAgICAgKiBQb3NpdGl2ZSBpbmRpY2VzIHJlZmVyIHRvIHZpc2libGUgbGF5ZXJzLCBhbiBpbmRleCBvZiB6ZXJvIHJlZmVycyB0b1xyXG4gICAgICogdGhlIGRlZmF1bHQgbGF5ZXIsIGFuZCBuZWdhdGl2ZSBpbmRpY2VzIHJlZmVyIHRvIGJ1ZmZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gICAgICogICAgIFRoZSBpbmRleCBvZiB0aGUgbGF5ZXIgdG8gcmV0cmlldmUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7R3VhY2Ftb2xlLkRpc3BsYXkuVmlzaWJsZUxheWVyfEd1YWNhbW9sZS5MYXllcn1cclxuICAgICAqICAgICBUaGUgbGF5ZXIgaGF2aW5nIHRoZSBnaXZlbiBpbmRleC5cclxuICAgICAqL1xyXG4gICAgdmFyIGdldExheWVyID0gZnVuY3Rpb24gZ2V0TGF5ZXIoaW5kZXgpIHtcclxuXHJcbiAgICAgICAgLy8gR2V0IGxheWVyLCBjcmVhdGUgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2luZGV4XTtcclxuICAgICAgICBpZiAoIWxheWVyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgbGF5ZXIgYmFzZWQgb24gaW5kZXhcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKVxyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBkaXNwbGF5LmdldERlZmF1bHRMYXllcigpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA+IDApXHJcbiAgICAgICAgICAgICAgICBsYXllciA9IGRpc3BsYXkuY3JlYXRlTGF5ZXIoKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBkaXNwbGF5LmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEFkZCBuZXcgbGF5ZXJcclxuICAgICAgICAgICAgbGF5ZXJzW2luZGV4XSA9IGxheWVyO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggcGFzc2VkIHRvIGdldExheWVyKCkgd2hlbiB0aGUgZ2l2ZW4gbGF5ZXIgd2FzIGNyZWF0ZWQuXHJcbiAgICAgKiBQb3NpdGl2ZSBpbmRpY2VzIHJlZmVyIHRvIHZpc2libGUgbGF5ZXJzLCBhbiBpbmRleCBvZiB6ZXJvIHJlZmVycyB0byB0aGVcclxuICAgICAqIGRlZmF1bHQgbGF5ZXIsIGFuZCBuZWdhdGl2ZSBpbmRpY2VzIHJlZmVyIHRvIGJ1ZmZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ8R3VhY2Ftb2xlLkxheWVyfSBsYXllclxyXG4gICAgICogICAgIFRoZSBsYXllciB3aG9zZSBpbmRleCBzaG91bGQgYmUgZGV0ZXJtaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogICAgIFRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gbGF5ZXIsIG9yIG51bGwgaWYgbm8gc3VjaCBsYXllciBpcyBhc3NvY2lhdGVkXHJcbiAgICAgKiAgICAgd2l0aCB0aGlzIGNsaWVudC5cclxuICAgICAqL1xyXG4gICAgdmFyIGdldExheWVySW5kZXggPSBmdW5jdGlvbiBnZXRMYXllckluZGV4KGxheWVyKSB7XHJcblxyXG4gICAgICAgIC8vIEF2b2lkIHNlYXJjaGluZyBpZiB0aGVyZSBjbGVhcmx5IGlzIG5vIHN1Y2ggbGF5ZXJcclxuICAgICAgICBpZiAoIWxheWVyKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gU2VhcmNoIHRocm91Z2ggZWFjaCBsYXllciwgcmV0dXJuaW5nIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gbGF5ZXJcclxuICAgICAgICAvLyBvbmNlIGZvdW5kXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGxheWVycykge1xyXG4gICAgICAgICAgICBpZiAobGF5ZXIgPT09IGxheWVyc1trZXldKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGtleSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIG5vIHN1Y2ggaW5kZXhcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFBhcnNlcihpbmRleCkge1xyXG5cclxuICAgICAgICB2YXIgcGFyc2VyID0gcGFyc2Vyc1tpbmRleF07XHJcblxyXG4gICAgICAgIC8vIElmIHBhcnNlciBub3QgeWV0IGNyZWF0ZWQsIGNyZWF0ZSBpdCwgYW5kIHRpZSB0byB0aGVcclxuICAgICAgICAvLyBvbmluc3RydWN0aW9uIGhhbmRsZXIgb2YgdGhlIHR1bm5lbC5cclxuICAgICAgICBpZiAocGFyc2VyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcGFyc2VyID0gcGFyc2Vyc1tpbmRleF0gPSBuZXcgR3VhY2Ftb2xlLlBhcnNlcigpO1xyXG4gICAgICAgICAgICBwYXJzZXIub25pbnN0cnVjdGlvbiA9IHR1bm5lbC5vbmluc3RydWN0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcnNlcjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVycyBmb3IgYWxsIGRlZmluZWQgbGF5ZXIgcHJvcGVydGllcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBsYXllclByb3BlcnR5SGFuZGxlcnMgPSB7XHJcblxyXG4gICAgICAgIFwibWl0ZXItbGltaXRcIjogZnVuY3Rpb24obGF5ZXIsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuc2V0TWl0ZXJMaW1pdChsYXllciwgcGFyc2VGbG9hdCh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXJzIGZvciBhbGwgaW5zdHJ1Y3Rpb24gb3Bjb2RlcyByZWNlaXZhYmxlIGJ5IGEgR3VhY2Ftb2xlIHByb3RvY29sXHJcbiAgICAgKiBjbGllbnQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgaW5zdHJ1Y3Rpb25IYW5kbGVycyA9IHtcclxuXHJcbiAgICAgICAgXCJhY2tcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0cmVhbV9pbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgcmVhc29uID0gcGFyYW1ldGVyc1sxXTtcclxuICAgICAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChwYXJhbWV0ZXJzWzJdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBzdHJlYW1cclxuICAgICAgICAgICAgdmFyIHN0cmVhbSA9IG91dHB1dF9zdHJlYW1zW3N0cmVhbV9pbmRleF07XHJcbiAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaWduYWwgYWNrIGlmIGhhbmRsZXIgZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5vbmFjaylcclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub25hY2sobmV3IEd1YWNhbW9sZS5TdGF0dXMoY29kZSwgcmVhc29uKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgY29kZSBpcyBhbiBlcnJvciwgaW52YWxpZGF0ZSBzdHJlYW0gaWYgbm90IGFscmVhZHlcclxuICAgICAgICAgICAgICAgIC8vIGludmFsaWRhdGVkIGJ5IG9uYWNrIGhhbmRsZXJcclxuICAgICAgICAgICAgICAgIGlmIChjb2RlID49IDB4MDEwMCAmJiBvdXRwdXRfc3RyZWFtc1tzdHJlYW1faW5kZXhdID09PSBzdHJlYW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1faW5kaWNlcy5mcmVlKHN0cmVhbV9pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG91dHB1dF9zdHJlYW1zW3N0cmVhbV9pbmRleF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiYXJjXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pKTtcclxuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludChwYXJhbWV0ZXJzWzFdKTtcclxuICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUludChwYXJhbWV0ZXJzWzJdKTtcclxuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHBhcnNlSW50KHBhcmFtZXRlcnNbM10pO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHBhcnNlRmxvYXQocGFyYW1ldGVyc1s0XSk7XHJcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHBhcnNlRmxvYXQocGFyYW1ldGVyc1s1XSk7XHJcbiAgICAgICAgICAgIHZhciBuZWdhdGl2ZSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNl0pO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS5hcmMobGF5ZXIsIHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIG5lZ2F0aXZlICE9IDApO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImFyZ3ZcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0cmVhbV9pbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgbWltZXR5cGUgPSBwYXJhbWV0ZXJzWzFdO1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHBhcmFtZXRlcnNbMl07XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgc3RyZWFtXHJcbiAgICAgICAgICAgIGlmIChndWFjX2NsaWVudC5vbmFyZ3YpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBzdHJlYW1zW3N0cmVhbV9pbmRleF0gPSBuZXcgR3VhY2Ftb2xlLklucHV0U3RyZWFtKGd1YWNfY2xpZW50LCBzdHJlYW1faW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZ3VhY19jbGllbnQub25hcmd2KHN0cmVhbSwgbWltZXR5cGUsIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHVuc3VwcG9ydGVkXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50LnNlbmRBY2soc3RyZWFtX2luZGV4LCBcIlJlY2VpdmluZyBhcmd1bWVudCB2YWx1ZXMgdW5zdXBwb3J0ZWRcIiwgMHgwMTAwKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJhdWRpb1wiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RyZWFtX2luZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBtaW1ldHlwZSA9IHBhcmFtZXRlcnNbMV07XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgc3RyZWFtIFxyXG4gICAgICAgICAgICB2YXIgc3RyZWFtID0gc3RyZWFtc1tzdHJlYW1faW5kZXhdID1cclxuICAgICAgICAgICAgICAgICAgICBuZXcgR3VhY2Ftb2xlLklucHV0U3RyZWFtKGd1YWNfY2xpZW50LCBzdHJlYW1faW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHBsYXllciBpbnN0YW5jZSB2aWEgY2FsbGJhY2tcclxuICAgICAgICAgICAgdmFyIGF1ZGlvUGxheWVyID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGd1YWNfY2xpZW50Lm9uYXVkaW8pXHJcbiAgICAgICAgICAgICAgICBhdWRpb1BsYXllciA9IGd1YWNfY2xpZW50Lm9uYXVkaW8oc3RyZWFtLCBtaW1ldHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB1bnN1Y2Nlc3NmdWwsIHRyeSB0byB1c2UgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgICAgIGlmICghYXVkaW9QbGF5ZXIpXHJcbiAgICAgICAgICAgICAgICBhdWRpb1BsYXllciA9IEd1YWNhbW9sZS5BdWRpb1BsYXllci5nZXRJbnN0YW5jZShzdHJlYW0sIG1pbWV0eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgc3VjY2Vzc2Z1bGx5IHJldHJpZXZlZCBhbiBhdWRpbyBwbGF5ZXIsIHNlbmQgc3VjY2VzcyByZXNwb25zZVxyXG4gICAgICAgICAgICBpZiAoYXVkaW9QbGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgIGF1ZGlvUGxheWVyc1tzdHJlYW1faW5kZXhdID0gYXVkaW9QbGF5ZXI7XHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5zZW5kQWNrKHN0cmVhbV9pbmRleCwgXCJPS1wiLCAweDAwMDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIG1pbWV0eXBlIG11c3QgYmUgdW5zdXBwb3J0ZWRcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZ3VhY19jbGllbnQuc2VuZEFjayhzdHJlYW1faW5kZXgsIFwiQkFEIFRZUEVcIiwgMHgwMzBGKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJibG9iXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBzdHJlYW0gXHJcbiAgICAgICAgICAgIHZhciBzdHJlYW1faW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBwYXJhbWV0ZXJzWzFdO1xyXG4gICAgICAgICAgICB2YXIgc3RyZWFtID0gc3RyZWFtc1tzdHJlYW1faW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgLy8gV3JpdGUgZGF0YVxyXG4gICAgICAgICAgICBpZiAoc3RyZWFtICYmIHN0cmVhbS5vbmJsb2IpXHJcbiAgICAgICAgICAgICAgICBzdHJlYW0ub25ibG9iKGRhdGEpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImJvZHlcIiA6IGZ1bmN0aW9uIGhhbmRsZUJvZHkocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IG9iamVjdFxyXG4gICAgICAgICAgICB2YXIgb2JqZWN0SW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IG9iamVjdHNbb2JqZWN0SW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0cmVhbUluZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciBtaW1ldHlwZSA9IHBhcmFtZXRlcnNbMl07XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGFyYW1ldGVyc1szXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gaWYgaGFuZGxlciBkZWZpbmVkXHJcbiAgICAgICAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0Lm9uYm9keSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0cmVhbSA9IHN0cmVhbXNbc3RyZWFtSW5kZXhdID0gbmV3IEd1YWNhbW9sZS5JbnB1dFN0cmVhbShndWFjX2NsaWVudCwgc3RyZWFtSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm9uYm9keShzdHJlYW0sIG1pbWV0eXBlLCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB1bnN1cHBvcnRlZFxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5zZW5kQWNrKHN0cmVhbUluZGV4LCBcIlJlY2VpcHQgb2YgYm9keSB1bnN1cHBvcnRlZFwiLCAweDAxMDApO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImNmaWxsXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsTWFzayA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzFdKSk7XHJcbiAgICAgICAgICAgIHZhciByID0gcGFyc2VJbnQocGFyYW1ldGVyc1syXSk7XHJcbiAgICAgICAgICAgIHZhciBnID0gcGFyc2VJbnQocGFyYW1ldGVyc1szXSk7XHJcbiAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQocGFyYW1ldGVyc1s0XSk7XHJcbiAgICAgICAgICAgIHZhciBhID0gcGFyc2VJbnQocGFyYW1ldGVyc1s1XSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnNldENoYW5uZWxNYXNrKGxheWVyLCBjaGFubmVsTWFzayk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuZmlsbENvbG9yKGxheWVyLCByLCBnLCBiLCBhKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJjbGlwXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pKTtcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXkuY2xpcChsYXllcik7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiY2xpcGJvYXJkXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHJlYW1faW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIG1pbWV0eXBlID0gcGFyYW1ldGVyc1sxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gXHJcbiAgICAgICAgICAgIGlmIChndWFjX2NsaWVudC5vbmNsaXBib2FyZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0cmVhbSA9IHN0cmVhbXNbc3RyZWFtX2luZGV4XSA9IG5ldyBHdWFjYW1vbGUuSW5wdXRTdHJlYW0oZ3VhY19jbGllbnQsIHN0cmVhbV9pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5vbmNsaXBib2FyZChzdHJlYW0sIG1pbWV0eXBlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB1bnN1cHBvcnRlZFxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5zZW5kQWNrKHN0cmVhbV9pbmRleCwgXCJDbGlwYm9hcmQgdW5zdXBwb3J0ZWRcIiwgMHgwMTAwKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJjbG9zZVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LmNsb3NlKGxheWVyKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJjb3B5XCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzcmNMID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1swXSkpO1xyXG4gICAgICAgICAgICB2YXIgc3JjWCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgc3JjWSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pO1xyXG4gICAgICAgICAgICB2YXIgc3JjV2lkdGggPSBwYXJzZUludChwYXJhbWV0ZXJzWzNdKTtcclxuICAgICAgICAgICAgdmFyIHNyY0hlaWdodCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNF0pO1xyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbE1hc2sgPSBwYXJzZUludChwYXJhbWV0ZXJzWzVdKTtcclxuICAgICAgICAgICAgdmFyIGRzdEwgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzZdKSk7XHJcbiAgICAgICAgICAgIHZhciBkc3RYID0gcGFyc2VJbnQocGFyYW1ldGVyc1s3XSk7XHJcbiAgICAgICAgICAgIHZhciBkc3RZID0gcGFyc2VJbnQocGFyYW1ldGVyc1s4XSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnNldENoYW5uZWxNYXNrKGRzdEwsIGNoYW5uZWxNYXNrKTtcclxuICAgICAgICAgICAgZGlzcGxheS5jb3B5KHNyY0wsIHNyY1gsIHNyY1ksIHNyY1dpZHRoLCBzcmNIZWlnaHQsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgZHN0TCwgZHN0WCwgZHN0WSk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiY3N0cm9rZVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbE1hc2sgPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1sxXSkpO1xyXG4gICAgICAgICAgICB2YXIgY2FwID0gbGluZUNhcFtwYXJzZUludChwYXJhbWV0ZXJzWzJdKV07XHJcbiAgICAgICAgICAgIHZhciBqb2luID0gbGluZUpvaW5bcGFyc2VJbnQocGFyYW1ldGVyc1szXSldO1xyXG4gICAgICAgICAgICB2YXIgdGhpY2tuZXNzID0gcGFyc2VJbnQocGFyYW1ldGVyc1s0XSk7XHJcbiAgICAgICAgICAgIHZhciByID0gcGFyc2VJbnQocGFyYW1ldGVyc1s1XSk7XHJcbiAgICAgICAgICAgIHZhciBnID0gcGFyc2VJbnQocGFyYW1ldGVyc1s2XSk7XHJcbiAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQocGFyYW1ldGVyc1s3XSk7XHJcbiAgICAgICAgICAgIHZhciBhID0gcGFyc2VJbnQocGFyYW1ldGVyc1s4XSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnNldENoYW5uZWxNYXNrKGxheWVyLCBjaGFubmVsTWFzayk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuc3Ryb2tlQ29sb3IobGF5ZXIsIGNhcCwgam9pbiwgdGhpY2tuZXNzLCByLCBnLCBiLCBhKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJjdXJzb3JcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGN1cnNvckhvdHNwb3RYID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBjdXJzb3JIb3RzcG90WSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgc3JjTCA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pKTtcclxuICAgICAgICAgICAgdmFyIHNyY1ggPSBwYXJzZUludChwYXJhbWV0ZXJzWzNdKTtcclxuICAgICAgICAgICAgdmFyIHNyY1kgPSBwYXJzZUludChwYXJhbWV0ZXJzWzRdKTtcclxuICAgICAgICAgICAgdmFyIHNyY1dpZHRoID0gcGFyc2VJbnQocGFyYW1ldGVyc1s1XSk7XHJcbiAgICAgICAgICAgIHZhciBzcmNIZWlnaHQgPSBwYXJzZUludChwYXJhbWV0ZXJzWzZdKTtcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXkuc2V0Q3Vyc29yKGN1cnNvckhvdHNwb3RYLCBjdXJzb3JIb3RzcG90WSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjTCwgc3JjWCwgc3JjWSwgc3JjV2lkdGgsIHNyY0hlaWdodCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiY3VydmVcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1swXSkpO1xyXG4gICAgICAgICAgICB2YXIgY3AxeCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgY3AxeSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pO1xyXG4gICAgICAgICAgICB2YXIgY3AyeCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbM10pO1xyXG4gICAgICAgICAgICB2YXIgY3AyeSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNF0pO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNV0pO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNl0pO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS5jdXJ2ZVRvKGxheWVyLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJkaXNjb25uZWN0XCIgOiBmdW5jdGlvbiBoYW5kbGVEaXNjb25uZWN0KHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdGVhciBkb3duIGNvbm5lY3Rpb25cclxuICAgICAgICAgICAgZ3VhY19jbGllbnQuZGlzY29ubmVjdCgpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImRpc3Bvc2VcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGxheWVyX2luZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB2aXNpYmxlIGxheWVyLCByZW1vdmUgZnJvbSBwYXJlbnRcclxuICAgICAgICAgICAgaWYgKGxheWVyX2luZGV4ID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIobGF5ZXJfaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5kaXNwb3NlKGxheWVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZWxldGUgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbGF5ZXJzW2xheWVyX2luZGV4XTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGJ1ZmZlciwganVzdCBkZWxldGUgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxheWVyX2luZGV4IDwgMClcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBsYXllcnNbbGF5ZXJfaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgLy8gQXR0ZW1wdGluZyB0byBkaXNwb3NlIHRoZSByb290IGxheWVyIGN1cnJlbnRseSBoYXMgbm8gZWZmZWN0LlxyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImRpc3RvcnRcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxheWVyX2luZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBhID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzWzFdKTtcclxuICAgICAgICAgICAgdmFyIGIgPSBwYXJzZUZsb2F0KHBhcmFtZXRlcnNbMl0pO1xyXG4gICAgICAgICAgICB2YXIgYyA9IHBhcnNlRmxvYXQocGFyYW1ldGVyc1szXSk7XHJcbiAgICAgICAgICAgIHZhciBkID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzWzRdKTtcclxuICAgICAgICAgICAgdmFyIGUgPSBwYXJzZUZsb2F0KHBhcmFtZXRlcnNbNV0pO1xyXG4gICAgICAgICAgICB2YXIgZiA9IHBhcnNlRmxvYXQocGFyYW1ldGVyc1s2XSk7XHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHZhbGlkIGZvciB2aXNpYmxlIGxheWVycyAobm90IGJ1ZmZlcnMpXHJcbiAgICAgICAgICAgIGlmIChsYXllcl9pbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihsYXllcl9pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmRpc3RvcnQobGF5ZXIsIGEsIGIsIGMsIGQsIGUsIGYpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sXHJcbiBcclxuICAgICAgICBcImVycm9yXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZWFzb24gPSBwYXJhbWV0ZXJzWzBdO1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbCBoYW5kbGVyIGlmIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKGd1YWNfY2xpZW50Lm9uZXJyb3IpXHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5vbmVycm9yKG5ldyBHdWFjYW1vbGUuU3RhdHVzKGNvZGUsIHJlYXNvbikpO1xyXG5cclxuICAgICAgICAgICAgZ3VhY19jbGllbnQuZGlzY29ubmVjdCgpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImVuZFwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RyZWFtX2luZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgc3RyZWFtXHJcbiAgICAgICAgICAgIHZhciBzdHJlYW0gPSBzdHJlYW1zW3N0cmVhbV9pbmRleF07XHJcbiAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaWduYWwgZW5kIG9mIHN0cmVhbSBpZiBoYW5kbGVyIGRlZmluZWRcclxuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0ub25lbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uZW5kKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBzdHJlYW1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdHJlYW1zW3N0cmVhbV9pbmRleF07XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiZmlsZVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RyZWFtX2luZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBtaW1ldHlwZSA9IHBhcmFtZXRlcnNbMV07XHJcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IHBhcmFtZXRlcnNbMl07XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgc3RyZWFtIFxyXG4gICAgICAgICAgICBpZiAoZ3VhY19jbGllbnQub25maWxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyZWFtID0gc3RyZWFtc1tzdHJlYW1faW5kZXhdID0gbmV3IEd1YWNhbW9sZS5JbnB1dFN0cmVhbShndWFjX2NsaWVudCwgc3RyZWFtX2luZGV4KTtcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50Lm9uZmlsZShzdHJlYW0sIG1pbWV0eXBlLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdW5zdXBwb3J0ZWRcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZ3VhY19jbGllbnQuc2VuZEFjayhzdHJlYW1faW5kZXgsIFwiRmlsZSB0cmFuc2ZlciB1bnN1cHBvcnRlZFwiLCAweDAxMDApO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImZpbGVzeXN0ZW1cIiA6IGZ1bmN0aW9uIGhhbmRsZUZpbGVzeXN0ZW0ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIG9iamVjdEluZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGFyYW1ldGVyc1sxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBvYmplY3QsIGlmIHN1cHBvcnRlZFxyXG4gICAgICAgICAgICBpZiAoZ3VhY19jbGllbnQub25maWxlc3lzdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0c1tvYmplY3RJbmRleF0gPSBuZXcgR3VhY2Ftb2xlLk9iamVjdChndWFjX2NsaWVudCwgb2JqZWN0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZ3VhY19jbGllbnQub25maWxlc3lzdGVtKG9iamVjdCwgbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHVuc3VwcG9ydGVkLCBzaW1wbHkgaWdub3JlIHRoZSBhdmFpbGFiaWxpdHkgb2YgdGhlIGZpbGVzeXN0ZW1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJpZGVudGl0eVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnNldFRyYW5zZm9ybShsYXllciwgMSwgMCwgMCwgMSwgMCwgMCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiaW1nXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHJlYW1faW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGNoYW5uZWxNYXNrID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pKTtcclxuICAgICAgICAgICAgdmFyIG1pbWV0eXBlID0gcGFyYW1ldGVyc1szXTtcclxuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludChwYXJhbWV0ZXJzWzRdKTtcclxuICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUludChwYXJhbWV0ZXJzWzVdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzdHJlYW1cclxuICAgICAgICAgICAgdmFyIHN0cmVhbSA9IHN0cmVhbXNbc3RyZWFtX2luZGV4XSA9IG5ldyBHdWFjYW1vbGUuSW5wdXRTdHJlYW0oZ3VhY19jbGllbnQsIHN0cmVhbV9pbmRleCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IHJlY2VpdmVkIGNvbnRlbnRzIG9uY2UgZGVjb2RlZFxyXG4gICAgICAgICAgICBkaXNwbGF5LnNldENoYW5uZWxNYXNrKGxheWVyLCBjaGFubmVsTWFzayk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuZHJhd1N0cmVhbShsYXllciwgeCwgeSwgc3RyZWFtLCBtaW1ldHlwZSk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwianBlZ1wiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbE1hc2sgPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1sxXSkpO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbM10pO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHBhcmFtZXRlcnNbNF07XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnNldENoYW5uZWxNYXNrKGxheWVyLCBjaGFubmVsTWFzayk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuZHJhdyhsYXllciwgeCwgeSwgXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiICsgZGF0YSk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwibGZpbGxcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoYW5uZWxNYXNrID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pKTtcclxuICAgICAgICAgICAgdmFyIHNyY0xheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1syXSkpO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS5zZXRDaGFubmVsTWFzayhsYXllciwgY2hhbm5lbE1hc2spO1xyXG4gICAgICAgICAgICBkaXNwbGF5LmZpbGxMYXllcihsYXllciwgc3JjTGF5ZXIpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImxpbmVcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1swXSkpO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS5saW5lVG8obGF5ZXIsIHgsIHkpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImxzdHJva2VcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoYW5uZWxNYXNrID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pKTtcclxuICAgICAgICAgICAgdmFyIHNyY0xheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1syXSkpO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS5zZXRDaGFubmVsTWFzayhsYXllciwgY2hhbm5lbE1hc2spO1xyXG4gICAgICAgICAgICBkaXNwbGF5LnN0cm9rZUxheWVyKGxheWVyLCBzcmNMYXllcik7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwibW91c2VcIiA6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1swXSk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNwbGF5IGFuZCBtb3ZlIHNvZnR3YXJlIGN1cnNvciB0byByZWNlaXZlZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICBkaXNwbGF5LnNob3dDdXJzb3IodHJ1ZSk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkubW92ZUN1cnNvcih4LCB5KTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJtb3ZlXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBsYXllcl9pbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50X2luZGV4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1syXSk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQocGFyYW1ldGVyc1szXSk7XHJcbiAgICAgICAgICAgIHZhciB6ID0gcGFyc2VJbnQocGFyYW1ldGVyc1s0XSk7XHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHZhbGlkIGZvciBub24tZGVmYXVsdCBsYXllcnNcclxuICAgICAgICAgICAgaWYgKGxheWVyX2luZGV4ID4gMCAmJiBwYXJlbnRfaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIobGF5ZXJfaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGdldExheWVyKHBhcmVudF9pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5Lm1vdmUobGF5ZXIsIHBhcmVudCwgeCwgeSwgeik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJuYW1lXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgaWYgKGd1YWNfY2xpZW50Lm9ubmFtZSkgZ3VhY19jbGllbnQub25uYW1lKHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwibmVzdFwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJzZXIgPSBnZXRQYXJzZXIocGFyc2VJbnQocGFyYW1ldGVyc1swXSkpO1xyXG4gICAgICAgICAgICBwYXJzZXIucmVjZWl2ZShwYXJhbWV0ZXJzWzFdKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcInBpcGVcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0cmVhbV9pbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgbWltZXR5cGUgPSBwYXJhbWV0ZXJzWzFdO1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHBhcmFtZXRlcnNbMl07XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgc3RyZWFtIFxyXG4gICAgICAgICAgICBpZiAoZ3VhY19jbGllbnQub25waXBlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyZWFtID0gc3RyZWFtc1tzdHJlYW1faW5kZXhdID0gbmV3IEd1YWNhbW9sZS5JbnB1dFN0cmVhbShndWFjX2NsaWVudCwgc3RyZWFtX2luZGV4KTtcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50Lm9ucGlwZShzdHJlYW0sIG1pbWV0eXBlLCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB1bnN1cHBvcnRlZFxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5zZW5kQWNrKHN0cmVhbV9pbmRleCwgXCJOYW1lZCBwaXBlcyB1bnN1cHBvcnRlZFwiLCAweDAxMDApO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcInBuZ1wiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbE1hc2sgPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1sxXSkpO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbM10pO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHBhcmFtZXRlcnNbNF07XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnNldENoYW5uZWxNYXNrKGxheWVyLCBjaGFubmVsTWFzayk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuZHJhdyhsYXllciwgeCwgeSwgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsXCIgKyBkYXRhKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJwb3BcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1swXSkpO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS5wb3AobGF5ZXIpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcInB1c2hcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1swXSkpO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS5wdXNoKGxheWVyKTtcclxuXHJcbiAgICAgICAgfSxcclxuIFxyXG4gICAgICAgIFwicmVjdFwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQocGFyYW1ldGVyc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQocGFyYW1ldGVyc1syXSk7XHJcbiAgICAgICAgICAgIHZhciB3ID0gcGFyc2VJbnQocGFyYW1ldGVyc1szXSk7XHJcbiAgICAgICAgICAgIHZhciBoID0gcGFyc2VJbnQocGFyYW1ldGVyc1s0XSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnJlY3QobGF5ZXIsIHgsIHksIHcsIGgpO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmdW5jdGlvbiByZXF1aXJlZChwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChndWFjX2NsaWVudC5vbnJlcXVpcmVkKSBndWFjX2NsaWVudC5vbnJlcXVpcmVkKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgXCJyZXNldFwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5LnJlc2V0KGxheWVyKTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICBcInNldFwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzBdKSk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGFyYW1ldGVyc1sxXTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1ldGVyc1syXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGwgcHJvcGVydHkgaGFuZGxlciBpZiBkZWZpbmVkXHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gbGF5ZXJQcm9wZXJ0eUhhbmRsZXJzW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlcilcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIobGF5ZXIsIHZhbHVlKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJzaGFkZVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbGF5ZXJfaW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGEgPSBwYXJzZUludChwYXJhbWV0ZXJzWzFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgdmFsaWQgZm9yIHZpc2libGUgbGF5ZXJzIChub3QgYnVmZmVycylcclxuICAgICAgICAgICAgaWYgKGxheWVyX2luZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IGdldExheWVyKGxheWVyX2luZGV4KTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkuc2hhZGUobGF5ZXIsIGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwic2l6ZVwiOiBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGF5ZXJfaW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIobGF5ZXJfaW5kZXgpO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBwYXJzZUludChwYXJhbWV0ZXJzWzFdKTtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS5yZXNpemUobGF5ZXIsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIFwic3RhcnRcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1swXSkpO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8obGF5ZXIsIHgsIHkpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcInN5bmNcIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG5cclxuICAgICAgICAgICAgLy8gRmx1c2ggZGlzcGxheSwgc2VuZCBzeW5jIHdoZW4gZG9uZVxyXG4gICAgICAgICAgICBkaXNwbGF5LmZsdXNoKGZ1bmN0aW9uIGRpc3BsYXlTeW5jQ29tcGxldGUoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3luY2hyb25pemUgYWxsIGF1ZGlvIHBsYXllcnNcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4IGluIGF1ZGlvUGxheWVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdWRpb1BsYXllciA9IGF1ZGlvUGxheWVyc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvUGxheWVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb1BsYXllci5zeW5jKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2VuZCBzeW5jIHJlc3BvbnNlIHRvIHNlcnZlclxyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCAhPT0gY3VycmVudFRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR1bm5lbC5zZW5kTWVzc2FnZShcInN5bmNcIiwgdGltZXN0YW1wKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGltZXN0YW1wID0gdGltZXN0YW1wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiByZWNlaXZlZCBmaXJzdCB1cGRhdGUsIG5vIGxvbmdlciB3YWl0aW5nLlxyXG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSBTVEFURV9XQUlUSU5HKVxyXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUoU1RBVEVfQ09OTkVDVEVEKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGwgc3luYyBoYW5kbGVyIGlmIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKGd1YWNfY2xpZW50Lm9uc3luYylcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50Lm9uc3luYyh0aW1lc3RhbXApO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcInRyYW5zZmVyXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzcmNMID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1swXSkpO1xyXG4gICAgICAgICAgICB2YXIgc3JjWCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgc3JjWSA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMl0pO1xyXG4gICAgICAgICAgICB2YXIgc3JjV2lkdGggPSBwYXJzZUludChwYXJhbWV0ZXJzWzNdKTtcclxuICAgICAgICAgICAgdmFyIHNyY0hlaWdodCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbNF0pO1xyXG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25faW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzVdKTtcclxuICAgICAgICAgICAgdmFyIGRzdEwgPSBnZXRMYXllcihwYXJzZUludChwYXJhbWV0ZXJzWzZdKSk7XHJcbiAgICAgICAgICAgIHZhciBkc3RYID0gcGFyc2VJbnQocGFyYW1ldGVyc1s3XSk7XHJcbiAgICAgICAgICAgIHZhciBkc3RZID0gcGFyc2VJbnQocGFyYW1ldGVyc1s4XSk7XHJcblxyXG4gICAgICAgICAgICAvKiBTUkMgKi9cclxuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uX2luZGV4ID09PSAweDMpXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LnB1dChzcmNMLCBzcmNYLCBzcmNZLCBzcmNXaWR0aCwgc3JjSGVpZ2h0LCBcclxuICAgICAgICAgICAgICAgICAgICBkc3RMLCBkc3RYLCBkc3RZKTtcclxuXHJcbiAgICAgICAgICAgIC8qIEFueXRoaW5nIGVsc2UgdGhhdCBpc24ndCBhIE5PLU9QICovXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZ1bmN0aW9uX2luZGV4ICE9PSAweDUpXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LnRyYW5zZmVyKHNyY0wsIHNyY1gsIHNyY1ksIHNyY1dpZHRoLCBzcmNIZWlnaHQsIFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdEwsIGRzdFgsIGRzdFksIEd1YWNhbW9sZS5DbGllbnQuRGVmYXVsdFRyYW5zZmVyRnVuY3Rpb25bZnVuY3Rpb25faW5kZXhdKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJ0cmFuc2Zvcm1cIjogZnVuY3Rpb24ocGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1swXSkpO1xyXG4gICAgICAgICAgICB2YXIgYSA9IHBhcnNlRmxvYXQocGFyYW1ldGVyc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciBiID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzWzJdKTtcclxuICAgICAgICAgICAgdmFyIGMgPSBwYXJzZUZsb2F0KHBhcmFtZXRlcnNbM10pO1xyXG4gICAgICAgICAgICB2YXIgZCA9IHBhcnNlRmxvYXQocGFyYW1ldGVyc1s0XSk7XHJcbiAgICAgICAgICAgIHZhciBlID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzWzVdKTtcclxuICAgICAgICAgICAgdmFyIGYgPSBwYXJzZUZsb2F0KHBhcmFtZXRlcnNbNl0pO1xyXG5cclxuICAgICAgICAgICAgZGlzcGxheS50cmFuc2Zvcm0obGF5ZXIsIGEsIGIsIGMsIGQsIGUsIGYpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcInVuZGVmaW5lXCIgOiBmdW5jdGlvbiBoYW5kbGVVbmRlZmluZShwYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgb2JqZWN0XHJcbiAgICAgICAgICAgIHZhciBvYmplY3RJbmRleCA9IHBhcnNlSW50KHBhcmFtZXRlcnNbMF0pO1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0c1tvYmplY3RJbmRleF07XHJcblxyXG4gICAgICAgICAgICAvLyBTaWduYWwgZW5kIG9mIG9iamVjdCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0Lm9udW5kZWZpbmUpXHJcbiAgICAgICAgICAgICAgICBvYmplY3Qub251bmRlZmluZSgpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcInZpZGVvXCI6IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHJlYW1faW5kZXggPSBwYXJzZUludChwYXJhbWV0ZXJzWzBdKTtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIocGFyc2VJbnQocGFyYW1ldGVyc1sxXSkpO1xyXG4gICAgICAgICAgICB2YXIgbWltZXR5cGUgPSBwYXJhbWV0ZXJzWzJdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHN0cmVhbVxyXG4gICAgICAgICAgICB2YXIgc3RyZWFtID0gc3RyZWFtc1tzdHJlYW1faW5kZXhdID1cclxuICAgICAgICAgICAgICAgICAgICBuZXcgR3VhY2Ftb2xlLklucHV0U3RyZWFtKGd1YWNfY2xpZW50LCBzdHJlYW1faW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHBsYXllciBpbnN0YW5jZSB2aWEgY2FsbGJhY2tcclxuICAgICAgICAgICAgdmFyIHZpZGVvUGxheWVyID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGd1YWNfY2xpZW50Lm9udmlkZW8pXHJcbiAgICAgICAgICAgICAgICB2aWRlb1BsYXllciA9IGd1YWNfY2xpZW50Lm9udmlkZW8oc3RyZWFtLCBsYXllciwgbWltZXR5cGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdW5zdWNjZXNzZnVsLCB0cnkgdG8gdXNlIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICBpZiAoIXZpZGVvUGxheWVyKVxyXG4gICAgICAgICAgICAgICAgdmlkZW9QbGF5ZXIgPSBHdWFjYW1vbGUuVmlkZW9QbGF5ZXIuZ2V0SW5zdGFuY2Uoc3RyZWFtLCBsYXllciwgbWltZXR5cGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBzdWNjZXNzZnVsbHkgcmV0cmlldmVkIGFuIHZpZGVvIHBsYXllciwgc2VuZCBzdWNjZXNzIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIGlmICh2aWRlb1BsYXllcikge1xyXG4gICAgICAgICAgICAgICAgdmlkZW9QbGF5ZXJzW3N0cmVhbV9pbmRleF0gPSB2aWRlb1BsYXllcjtcclxuICAgICAgICAgICAgICAgIGd1YWNfY2xpZW50LnNlbmRBY2soc3RyZWFtX2luZGV4LCBcIk9LXCIsIDB4MDAwMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgbWltZXR5cGUgbXVzdCBiZSB1bnN1cHBvcnRlZFxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBndWFjX2NsaWVudC5zZW5kQWNrKHN0cmVhbV9pbmRleCwgXCJCQUQgVFlQRVwiLCAweDAzMEYpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB0dW5uZWwub25pbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKG9wY29kZSwgcGFyYW1ldGVycykge1xyXG5cclxuICAgICAgICB2YXIgaGFuZGxlciA9IGluc3RydWN0aW9uSGFuZGxlcnNbb3Bjb2RlXTtcclxuICAgICAgICBpZiAoaGFuZGxlcilcclxuICAgICAgICAgICAgaGFuZGxlcihwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgYSBkaXNjb25uZWN0IGluc3RydWN0aW9uIHRvIHRoZSBzZXJ2ZXIgYW5kIGNsb3NlcyB0aGUgdHVubmVsLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLy8gT25seSBhdHRlbXB0IGRpc2Nvbm5lY3Rpb24gbm90IGRpc2Nvbm5lY3RlZC5cclxuICAgICAgICBpZiAoY3VycmVudFN0YXRlICE9IFNUQVRFX0RJU0NPTk5FQ1RFRFxyXG4gICAgICAgICAgICAgICAgJiYgY3VycmVudFN0YXRlICE9IFNUQVRFX0RJU0NPTk5FQ1RJTkcpIHtcclxuXHJcbiAgICAgICAgICAgIHNldFN0YXRlKFNUQVRFX0RJU0NPTk5FQ1RJTkcpO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RvcCBwaW5nXHJcbiAgICAgICAgICAgIGlmIChwaW5nSW50ZXJ2YWwpXHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChwaW5nSW50ZXJ2YWwpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2VuZCBkaXNjb25uZWN0IG1lc3NhZ2UgYW5kIGRpc2Nvbm5lY3RcclxuICAgICAgICAgICAgdHVubmVsLnNlbmRNZXNzYWdlKFwiZGlzY29ubmVjdFwiKTtcclxuICAgICAgICAgICAgdHVubmVsLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgc2V0U3RhdGUoU1RBVEVfRElTQ09OTkVDVEVEKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgdGhlIHVuZGVybHlpbmcgdHVubmVsIG9mIHRoaXMgR3VhY2Ftb2xlLkNsaWVudCwgcGFzc2luZyB0aGVcclxuICAgICAqIGdpdmVuIGFyYml0cmFyeSBkYXRhIHRvIHRoZSB0dW5uZWwgZHVyaW5nIHRoZSBjb25uZWN0aW9uIHByb2Nlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRhdGEgQXJiaXRyYXJ5IGNvbm5lY3Rpb24gZGF0YSB0byBiZSBzZW50IHRvIHRoZSB1bmRlcmx5aW5nXHJcbiAgICAgKiAgICAgICAgICAgICB0dW5uZWwgZHVyaW5nIHRoZSBjb25uZWN0aW9uIHByb2Nlc3MuXHJcbiAgICAgKiBAdGhyb3dzIHtHdWFjYW1vbGUuU3RhdHVzfSBJZiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIGNvbm5lY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29ubmVjdCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHJcbiAgICAgICAgc2V0U3RhdGUoU1RBVEVfQ09OTkVDVElORyk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHR1bm5lbC5jb25uZWN0KGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKFNUQVRFX0lETEUpO1xyXG4gICAgICAgICAgICB0aHJvdyBzdGF0dXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQaW5nIGV2ZXJ5IDUgc2Vjb25kcyAoZW5zdXJlIGNvbm5lY3Rpb24gYWxpdmUpXHJcbiAgICAgICAgcGluZ0ludGVydmFsID0gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0dW5uZWwuc2VuZE1lc3NhZ2UoXCJub3BcIik7XHJcbiAgICAgICAgfSwgNTAwMCk7XHJcblxyXG4gICAgICAgIHNldFN0YXRlKFNUQVRFX1dBSVRJTkcpO1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogTWFwIG9mIGFsbCBHdWFjYW1vbGUgYmluYXJ5IHJhc3RlciBvcGVyYXRpb25zIHRvIHRyYW5zZmVyIGZ1bmN0aW9ucy5cclxuICogQHByaXZhdGVcclxuICovXHJcbkd1YWNhbW9sZS5DbGllbnQuRGVmYXVsdFRyYW5zZmVyRnVuY3Rpb24gPSB7XHJcblxyXG4gICAgLyogQkxBQ0sgKi9cclxuICAgIDB4MDogZnVuY3Rpb24gKHNyYywgZHN0KSB7XHJcbiAgICAgICAgZHN0LnJlZCA9IGRzdC5ncmVlbiA9IGRzdC5ibHVlID0gMHgwMDtcclxuICAgIH0sXHJcblxyXG4gICAgLyogV0hJVEUgKi9cclxuICAgIDB4RjogZnVuY3Rpb24gKHNyYywgZHN0KSB7XHJcbiAgICAgICAgZHN0LnJlZCA9IGRzdC5ncmVlbiA9IGRzdC5ibHVlID0gMHhGRjtcclxuICAgIH0sXHJcblxyXG4gICAgLyogU1JDICovXHJcbiAgICAweDM6IGZ1bmN0aW9uIChzcmMsIGRzdCkge1xyXG4gICAgICAgIGRzdC5yZWQgICA9IHNyYy5yZWQ7XHJcbiAgICAgICAgZHN0LmdyZWVuID0gc3JjLmdyZWVuO1xyXG4gICAgICAgIGRzdC5ibHVlICA9IHNyYy5ibHVlO1xyXG4gICAgICAgIGRzdC5hbHBoYSA9IHNyYy5hbHBoYTtcclxuICAgIH0sXHJcblxyXG4gICAgLyogREVTVCAobm8tb3ApICovXHJcbiAgICAweDU6IGZ1bmN0aW9uIChzcmMsIGRzdCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmdcclxuICAgIH0sXHJcblxyXG4gICAgLyogSW52ZXJ0IFNSQyAqL1xyXG4gICAgMHhDOiBmdW5jdGlvbiAoc3JjLCBkc3QpIHtcclxuICAgICAgICBkc3QucmVkICAgPSAweEZGICYgfnNyYy5yZWQ7XHJcbiAgICAgICAgZHN0LmdyZWVuID0gMHhGRiAmIH5zcmMuZ3JlZW47XHJcbiAgICAgICAgZHN0LmJsdWUgID0gMHhGRiAmIH5zcmMuYmx1ZTtcclxuICAgICAgICBkc3QuYWxwaGEgPSAgc3JjLmFscGhhO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgLyogSW52ZXJ0IERFU1QgKi9cclxuICAgIDB4QTogZnVuY3Rpb24gKHNyYywgZHN0KSB7XHJcbiAgICAgICAgZHN0LnJlZCAgID0gMHhGRiAmIH5kc3QucmVkO1xyXG4gICAgICAgIGRzdC5ncmVlbiA9IDB4RkYgJiB+ZHN0LmdyZWVuO1xyXG4gICAgICAgIGRzdC5ibHVlICA9IDB4RkYgJiB+ZHN0LmJsdWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qIEFORCAqL1xyXG4gICAgMHgxOiBmdW5jdGlvbiAoc3JjLCBkc3QpIHtcclxuICAgICAgICBkc3QucmVkICAgPSAgKCBzcmMucmVkICAgJiAgZHN0LnJlZCk7XHJcbiAgICAgICAgZHN0LmdyZWVuID0gICggc3JjLmdyZWVuICYgIGRzdC5ncmVlbik7XHJcbiAgICAgICAgZHN0LmJsdWUgID0gICggc3JjLmJsdWUgICYgIGRzdC5ibHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyogTkFORCAqL1xyXG4gICAgMHhFOiBmdW5jdGlvbiAoc3JjLCBkc3QpIHtcclxuICAgICAgICBkc3QucmVkICAgPSAweEZGICYgfiggc3JjLnJlZCAgICYgIGRzdC5yZWQpO1xyXG4gICAgICAgIGRzdC5ncmVlbiA9IDB4RkYgJiB+KCBzcmMuZ3JlZW4gJiAgZHN0LmdyZWVuKTtcclxuICAgICAgICBkc3QuYmx1ZSAgPSAweEZGICYgfiggc3JjLmJsdWUgICYgIGRzdC5ibHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyogT1IgKi9cclxuICAgIDB4NzogZnVuY3Rpb24gKHNyYywgZHN0KSB7XHJcbiAgICAgICAgZHN0LnJlZCAgID0gICggc3JjLnJlZCAgIHwgIGRzdC5yZWQpO1xyXG4gICAgICAgIGRzdC5ncmVlbiA9ICAoIHNyYy5ncmVlbiB8ICBkc3QuZ3JlZW4pO1xyXG4gICAgICAgIGRzdC5ibHVlICA9ICAoIHNyYy5ibHVlICB8ICBkc3QuYmx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qIE5PUiAqL1xyXG4gICAgMHg4OiBmdW5jdGlvbiAoc3JjLCBkc3QpIHtcclxuICAgICAgICBkc3QucmVkICAgPSAweEZGICYgfiggc3JjLnJlZCAgIHwgIGRzdC5yZWQpO1xyXG4gICAgICAgIGRzdC5ncmVlbiA9IDB4RkYgJiB+KCBzcmMuZ3JlZW4gfCAgZHN0LmdyZWVuKTtcclxuICAgICAgICBkc3QuYmx1ZSAgPSAweEZGICYgfiggc3JjLmJsdWUgIHwgIGRzdC5ibHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyogWE9SICovXHJcbiAgICAweDY6IGZ1bmN0aW9uIChzcmMsIGRzdCkge1xyXG4gICAgICAgIGRzdC5yZWQgICA9ICAoIHNyYy5yZWQgICBeICBkc3QucmVkKTtcclxuICAgICAgICBkc3QuZ3JlZW4gPSAgKCBzcmMuZ3JlZW4gXiAgZHN0LmdyZWVuKTtcclxuICAgICAgICBkc3QuYmx1ZSAgPSAgKCBzcmMuYmx1ZSAgXiAgZHN0LmJsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiBYTk9SICovXHJcbiAgICAweDk6IGZ1bmN0aW9uIChzcmMsIGRzdCkge1xyXG4gICAgICAgIGRzdC5yZWQgICA9IDB4RkYgJiB+KCBzcmMucmVkICAgXiAgZHN0LnJlZCk7XHJcbiAgICAgICAgZHN0LmdyZWVuID0gMHhGRiAmIH4oIHNyYy5ncmVlbiBeICBkc3QuZ3JlZW4pO1xyXG4gICAgICAgIGRzdC5ibHVlICA9IDB4RkYgJiB+KCBzcmMuYmx1ZSAgXiAgZHN0LmJsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiBBTkQgaW52ZXJ0ZWQgc291cmNlICovXHJcbiAgICAweDQ6IGZ1bmN0aW9uIChzcmMsIGRzdCkge1xyXG4gICAgICAgIGRzdC5yZWQgICA9ICAweEZGICYgKH5zcmMucmVkICAgJiAgZHN0LnJlZCk7XHJcbiAgICAgICAgZHN0LmdyZWVuID0gIDB4RkYgJiAofnNyYy5ncmVlbiAmICBkc3QuZ3JlZW4pO1xyXG4gICAgICAgIGRzdC5ibHVlICA9ICAweEZGICYgKH5zcmMuYmx1ZSAgJiAgZHN0LmJsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiBPUiBpbnZlcnRlZCBzb3VyY2UgKi9cclxuICAgIDB4RDogZnVuY3Rpb24gKHNyYywgZHN0KSB7XHJcbiAgICAgICAgZHN0LnJlZCAgID0gIDB4RkYgJiAofnNyYy5yZWQgICB8ICBkc3QucmVkKTtcclxuICAgICAgICBkc3QuZ3JlZW4gPSAgMHhGRiAmICh+c3JjLmdyZWVuIHwgIGRzdC5ncmVlbik7XHJcbiAgICAgICAgZHN0LmJsdWUgID0gIDB4RkYgJiAofnNyYy5ibHVlICB8ICBkc3QuYmx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qIEFORCBpbnZlcnRlZCBkZXN0aW5hdGlvbiAqL1xyXG4gICAgMHgyOiBmdW5jdGlvbiAoc3JjLCBkc3QpIHtcclxuICAgICAgICBkc3QucmVkICAgPSAgMHhGRiAmICggc3JjLnJlZCAgICYgfmRzdC5yZWQpO1xyXG4gICAgICAgIGRzdC5ncmVlbiA9ICAweEZGICYgKCBzcmMuZ3JlZW4gJiB+ZHN0LmdyZWVuKTtcclxuICAgICAgICBkc3QuYmx1ZSAgPSAgMHhGRiAmICggc3JjLmJsdWUgICYgfmRzdC5ibHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyogT1IgaW52ZXJ0ZWQgZGVzdGluYXRpb24gKi9cclxuICAgIDB4QjogZnVuY3Rpb24gKHNyYywgZHN0KSB7XHJcbiAgICAgICAgZHN0LnJlZCAgID0gIDB4RkYgJiAoIHNyYy5yZWQgICB8IH5kc3QucmVkKTtcclxuICAgICAgICBkc3QuZ3JlZW4gPSAgMHhGRiAmICggc3JjLmdyZWVuIHwgfmRzdC5ncmVlbik7XHJcbiAgICAgICAgZHN0LmJsdWUgID0gIDB4RkYgJiAoIHNyYy5ibHVlICB8IH5kc3QuYmx1ZSk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQSByZWFkZXIgd2hpY2ggYXV0b21hdGljYWxseSBoYW5kbGVzIHRoZSBnaXZlbiBpbnB1dCBzdHJlYW0sIHJldHVybmluZ1xyXG4gKiByZWNlaXZlZCBibG9icyBhcyBhIHNpbmdsZSBkYXRhIFVSSSBidWlsdCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHN0cmVhbS5cclxuICogTm90ZSB0aGF0IHRoaXMgb2JqZWN0IHdpbGwgb3ZlcndyaXRlIGFueSBpbnN0YWxsZWQgZXZlbnQgaGFuZGxlcnMgb24gdGhlXHJcbiAqIGdpdmVuIEd1YWNhbW9sZS5JbnB1dFN0cmVhbS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gc3RyZWFtXHJcbiAqICAgICBUaGUgc3RyZWFtIHRoYXQgZGF0YSB3aWxsIGJlIHJlYWQgZnJvbS5cclxuICovXHJcbkd1YWNhbW9sZS5EYXRhVVJJUmVhZGVyID0gZnVuY3Rpb24oc3RyZWFtLCBtaW1ldHlwZSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLkRhdGFVUklSZWFkZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY19yZWFkZXIgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBkYXRhIFVSSS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdmFyIHVyaSA9ICdkYXRhOicgKyBtaW1ldHlwZSArICc7YmFzZTY0LCc7XHJcblxyXG4gICAgLy8gUmVjZWl2ZSBibG9icyBhcyBhcnJheSBidWZmZXJzXHJcbiAgICBzdHJlYW0ub25ibG9iID0gZnVuY3Rpb24gZGF0YVVSSVJlYWRlckJsb2IoZGF0YSkge1xyXG5cclxuICAgICAgICAvLyBDdXJyZW50bHkgYXNzdW1pbmcgZGF0YSB3aWxsIEFMV0FZUyBiZSBzYWZlIHRvIHNpbXBseSBhcHBlbmQuIFRoaXNcclxuICAgICAgICAvLyB3aWxsIG5vdCBiZSB0cnVlIGlmIHRoZSByZWNlaXZlZCBiYXNlNjQgZGF0YSBlbmNvZGVzIGEgbnVtYmVyIG9mXHJcbiAgICAgICAgLy8gYnl0ZXMgdGhhdCBpc24ndCBhIG11bHRpcGxlIG9mIHRocmVlIChhcyBiYXNlNjQgZXhwYW5kcyBpbiBhIHJhdGlvXHJcbiAgICAgICAgLy8gb2YgZXhhY3RseSAzOjQpLlxyXG4gICAgICAgIHVyaSArPSBkYXRhO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gU2ltcGx5IGNhbGwgb25lbmQgd2hlbiBlbmQgcmVjZWl2ZWRcclxuICAgIHN0cmVhbS5vbmVuZCA9IGZ1bmN0aW9uIGRhdGFVUklSZWFkZXJFbmQoKSB7XHJcbiAgICAgICAgaWYgKGd1YWNfcmVhZGVyLm9uZW5kKVxyXG4gICAgICAgICAgICBndWFjX3JlYWRlci5vbmVuZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgVVJJIG9mIGFsbCBkYXRhIHJlY2VpdmVkIHRocm91Z2ggdGhlIHVuZGVybHlpbmcgc3RyZWFtXHJcbiAgICAgKiB0aHVzIGZhci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICogICAgIFRoZSBkYXRhIFVSSSBvZiBhbGwgZGF0YSByZWNlaXZlZCB0aHJvdWdoIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSB0aHVzXHJcbiAgICAgKiAgICAgZmFyLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldFVSSSA9IGZ1bmN0aW9uIGdldFVSSSgpIHtcclxuICAgICAgICByZXR1cm4gdXJpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIG9uY2UgdGhpcyBzdHJlYW0gaXMgZmluaXNoZWQgYW5kIG5vIGZ1cnRoZXIgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHRoaXMub25lbmQgPSBudWxsO1xyXG5cclxufTtcbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogVGhlIEd1YWNhbW9sZSBkaXNwbGF5LiBUaGUgZGlzcGxheSBkb2VzIG5vdCBkZWFsIHdpdGggdGhlIEd1YWNhbW9sZVxyXG4gKiBwcm90b2NvbCwgYW5kIGluc3RlYWQgaW1wbGVtZW50cyBhIHNldCBvZiBncmFwaGljYWwgb3BlcmF0aW9ucyB3aGljaFxyXG4gKiBlbWJvZHkgdGhlIHNldCBvZiBvcGVyYXRpb25zIHByZXNlbnQgaW4gdGhlIHByb3RvY29sLiBUaGUgb3JkZXIgb3BlcmF0aW9uc1xyXG4gKiBhcmUgZXhlY3V0ZWQgaXMgZ3VhcmFudGVlZCB0byBiZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVpciBjb3JyZXNwb25kaW5nXHJcbiAqIGZ1bmN0aW9ucyBhcmUgY2FsbGVkLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5HdWFjYW1vbGUuRGlzcGxheSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLkRpc3BsYXkuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY19kaXNwbGF5ID0gdGhpcztcclxuXHJcbiAgICB2YXIgZGlzcGxheVdpZHRoID0gMDtcclxuICAgIHZhciBkaXNwbGF5SGVpZ2h0ID0gMDtcclxuICAgIHZhciBkaXNwbGF5U2NhbGUgPSAxO1xyXG5cclxuICAgIC8vIENyZWF0ZSBkaXNwbGF5XHJcbiAgICB2YXIgZGlzcGxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICBkaXNwbGF5LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgZGlzcGxheS5zdHlsZS53aWR0aCA9IGRpc3BsYXlXaWR0aCArIFwicHhcIjtcclxuICAgIGRpc3BsYXkuc3R5bGUuaGVpZ2h0ID0gZGlzcGxheUhlaWdodCArIFwicHhcIjtcclxuXHJcbiAgICAvLyBFbnN1cmUgdHJhbnNmb3JtYXRpb25zIG9uIGRpc3BsYXkgb3JpZ2luYXRlIGF0IDAsMFxyXG4gICAgZGlzcGxheS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPVxyXG4gICAgZGlzcGxheS5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPVxyXG4gICAgZGlzcGxheS5zdHlsZS5Nb3pUcmFuc2Zvcm1PcmlnaW4gPVxyXG4gICAgZGlzcGxheS5zdHlsZS5PVHJhbnNmb3JtT3JpZ2luID1cclxuICAgIGRpc3BsYXkuc3R5bGUubXNUcmFuc2Zvcm1PcmlnaW4gPVxyXG4gICAgICAgIFwiMCAwXCI7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGRlZmF1bHQgbGF5ZXJcclxuICAgIHZhciBkZWZhdWx0X2xheWVyID0gbmV3IEd1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllcihkaXNwbGF5V2lkdGgsIGRpc3BsYXlIZWlnaHQpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBjdXJzb3IgbGF5ZXJcclxuICAgIHZhciBjdXJzb3IgPSBuZXcgR3VhY2Ftb2xlLkRpc3BsYXkuVmlzaWJsZUxheWVyKDAsIDApO1xyXG4gICAgY3Vyc29yLnNldENoYW5uZWxNYXNrKEd1YWNhbW9sZS5MYXllci5TUkMpO1xyXG5cclxuICAgIC8vIEFkZCBkZWZhdWx0IGxheWVyIGFuZCBjdXJzb3IgdG8gZGlzcGxheVxyXG4gICAgZGlzcGxheS5hcHBlbmRDaGlsZChkZWZhdWx0X2xheWVyLmdldEVsZW1lbnQoKSk7XHJcbiAgICBkaXNwbGF5LmFwcGVuZENoaWxkKGN1cnNvci5nZXRFbGVtZW50KCkpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBib3VuZGluZyBkaXYgXHJcbiAgICB2YXIgYm91bmRzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgIGJvdW5kcy5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcclxuICAgIGJvdW5kcy5zdHlsZS53aWR0aCA9IChkaXNwbGF5V2lkdGgqZGlzcGxheVNjYWxlKSArIFwicHhcIjtcclxuICAgIGJvdW5kcy5zdHlsZS5oZWlnaHQgPSAoZGlzcGxheUhlaWdodCpkaXNwbGF5U2NhbGUpICsgXCJweFwiO1xyXG5cclxuICAgIC8vIEFkZCBkaXNwbGF5IHRvIGJvdW5kc1xyXG4gICAgYm91bmRzLmFwcGVuZENoaWxkKGRpc3BsYXkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgaG90c3BvdCBvZiB0aGUgbW91c2UgY3Vyc29yLiBUaGUgaG90c3BvdCBpc1xyXG4gICAgICogdGhlIHJlbGF0aXZlIGxvY2F0aW9uIHdpdGhpbiB0aGUgaW1hZ2Ugb2YgdGhlIG1vdXNlIGN1cnNvciBhdCB3aGljaFxyXG4gICAgICogZWFjaCBjbGljayBvY2N1cnMuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3Vyc29ySG90c3BvdFggPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgaG90c3BvdCBvZiB0aGUgbW91c2UgY3Vyc29yLiBUaGUgaG90c3BvdCBpc1xyXG4gICAgICogdGhlIHJlbGF0aXZlIGxvY2F0aW9uIHdpdGhpbiB0aGUgaW1hZ2Ugb2YgdGhlIG1vdXNlIGN1cnNvciBhdCB3aGljaFxyXG4gICAgICogZWFjaCBjbGljayBvY2N1cnMuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3Vyc29ySG90c3BvdFkgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgWCBjb29yZGluYXRlIG9mIHRoZSBsb2NhbCBtb3VzZSBjdXJzb3IuIFRoaXMgaXMgbm90XHJcbiAgICAgKiBuZWNlc3NhcmlseSB0aGUgbG9jYXRpb24gb2YgdGhlIGFjdHVhbCBtb3VzZSAtIGl0IHJlZmVycyBvbmx5IHRvXHJcbiAgICAgKiB0aGUgbG9jYXRpb24gb2YgdGhlIGN1cnNvciBpbWFnZSB3aXRoaW4gdGhlIEd1YWNhbW9sZSBkaXNwbGF5LCBhc1xyXG4gICAgICogbGFzdCBzZXQgYnkgbW92ZUN1cnNvcigpLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnNvclggPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgWCBjb29yZGluYXRlIG9mIHRoZSBsb2NhbCBtb3VzZSBjdXJzb3IuIFRoaXMgaXMgbm90XHJcbiAgICAgKiBuZWNlc3NhcmlseSB0aGUgbG9jYXRpb24gb2YgdGhlIGFjdHVhbCBtb3VzZSAtIGl0IHJlZmVycyBvbmx5IHRvXHJcbiAgICAgKiB0aGUgbG9jYXRpb24gb2YgdGhlIGN1cnNvciBpbWFnZSB3aXRoaW4gdGhlIEd1YWNhbW9sZSBkaXNwbGF5LCBhc1xyXG4gICAgICogbGFzdCBzZXQgYnkgbW92ZUN1cnNvcigpLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnNvclkgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiB0aGUgZGVmYXVsdCBsYXllciAoYW5kIHRodXMgdGhlIGVudGlyZSBHdWFjYW1vbGUgZGlzcGxheSlcclxuICAgICAqIGlzIHJlc2l6ZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSBuZXcgd2lkdGggb2YgdGhlIEd1YWNhbW9sZSBkaXNwbGF5LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgR3VhY2Ftb2xlIGRpc3BsYXkuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25yZXNpemUgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIGxvY2FsIGN1cnNvciBpbWFnZSBpcyBjaGFuZ2VkLiBUaGlzIGNhbiBiZSB1c2VkIHRvXHJcbiAgICAgKiBpbXBsZW1lbnQgc3BlY2lhbCBoYW5kbGluZyBvZiB0aGUgY2xpZW50LXNpZGUgY3Vyc29yLCBvciB0byBvdmVycmlkZVxyXG4gICAgICogdGhlIGRlZmF1bHQgdXNlIG9mIGEgc29mdHdhcmUgY3Vyc29yIGxheWVyLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBUaGUgY3Vyc29yIGltYWdlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFgtY29vcmRpbmF0ZSBvZiB0aGUgY3Vyc29yIGhvdHNwb3QuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWS1jb29yZGluYXRlIG9mIHRoZSBjdXJzb3IgaG90c3BvdC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmN1cnNvciA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcXVldWUgb2YgYWxsIHBlbmRpbmcgVGFza3MuIFRhc2tzIHdpbGwgYmUgcnVuIGluIG9yZGVyLCB3aXRoIG5ld1xyXG4gICAgICogdGFza3MgYWRkZWQgYXQgdGhlIGVuZCBvZiB0aGUgcXVldWUgYW5kIG9sZCB0YXNrcyByZW1vdmVkIGZyb20gdGhlXHJcbiAgICAgKiBmcm9udCBvZiB0aGUgcXVldWUgKEZJRk8pLiBUaGVzZSB0YXNrcyB3aWxsIGV2ZW50dWFsbHkgYmUgZ3JvdXBlZFxyXG4gICAgICogaW50byBhIEZyYW1lLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtUYXNrW119XHJcbiAgICAgKi9cclxuICAgIHZhciB0YXNrcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHF1ZXVlIG9mIGFsbCBmcmFtZXMuIEVhY2ggZnJhbWUgaXMgYSBwYWlyaW5nIG9mIGFuIGFycmF5IG9mIHRhc2tzXHJcbiAgICAgKiBhbmQgYSBjYWxsYmFjayB3aGljaCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSBmcmFtZSBpcyByZW5kZXJlZC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7RnJhbWVbXX1cclxuICAgICAqL1xyXG4gICAgdmFyIGZyYW1lcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmx1c2hlcyBhbGwgcGVuZGluZyBmcmFtZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfX2ZsdXNoX2ZyYW1lcygpIHtcclxuXHJcbiAgICAgICAgdmFyIHJlbmRlcmVkX2ZyYW1lcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIERyYXcgYWxsIHBlbmRpbmcgZnJhbWVzLCBpZiByZWFkeVxyXG4gICAgICAgIHdoaWxlIChyZW5kZXJlZF9mcmFtZXMgPCBmcmFtZXMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBmcmFtZXNbcmVuZGVyZWRfZnJhbWVzXTtcclxuICAgICAgICAgICAgaWYgKCFmcmFtZS5pc1JlYWR5KCkpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGZyYW1lLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIHJlbmRlcmVkX2ZyYW1lcysrO1xyXG5cclxuICAgICAgICB9IFxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgcmVuZGVyZWQgZnJhbWVzIGZyb20gYXJyYXlcclxuICAgICAgICBmcmFtZXMuc3BsaWNlKDAsIHJlbmRlcmVkX2ZyYW1lcyk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gb3JkZXJlZCBsaXN0IG9mIHRhc2tzIHdoaWNoIG11c3QgYmUgZXhlY3V0ZWQgYXRvbWljYWxseS4gT25jZVxyXG4gICAgICogZXhlY3V0ZWQsIGFuIGFzc29jaWF0ZWQgKGFuZCBvcHRpb25hbCkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGZyYW1lIGlzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZC5cclxuICAgICAqIEBwYXJhbSB7VGFza1tdfSB0YXNrcyBUaGUgc2V0IG9mIHRhc2tzIHdoaWNoIG11c3QgYmUgZXhlY3V0ZWQgdG8gcmVuZGVyXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRnJhbWUoY2FsbGJhY2ssIHRhc2tzKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIGZyYW1lIGlzIHJlYWR5IHRvIGJlIHJlbmRlcmVkLiBUaGlzIGZ1bmN0aW9uXHJcbiAgICAgICAgICogcmV0dXJucyB0cnVlIGlmIGFuZCBvbmx5IGlmIEFMTCB1bmRlcmx5aW5nIHRhc2tzIGFyZSB1bmJsb2NrZWQuXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgYWxsIHVuZGVybHlpbmcgdGFza3MgYXJlIHVuYmxvY2tlZCxcclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaXNSZWFkeSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBibG9ja2VkIHRhc2tzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHRhc2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFza3NbaV0uYmxvY2tlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vIGJsb2NrZWQgdGFza3MsIHRoZSBmcmFtZSBpcyByZWFkeVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVuZGVycyB0aGlzIGZyYW1lLCBjYWxsaW5nIHRoZSBhc3NvY2lhdGVkIGNhbGxiYWNrLCBpZiBhbnksIGFmdGVyXHJcbiAgICAgICAgICogdGhlIGZyYW1lIGlzIGNvbXBsZXRlLiBUaGlzIGZ1bmN0aW9uIE1VU1Qgb25seSBiZSBjYWxsZWQgd2hlbiBub1xyXG4gICAgICAgICAqIGJsb2NrZWQgdGFza3MgZXhpc3QuIENhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aXRoIGJsb2NrZWQgdGFza3NcclxuICAgICAgICAgKiB3aWxsIHJlc3VsdCBpbiB1bmRlZmluZWQgYmVoYXZpb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gRHJhdyBhbGwgcGVuZGluZyB0YXNrcy5cclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgdGFza3MubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB0YXNrc1tpXS5leGVjdXRlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxsIGNhbGxiYWNrXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbnRhaW5lciBmb3IgYW4gdGFzayBoYW5kbGVyLiBFYWNoIG9wZXJhdGlvbiB3aGljaCBtdXN0IGJlIG9yZGVyZWRcclxuICAgICAqIGlzIGFzc29jaWF0ZWQgd2l0aCBhIFRhc2sgdGhhdCBnb2VzIGludG8gYSB0YXNrIHF1ZXVlLiBUYXNrcyBpbiB0aGlzXHJcbiAgICAgKiBxdWV1ZSBhcmUgZXhlY3V0ZWQgaW4gb3JkZXIgb25jZSB0aGVpciBoYW5kbGVycyBhcmUgc2V0LCB3aGlsZSBUYXNrcyBcclxuICAgICAqIHdpdGhvdXQgaGFuZGxlcnMgYmxvY2sgdGhlbXNlbHZlcyBhbmQgYW55IGZvbGxvd2luZyBUYXNrcyBmcm9tIHJ1bm5pbmcuXHJcbiAgICAgKlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGFza0hhbmRsZXIgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIHRhc2sgXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5zLCBpZiBhbnkuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJsb2NrZWQgV2hldGhlciB0aGlzIHRhc2sgc2hvdWxkIHN0YXJ0IGJsb2NrZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFRhc2sodGFza0hhbmRsZXIsIGJsb2NrZWQpIHtcclxuICAgICAgIFxyXG4gICAgICAgIHZhciB0YXNrID0gdGhpcztcclxuICAgICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBUYXNrIGlzIGJsb2NrZWQuXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ibG9ja2VkID0gYmxvY2tlZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5ibG9ja3MgdGhpcyBUYXNrLCBhbGxvd2luZyBpdCB0byBydW4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51bmJsb2NrID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXNrLmJsb2NrZWQpIHtcclxuICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgX19mbHVzaF9mcmFtZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxzIHRoZSBoYW5kbGVyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRhc2sgSU1NRURJQVRFTFkuIFRoaXNcclxuICAgICAgICAgKiBmdW5jdGlvbiBkb2VzIG5vdCB0cmFjayB3aGV0aGVyIHRoaXMgdGFzayBpcyBtYXJrZWQgYXMgYmxvY2tlZC5cclxuICAgICAgICAgKiBFbmZvcmNpbmcgdGhlIGJsb2NrZWQgc3RhdHVzIG9mIHRhc2tzIGlzIHVwIHRvIHRoZSBjYWxsZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXNrSGFuZGxlcikgdGFza0hhbmRsZXIoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBhIHRhc2sgZm9yIGZ1dHVyZSBleGVjdXRpb24uIFRoZSBnaXZlbiBoYW5kbGVyIHdpbGwgZXhlY3V0ZVxyXG4gICAgICogaW1tZWRpYXRlbHkgYWZ0ZXIgYWxsIHByZXZpb3VzIHRhc2tzIHVwb24gZnJhbWUgZmx1c2gsIHVubGVzcyB0aGlzXHJcbiAgICAgKiB0YXNrIGlzIGJsb2NrZWQuIElmIGFueSB0YXNrcyBpcyBibG9ja2VkLCB0aGUgZW50aXJlIGZyYW1lIHdpbGwgbm90XHJcbiAgICAgKiByZW5kZXIgKGFuZCBubyB0YXNrcyB3aXRoaW4gd2lsbCBleGVjdXRlKSB1bnRpbCBhbGwgdGFza3MgYXJlIHVuYmxvY2tlZC5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBwb3NzaWJsZSwgaWYgYW55LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBibG9ja2VkIFdoZXRoZXIgdGhlIHRhc2sgc2hvdWxkIHN0YXJ0IGJsb2NrZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7VGFza30gVGhlIFRhc2sgY3JlYXRlZCBhbmQgYWRkZWQgdG8gdGhlIHF1ZXVlIGZvciBmdXR1cmVcclxuICAgICAqICAgICAgICAgICAgICAgICBydW5uaW5nLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzY2hlZHVsZVRhc2soaGFuZGxlciwgYmxvY2tlZCkge1xyXG4gICAgICAgIHZhciB0YXNrID0gbmV3IFRhc2soaGFuZGxlciwgYmxvY2tlZCk7XHJcbiAgICAgICAgdGFza3MucHVzaCh0YXNrKTtcclxuICAgICAgICByZXR1cm4gdGFzaztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgdGhlIEd1YWNhbW9sZSBkaXNwbGF5LlxyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBHdWFjYW1vbGUgZGlzcGxheS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGlzIGRpc3BsYXkuXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHdpZHRoIG9mIHRoaXMgZGlzcGxheTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBkaXNwbGF5V2lkdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoaXMgZGlzcGxheS5cclxuICAgICAqIFxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoaXMgZGlzcGxheTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gZGlzcGxheUhlaWdodDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGxheWVyIG9mIHRoaXMgZGlzcGxheS4gRWFjaCBHdWFjYW1vbGUgZGlzcGxheSBhbHdheXNcclxuICAgICAqIGhhcyBhdCBsZWFzdCBvbmUgbGF5ZXIuIE90aGVyIGxheWVycyBjYW4gb3B0aW9uYWxseSBiZSBjcmVhdGVkIHdpdGhpblxyXG4gICAgICogdGhpcyBsYXllciwgYnV0IHRoZSBkZWZhdWx0IGxheWVyIGNhbm5vdCBiZSByZW1vdmVkIGFuZCBpcyB0aGUgYWJzb2x1dGVcclxuICAgICAqIGFuY2VzdG9yIG9mIGFsbCBvdGhlciBsYXllcnMuXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm4ge0d1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllcn0gVGhlIGRlZmF1bHQgbGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0RGVmYXVsdExheWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRfbGF5ZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3Vyc29yIGxheWVyIG9mIHRoaXMgZGlzcGxheS4gRWFjaCBHdWFjYW1vbGUgZGlzcGxheSBjb250YWluc1xyXG4gICAgICogYSBsYXllciBmb3IgdGhlIGltYWdlIG9mIHRoZSBtb3VzZSBjdXJzb3IuIFRoaXMgbGF5ZXIgaXMgYSBzcGVjaWFsIGNhc2VcclxuICAgICAqIGFuZCBleGlzdHMgYWJvdmUgYWxsIG90aGVyIGxheWVycywgc2ltaWxhciB0byB0aGUgaGFyZHdhcmUgbW91c2UgY3Vyc29yLlxyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJuIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ9IFRoZSBjdXJzb3IgbGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0Q3Vyc29yTGF5ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gY3Vyc29yO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgbGF5ZXIuIFRoZSBuZXcgbGF5ZXIgd2lsbCBiZSBhIGRpcmVjdCBjaGlsZCBvZiB0aGUgZGVmYXVsdFxyXG4gICAgICogbGF5ZXIsIGJ1dCBjYW4gYmUgbW92ZWQgdG8gYmUgYSBjaGlsZCBvZiBhbnkgb3RoZXIgbGF5ZXIuIExheWVycyByZXR1cm5lZFxyXG4gICAgICogYnkgdGhpcyBmdW5jdGlvbiBhcmUgdmlzaWJsZS5cclxuICAgICAqIFxyXG4gICAgICogQHJldHVybiB7R3VhY2Ftb2xlLkRpc3BsYXkuVmlzaWJsZUxheWVyfSBUaGUgbmV3bHktY3JlYXRlZCBsYXllci5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jcmVhdGVMYXllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBsYXllciA9IG5ldyBHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXIoZGlzcGxheVdpZHRoLCBkaXNwbGF5SGVpZ2h0KTtcclxuICAgICAgICBsYXllci5tb3ZlKGRlZmF1bHRfbGF5ZXIsIDAsIDAsIDApO1xyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlci4gQnVmZmVycyBhcmUgaW52aXNpYmxlLCBvZmYtc2NyZWVuIHN1cmZhY2VzLiBUaGV5XHJcbiAgICAgKiBhcmUgaW1wbGVtZW50ZWQgaW4gdGhlIHNhbWUgbWFubmVyIGFzIGxheWVycywgYnV0IGRvIG5vdCBwcm92aWRlIHRoZVxyXG4gICAgICogc2FtZSBuZXN0aW5nIHNlbWFudGljcy5cclxuICAgICAqIFxyXG4gICAgICogQHJldHVybiB7R3VhY2Ftb2xlLkxheWVyfSBUaGUgbmV3bHktY3JlYXRlZCBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3JlYXRlQnVmZmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBHdWFjYW1vbGUuTGF5ZXIoMCwgMCk7XHJcbiAgICAgICAgYnVmZmVyLmF1dG9zaXplID0gMTtcclxuICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZsdXNoIGFsbCBwZW5kaW5nIGRyYXcgdGFza3MsIGlmIHBvc3NpYmxlLCBhcyBhIG5ldyBmcmFtZS4gSWYgdGhlIGVudGlyZVxyXG4gICAgICogZnJhbWUgaXMgbm90IHJlYWR5LCB0aGUgZmx1c2ggd2lsbCB3YWl0IHVudGlsIGFsbCByZXF1aXJlZCB0YXNrcyBhcmVcclxuICAgICAqIHVuYmxvY2tlZC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGZyYW1lIGlzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHVzaGVkLiBUaGlzIG1heSBoYXBwZW4gaW1tZWRpYXRlbHksIG9yXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRlciB3aGVuIGJsb2NrZWQgdGFza3MgYmVjb21lIHVuYmxvY2tlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblxyXG4gICAgICAgIC8vIEFkZCBmcmFtZSwgcmVzZXQgdGFza3NcclxuICAgICAgICBmcmFtZXMucHVzaChuZXcgRnJhbWUoY2FsbGJhY2ssIHRhc2tzKSk7XHJcbiAgICAgICAgdGFza3MgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gQXR0ZW1wdCBmbHVzaFxyXG4gICAgICAgIF9fZmx1c2hfZnJhbWVzKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGhvdHNwb3QgYW5kIGltYWdlIG9mIHRoZSBtb3VzZSBjdXJzb3IgZGlzcGxheWVkIHdpdGhpbiB0aGVcclxuICAgICAqIEd1YWNhbW9sZSBkaXNwbGF5LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaG90c3BvdFggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3Vyc29yIGhvdHNwb3QuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaG90c3BvdFkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3Vyc29yIGhvdHNwb3QuXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIHNvdXJjZSBsYXllciBjb250YWluaW5nIHRoZSBkYXRhIHdoaWNoXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIG1vdXNlIGN1cnNvciBpbWFnZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIGxheWVyJ3MgY29vcmRpbmF0ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBsYXllcidzIGNvb3JkaW5hdGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3cgVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgbGF5ZXInc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZSBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmNoIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgbGF5ZXIncyBjb29yZGluYXRlIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXRDdXJzb3IgPSBmdW5jdGlvbihob3RzcG90WCwgaG90c3BvdFksIGxheWVyLCBzcmN4LCBzcmN5LCBzcmN3LCBzcmNoKSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9zZXRfY3Vyc29yKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IGhvdHNwb3RcclxuICAgICAgICAgICAgZ3VhY19kaXNwbGF5LmN1cnNvckhvdHNwb3RYID0gaG90c3BvdFg7XHJcbiAgICAgICAgICAgIGd1YWNfZGlzcGxheS5jdXJzb3JIb3RzcG90WSA9IGhvdHNwb3RZO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzZXQgY3Vyc29yIHNpemVcclxuICAgICAgICAgICAgY3Vyc29yLnJlc2l6ZShzcmN3LCBzcmNoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgY3Vyc29yIHRvIGN1cnNvciBsYXllclxyXG4gICAgICAgICAgICBjdXJzb3IuY29weShsYXllciwgc3JjeCwgc3JjeSwgc3Jjdywgc3JjaCwgMCwgMCk7XHJcbiAgICAgICAgICAgIGd1YWNfZGlzcGxheS5tb3ZlQ3Vyc29yKGd1YWNfZGlzcGxheS5jdXJzb3JYLCBndWFjX2Rpc3BsYXkuY3Vyc29yWSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaXJlIGN1cnNvciBjaGFuZ2UgZXZlbnRcclxuICAgICAgICAgICAgaWYgKGd1YWNfZGlzcGxheS5vbmN1cnNvcilcclxuICAgICAgICAgICAgICAgIGd1YWNfZGlzcGxheS5vbmN1cnNvcihjdXJzb3IudG9DYW52YXMoKSwgaG90c3BvdFgsIGhvdHNwb3RZKTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBzb2Z0d2FyZS1yZW5kZXJlZCBjdXJzb3IgaXMgc2hvd24uIFRoaXMgY3Vyc29yIGRpZmZlcnNcclxuICAgICAqIGZyb20gdGhlIGhhcmR3YXJlIGN1cnNvciBpbiB0aGF0IGl0IGlzIGJ1aWx0IGludG8gdGhlIEd1YWNhbW9sZS5EaXNwbGF5LFxyXG4gICAgICogYW5kIHJlbGllcyBvbiBpdHMgb3duIEd1YWNhbW9sZSBsYXllciB0byByZW5kZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2hvd249dHJ1ZV0gV2hldGhlciB0byBzaG93IHRoZSBzb2Z0d2FyZSBjdXJzb3IuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2hvd0N1cnNvciA9IGZ1bmN0aW9uKHNob3duKSB7XHJcblxyXG4gICAgICAgIHZhciBlbGVtZW50ID0gY3Vyc29yLmdldEVsZW1lbnQoKTtcclxuICAgICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgZnJvbSBET00gaWYgaGlkZGVuXHJcbiAgICAgICAgaWYgKHNob3duID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50KVxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBlbnN1cmUgY3Vyc29yIGlzIGNoaWxkIG9mIGRpc3BsYXlcclxuICAgICAgICBlbHNlIGlmIChwYXJlbnQgIT09IGRpc3BsYXkpXHJcbiAgICAgICAgICAgIGRpc3BsYXkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGxvY2F0aW9uIG9mIHRoZSBsb2NhbCBjdXJzb3IgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLiBGb3IgdGhlXHJcbiAgICAgKiBzYWtlIG9mIHJlc3BvbnNpdmVuZXNzLCB0aGlzIGZ1bmN0aW9uIHBlcmZvcm1zIGl0cyBhY3Rpb24gaW1tZWRpYXRlbHkuXHJcbiAgICAgKiBDdXJzb3IgbW90aW9uIGlzIG5vdCBtYWludGFpbmVkIHdpdGhpbiBhdG9taWMgZnJhbWVzLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIHRvIG1vdmUgdGhlIGN1cnNvciB0by5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgdG8gbW92ZSB0aGUgY3Vyc29yIHRvLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vdmVDdXJzb3IgPSBmdW5jdGlvbih4LCB5KSB7XHJcblxyXG4gICAgICAgIC8vIE1vdmUgY3Vyc29yIGxheWVyXHJcbiAgICAgICAgY3Vyc29yLnRyYW5zbGF0ZSh4IC0gZ3VhY19kaXNwbGF5LmN1cnNvckhvdHNwb3RYLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgeSAtIGd1YWNfZGlzcGxheS5jdXJzb3JIb3RzcG90WSk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBzdG9yZWQgcG9zaXRpb25cclxuICAgICAgICBndWFjX2Rpc3BsYXkuY3Vyc29yWCA9IHg7XHJcbiAgICAgICAgZ3VhY19kaXNwbGF5LmN1cnNvclkgPSB5O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBMYXllciB0byB0aGUgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodC5cclxuICAgICAqIFJlc2l6aW5nIGlzIG9ubHkgYXR0ZW1wdGVkIGlmIHRoZSBuZXcgc2l6ZSBwcm92aWRlZCBpcyBhY3R1YWxseSBkaWZmZXJlbnRcclxuICAgICAqIGZyb20gdGhlIGN1cnJlbnQgc2l6ZS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byByZXNpemUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIG5ldyB3aWR0aC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIG5ldyBoZWlnaHQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzaXplID0gZnVuY3Rpb24obGF5ZXIsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X3Jlc2l6ZSgpIHtcclxuXHJcbiAgICAgICAgICAgIGxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlc2l6ZSBkaXNwbGF5IGlmIGRlZmF1bHQgbGF5ZXIgaXMgcmVzaXplZFxyXG4gICAgICAgICAgICBpZiAobGF5ZXIgPT09IGRlZmF1bHRfbGF5ZXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgKHNldCkgZGlzcGxheSBzaXplXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5V2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LnN0eWxlLndpZHRoID0gZGlzcGxheVdpZHRoICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5zdHlsZS5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0ICsgXCJweFwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBib3VuZHMgc2l6ZVxyXG4gICAgICAgICAgICAgICAgYm91bmRzLnN0eWxlLndpZHRoID0gKGRpc3BsYXlXaWR0aCpkaXNwbGF5U2NhbGUpICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgYm91bmRzLnN0eWxlLmhlaWdodCA9IChkaXNwbGF5SGVpZ2h0KmRpc3BsYXlTY2FsZSkgKyBcInB4XCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IG9mIHJlc2l6ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGd1YWNfZGlzcGxheS5vbnJlc2l6ZSlcclxuICAgICAgICAgICAgICAgICAgICBndWFjX2Rpc3BsYXkub25yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBzcGVjaWZpZWQgaW1hZ2UgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLiBUaGUgaW1hZ2Ugc3BlY2lmaWVkXHJcbiAgICAgKiBtdXN0IGFscmVhZHkgYmUgbG9hZGVkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXJcclxuICAgICAqICAgICBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiAgICAgVGhlIGRlc3RpbmF0aW9uIFggY29vcmRpbmF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBcclxuICAgICAqICAgICBUaGUgZGVzdGluYXRpb24gWSBjb29yZGluYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Q2FudmFzSW1hZ2VTb3VyY2V9IGltYWdlXHJcbiAgICAgKiAgICAgVGhlIGltYWdlIHRvIGRyYXcuIE5vdGUgdGhhdCB0aGlzIG5vdCBhIFVSTC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmF3SW1hZ2UgPSBmdW5jdGlvbihsYXllciwgeCwgeSwgaW1hZ2UpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X2RyYXdJbWFnZSgpIHtcclxuICAgICAgICAgICAgbGF5ZXIuZHJhd0ltYWdlKHgsIHksIGltYWdlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgaW1hZ2UgY29udGFpbmVkIHdpdGhpbiB0aGUgc3BlY2lmaWVkIEJsb2IgYXQgdGhlIGdpdmVuXHJcbiAgICAgKiBjb29yZGluYXRlcy4gVGhlIEJsb2Igc3BlY2lmaWVkIG11c3QgYWxyZWFkeSBiZSBwb3B1bGF0ZWQgd2l0aCBpbWFnZVxyXG4gICAgICogZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXJcclxuICAgICAqICAgICBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiAgICAgVGhlIGRlc3RpbmF0aW9uIFggY29vcmRpbmF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogICAgIFRoZSBkZXN0aW5hdGlvbiBZIGNvb3JkaW5hdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtCbG9ifSBibG9iXHJcbiAgICAgKiAgICAgVGhlIEJsb2IgY29udGFpbmluZyB0aGUgaW1hZ2UgZGF0YSB0byBkcmF3LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYXdCbG9iID0gZnVuY3Rpb24obGF5ZXIsIHgsIHksIGJsb2IpIHtcclxuXHJcbiAgICAgICAgdmFyIHRhc2s7XHJcblxyXG4gICAgICAgIC8vIFByZWZlciBjcmVhdGVJbWFnZUJpdG1hcCgpIG92ZXIgYmxvYiBVUkxzIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGlmICh3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBiaXRtYXA7XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IGltYWdlIG9uY2UgbG9hZGVkXHJcbiAgICAgICAgICAgIHRhc2sgPSBzY2hlZHVsZVRhc2soZnVuY3Rpb24gZHJhd0ltYWdlQml0bWFwKCkge1xyXG4gICAgICAgICAgICAgICAgbGF5ZXIuZHJhd0ltYWdlKHgsIHksIGJpdG1hcCk7XHJcbiAgICAgICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gTG9hZCBpbWFnZSBmcm9tIHByb3ZpZGVkIGJsb2JcclxuICAgICAgICAgICAgd2luZG93LmNyZWF0ZUltYWdlQml0bWFwKGJsb2IpLnRoZW4oZnVuY3Rpb24gYml0bWFwTG9hZGVkKGRlY29kZWQpIHtcclxuICAgICAgICAgICAgICAgIGJpdG1hcCA9IGRlY29kZWQ7XHJcbiAgICAgICAgICAgICAgICB0YXNrLnVuYmxvY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIGJsb2IgVVJMcyBhbmQgdGhlIEltYWdlIG9iamVjdCBpZiBjcmVhdGVJbWFnZUJpdG1hcCgpIGlzXHJcbiAgICAgICAgLy8gdW5hdmFpbGFibGVcclxuICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBVUkwgZm9yIGJsb2JcclxuICAgICAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IGFuZCBmcmVlIGJsb2IgVVJMIHdoZW4gcmVhZHlcclxuICAgICAgICAgICAgdGFzayA9IHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfZHJhd0Jsb2IoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRHJhdyB0aGUgaW1hZ2Ugb25seSBpZiBpdCBsb2FkZWQgd2l0aG91dCBlcnJvcnNcclxuICAgICAgICAgICAgICAgIGlmIChpbWFnZS53aWR0aCAmJiBpbWFnZS5oZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZHJhd0ltYWdlKHgsIHksIGltYWdlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCbG9iIFVSTCBubyBsb25nZXIgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XHJcblxyXG4gICAgICAgICAgICB9LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIExvYWQgaW1hZ2UgZnJvbSBVUkxcclxuICAgICAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IHRhc2sudW5ibG9jaztcclxuICAgICAgICAgICAgaW1hZ2Uub25lcnJvciA9IHRhc2sudW5ibG9jaztcclxuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gdXJsO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBpbWFnZSB3aXRoaW4gdGhlIGdpdmVuIHN0cmVhbSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuIFRoZVxyXG4gICAgICogaW1hZ2Ugd2lsbCBiZSBsb2FkZWQgYXV0b21hdGljYWxseSwgYW5kIHRoaXMgYW5kIGFueSBmdXR1cmUgb3BlcmF0aW9uc1xyXG4gICAgICogd2lsbCB3YWl0IGZvciB0aGUgaW1hZ2UgdG8gZmluaXNoIGxvYWRpbmcuIFRoaXMgZnVuY3Rpb24gd2lsbFxyXG4gICAgICogYXV0b21hdGljYWxseSBjaG9vc2UgYW4gYXBwcm9yaWF0ZSBtZXRob2QgZm9yIHJlYWRpbmcgYW5kIGRlY29kaW5nIHRoZVxyXG4gICAgICogZ2l2ZW4gaW1hZ2Ugc3RyZWFtLCBhbmQgc2hvdWxkIGJlIHByZWZlcnJlZCBmb3IgcmVjZWl2ZWQgc3RyZWFtcyBleGNlcHRcclxuICAgICAqIHdoZXJlIG1hbnVhbCBkZWNvZGluZyBvZiB0aGUgc3RyZWFtIGlzIHVuYXZvaWRhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllclxyXG4gICAgICogICAgIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqICAgICBUaGUgZGVzdGluYXRpb24gWCBjb29yZGluYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiAgICAgVGhlIGRlc3RpbmF0aW9uIFkgY29vcmRpbmF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5JbnB1dFN0cmVhbX0gc3RyZWFtXHJcbiAgICAgKiAgICAgVGhlIHN0cmVhbSBhbG9uZyB3aGljaCBpbWFnZSBkYXRhIHdpbGwgYmUgcmVjZWl2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAgICAgKiAgICAgVGhlIG1pbWV0eXBlIG9mIHRoZSBpbWFnZSB3aXRoaW4gdGhlIHN0cmVhbS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5kcmF3U3RyZWFtID0gZnVuY3Rpb24gZHJhd1N0cmVhbShsYXllciwgeCwgeSwgc3RyZWFtLCBtaW1ldHlwZSkge1xyXG5cclxuICAgICAgICAvLyBJZiBjcmVhdGVJbWFnZUJpdG1hcCgpIGlzIGF2YWlsYWJsZSwgbG9hZCB0aGUgaW1hZ2UgYXMgYSBibG9iIHNvXHJcbiAgICAgICAgLy8gdGhhdCBmdW5jdGlvbiBjYW4gYmUgdXNlZFxyXG4gICAgICAgIGlmICh3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXApIHtcclxuICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBHdWFjYW1vbGUuQmxvYlJlYWRlcihzdHJlYW0sIG1pbWV0eXBlKTtcclxuICAgICAgICAgICAgcmVhZGVyLm9uZW5kID0gZnVuY3Rpb24gZHJhd0ltYWdlQmxvYigpIHtcclxuICAgICAgICAgICAgICAgIGd1YWNfZGlzcGxheS5kcmF3QmxvYihsYXllciwgeCwgeSwgcmVhZGVyLmdldEJsb2IoKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMYWNraW5nIGNyZWF0ZUltYWdlQml0bWFwKCksIGZhbGwgYmFjayB0byBkYXRhIFVSSXMgYW5kIHRoZSBJbWFnZVxyXG4gICAgICAgIC8vIG9iamVjdFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEd1YWNhbW9sZS5EYXRhVVJJUmVhZGVyKHN0cmVhbSwgbWltZXR5cGUpO1xyXG4gICAgICAgICAgICByZWFkZXIub25lbmQgPSBmdW5jdGlvbiBkcmF3SW1hZ2VEYXRhVVJJKCkge1xyXG4gICAgICAgICAgICAgICAgZ3VhY19kaXNwbGF5LmRyYXcobGF5ZXIsIHgsIHksIHJlYWRlci5nZXRVUkkoKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgaW1hZ2UgYXQgdGhlIHNwZWNpZmllZCBVUkwgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLiBUaGUgaW1hZ2VcclxuICAgICAqIHdpbGwgYmUgbG9hZGVkIGF1dG9tYXRpY2FsbHksIGFuZCB0aGlzIGFuZCBhbnkgZnV0dXJlIG9wZXJhdGlvbnMgd2lsbFxyXG4gICAgICogd2FpdCBmb3IgdGhlIGltYWdlIHRvIGZpbmlzaCBsb2FkaW5nLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBkZXN0aW5hdGlvbiBYIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgZGVzdGluYXRpb24gWSBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoZSBpbWFnZSB0byBkcmF3LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbihsYXllciwgeCwgeSwgdXJsKSB7XHJcblxyXG4gICAgICAgIHZhciB0YXNrID0gc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9kcmF3KCkge1xyXG5cclxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgaW1hZ2Ugb25seSBpZiBpdCBsb2FkZWQgd2l0aG91dCBlcnJvcnNcclxuICAgICAgICAgICAgaWYgKGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodClcclxuICAgICAgICAgICAgICAgIGxheWVyLmRyYXdJbWFnZSh4LCB5LCBpbWFnZSk7XHJcblxyXG4gICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICBpbWFnZS5vbmxvYWQgPSB0YXNrLnVuYmxvY2s7XHJcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IHRhc2sudW5ibG9jaztcclxuICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBsYXlzIHRoZSB2aWRlbyBhdCB0aGUgc3BlY2lmaWVkIFVSTCB3aXRoaW4gdGhpcyBsYXllci4gVGhlIHZpZGVvXHJcbiAgICAgKiB3aWxsIGJlIGxvYWRlZCBhdXRvbWF0aWNhbGx5LCBhbmQgdGhpcyBhbmQgYW55IGZ1dHVyZSBvcGVyYXRpb25zIHdpbGxcclxuICAgICAqIHdhaXQgZm9yIHRoZSB2aWRlbyB0byBmaW5pc2ggbG9hZGluZy4gRnV0dXJlIG9wZXJhdGlvbnMgd2lsbCBub3QgYmVcclxuICAgICAqIGV4ZWN1dGVkIHVudGlsIHRoZSB2aWRlbyBmaW5pc2hlcyBwbGF5aW5nLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZSBUaGUgbWltZXR5cGUgb2YgdGhlIHZpZGVvIHRvIHBsYXkuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSB2aWRlbyBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgb2YgdGhlIHZpZGVvIHRvIHBsYXkuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGxheSA9IGZ1bmN0aW9uKGxheWVyLCBtaW1ldHlwZSwgZHVyYXRpb24sIHVybCkge1xyXG5cclxuICAgICAgICAvLyBTdGFydCBsb2FkaW5nIHRoZSB2aWRlb1xyXG4gICAgICAgIHZhciB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcclxuICAgICAgICB2aWRlby50eXBlID0gbWltZXR5cGU7XHJcbiAgICAgICAgdmlkZW8uc3JjID0gdXJsO1xyXG5cclxuICAgICAgICAvLyBTdGFydCBjb3B5aW5nIGZyYW1lcyB3aGVuIHBsYXlpbmdcclxuICAgICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKFwicGxheVwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbmRlcl9jYWxsYmFjaygpIHtcclxuICAgICAgICAgICAgICAgIGxheWVyLmRyYXdJbWFnZSgwLCAwLCB2aWRlbyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpZGVvLmVuZGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHJlbmRlcl9jYWxsYmFjaywgMjApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZW5kZXJfY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfSwgZmFsc2UpO1xyXG5cclxuICAgICAgICBzY2hlZHVsZVRhc2sodmlkZW8ucGxheSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZmVyIGEgcmVjdGFuZ2xlIG9mIGltYWdlIGRhdGEgZnJvbSBvbmUgTGF5ZXIgdG8gdGhpcyBMYXllciB1c2luZyB0aGVcclxuICAgICAqIHNwZWNpZmllZCB0cmFuc2ZlciBmdW5jdGlvbi5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IHNyY0xheWVyIFRoZSBMYXllciB0byBjb3B5IGltYWdlIGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3MgY29vcmRpbmF0ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzIGNvb3JkaW5hdGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3cgVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXInc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZSBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmNoIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgTGF5ZXIncyBjb29yZGluYXRlIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGRzdExheWVyIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgZGVzdGluYXRpb24gWCBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIGRlc3RpbmF0aW9uIFkgY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZmVyRnVuY3Rpb24gVGhlIHRyYW5zZmVyIGZ1bmN0aW9uIHRvIHVzZSB0b1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2ZlciBkYXRhIGZyb20gc291cmNlIHRvXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyYW5zZmVyID0gZnVuY3Rpb24oc3JjTGF5ZXIsIHNyY3gsIHNyY3ksIHNyY3csIHNyY2gsIGRzdExheWVyLCB4LCB5LCB0cmFuc2ZlckZ1bmN0aW9uKSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV90cmFuc2ZlcigpIHtcclxuICAgICAgICAgICAgZHN0TGF5ZXIudHJhbnNmZXIoc3JjTGF5ZXIsIHNyY3gsIHNyY3ksIHNyY3csIHNyY2gsIHgsIHksIHRyYW5zZmVyRnVuY3Rpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFB1dCBhIHJlY3RhbmdsZSBvZiBpbWFnZSBkYXRhIGZyb20gb25lIExheWVyIHRvIHRoaXMgTGF5ZXIgZGlyZWN0bHlcclxuICAgICAqIHdpdGhvdXQgcGVyZm9ybWluZyBhbnkgYWxwaGEgYmxlbmRpbmcuIFNpbXBseSBjb3B5IHRoZSBkYXRhLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gc3JjTGF5ZXIgVGhlIExheWVyIHRvIGNvcHkgaW1hZ2UgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3ggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXIncyBjb29yZGluYXRlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3MgY29vcmRpbmF0ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjdyBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY2ggVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBMYXllcidzIGNvb3JkaW5hdGUgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gZHN0TGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBkZXN0aW5hdGlvbiBYIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgZGVzdGluYXRpb24gWSBjb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnB1dCA9IGZ1bmN0aW9uKHNyY0xheWVyLCBzcmN4LCBzcmN5LCBzcmN3LCBzcmNoLCBkc3RMYXllciwgeCwgeSkge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfcHV0KCkge1xyXG4gICAgICAgICAgICBkc3RMYXllci5wdXQoc3JjTGF5ZXIsIHNyY3gsIHNyY3ksIHNyY3csIHNyY2gsIHgsIHkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcHkgYSByZWN0YW5nbGUgb2YgaW1hZ2UgZGF0YSBmcm9tIG9uZSBMYXllciB0byB0aGlzIExheWVyLiBUaGlzXHJcbiAgICAgKiBvcGVyYXRpb24gd2lsbCBjb3B5IGV4YWN0bHkgdGhlIGltYWdlIGRhdGEgdGhhdCB3aWxsIGJlIGRyYXduIG9uY2UgYWxsXHJcbiAgICAgKiBvcGVyYXRpb25zIG9mIHRoZSBzb3VyY2UgTGF5ZXIgdGhhdCB3ZXJlIHBlbmRpbmcgYXQgdGhlIHRpbWUgdGhpc1xyXG4gICAgICogZnVuY3Rpb24gd2FzIGNhbGxlZCBhcmUgY29tcGxldGUuIFRoaXMgb3BlcmF0aW9uIHdpbGwgbm90IGFsdGVyIHRoZVxyXG4gICAgICogc2l6ZSBvZiB0aGUgc291cmNlIExheWVyIGV2ZW4gaWYgaXRzIGF1dG9zaXplIHByb3BlcnR5IGlzIHNldCB0byB0cnVlLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gc3JjTGF5ZXIgVGhlIExheWVyIHRvIGNvcHkgaW1hZ2UgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3ggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXIncyBjb29yZGluYXRlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3MgY29vcmRpbmF0ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjdyBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY2ggVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBMYXllcidzIGNvb3JkaW5hdGUgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gZHN0TGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBkZXN0aW5hdGlvbiBYIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgZGVzdGluYXRpb24gWSBjb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvcHkgPSBmdW5jdGlvbihzcmNMYXllciwgc3JjeCwgc3JjeSwgc3Jjdywgc3JjaCwgZHN0TGF5ZXIsIHgsIHkpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X2NvcHkoKSB7XHJcbiAgICAgICAgICAgIGRzdExheWVyLmNvcHkoc3JjTGF5ZXIsIHNyY3gsIHNyY3ksIHNyY3csIHNyY2gsIHgsIHkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIG5ldyBwYXRoIGF0IHRoZSBzcGVjaWZpZWQgcG9pbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gZHJhdy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGRyYXcuXHJcbiAgICAgKi9cclxuICAgIHRoaXMubW92ZVRvID0gZnVuY3Rpb24obGF5ZXIsIHgsIHkpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X21vdmVUbygpIHtcclxuICAgICAgICAgICAgbGF5ZXIubW92ZVRvKHgsIHkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0aGUgc3BlY2lmaWVkIGxpbmUgdG8gdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSB0byBkcmF3LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgdG8gZHJhdy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5saW5lVG8gPSBmdW5jdGlvbihsYXllciwgeCwgeSkge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfbGluZVRvKCkge1xyXG4gICAgICAgICAgICBsYXllci5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRoZSBzcGVjaWZpZWQgYXJjIHRvIHRoZSBjdXJyZW50IHBhdGguXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgd2hpY2hcclxuICAgICAqICAgICAgICAgICAgICAgICAgIHdpbGwgY29udGFpbiB0aGUgYXJjLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgd2hpY2hcclxuICAgICAqICAgICAgICAgICAgICAgICAgIHdpbGwgY29udGFpbiB0aGUgYXJjLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZSBUaGUgc3RhcnRpbmcgYW5nbGUgb2YgdGhlIGFyYywgaW4gcmFkaWFucy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRBbmdsZSBUaGUgZW5kaW5nIGFuZ2xlIG9mIHRoZSBhcmMsIGluIHJhZGlhbnMuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5lZ2F0aXZlIFdoZXRoZXIgdGhlIGFyYyBzaG91bGQgYmUgZHJhd24gaW4gb3JkZXIgb2ZcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVhc2luZyBhbmdsZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5hcmMgPSBmdW5jdGlvbihsYXllciwgeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgbmVnYXRpdmUpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X2FyYygpIHtcclxuICAgICAgICAgICAgbGF5ZXIuYXJjKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIG5lZ2F0aXZlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBuZXcgcGF0aCBhdCB0aGUgc3BlY2lmaWVkIHBvaW50LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjcDF4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3AxeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNwMnggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3AyeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZHBvaW50IG9mIHRoZSBjdXJ2ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGVuZHBvaW50IG9mIHRoZSBjdXJ2ZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJ2ZVRvID0gZnVuY3Rpb24obGF5ZXIsIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X2N1cnZlVG8oKSB7XHJcbiAgICAgICAgICAgIGxheWVyLmN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGggYnkgY29ubmVjdGluZyB0aGUgZW5kIHBvaW50IHdpdGggdGhlIHN0YXJ0XHJcbiAgICAgKiBwb2ludCAoaWYgYW55KSB3aXRoIGEgc3RyYWlnaHQgbGluZS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xvc2UgPSBmdW5jdGlvbihsYXllcikge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfY2xvc2UoKSB7XHJcbiAgICAgICAgICAgIGxheWVyLmNsb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlIHRvIHRoZSBjdXJyZW50IHBhdGguXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gZHJhdyB1cG9uLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgdG8gZHJhdy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZSB0byBkcmF3LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGRyYXcuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVjdCA9IGZ1bmN0aW9uKGxheWVyLCB4LCB5LCB3LCBoKSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9yZWN0KCkge1xyXG4gICAgICAgICAgICBsYXllci5yZWN0KHgsIHksIHcsIGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsaXAgYWxsIGZ1dHVyZSBkcmF3aW5nIG9wZXJhdGlvbnMgYnkgdGhlIGN1cnJlbnQgcGF0aC4gVGhlIGN1cnJlbnQgcGF0aFxyXG4gICAgICogaXMgaW1wbGljaXRseSBjbG9zZWQuIFRoZSBjdXJyZW50IHBhdGggY2FuIGNvbnRpbnVlIHRvIGJlIHJldXNlZFxyXG4gICAgICogZm9yIG90aGVyIG9wZXJhdGlvbnMgKHN1Y2ggYXMgZmlsbENvbG9yKCkpIGJ1dCBhIG5ldyBwYXRoIHdpbGwgYmUgc3RhcnRlZFxyXG4gICAgICogb25jZSBhIHBhdGggZHJhd2luZyBvcGVyYXRpb24gKHBhdGgoKSBvciByZWN0KCkpIGlzIHVzZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gYWZmZWN0LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaXAgPSBmdW5jdGlvbihsYXllcikge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfY2xpcCgpIHtcclxuICAgICAgICAgICAgbGF5ZXIuY2xpcCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cm9rZSB0aGUgY3VycmVudCBwYXRoIHdpdGggdGhlIHNwZWNpZmllZCBjb2xvci4gVGhlIGN1cnJlbnQgcGF0aFxyXG4gICAgICogaXMgaW1wbGljaXRseSBjbG9zZWQuIFRoZSBjdXJyZW50IHBhdGggY2FuIGNvbnRpbnVlIHRvIGJlIHJldXNlZFxyXG4gICAgICogZm9yIG90aGVyIG9wZXJhdGlvbnMgKHN1Y2ggYXMgY2xpcCgpKSBidXQgYSBuZXcgcGF0aCB3aWxsIGJlIHN0YXJ0ZWRcclxuICAgICAqIG9uY2UgYSBwYXRoIGRyYXdpbmcgb3BlcmF0aW9uIChwYXRoKCkgb3IgcmVjdCgpKSBpcyB1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYXAgVGhlIGxpbmUgY2FwIHN0eWxlLiBDYW4gYmUgXCJyb3VuZFwiLCBcInNxdWFyZVwiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBvciBcImJ1dHRcIi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBqb2luIFRoZSBsaW5lIGpvaW4gc3R5bGUuIENhbiBiZSBcInJvdW5kXCIsIFwiYmV2ZWxcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG9yIFwibWl0ZXJcIi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aGlja25lc3MgVGhlIGxpbmUgdGhpY2tuZXNzIGluIHBpeGVscy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIFRoZSByZWQgY29tcG9uZW50IG9mIHRoZSBjb2xvciB0byBmaWxsLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGcgVGhlIGdyZWVuIGNvbXBvbmVudCBvZiB0aGUgY29sb3IgdG8gZmlsbC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBibHVlIGNvbXBvbmVudCBvZiB0aGUgY29sb3IgdG8gZmlsbC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBhbHBoYSBjb21wb25lbnQgb2YgdGhlIGNvbG9yIHRvIGZpbGwuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBmdW5jdGlvbihsYXllciwgY2FwLCBqb2luLCB0aGlja25lc3MsIHIsIGcsIGIsIGEpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X3N0cm9rZUNvbG9yKCkge1xyXG4gICAgICAgICAgICBsYXllci5zdHJva2VDb2xvcihjYXAsIGpvaW4sIHRoaWNrbmVzcywgciwgZywgYiwgYSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsbHMgdGhlIGN1cnJlbnQgcGF0aCB3aXRoIHRoZSBzcGVjaWZpZWQgY29sb3IuIFRoZSBjdXJyZW50IHBhdGhcclxuICAgICAqIGlzIGltcGxpY2l0bHkgY2xvc2VkLiBUaGUgY3VycmVudCBwYXRoIGNhbiBjb250aW51ZSB0byBiZSByZXVzZWRcclxuICAgICAqIGZvciBvdGhlciBvcGVyYXRpb25zIChzdWNoIGFzIGNsaXAoKSkgYnV0IGEgbmV3IHBhdGggd2lsbCBiZSBzdGFydGVkXHJcbiAgICAgKiBvbmNlIGEgcGF0aCBkcmF3aW5nIG9wZXJhdGlvbiAocGF0aCgpIG9yIHJlY3QoKSkgaXMgdXNlZC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gciBUaGUgcmVkIGNvbXBvbmVudCBvZiB0aGUgY29sb3IgdG8gZmlsbC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBnIFRoZSBncmVlbiBjb21wb25lbnQgb2YgdGhlIGNvbG9yIHRvIGZpbGwuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgYmx1ZSBjb21wb25lbnQgb2YgdGhlIGNvbG9yIHRvIGZpbGwuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgYWxwaGEgY29tcG9uZW50IG9mIHRoZSBjb2xvciB0byBmaWxsLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpbGxDb2xvciA9IGZ1bmN0aW9uKGxheWVyLCByLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV9maWxsQ29sb3IoKSB7XHJcbiAgICAgICAgICAgIGxheWVyLmZpbGxDb2xvcihyLCBnLCBiLCBhKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJva2UgdGhlIGN1cnJlbnQgcGF0aCB3aXRoIHRoZSBpbWFnZSB3aXRoaW4gdGhlIHNwZWNpZmllZCBsYXllci4gVGhlXHJcbiAgICAgKiBpbWFnZSBkYXRhIHdpbGwgYmUgdGlsZWQgaW5maW5pdGVseSB3aXRoaW4gdGhlIHN0cm9rZS4gVGhlIGN1cnJlbnQgcGF0aFxyXG4gICAgICogaXMgaW1wbGljaXRseSBjbG9zZWQuIFRoZSBjdXJyZW50IHBhdGggY2FuIGNvbnRpbnVlIHRvIGJlIHJldXNlZFxyXG4gICAgICogZm9yIG90aGVyIG9wZXJhdGlvbnMgKHN1Y2ggYXMgY2xpcCgpKSBidXQgYSBuZXcgcGF0aCB3aWxsIGJlIHN0YXJ0ZWRcclxuICAgICAqIG9uY2UgYSBwYXRoIGRyYXdpbmcgb3BlcmF0aW9uIChwYXRoKCkgb3IgcmVjdCgpKSBpcyB1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYXAgVGhlIGxpbmUgY2FwIHN0eWxlLiBDYW4gYmUgXCJyb3VuZFwiLCBcInNxdWFyZVwiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBvciBcImJ1dHRcIi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBqb2luIFRoZSBsaW5lIGpvaW4gc3R5bGUuIENhbiBiZSBcInJvdW5kXCIsIFwiYmV2ZWxcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG9yIFwibWl0ZXJcIi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aGlja25lc3MgVGhlIGxpbmUgdGhpY2tuZXNzIGluIHBpeGVscy5cclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBzcmNMYXllciBUaGUgbGF5ZXIgdG8gdXNlIGFzIGEgcmVwZWF0aW5nIHBhdHRlcm5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoaW4gdGhlIHN0cm9rZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdHJva2VMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBjYXAsIGpvaW4sIHRoaWNrbmVzcywgc3JjTGF5ZXIpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X3N0cm9rZUxheWVyKCkge1xyXG4gICAgICAgICAgICBsYXllci5zdHJva2VMYXllcihjYXAsIGpvaW4sIHRoaWNrbmVzcywgc3JjTGF5ZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGxzIHRoZSBjdXJyZW50IHBhdGggd2l0aCB0aGUgaW1hZ2Ugd2l0aGluIHRoZSBzcGVjaWZpZWQgbGF5ZXIuIFRoZVxyXG4gICAgICogaW1hZ2UgZGF0YSB3aWxsIGJlIHRpbGVkIGluZmluaXRlbHkgd2l0aGluIHRoZSBzdHJva2UuIFRoZSBjdXJyZW50IHBhdGhcclxuICAgICAqIGlzIGltcGxpY2l0bHkgY2xvc2VkLiBUaGUgY3VycmVudCBwYXRoIGNhbiBjb250aW51ZSB0byBiZSByZXVzZWRcclxuICAgICAqIGZvciBvdGhlciBvcGVyYXRpb25zIChzdWNoIGFzIGNsaXAoKSkgYnV0IGEgbmV3IHBhdGggd2lsbCBiZSBzdGFydGVkXHJcbiAgICAgKiBvbmNlIGEgcGF0aCBkcmF3aW5nIG9wZXJhdGlvbiAocGF0aCgpIG9yIHJlY3QoKSkgaXMgdXNlZC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gc3JjTGF5ZXIgVGhlIGxheWVyIHRvIHVzZSBhcyBhIHJlcGVhdGluZyBwYXR0ZXJuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aGluIHRoZSBmaWxsLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpbGxMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBzcmNMYXllcikge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfZmlsbExheWVyKCkge1xyXG4gICAgICAgICAgICBsYXllci5maWxsTGF5ZXIoc3JjTGF5ZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFB1c2ggY3VycmVudCBsYXllciBzdGF0ZSBvbnRvIHN0YWNrLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5wdXNoID0gZnVuY3Rpb24obGF5ZXIpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X3B1c2goKSB7XHJcbiAgICAgICAgICAgIGxheWVyLnB1c2goKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3AgbGF5ZXIgc3RhdGUgb2ZmIHN0YWNrLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGRyYXcgdXBvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3AgPSBmdW5jdGlvbihsYXllcikge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfcG9wKCkge1xyXG4gICAgICAgICAgICBsYXllci5wb3AoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgbGF5ZXIsIGNsZWFyaW5nIHRoZSBzdGFjaywgdGhlIGN1cnJlbnQgcGF0aCwgYW5kIGFueSB0cmFuc2Zvcm1cclxuICAgICAqIG1hdHJpeC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byBkcmF3IHVwb24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbihsYXllcikge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfcmVzZXQoKSB7XHJcbiAgICAgICAgICAgIGxheWVyLnJlc2V0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gYWZmaW5lIHRyYW5zZm9ybSAoZGVmaW5lZCB3aXRoIHNpeCB2YWx1ZXMgZnJvbSB0aGVcclxuICAgICAqIHRyYW5zZm9ybSdzIG1hdHJpeCkuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSB0aGlyZCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkIFRoZSBmb3VydGggdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZSBUaGUgZmlmdGggdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZiBUaGUgc2l4dGggdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24obGF5ZXIsIGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X3NldFRyYW5zZm9ybSgpIHtcclxuICAgICAgICAgICAgbGF5ZXIuc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIGFmZmluZSB0cmFuc2Zvcm0gKGRlZmluZWQgd2l0aCBzaXggdmFsdWVzIGZyb20gdGhlXHJcbiAgICAgKiB0cmFuc2Zvcm0ncyBtYXRyaXgpLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgdGhpcmQgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZCBUaGUgZm91cnRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGUgVGhlIGZpZnRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGYgVGhlIHNpeHRoIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGxheWVyLCBhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIF9fZGlzcGxheV90cmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgICAgIGxheWVyLnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjaGFubmVsIG1hc2sgZm9yIGZ1dHVyZSBvcGVyYXRpb25zIG9uIHRoaXMgTGF5ZXIuXHJcbiAgICAgKiBcclxuICAgICAqIFRoZSBjaGFubmVsIG1hc2sgaXMgYSBHdWFjYW1vbGUtc3BlY2lmaWMgY29tcG9zaXRpbmcgb3BlcmF0aW9uIGlkZW50aWZpZXJcclxuICAgICAqIHdpdGggYSBzaW5nbGUgYml0IHJlcHJlc2VudGluZyBlYWNoIG9mIGZvdXIgY2hhbm5lbHMgKGluIG9yZGVyKTogc291cmNlXHJcbiAgICAgKiBpbWFnZSB3aGVyZSBkZXN0aW5hdGlvbiB0cmFuc3BhcmVudCwgc291cmNlIHdoZXJlIGRlc3RpbmF0aW9uIG9wYXF1ZSxcclxuICAgICAqIGRlc3RpbmF0aW9uIHdoZXJlIHNvdXJjZSB0cmFuc3BhcmVudCwgYW5kIGRlc3RpbmF0aW9uIHdoZXJlIHNvdXJjZVxyXG4gICAgICogb3BhcXVlLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXNrIFRoZSBjaGFubmVsIG1hc2sgZm9yIGZ1dHVyZSBvcGVyYXRpb25zIG9uIHRoaXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIExheWVyLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNldENoYW5uZWxNYXNrID0gZnVuY3Rpb24obGF5ZXIsIG1hc2spIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gX19kaXNwbGF5X3NldENoYW5uZWxNYXNrKCkge1xyXG4gICAgICAgICAgICBsYXllci5zZXRDaGFubmVsTWFzayhtYXNrKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtaXRlciBsaW1pdCBmb3Igc3Ryb2tlIG9wZXJhdGlvbnMgdXNpbmcgdGhlIG1pdGVyIGpvaW4uIFRoaXNcclxuICAgICAqIGxpbWl0IGlzIHRoZSBtYXhpbXVtIHJhdGlvIG9mIHRoZSBzaXplIG9mIHRoZSBtaXRlciBqb2luIHRvIHRoZSBzdHJva2VcclxuICAgICAqIHdpZHRoLiBJZiB0aGlzIHJhdGlvIGlzIGV4Y2VlZGVkLCB0aGUgbWl0ZXIgd2lsbCBub3QgYmUgZHJhd24gZm9yIHRoYXRcclxuICAgICAqIGpvaW50IG9mIHRoZSBwYXRoLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCBUaGUgbWl0ZXIgbGltaXQgZm9yIHN0cm9rZSBvcGVyYXRpb25zIHVzaW5nIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIG1pdGVyIGpvaW4uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2V0TWl0ZXJMaW1pdCA9IGZ1bmN0aW9uKGxheWVyLCBsaW1pdCkge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBfX2Rpc3BsYXlfc2V0TWl0ZXJMaW1pdCgpIHtcclxuICAgICAgICAgICAgbGF5ZXIuc2V0TWl0ZXJMaW1pdChsaW1pdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgY29udGFpbmVyIGVudGlyZWx5LCBzdWNoIHRoYXQgaXQgaXMgbm8gbG9uZ2VyXHJcbiAgICAgKiBjb250YWluZWQgd2l0aGluIGl0cyBwYXJlbnQgbGF5ZXIsIGlmIGFueS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllcn0gbGF5ZXJcclxuICAgICAqICAgICBUaGUgbGF5ZXIgYmVpbmcgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UobGF5ZXIpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gZGlzcG9zZUxheWVyKCkge1xyXG4gICAgICAgICAgICBsYXllci5kaXNwb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gYWZmaW5lIHRyYW5zZm9ybSAoZGVmaW5lZCB3aXRoIHNpeCB2YWx1ZXMgZnJvbSB0aGVcclxuICAgICAqIHRyYW5zZm9ybSdzIG1hdHJpeCkgdG8gdGhlIGdpdmVuIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkRpc3BsYXkuVmlzaWJsZUxheWVyfSBsYXllclxyXG4gICAgICogICAgIFRoZSBsYXllciBiZWluZyBkaXN0b3J0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFcclxuICAgICAqICAgICBUaGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJcclxuICAgICAqICAgICBUaGUgc2Vjb25kIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjXHJcbiAgICAgKiAgICAgVGhlIHRoaXJkIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkXHJcbiAgICAgKiAgICAgVGhlIGZvdXJ0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZVxyXG4gICAgICogICAgIFRoZSBmaWZ0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZlxyXG4gICAgICogICAgIFRoZSBzaXh0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5kaXN0b3J0ID0gZnVuY3Rpb24gZGlzdG9ydChsYXllciwgYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgIHNjaGVkdWxlVGFzayhmdW5jdGlvbiBkaXN0b3J0TGF5ZXIoKSB7XHJcbiAgICAgICAgICAgIGxheWVyLmRpc3RvcnQoYSwgYiwgYywgZCwgZSwgZik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBnaXZlbiBsYXllciB0byB0aGUgZ2l2ZW4gWCBhbmQgWVxyXG4gICAgICogY29vcmRpbmF0ZSwgc2V0cyB0aGUgWiBzdGFja2luZyBvcmRlciwgYW5kIHJlcGFyZW50cyB0aGUgbGF5ZXJcclxuICAgICAqIHRvIHRoZSBnaXZlbiBwYXJlbnQgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ9IGxheWVyXHJcbiAgICAgKiAgICAgVGhlIGxheWVyIGJlaW5nIG1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkRpc3BsYXkuVmlzaWJsZUxheWVyfSBwYXJlbnRcclxuICAgICAqICAgICBUaGUgcGFyZW50IHRvIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogICAgIFRoZSBYIGNvb3JkaW5hdGUgdG8gbW92ZSB0by5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogICAgIFRoZSBZIGNvb3JkaW5hdGUgdG8gbW92ZSB0by5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gelxyXG4gICAgICogICAgIFRoZSBaIGNvb3JkaW5hdGUgdG8gbW92ZSB0by5cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb3ZlID0gZnVuY3Rpb24gbW92ZShsYXllciwgcGFyZW50LCB4LCB5LCB6KSB7XHJcbiAgICAgICAgc2NoZWR1bGVUYXNrKGZ1bmN0aW9uIG1vdmVMYXllcigpIHtcclxuICAgICAgICAgICAgbGF5ZXIubW92ZShwYXJlbnQsIHgsIHksIHopO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBnaXZlbiB2YWx1ZSwgd2hlcmUgMjU1IGlzXHJcbiAgICAgKiBmdWxseSBvcGFxdWUgYW5kIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ9IGxheWVyXHJcbiAgICAgKiAgICAgVGhlIGxheWVyIHdob3NlIG9wYWNpdHkgc2hvdWxkIGJlIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWxwaGFcclxuICAgICAqICAgICBUaGUgb3BhY2l0eSB0byBzZXQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2hhZGUgPSBmdW5jdGlvbiBzaGFkZShsYXllciwgYWxwaGEpIHtcclxuICAgICAgICBzY2hlZHVsZVRhc2soZnVuY3Rpb24gc2hhZGVMYXllcigpIHtcclxuICAgICAgICAgICAgbGF5ZXIuc2hhZGUoYWxwaGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjYWxlIG9mIHRoZSBjbGllbnQgZGlzcGxheSBlbGVtZW50IHN1Y2ggdGhhdCBpdCByZW5kZXJzIGF0XHJcbiAgICAgKiBhIHJlbGF0aXZlbHkgc21hbGxlciBvciBsYXJnZXIgc2l6ZSwgd2l0aG91dCBhZmZlY3RpbmcgdGhlIHRydWVcclxuICAgICAqIHJlc29sdXRpb24gb2YgdGhlIGRpc3BsYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIFRoZSBzY2FsZSB0byByZXNpemUgdG8sIHdoZXJlIDEuMCBpcyBub3JtYWxcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBzaXplICgxOjEgc2NhbGUpLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcclxuXHJcbiAgICAgICAgZGlzcGxheS5zdHlsZS50cmFuc2Zvcm0gPVxyXG4gICAgICAgIGRpc3BsYXkuc3R5bGUuV2Via2l0VHJhbnNmb3JtID1cclxuICAgICAgICBkaXNwbGF5LnN0eWxlLk1velRyYW5zZm9ybSA9XHJcbiAgICAgICAgZGlzcGxheS5zdHlsZS5PVHJhbnNmb3JtID1cclxuICAgICAgICBkaXNwbGF5LnN0eWxlLm1zVHJhbnNmb3JtID1cclxuXHJcbiAgICAgICAgICAgIFwic2NhbGUoXCIgKyBzY2FsZSArIFwiLFwiICsgc2NhbGUgKyBcIilcIjtcclxuXHJcbiAgICAgICAgZGlzcGxheVNjYWxlID0gc2NhbGU7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBib3VuZHMgc2l6ZVxyXG4gICAgICAgIGJvdW5kcy5zdHlsZS53aWR0aCA9IChkaXNwbGF5V2lkdGgqZGlzcGxheVNjYWxlKSArIFwicHhcIjtcclxuICAgICAgICBib3VuZHMuc3R5bGUuaGVpZ2h0ID0gKGRpc3BsYXlIZWlnaHQqZGlzcGxheVNjYWxlKSArIFwicHhcIjtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2NhbGUgb2YgdGhlIGRpc3BsYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2NhbGUgb2YgdGhlIGRpc3BsYXkuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0U2NhbGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gZGlzcGxheVNjYWxlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjYW52YXMgZWxlbWVudCBjb250YWluaW5nIHRoZSBlbnRpcmUgZGlzcGxheSwgd2l0aCBhbGwgY2hpbGRcclxuICAgICAqIGxheWVycyBjb21wb3NpdGVkIHdpdGhpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQSBuZXcgY2FudmFzIGVsZW1lbnQgY29udGFpbmluZyBhIGNvcHkgb2ZcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZGlzcGxheS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5mbGF0dGVuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICBcclxuICAgICAgICAvLyBHZXQgZGVzdGluYXRpb24gY2FudmFzXHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gZGVmYXVsdF9sYXllci53aWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGVmYXVsdF9sYXllci5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyBzb3J0ZWQgYXJyYXkgb2YgY2hpbGRyZW5cclxuICAgICAgICBmdW5jdGlvbiBnZXRfY2hpbGRyZW4obGF5ZXIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIGFycmF5IG9mIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCBpbiBsYXllci5jaGlsZHJlbilcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobGF5ZXIuY2hpbGRyZW5baW5kZXhdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvcnRcclxuICAgICAgICAgICAgY2hpbGRyZW4uc29ydChmdW5jdGlvbiBjaGlsZHJlbl9jb21wYXJhdG9yKGEsIGIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGJhc2VkIG9uIFogb3JkZXJcclxuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gYS56IC0gYi56O1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgIT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmY7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgWiBvcmRlciBpZGVudGljYWwsIHVzZSBkb2N1bWVudCBvcmRlclxyXG4gICAgICAgICAgICAgICAgdmFyIGFfZWxlbWVudCA9IGEuZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJfZWxlbWVudCA9IGIuZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gYl9lbGVtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGFfZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcpIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HKSByZXR1cm4gIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgc2FtZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIERvbmVcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXdzIHRoZSBjb250ZW50cyBvZiB0aGUgZ2l2ZW4gbGF5ZXIgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgZnVuY3Rpb24gZHJhd19sYXllcihsYXllciwgeCwgeSkge1xyXG5cclxuICAgICAgICAgICAgLy8gRHJhdyBsYXllclxyXG4gICAgICAgICAgICBpZiAobGF5ZXIud2lkdGggPiAwICYmIGxheWVyLmhlaWdodCA+IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTYXZlIGFuZCB1cGRhdGUgYWxwaGFcclxuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsX2FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgKj0gbGF5ZXIuYWxwaGEgLyAyNTUuMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IGRhdGFcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGxheWVyLmdldENhbnZhcygpLCB4LCB5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEcmF3IGFsbCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZ2V0X2NoaWxkcmVuKGxheWVyKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYXdfbGF5ZXIoY2hpbGQsIHggKyBjaGlsZC54LCB5ICsgY2hpbGQueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBhbHBoYVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGluaXRpYWxfYWxwaGE7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhdyBkZWZhdWx0IGxheWVyIGFuZCBhbGwgY2hpbGRyZW5cclxuICAgICAgICBkcmF3X2xheWVyKGRlZmF1bHRfbGF5ZXIsIDAsIDApO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gbmV3IGNhbnZhcyBjb3B5XHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgICAgICBcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNpbXBsZSBjb250YWluZXIgZm9yIEd1YWNhbW9sZS5MYXllciwgYWxsb3dpbmcgbGF5ZXJzIHRvIGJlIGVhc2lseVxyXG4gKiByZXBvc2l0aW9uZWQgYW5kIG5lc3RlZC4gVGhpcyBhbGxvd3MgY2VydGFpbiBvcGVyYXRpb25zIHRvIGJlIGFjY2VsZXJhdGVkXHJcbiAqIHRocm91Z2ggRE9NIG1hbmlwdWxhdGlvbiwgcmF0aGVyIHRoYW4gcmFzdGVyIG9wZXJhdGlvbnMuXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1Z21lbnRzIEd1YWNhbW9sZS5MYXllclxyXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBMYXllciwgaW4gcGl4ZWxzLiBUaGUgY2FudmFzIGVsZW1lbnRcclxuICogICAgICAgICAgICAgICAgICAgICAgIGJhY2tpbmcgdGhpcyBMYXllciB3aWxsIGJlIGdpdmVuIHRoaXMgd2lkdGguXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgTGF5ZXIsIGluIHBpeGVscy4gVGhlIGNhbnZhcyBlbGVtZW50XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgYmFja2luZyB0aGlzIExheWVyIHdpbGwgYmUgZ2l2ZW4gdGhpcyBoZWlnaHQuXHJcbiAqL1xyXG5HdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXIgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcblxyXG4gICAgR3VhY2Ftb2xlLkxheWVyLmFwcGx5KHRoaXMsIFt3aWR0aCwgaGVpZ2h0XSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBsYXllci5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBsYXllciA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZGVudGlmaWVyIHdoaWNoIHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhpcyBsYXllci4gVGhpcyBpcyBDT01QTEVURUxZXHJcbiAgICAgKiBVTlJFTEFURUQgdG8gdGhlIGluZGV4IG9mIHRoZSB1bmRlcmx5aW5nIGxheWVyLCB3aGljaCBpcyBzcGVjaWZpY1xyXG4gICAgICogdG8gdGhlIEd1YWNhbW9sZSBwcm90b2NvbCwgYW5kIG5vdCByZWxldmFudCBhdCB0aGlzIGxldmVsLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fX3VuaXF1ZV9pZCA9IEd1YWNhbW9sZS5EaXNwbGF5LlZpc2libGVMYXllci5fX25leHRfaWQrKztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBsYXllciBjb250YWluZXIsIHdoZXJlIDI1NSBpcyBmdWxseSBvcGFxdWUgYW5kIDAgaXNcclxuICAgICAqIGZ1bGx5IHRyYW5zcGFyZW50LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmFscGhhID0gMHhGRjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhpcyBsYXllciBjb250YWluZXIgd2l0aGluXHJcbiAgICAgKiBpdHMgcGFyZW50LCBpbiBwaXhlbHMuXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnggPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGlzIGxheWVyIGNvbnRhaW5lciB3aXRoaW5cclxuICAgICAqIGl0cyBwYXJlbnQsIGluIHBpeGVscy5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMueSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBaIHN0YWNraW5nIG9yZGVyIG9mIHRoaXMgbGF5ZXIgcmVsYXRpdmUgdG8gb3RoZXIgc2libGluZyBsYXllcnMuXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnogPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkIHRvIHRoaXMgbGF5ZXIgY29udGFpbmVyLiBFYWNoIGVsZW1lbnRcclxuICAgICAqIGNvcnJlc3BvbmRzIHRvIGEgdmFsdWUgZnJvbSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4LCB3aXRoIHRoZSBmaXJzdFxyXG4gICAgICogdGhyZWUgdmFsdWVzIGJlaW5nIHRoZSBmaXJzdCByb3csIGFuZCB0aGUgbGFzdCB0aHJlZSB2YWx1ZXMgYmVpbmcgdGhlXHJcbiAgICAgKiBzZWNvbmQgcm93LiBUaGVyZSBhcmUgc2l4IHZhbHVlcyB0b3RhbC5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge051bWJlcltdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1hdHJpeCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwYXJlbnQgbGF5ZXIgY29udGFpbmVyIG9mIHRoaXMgbGF5ZXIsIGlmIGFueS5cclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvZiBhbGwgY2hpbGRyZW4gb2YgdGhpcyBsYXllciwgaW5kZXhlZCBieSBsYXllciBpbmRleC4gVGhpcyBvYmplY3RcclxuICAgICAqIHdpbGwgaGF2ZSBvbmUgcHJvcGVydHkgcGVyIGNoaWxkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNoaWxkcmVuID0ge307XHJcblxyXG4gICAgLy8gU2V0IGxheWVyIHBvc2l0aW9uXHJcbiAgICB2YXIgY2FudmFzID0gbGF5ZXIuZ2V0Q2FudmFzKCk7XHJcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9IFwiMHB4XCI7XHJcbiAgICBjYW52YXMuc3R5bGUudG9wID0gXCIwcHhcIjtcclxuXHJcbiAgICAvLyBDcmVhdGUgZGl2IHdpdGggZ2l2ZW4gc2l6ZVxyXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICBkaXYuYXBwZW5kQ2hpbGQoY2FudmFzKTtcclxuICAgIGRpdi5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xyXG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcclxuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgIGRpdi5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcclxuICAgIGRpdi5zdHlsZS50b3AgPSBcIjBweFwiO1xyXG4gICAgZGl2LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1cGVyY2xhc3MgcmVzaXplKCkgZnVuY3Rpb24uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgX19zdXBlcl9yZXNpemUgPSB0aGlzLnJlc2l6ZTtcclxuXHJcbiAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcbiAgICAgICAgLy8gUmVzaXplIGNvbnRhaW5pbmcgZGl2XHJcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcclxuXHJcbiAgICAgICAgX19zdXBlcl9yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgfTtcclxuICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBjYW52YXMgYW5kIGFueSBvdGhlciBlbGVtZW50c1xyXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH0gVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGlzIGxheWVyJ3MgY2FudmFzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gZGl2O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgdGhpcyBsYXllcidzIHRyYW5zZm9ybS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciB0cmFuc2xhdGUgPSBcInRyYW5zbGF0ZSgwcHgsIDBweClcIjsgLy8gKDAsIDApXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXJiaXRyYXJ5IG1hdHJpeCBjb21wb25lbnQgb2YgdGhpcyBsYXllcidzIHRyYW5zZm9ybS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBtYXRyaXggPSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiOyAvLyBJZGVudGl0eVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoaXMgbGF5ZXIgdG8gdGhlIGdpdmVuIFggYW5kIFlcclxuICAgICAqIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgdG8gbW92ZSB0by5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgdG8gbW92ZSB0by5cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5KSB7XHJcblxyXG4gICAgICAgIGxheWVyLnggPSB4O1xyXG4gICAgICAgIGxheWVyLnkgPSB5O1xyXG5cclxuICAgICAgICAvLyBHZW5lcmF0ZSB0cmFuc2xhdGlvblxyXG4gICAgICAgIHRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgeCArIFwicHgsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyB5ICsgXCJweClcIjtcclxuXHJcbiAgICAgICAgLy8gU2V0IGxheWVyIHRyYW5zZm9ybSBcclxuICAgICAgICBkaXYuc3R5bGUudHJhbnNmb3JtID1cclxuICAgICAgICBkaXYuc3R5bGUuV2Via2l0VHJhbnNmb3JtID1cclxuICAgICAgICBkaXYuc3R5bGUuTW96VHJhbnNmb3JtID1cclxuICAgICAgICBkaXYuc3R5bGUuT1RyYW5zZm9ybSA9XHJcbiAgICAgICAgZGl2LnN0eWxlLm1zVHJhbnNmb3JtID1cclxuXHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZSArIFwiIFwiICsgbWF0cml4O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhpcyBWaXNpYmxlTGF5ZXIgdG8gdGhlIGdpdmVuIFggYW5kIFlcclxuICAgICAqIGNvb3JkaW5hdGUsIHNldHMgdGhlIFogc3RhY2tpbmcgb3JkZXIsIGFuZCByZXBhcmVudHMgdGhpcyBWaXNpYmxlTGF5ZXJcclxuICAgICAqIHRvIHRoZSBnaXZlbiBWaXNpYmxlTGF5ZXIuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkRpc3BsYXkuVmlzaWJsZUxheWVyfSBwYXJlbnQgVGhlIHBhcmVudCB0byBzZXQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIHRvIG1vdmUgdG8uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIHRvIG1vdmUgdG8uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geiBUaGUgWiBjb29yZGluYXRlIHRvIG1vdmUgdG8uXHJcbiAgICAgKi9cclxuICAgIHRoaXMubW92ZSA9IGZ1bmN0aW9uKHBhcmVudCwgeCwgeSwgeikge1xyXG5cclxuICAgICAgICAvLyBTZXQgcGFyZW50IGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIGlmIChsYXllci5wYXJlbnQgIT09IHBhcmVudCkge1xyXG5cclxuICAgICAgICAgICAgLy8gTWFpbnRhaW4gcmVsYXRpb25zaGlwXHJcbiAgICAgICAgICAgIGlmIChsYXllci5wYXJlbnQpXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbGF5ZXIucGFyZW50LmNoaWxkcmVuW2xheWVyLl9fdW5pcXVlX2lkXTtcclxuICAgICAgICAgICAgbGF5ZXIucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5bbGF5ZXIuX191bmlxdWVfaWRdID0gbGF5ZXI7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXBhcmVudCBlbGVtZW50XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRfZWxlbWVudCA9IHBhcmVudC5nZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIHBhcmVudF9lbGVtZW50LmFwcGVuZENoaWxkKGRpdik7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2V0IGxvY2F0aW9uXHJcbiAgICAgICAgbGF5ZXIudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgIGxheWVyLnogPSB6O1xyXG4gICAgICAgIGRpdi5zdHlsZS56SW5kZXggPSB6O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoaXMgbGF5ZXIgdG8gdGhlIGdpdmVuIHZhbHVlLCB3aGVyZSAyNTUgaXMgZnVsbHlcclxuICAgICAqIG9wYXF1ZSBhbmQgMCBpcyBmdWxseSB0cmFuc3BhcmVudC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIG9wYWNpdHkgdG8gc2V0LlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNoYWRlID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgIGxheWVyLmFscGhhID0gYTtcclxuICAgICAgICBkaXYuc3R5bGUub3BhY2l0eSA9IGEvMjU1LjA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGlzIGxheWVyIGNvbnRhaW5lciBlbnRpcmVseSwgc3VjaCB0aGF0IGl0IGlzIG5vIGxvbmdlclxyXG4gICAgICogY29udGFpbmVkIHdpdGhpbiBpdHMgcGFyZW50IGxheWVyLCBpZiBhbnkuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgZnJvbSBwYXJlbnQgY29udGFpbmVyXHJcbiAgICAgICAgaWYgKGxheWVyLnBhcmVudCkge1xyXG4gICAgICAgICAgICBkZWxldGUgbGF5ZXIucGFyZW50LmNoaWxkcmVuW2xheWVyLl9fdW5pcXVlX2lkXTtcclxuICAgICAgICAgICAgbGF5ZXIucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHBhcmVudCBlbGVtZW50XHJcbiAgICAgICAgaWYgKGRpdi5wYXJlbnROb2RlKVxyXG4gICAgICAgICAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xyXG4gICAgICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIGFmZmluZSB0cmFuc2Zvcm0gKGRlZmluZWQgd2l0aCBzaXggdmFsdWVzIGZyb20gdGhlXHJcbiAgICAgKiB0cmFuc2Zvcm0ncyBtYXRyaXgpLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIHRoaXJkIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVGhlIGZvdXJ0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlIFRoZSBmaWZ0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmIFRoZSBzaXh0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5kaXN0b3J0ID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xyXG5cclxuICAgICAgICAvLyBTdG9yZSBtYXRyaXhcclxuICAgICAgICBsYXllci5tYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XHJcblxyXG4gICAgICAgIC8vIEdlbmVyYXRlIG1hdHJpeCB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIG1hdHJpeCA9XHJcblxyXG4gICAgICAgICAgICAvKiBhIGMgZVxyXG4gICAgICAgICAgICAgKiBiIGQgZlxyXG4gICAgICAgICAgICAgKiAwIDAgMVxyXG4gICAgICAgICAgICAgKi9cclxuICAgIFxyXG4gICAgICAgICAgICBcIm1hdHJpeChcIiArIGEgKyBcIixcIiArIGIgKyBcIixcIiArIGMgKyBcIixcIiArIGQgKyBcIixcIiArIGUgKyBcIixcIiArIGYgKyBcIilcIjtcclxuXHJcbiAgICAgICAgLy8gU2V0IGxheWVyIHRyYW5zZm9ybSBcclxuICAgICAgICBkaXYuc3R5bGUudHJhbnNmb3JtID1cclxuICAgICAgICBkaXYuc3R5bGUuV2Via2l0VHJhbnNmb3JtID1cclxuICAgICAgICBkaXYuc3R5bGUuTW96VHJhbnNmb3JtID1cclxuICAgICAgICBkaXYuc3R5bGUuT1RyYW5zZm9ybSA9XHJcbiAgICAgICAgZGl2LnN0eWxlLm1zVHJhbnNmb3JtID1cclxuXHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZSArIFwiIFwiICsgbWF0cml4O1xyXG5cclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBuZXh0IGlkZW50aWZpZXIgdG8gYmUgYXNzaWduZWQgdG8gdGhlIGxheWVyIGNvbnRhaW5lci4gVGhpcyBpZGVudGlmaWVyXHJcbiAqIHVuaXF1ZWx5IGlkZW50aWZpZXMgZWFjaCBWaXNpYmxlTGF5ZXIsIGJ1dCBpcyB1bnJlbGF0ZWQgdG8gdGhlIGluZGV4IG9mXHJcbiAqIHRoZSBsYXllciwgd2hpY2ggZXhpc3RzIGF0IHRoZSBwcm90b2NvbC9jbGllbnQgbGV2ZWwgb25seS5cclxuICogXHJcbiAqIEBwcml2YXRlXHJcbiAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAqL1xyXG5HdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXIuX19uZXh0X2lkID0gMDtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgaGlkZGVuIGlucHV0IGZpZWxkIHdoaWNoIGF0dGVtcHRzIHRvIGtlZXAgaXRzZWxmIGZvY3VzZWQgYXQgYWxsIHRpbWVzLFxyXG4gKiBleGNlcHQgd2hlbiBhbm90aGVyIGlucHV0IGZpZWxkIGhhcyBiZWVuIGludGVudGlvbmFsbHkgZm9jdXNlZCwgd2hldGhlclxyXG4gKiBwcm9ncmFtYXRpY2FsbHkgb3IgYnkgdGhlIHVzZXIuIFRoZSBhY3R1YWwgdW5kZXJseWluZyBpbnB1dCBmaWVsZCwgcmV0dXJuZWRcclxuICogYnkgZ2V0RWxlbWVudCgpLCBtYXkgYmUgdXNlZCBhcyBhIHJlbGlhYmxlIHNvdXJjZSBvZiBrZXlib2FyZC1yZWxhdGVkIGV2ZW50cyxcclxuICogcGFydGljdWxhcmx5IGNvbXBvc2l0aW9uIGFuZCBpbnB1dCBldmVudHMgd2hpY2ggbWF5IHJlcXVpcmUgYSBmb2N1c2VkIGlucHV0XHJcbiAqIGZpZWxkIHRvIGJlIGRpc3BhdGNoZWQgYXQgYWxsLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbkd1YWNhbW9sZS5JbnB1dFNpbmsgPSBmdW5jdGlvbiBJbnB1dFNpbmsoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZSBvZiBHdWFjYW1vbGUuSW5wdXRTaW5rLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLklucHV0U2lua31cclxuICAgICAqL1xyXG4gICAgdmFyIHNpbmsgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHVuZGVybHlpbmcgaW5wdXQgZmllbGQsIHN0eWxlZCB0byBiZSBpbnZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB2YXIgZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xyXG4gICAgZmllbGQuc3R5bGUucG9zaXRpb24gICA9ICdmaXhlZCc7XHJcbiAgICBmaWVsZC5zdHlsZS5vdXRsaW5lICAgID0gJ25vbmUnO1xyXG4gICAgZmllbGQuc3R5bGUuYm9yZGVyICAgICA9ICdub25lJztcclxuICAgIGZpZWxkLnN0eWxlLm1hcmdpbiAgICAgPSAnMCc7XHJcbiAgICBmaWVsZC5zdHlsZS5wYWRkaW5nICAgID0gJzAnO1xyXG4gICAgZmllbGQuc3R5bGUuaGVpZ2h0ICAgICA9ICcwJztcclxuICAgIGZpZWxkLnN0eWxlLndpZHRoICAgICAgPSAnMCc7XHJcbiAgICBmaWVsZC5zdHlsZS5sZWZ0ICAgICAgID0gJzAnO1xyXG4gICAgZmllbGQuc3R5bGUuYm90dG9tICAgICA9ICcwJztcclxuICAgIGZpZWxkLnN0eWxlLnJlc2l6ZSAgICAgPSAnbm9uZSc7XHJcbiAgICBmaWVsZC5zdHlsZS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcclxuICAgIGZpZWxkLnN0eWxlLmNvbG9yICAgICAgPSAndHJhbnNwYXJlbnQnO1xyXG5cclxuICAgIC8vIEtlZXAgZmllbGQgY2xlYXIgd2hlbiBtb2RpZmllZCB2aWEgbm9ybWFsIGtleXByZXNzZXNcclxuICAgIGZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCBmdW5jdGlvbiBjbGVhcktleXByZXNzKGUpIHtcclxuICAgICAgICBmaWVsZC52YWx1ZSA9ICcnO1xyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIC8vIEtlZXAgZmllbGQgY2xlYXIgd2hlbiBtb2RvZmllZCB2aWEgY29tcG9zaXRpb24gZXZlbnRzXHJcbiAgICBmaWVsZC5hZGRFdmVudExpc3RlbmVyKFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24gY2xlYXJDb21wbGV0ZWRDb21wb3NpdGlvbihlKSB7XHJcbiAgICAgICAgaWYgKGUuZGF0YSlcclxuICAgICAgICAgICAgZmllbGQudmFsdWUgPSAnJztcclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAvLyBLZWVwIGZpZWxkIGNsZWFyIHdoZW4gbW9kb2ZpZWQgdmlhIGlucHV0IGV2ZW50c1xyXG4gICAgZmllbGQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIGNsZWFyQ29tcGxldGVkSW5wdXQoZSkge1xyXG4gICAgICAgIGlmIChlLmRhdGEgJiYgIWUuaXNDb21wb3NpbmcpXHJcbiAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gJyc7XHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgLy8gV2hlbmV2ZXIgZm9jdXMgaXMgZ2FpbmVkLCBhdXRvbWF0aWNhbGx5IGNsaWNrIHRvIGVuc3VyZSBjdXJzb3IgaXNcclxuICAgIC8vIGFjdHVhbGx5IHBsYWNlZCB3aXRoaW4gdGhlIGZpZWxkICh0aGUgZmllbGQgbWF5IHNpbXBseSBiZSBoaWdobGlnaHRlZCBvclxyXG4gICAgLy8gb3V0bGluZWQgb3RoZXJ3aXNlKVxyXG4gICAgZmllbGQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGZ1bmN0aW9uIGZvY3VzUmVjZWl2ZWQoKSB7XHJcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gZGVmZXJSZWZvY3VzKCkge1xyXG4gICAgICAgICAgICBmaWVsZC5jbGljaygpO1xyXG4gICAgICAgICAgICBmaWVsZC5zZWxlY3QoKTtcclxuICAgICAgICB9LCAwKTtcclxuICAgIH0sIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gZm9jdXMgdGhlIHVuZGVybHlpbmcgaW5wdXQgZmllbGQuIFRoZSBmb2N1cyBhdHRlbXB0IG9jY3Vyc1xyXG4gICAgICogYXN5bmNocm9ub3VzbHksIGFuZCBtYXkgc2lsZW50bHkgZmFpbCBkZXBlbmRpbmcgb24gYnJvd3NlciByZXN0cmljdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZm9jdXMgPSBmdW5jdGlvbiBmb2N1cygpIHtcclxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiBkZWZlclJlZm9jdXMoKSB7XHJcbiAgICAgICAgICAgIGZpZWxkLmZvY3VzKCk7IC8vIEZvY3VzIG11c3QgYmUgZGVmZXJyZWQgdG8gd29yayByZWxpYWJseSBhY3Jvc3MgYnJvd3NlcnNcclxuICAgICAgICB9LCAwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGlucHV0IGZpZWxkLiBUaGlzIGlucHV0IGZpZWxkIE1VU1QgYmUgbWFudWFsbHlcclxuICAgICAqIGFkZGVkIHRvIHRoZSBET00gZm9yIHRoZSBHdWFjYW1vbGUuSW5wdXRTaW5rIHRvIGhhdmUgYW55IGVmZmVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcclxuICAgICAgICByZXR1cm4gZmllbGQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVmb2N1cyBpbnB1dCBzaW5rIGlmIHBhcnQgb2YgRE9NXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiByZWZvY3VzU2luayhlKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCByZWZvY3VzIGlmIGZvY3VzIGlzIG9uIGFuIGlucHV0IGZpZWxkXHJcbiAgICAgICAgdmFyIGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgICAgIGlmIChmb2N1c2VkICYmIGZvY3VzZWQgIT09IGRvY3VtZW50LmJvZHkpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgY29uc2lkZXIgZm9jdXNlZCBpbnB1dCBmaWVsZHMgd2hpY2ggYXJlIGFjdHVhbGx5IHZpc2libGVcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBmb2N1c2VkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICBpZiAocmVjdC5sZWZ0ICsgcmVjdC53aWR0aCA+IDAgJiYgcmVjdC50b3AgKyByZWN0LmhlaWdodCA+IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVmb2N1cyBpbnB1dCBzaW5rIGluc3RlYWQgb2YgaGFuZGxpbmcgY2xpY2tcclxuICAgICAgICBzaW5rLmZvY3VzKCk7XHJcblxyXG4gICAgfSwgdHJ1ZSk7XHJcblxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQW4gaW5wdXQgc3RyZWFtIGFic3RyYWN0aW9uIHVzZWQgYnkgdGhlIEd1YWNhbW9sZSBjbGllbnQgdG8gZmFjaWxpdGF0ZVxyXG4gKiB0cmFuc2ZlciBvZiBmaWxlcyBvciBvdGhlciBiaW5hcnkgZGF0YS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0d1YWNhbW9sZS5DbGllbnR9IGNsaWVudCBUaGUgY2xpZW50IG93bmluZyB0aGlzIHN0cmVhbS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGlzIHN0cmVhbS5cclxuICovXHJcbkd1YWNhbW9sZS5JbnB1dFN0cmVhbSA9IGZ1bmN0aW9uKGNsaWVudCwgaW5kZXgpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIHN0cmVhbS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX3N0cmVhbSA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhpcyBzdHJlYW0uXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiBhIGJsb2Igb2YgZGF0YSBpcyByZWNlaXZlZC5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBUaGUgcmVjZWl2ZWQgYmFzZTY0IGRhdGEuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25ibG9iID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoaXMgc3RyZWFtIGlzIGNsb3NlZC5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHRoaXMub25lbmQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWNrbm93bGVkZ2VzIHRoZSByZWNlaXB0IG9mIGEgYmxvYi5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgQSBodW1hbi1yZWFkYWJsZSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGVycm9yXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBvciBzdGF0dXMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgZXJyb3IgY29kZSwgaWYgYW55LCBvciAwIGZvciBzdWNjZXNzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlbmRBY2sgPSBmdW5jdGlvbihtZXNzYWdlLCBjb2RlKSB7XHJcbiAgICAgICAgY2xpZW50LnNlbmRBY2soZ3VhY19zdHJlYW0uaW5kZXgsIG1lc3NhZ2UsIGNvZGUpO1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlZ2VyIHBvb2wgd2hpY2ggcmV0dXJucyBjb25zaXN0ZW50bHkgaW5jcmVhc2luZyBpbnRlZ2VycyB3aGlsZSBpbnRlZ2Vyc1xyXG4gKiBhcmUgaW4gdXNlLCBhbmQgcHJldmlvdXNseS11c2VkIGludGVnZXJzIHdoZW4gcG9zc2libGUuXHJcbiAqIEBjb25zdHJ1Y3RvciBcclxuICovXHJcbkd1YWNhbW9sZS5JbnRlZ2VyUG9vbCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgaW50ZWdlciBwb29sLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX3Bvb2wgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2YgYXZhaWxhYmxlIGludGVnZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XHJcbiAgICAgKi9cclxuICAgIHZhciBwb29sID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmV4dCBpbnRlZ2VyIHRvIHJldHVybiBpZiBubyBtb3JlIGludGVnZXJzIHJlbWFpbi5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmV4dF9pbnQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBhdmFpbGFibGUgaW50ZWdlciBpbiB0aGUgcG9vbC4gSWYgcG9zc2libGUsIGEgcHJldmlvdXNseVxyXG4gICAgICogdXNlZCBpbnRlZ2VyIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG5leHQgYXZhaWxhYmxlIGludGVnZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMubmV4dCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBJZiBmcmVlJ2QgaW50ZWdlcnMgZXhpc3QsIHJldHVybiBvbmUgb2YgdGhvc2VcclxuICAgICAgICBpZiAocG9vbC5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICByZXR1cm4gcG9vbC5zaGlmdCgpO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHJldHVybiBhIG5ldyBpbnRlZ2VyXHJcbiAgICAgICAgcmV0dXJuIGd1YWNfcG9vbC5uZXh0X2ludCsrO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGcmVlcyB0aGUgZ2l2ZW4gaW50ZWdlciwgYWxsb3dpbmcgaXQgdG8gYmUgcmV1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW50ZWdlciBUaGUgaW50ZWdlciB0byBmcmVlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmZyZWUgPSBmdW5jdGlvbihpbnRlZ2VyKSB7XHJcbiAgICAgICAgcG9vbC5wdXNoKGludGVnZXIpO1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIHJlYWRlciB3aGljaCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgdGhlIGdpdmVuIGlucHV0IHN0cmVhbSwgYXNzZW1ibGluZyBhbGxcclxuICogcmVjZWl2ZWQgYmxvYnMgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0IGJ5IGFwcGVuZGluZyB0aGVtIHRvIGVhY2ggb3RoZXIsIGluXHJcbiAqIG9yZGVyLCBhbmQgZGVjb2RpbmcgdGhlIHJlc3VsdCBhcyBKU09OLiBOb3RlIHRoYXQgdGhpcyBvYmplY3Qgd2lsbCBvdmVyd3JpdGVcclxuICogYW55IGluc3RhbGxlZCBldmVudCBoYW5kbGVycyBvbiB0aGUgZ2l2ZW4gR3VhY2Ftb2xlLklucHV0U3RyZWFtLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLklucHV0U3RyZWFtfSBzdHJlYW1cclxuICogICAgIFRoZSBzdHJlYW0gdGhhdCBKU09OIHdpbGwgYmUgcmVhZCBmcm9tLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkpTT05SZWFkZXIgPSBmdW5jdGlvbiBndWFjYW1vbGVKU09OUmVhZGVyKHN0cmVhbSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLkpTT05SZWFkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuSlNPTlJlYWRlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNSZWFkZXIgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JhcHBlZCBHdWFjYW1vbGUuU3RyaW5nUmVhZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLlN0cmluZ1JlYWRlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIHN0cmluZ1JlYWRlciA9IG5ldyBHdWFjYW1vbGUuU3RyaW5nUmVhZGVyKHN0cmVhbSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgSlNPTiByZWFkIHRodXMgZmFyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB2YXIganNvbiA9ICcnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhpcyBHdWFjYW1vbGUuSlNPTlJlYWRlciwgaW4gY2hhcmFjdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKiAgICAgVGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoaXMgR3VhY2Ftb2xlLkpTT05SZWFkZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiBqc29uLmxlbmd0aDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGlzIEd1YWNhbW9sZS5KU09OUmVhZGVyIGFzIGEgSmF2YVNjcmlwdFxyXG4gICAgICogb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICAqICAgICBUaGUgY29udGVudHMgb2YgdGhpcyBHdWFjYW1vbGUuSlNPTlJlYWRlciwgYXMgcGFyc2VkIGZyb20gdGhlIEpTT05cclxuICAgICAqICAgICBjb250ZW50cyBvZiB0aGUgaW5wdXQgc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldEpTT04gPSBmdW5jdGlvbiBnZXRKU09OKCkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBcHBlbmQgYWxsIHJlY2VpdmVkIHRleHRcclxuICAgIHN0cmluZ1JlYWRlci5vbnRleHQgPSBmdW5jdGlvbiBvbnRleHQodGV4dCkge1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgcmVjZWl2ZWQgdGV4dFxyXG4gICAgICAgIGpzb24gKz0gdGV4dDtcclxuXHJcbiAgICAgICAgLy8gQ2FsbCBoYW5kbGVyLCBpZiBwcmVzZW50XHJcbiAgICAgICAgaWYgKGd1YWNSZWFkZXIub25wcm9ncmVzcylcclxuICAgICAgICAgICAgZ3VhY1JlYWRlci5vbnByb2dyZXNzKHRleHQubGVuZ3RoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFNpbXBseSBjYWxsIG9uZW5kIHdoZW4gZW5kIHJlY2VpdmVkXHJcbiAgICBzdHJpbmdSZWFkZXIub25lbmQgPSBmdW5jdGlvbiBvbmVuZCgpIHtcclxuICAgICAgICBpZiAoZ3VhY1JlYWRlci5vbmVuZClcclxuICAgICAgICAgICAgZ3VhY1JlYWRlci5vbmVuZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIG9uY2UgZm9yIGV2ZXJ5IGJsb2Igb2YgZGF0YSByZWNlaXZlZC5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXHJcbiAgICAgKiAgICAgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHJlY2VpdmVkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgb25jZSB0aGlzIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgbm8gZnVydGhlciBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmVuZCA9IG51bGw7XHJcblxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgY3Jvc3MtYnJvd3NlciBhbmQgY3Jvc3Mta2V5Ym9hcmQga2V5Ym9hcmQgZm9yIGEgc3BlY2lmaWMgZWxlbWVudC5cclxuICogQnJvd3NlciBhbmQga2V5Ym9hcmQgbGF5b3V0IHZhcmlhdGlvbiBpcyBhYnN0cmFjdGVkIGF3YXksIHByb3ZpZGluZyBldmVudHNcclxuICogd2hpY2ggcmVwcmVzZW50IGtleXMgYXMgdGhlaXIgY29ycmVzcG9uZGluZyBYMTEga2V5c3ltLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudH0gW2VsZW1lbnRdXHJcbiAqICAgIFRoZSBFbGVtZW50IHRvIHVzZSB0byBwcm92aWRlIGtleWJvYXJkIGV2ZW50cy4gSWYgb21pdHRlZCwgYXQgbGVhc3Qgb25lXHJcbiAqICAgIEVsZW1lbnQgbXVzdCBiZSBtYW51YWxseSBwcm92aWRlZCB0aHJvdWdoIHRoZSBsaXN0ZW5UbygpIGZ1bmN0aW9uIGZvclxyXG4gKiAgICB0aGUgR3VhY2Ftb2xlLktleWJvYXJkIGluc3RhbmNlIHRvIGhhdmUgYW55IGVmZmVjdC5cclxuICovXHJcbkd1YWNhbW9sZS5LZXlib2FyZCA9IGZ1bmN0aW9uIEtleWJvYXJkKGVsZW1lbnQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIEd1YWNhbW9sZS5LZXlib2FyZC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX2tleWJvYXJkID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGludGVnZXIgdmFsdWUgd2hpY2ggdW5pcXVlbHkgaWRlbnRpZmllcyB0aGlzIEd1YWNhbW9sZS5LZXlib2FyZFxyXG4gICAgICogaW5zdGFuY2Ugd2l0aCByZXNwZWN0IHRvIG90aGVyIEd1YWNhbW9sZS5LZXlib2FyZCBpbnN0YW5jZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjS2V5Ym9hcmRJRCA9IEd1YWNhbW9sZS5LZXlib2FyZC5fbmV4dElEKys7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2hpY2ggaXMgYWRkZWQgdG8gZXZlbnQgb2JqZWN0cyB2aWEgbWFya0V2ZW50KClcclxuICAgICAqIHRvIG5vdGUgdGhhdCB0aGV5IGhhdmUgYWxyZWFkeSBiZWVuIGhhbmRsZWQgYnkgdGhpcyBHdWFjYW1vbGUuS2V5Ym9hcmQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdmFyIEVWRU5UX01BUktFUiA9ICdfR1VBQ19LRVlCT0FSRF9IQU5ETEVEX0JZXycgKyBndWFjS2V5Ym9hcmRJRDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgd2l0aCB0aGUgZWxlbWVudCBhc3NvY2lhdGVkXHJcbiAgICAgKiB3aXRoIHRoaXMgR3VhY2Ftb2xlLktleWJvYXJkIGluIGZvY3VzLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrZXlzeW0gVGhlIGtleXN5bSBvZiB0aGUga2V5IGJlaW5nIHByZXNzZWQuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBrZXkgZXZlbnQgc2hvdWxkIGJlIGFsbG93ZWQgdGhyb3VnaCB0byB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgIGJyb3dzZXIsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmtleWRvd24gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgd2l0aCB0aGUgZWxlbWVudCBhc3NvY2lhdGVkXHJcbiAgICAgKiB3aXRoIHRoaXMgR3VhY2Ftb2xlLktleWJvYXJkIGluIGZvY3VzLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrZXlzeW0gVGhlIGtleXN5bSBvZiB0aGUga2V5IGJlaW5nIHJlbGVhc2VkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm9ua2V5dXAgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9mIGtub3duIHBsYXRmb3JtLXNwZWNpZmljIG9yIGJyb3dzZXItc3BlY2lmaWMgcXVpcmtzIHdoaWNoIG11c3QgYmVcclxuICAgICAqIGFjY291bnRlZCBmb3IgdG8gcHJvcGVybHkgaW50ZXJwcmV0IGtleSBldmVudHMsIGV2ZW4gaWYgdGhlIG9ubHkgd2F5IHRvXHJcbiAgICAgKiByZWxpYWJseSBkZXRlY3QgdGhhdCBxdWlyayBpcyB0byBwbGF0Zm9ybS9icm93c2VyLXNuaWZmLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIEJvb2xlYW4+fVxyXG4gICAgICovXHJcbiAgICB2YXIgcXVpcmtzID0ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIGtleXVwIGV2ZW50cyBhcmUgdW5pdmVyc2FsbHkgdW5yZWxpYWJsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGtleXVwVW5yZWxpYWJsZTogZmFsc2UsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIEFsdCBrZXkgaXMgYWN0dWFsbHkgYSBtb2RpZmllciBmb3IgdHlwYWJsZSBrZXlzIGFuZCBpc1xyXG4gICAgICAgICAqIHRodXMgbmV2ZXIgdXNlZCBmb3Iga2V5Ym9hcmQgc2hvcnRjdXRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWx0SXNUeXBhYmxlT25seTogZmFsc2UsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgd2UgY2FuIHJlbHkgb24gcmVjZWl2aW5nIGEga2V5dXAgZXZlbnQgZm9yIHRoZSBDYXBzIExvY2tcclxuICAgICAgICAgKiBrZXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjYXBzTG9ja0tleXVwVW5yZWxpYWJsZTogZmFsc2VcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFNldCBxdWlyayBmbGFncyBkZXBlbmRpbmcgb24gcGxhdGZvcm0vYnJvd3NlciwgaWYgc3VjaCBpbmZvcm1hdGlvbiBpc1xyXG4gICAgLy8gYXZhaWxhYmxlXHJcbiAgICBpZiAobmF2aWdhdG9yICYmIG5hdmlnYXRvci5wbGF0Zm9ybSkge1xyXG5cclxuICAgICAgICAvLyBBbGwga2V5dXAgZXZlbnRzIGFyZSB1bnJlbGlhYmxlIG9uIGlPUyAoc2FkbHkpXHJcbiAgICAgICAgaWYgKG5hdmlnYXRvci5wbGF0Zm9ybS5tYXRjaCgvaXBhZHxpcGhvbmV8aXBvZC9pKSlcclxuICAgICAgICAgICAgcXVpcmtzLmtleXVwVW5yZWxpYWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIFRoZSBBbHQga2V5IG9uIE1hYyBpcyBuZXZlciB1c2VkIGZvciBrZXlib2FyZCBzaG9ydGN1dHMsIGFuZCB0aGVcclxuICAgICAgICAvLyBDYXBzIExvY2sga2V5IG5ldmVyIGRpc3BhdGNoZXMga2V5dXAgZXZlbnRzXHJcbiAgICAgICAgZWxzZSBpZiAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKC9ebWFjL2kpKSB7XHJcbiAgICAgICAgICAgIHF1aXJrcy5hbHRJc1R5cGFibGVPbmx5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcXVpcmtzLmNhcHNMb2NrS2V5dXBVbnJlbGlhYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBrZXkgZXZlbnQgaGF2aW5nIGEgY29ycmVzcG9uZGluZyB0aW1lc3RhbXAuIFRoaXMgZXZlbnQgaXMgbm9uLXNwZWNpZmljLlxyXG4gICAgICogSXRzIHN1YmNsYXNzZXMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCB3aGVuIHJlY29yZGluZyBzcGVjaWZpYyBrZXlcclxuICAgICAqIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBLZXlFdmVudCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBrZXkgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGtleV9ldmVudCA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGFyYml0cmFyeSB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzLCBpbmRpY2F0aW5nIHRoaXMgZXZlbnQnc1xyXG4gICAgICAgICAqIHBvc2l0aW9uIGluIHRpbWUgcmVsYXRpdmUgdG8gb3RoZXIgZXZlbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGlzIGtleSBldmVudCBzaG91bGQgYmUgcHJldmVudGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBrZXlzeW0gb2YgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXkgZXZlbnQsIGFzIGRldGVybWluZWRcclxuICAgICAgICAgKiBieSBhIGJlc3QtZWZmb3J0IGd1ZXNzIHVzaW5nIGF2YWlsYWJsZSBldmVudCBwcm9wZXJ0aWVzIGFuZCBrZXlib2FyZFxyXG4gICAgICAgICAqIHN0YXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmtleXN5bSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGtleXN5bSB2YWx1ZSBvZiB0aGlzIGtleSBldmVudCBpcyBrbm93biB0byBiZSByZWxpYWJsZS5cclxuICAgICAgICAgKiBJZiBmYWxzZSwgdGhlIGtleXN5bSBtYXkgc3RpbGwgYmUgdmFsaWQsIGJ1dCBpdCdzIG9ubHkgYSBiZXN0IGd1ZXNzLFxyXG4gICAgICAgICAqIGFuZCBmdXR1cmUga2V5IGV2ZW50cyBtYXkgYmUgYSBiZXR0ZXIgc291cmNlIG9mIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZWxpYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhpcyBldmVudCB3YXNcclxuICAgICAgICAgKiByZWNlaXZlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGlzXHJcbiAgICAgICAgICogICAgICAgICAgICAgICAgICBldmVudCB3YXMgcmVjZWl2ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5nZXRBZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0ga2V5X2V2ZW50LnRpbWVzdGFtcDtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoZSBwcmVzc2luZyBvZiBhIGtleSwgd2hpY2ggbmVlZCBub3QgYmUgYSBrZXlcclxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCBhIHByaW50YWJsZSBjaGFyYWN0ZXIuIFRoZSBwcmVzZW5jZSBvciBhYnNlbmNlIG9mIGFueVxyXG4gICAgICogaW5mb3JtYXRpb24gd2l0aGluIHRoaXMgb2JqZWN0IGlzIGJyb3dzZXItZGVwZW5kZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBhdWdtZW50cyBHdWFjYW1vbGUuS2V5Ym9hcmQuS2V5RXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrZXlDb2RlIFRoZSBKYXZhU2NyaXB0IGtleSBjb2RlIG9mIHRoZSBrZXkgcHJlc3NlZC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlJZGVudGlmaWVyIFRoZSBsZWdhY3kgRE9NMyBcImtleUlkZW50aWZpZXJcIiBvZiB0aGUga2V5XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzc2VkLCBhcyBkZWZpbmVkIGF0OlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwOTA5MDgvI2V2ZW50cy1FdmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgc3RhbmRhcmQgbmFtZSBvZiB0aGUga2V5IHByZXNzZWQsIGFzIGRlZmluZWQgYXQ6XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLUtleWJvYXJkRXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhdGlvbiBUaGUgbG9jYXRpb24gb24gdGhlIGtleWJvYXJkIGNvcnJlc3BvbmRpbmcgdG9cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUga2V5IHByZXNzZWQsIGFzIGRlZmluZWQgYXQ6XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICovXHJcbiAgICB2YXIgS2V5ZG93bkV2ZW50ID0gZnVuY3Rpb24oa2V5Q29kZSwga2V5SWRlbnRpZmllciwga2V5LCBsb2NhdGlvbikge1xyXG5cclxuICAgICAgICAvLyBXZSBleHRlbmQgS2V5RXZlbnRcclxuICAgICAgICBLZXlFdmVudC5hcHBseSh0aGlzKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIEphdmFTY3JpcHQga2V5IGNvZGUgb2YgdGhlIGtleSBwcmVzc2VkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmtleUNvZGUgPSBrZXlDb2RlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGVnYWN5IERPTTMgXCJrZXlJZGVudGlmaWVyXCIgb2YgdGhlIGtleSBwcmVzc2VkLCBhcyBkZWZpbmVkIGF0OlxyXG4gICAgICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDkwOTA4LyNldmVudHMtRXZlbnRzLUtleWJvYXJkRXZlbnRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5rZXlJZGVudGlmaWVyID0ga2V5SWRlbnRpZmllcjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHN0YW5kYXJkIG5hbWUgb2YgdGhlIGtleSBwcmVzc2VkLCBhcyBkZWZpbmVkIGF0OlxyXG4gICAgICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLUtleWJvYXJkRXZlbnRcclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG9jYXRpb24gb24gdGhlIGtleWJvYXJkIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGtleSBwcmVzc2VkLCBhc1xyXG4gICAgICAgICAqIGRlZmluZWQgYXQ6XHJcbiAgICAgICAgICogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG5cclxuICAgICAgICAvLyBJZiBrZXkgaXMga25vd24gZnJvbSBrZXlDb2RlIG9yIERPTTMgYWxvbmUsIHVzZSB0aGF0XHJcbiAgICAgICAgdGhpcy5rZXlzeW0gPSAga2V5c3ltX2Zyb21fa2V5X2lkZW50aWZpZXIoa2V5LCBsb2NhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB8fCBrZXlzeW1fZnJvbV9rZXljb2RlKGtleUNvZGUsIGxvY2F0aW9uKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0aGUga2V5dXAgZm9sbG93aW5nIHRoaXMga2V5ZG93biBldmVudCBpcyBrbm93biB0byBiZVxyXG4gICAgICAgICAqIHJlbGlhYmxlLiBJZiBmYWxzZSwgd2UgY2Fubm90IHJlbHkgb24gdGhlIGtleXVwIGV2ZW50IHRvIG9jY3VyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5rZXl1cFJlbGlhYmxlID0gIXF1aXJrcy5rZXl1cFVucmVsaWFibGU7XHJcblxyXG4gICAgICAgIC8vIERPTTMgYW5kIGtleUNvZGUgYXJlIHJlbGlhYmxlIHNvdXJjZXMgaWYgdGhlIGNvcnJlc3BvbmRpbmcga2V5IGlzXHJcbiAgICAgICAgLy8gbm90IGEgcHJpbnRhYmxlIGtleVxyXG4gICAgICAgIGlmICh0aGlzLmtleXN5bSAmJiAhaXNQcmludGFibGUodGhpcy5rZXlzeW0pKVxyXG4gICAgICAgICAgICB0aGlzLnJlbGlhYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gVXNlIGxlZ2FjeSBrZXlJZGVudGlmaWVyIGFzIGEgbGFzdCByZXNvcnQsIGlmIGl0IGxvb2tzIHNhbmVcclxuICAgICAgICBpZiAoIXRoaXMua2V5c3ltICYmIGtleV9pZGVudGlmaWVyX3NhbmUoa2V5Q29kZSwga2V5SWRlbnRpZmllcikpXHJcbiAgICAgICAgICAgIHRoaXMua2V5c3ltID0ga2V5c3ltX2Zyb21fa2V5X2lkZW50aWZpZXIoa2V5SWRlbnRpZmllciwgbG9jYXRpb24sIGd1YWNfa2V5Ym9hcmQubW9kaWZpZXJzLnNoaWZ0KTtcclxuXHJcbiAgICAgICAgLy8gSWYgYSBrZXkgaXMgcHJlc3NlZCB3aGlsZSBtZXRhIGlzIGhlbGQgZG93biwgdGhlIGtleXVwIHdpbGxcclxuICAgICAgICAvLyBuZXZlciBiZSBzZW50IGluIENocm9tZSAoYnVnICMxMDg0MDQpXHJcbiAgICAgICAgaWYgKGd1YWNfa2V5Ym9hcmQubW9kaWZpZXJzLm1ldGEgJiYgdGhpcy5rZXlzeW0gIT09IDB4RkZFNyAmJiB0aGlzLmtleXN5bSAhPT0gMHhGRkU4KVxyXG4gICAgICAgICAgICB0aGlzLmtleXVwUmVsaWFibGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gV2UgY2Fubm90IHJlbHkgb24gcmVjZWl2aW5nIGtleXVwIGZvciBDYXBzIExvY2sgb24gY2VydGFpbiBwbGF0Zm9ybXNcclxuICAgICAgICBlbHNlIGlmICh0aGlzLmtleXN5bSA9PT0gMHhGRkU1ICYmIHF1aXJrcy5jYXBzTG9ja0tleXVwVW5yZWxpYWJsZSlcclxuICAgICAgICAgICAgdGhpcy5rZXl1cFJlbGlhYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIGRlZmF1bHQgYWN0aW9uIGZvciBBbHQrY29tYmluYXRpb25zIG11c3QgYmUgcHJldmVudGVkXHJcbiAgICAgICAgdmFyIHByZXZlbnRfYWx0ID0gIWd1YWNfa2V5Ym9hcmQubW9kaWZpZXJzLmN0cmwgJiYgIXF1aXJrcy5hbHRJc1R5cGFibGVPbmx5O1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBkZWZhdWx0IGFjdGlvbiBmb3IgQ3RybCtjb21iaW5hdGlvbnMgbXVzdCBiZSBwcmV2ZW50ZWRcclxuICAgICAgICB2YXIgcHJldmVudF9jdHJsID0gIWd1YWNfa2V5Ym9hcmQubW9kaWZpZXJzLmFsdDtcclxuXHJcbiAgICAgICAgLy8gV2UgbXVzdCByZWx5IG9uIHRoZSAocG90ZW50aWFsbHkgYnVnZ3kpIGtleUlkZW50aWZpZXIgaWYgcHJldmVudGluZ1xyXG4gICAgICAgIC8vIHRoZSBkZWZhdWx0IGFjdGlvbiBpcyBpbXBvcnRhbnRcclxuICAgICAgICBpZiAoKHByZXZlbnRfY3RybCAmJiBndWFjX2tleWJvYXJkLm1vZGlmaWVycy5jdHJsKVxyXG4gICAgICAgICB8fCAocHJldmVudF9hbHQgICYmIGd1YWNfa2V5Ym9hcmQubW9kaWZpZXJzLmFsdClcclxuICAgICAgICAgfHwgZ3VhY19rZXlib2FyZC5tb2RpZmllcnMubWV0YVxyXG4gICAgICAgICB8fCBndWFjX2tleWJvYXJkLm1vZGlmaWVycy5oeXBlcilcclxuICAgICAgICAgICAgdGhpcy5yZWxpYWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIFJlY29yZCBtb3N0IHJlY2VudGx5IGtub3duIGtleXN5bSBieSBhc3NvY2lhdGVkIGtleSBjb2RlXHJcbiAgICAgICAgcmVjZW50S2V5c3ltW2tleUNvZGVdID0gdGhpcy5rZXlzeW07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBLZXlkb3duRXZlbnQucHJvdG90eXBlID0gbmV3IEtleUV2ZW50KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoZSBwcmVzc2luZyBvZiBhIGtleSwgd2hpY2ggTVVTVCBiZVxyXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIGEgcHJpbnRhYmxlIGNoYXJhY3Rlci4gVGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgYW55XHJcbiAgICAgKiBpbmZvcm1hdGlvbiB3aXRoaW4gdGhpcyBvYmplY3QgaXMgYnJvd3Nlci1kZXBlbmRlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1Z21lbnRzIEd1YWNhbW9sZS5LZXlib2FyZC5LZXlFdmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJDb2RlIFRoZSBVbmljb2RlIGNvZGVwb2ludCBvZiB0aGUgY2hhcmFjdGVyIHRoYXRcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB3b3VsZCBiZSB0eXBlZCBieSB0aGUga2V5IHByZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciBLZXlwcmVzc0V2ZW50ID0gZnVuY3Rpb24oY2hhckNvZGUpIHtcclxuXHJcbiAgICAgICAgLy8gV2UgZXh0ZW5kIEtleUV2ZW50XHJcbiAgICAgICAgS2V5RXZlbnQuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBVbmljb2RlIGNvZGVwb2ludCBvZiB0aGUgY2hhcmFjdGVyIHRoYXQgd291bGQgYmUgdHlwZWQgYnkgdGhlXHJcbiAgICAgICAgICoga2V5IHByZXNzZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hhckNvZGUgPSBjaGFyQ29kZTtcclxuXHJcbiAgICAgICAgLy8gUHVsbCBrZXlzeW0gZnJvbSBjaGFyIGNvZGVcclxuICAgICAgICB0aGlzLmtleXN5bSA9IGtleXN5bV9mcm9tX2NoYXJjb2RlKGNoYXJDb2RlKTtcclxuXHJcbiAgICAgICAgLy8gS2V5cHJlc3MgaXMgYWx3YXlzIHJlbGlhYmxlXHJcbiAgICAgICAgdGhpcy5yZWxpYWJsZSA9IHRydWU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBLZXlwcmVzc0V2ZW50LnByb3RvdHlwZSA9IG5ldyBLZXlFdmVudCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5mb3JtYXRpb24gcmVsYXRlZCB0byB0aGUgcHJlc3Npbmcgb2YgYSBrZXksIHdoaWNoIG5lZWQgbm90IGJlIGEga2V5XHJcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggYSBwcmludGFibGUgY2hhcmFjdGVyLiBUaGUgcHJlc2VuY2Ugb3IgYWJzZW5jZSBvZiBhbnlcclxuICAgICAqIGluZm9ybWF0aW9uIHdpdGhpbiB0aGlzIG9iamVjdCBpcyBicm93c2VyLWRlcGVuZGVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAYXVnbWVudHMgR3VhY2Ftb2xlLktleWJvYXJkLktleUV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga2V5Q29kZSBUaGUgSmF2YVNjcmlwdCBrZXkgY29kZSBvZiB0aGUga2V5IHJlbGVhc2VkLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleUlkZW50aWZpZXIgVGhlIGxlZ2FjeSBET00zIFwia2V5SWRlbnRpZmllclwiIG9mIHRoZSBrZXlcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VkLCBhcyBkZWZpbmVkIGF0OlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwOTA5MDgvI2V2ZW50cy1FdmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgc3RhbmRhcmQgbmFtZSBvZiB0aGUga2V5IHJlbGVhc2VkLCBhcyBkZWZpbmVkIGF0OlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1LZXlib2FyZEV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbG9jYXRpb24gVGhlIGxvY2F0aW9uIG9uIHRoZSBrZXlib2FyZCBjb3JyZXNwb25kaW5nIHRvXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGtleSByZWxlYXNlZCwgYXMgZGVmaW5lZCBhdDpcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1LZXlib2FyZEV2ZW50XHJcbiAgICAgKi9cclxuICAgIHZhciBLZXl1cEV2ZW50ID0gZnVuY3Rpb24oa2V5Q29kZSwga2V5SWRlbnRpZmllciwga2V5LCBsb2NhdGlvbikge1xyXG5cclxuICAgICAgICAvLyBXZSBleHRlbmQgS2V5RXZlbnRcclxuICAgICAgICBLZXlFdmVudC5hcHBseSh0aGlzKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIEphdmFTY3JpcHQga2V5IGNvZGUgb2YgdGhlIGtleSByZWxlYXNlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5rZXlDb2RlID0ga2V5Q29kZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxlZ2FjeSBET00zIFwia2V5SWRlbnRpZmllclwiIG9mIHRoZSBrZXkgcmVsZWFzZWQsIGFzIGRlZmluZWQgYXQ6XHJcbiAgICAgICAgICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwOTA5MDgvI2V2ZW50cy1FdmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmtleUlkZW50aWZpZXIgPSBrZXlJZGVudGlmaWVyO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc3RhbmRhcmQgbmFtZSBvZiB0aGUga2V5IHJlbGVhc2VkLCBhcyBkZWZpbmVkIGF0OlxyXG4gICAgICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLUtleWJvYXJkRXZlbnRcclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG9jYXRpb24gb24gdGhlIGtleWJvYXJkIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGtleSByZWxlYXNlZCwgYXNcclxuICAgICAgICAgKiBkZWZpbmVkIGF0OlxyXG4gICAgICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLUtleWJvYXJkRXZlbnRcclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcclxuXHJcbiAgICAgICAgLy8gSWYga2V5IGlzIGtub3duIGZyb20ga2V5Q29kZSBvciBET00zIGFsb25lLCB1c2UgdGhhdFxyXG4gICAgICAgIHRoaXMua2V5c3ltID0gIGtleXN5bV9mcm9tX2tleWNvZGUoa2V5Q29kZSwgbG9jYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgfHwga2V5c3ltX2Zyb21fa2V5X2lkZW50aWZpZXIoa2V5LCBsb2NhdGlvbik7IC8vIGtleUNvZGUgaXMgc3RpbGwgbW9yZSByZWxpYWJsZSBmb3Iga2V5dXAgd2hlbiBkZWFkIGtleXMgYXJlIGluIHVzZVxyXG5cclxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIG1vc3QgcmVjZW50bHkgcHJlc3NlZCBrZXlzeW0gYXNzb2NpYXRlZCB3aXRoIHRoZVxyXG4gICAgICAgIC8vIGtleUNvZGUgaWYgdGhlIGluZmVycmVkIGtleSBkb2Vzbid0IHNlZW0gdG8gYWN0dWFsbHkgYmUgcHJlc3NlZFxyXG4gICAgICAgIGlmICghZ3VhY19rZXlib2FyZC5wcmVzc2VkW3RoaXMua2V5c3ltXSlcclxuICAgICAgICAgICAgdGhpcy5rZXlzeW0gPSByZWNlbnRLZXlzeW1ba2V5Q29kZV0gfHwgdGhpcy5rZXlzeW07XHJcblxyXG4gICAgICAgIC8vIEtleXVwIGlzIGFzIHJlbGlhYmxlIGFzIGl0IHdpbGwgZXZlciBiZVxyXG4gICAgICAgIHRoaXMucmVsaWFibGUgPSB0cnVlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgS2V5dXBFdmVudC5wcm90b3R5cGUgPSBuZXcgS2V5RXZlbnQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHJlY29yZGVkIGV2ZW50cywgd2hpY2ggY2FuIGJlIGluc3RhbmNlcyBvZiB0aGUgcHJpdmF0ZVxyXG4gICAgICogS2V5ZG93bkV2ZW50LCBLZXlwcmVzc0V2ZW50LCBhbmQgS2V5dXBFdmVudCBjbGFzc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7S2V5RXZlbnRbXX1cclxuICAgICAqL1xyXG4gICAgdmFyIGV2ZW50TG9nID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2Yga25vd24gSmF2YVNjcmlwdCBrZXljb2RlcyB3aGljaCBkbyBub3QgbWFwIHRvIHR5cGFibGUgY2hhcmFjdGVyc1xyXG4gICAgICogdG8gdGhlaXIgWDExIGtleXN5bSBlcXVpdmFsZW50cy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBrZXljb2RlS2V5c3ltcyA9IHtcclxuICAgICAgICA4OiAgIFsweEZGMDhdLCAvLyBiYWNrc3BhY2VcclxuICAgICAgICA5OiAgIFsweEZGMDldLCAvLyB0YWJcclxuICAgICAgICAxMjogIFsweEZGMEIsIDB4RkYwQiwgMHhGRjBCLCAweEZGQjVdLCAvLyBjbGVhciAgICAgICAvIEtQIDVcclxuICAgICAgICAxMzogIFsweEZGMERdLCAvLyBlbnRlclxyXG4gICAgICAgIDE2OiAgWzB4RkZFMSwgMHhGRkUxLCAweEZGRTJdLCAvLyBzaGlmdFxyXG4gICAgICAgIDE3OiAgWzB4RkZFMywgMHhGRkUzLCAweEZGRTRdLCAvLyBjdHJsXHJcbiAgICAgICAgMTg6ICBbMHhGRkU5LCAweEZGRTksIDB4RkUwM10sIC8vIGFsdFxyXG4gICAgICAgIDE5OiAgWzB4RkYxM10sIC8vIHBhdXNlL2JyZWFrXHJcbiAgICAgICAgMjA6ICBbMHhGRkU1XSwgLy8gY2FwcyBsb2NrXHJcbiAgICAgICAgMjc6ICBbMHhGRjFCXSwgLy8gZXNjYXBlXHJcbiAgICAgICAgMzI6ICBbMHgwMDIwXSwgLy8gc3BhY2VcclxuICAgICAgICAzMzogIFsweEZGNTUsIDB4RkY1NSwgMHhGRjU1LCAweEZGQjldLCAvLyBwYWdlIHVwICAgICAvIEtQIDlcclxuICAgICAgICAzNDogIFsweEZGNTYsIDB4RkY1NiwgMHhGRjU2LCAweEZGQjNdLCAvLyBwYWdlIGRvd24gICAvIEtQIDNcclxuICAgICAgICAzNTogIFsweEZGNTcsIDB4RkY1NywgMHhGRjU3LCAweEZGQjFdLCAvLyBlbmQgICAgICAgICAvIEtQIDFcclxuICAgICAgICAzNjogIFsweEZGNTAsIDB4RkY1MCwgMHhGRjUwLCAweEZGQjddLCAvLyBob21lICAgICAgICAvIEtQIDdcclxuICAgICAgICAzNzogIFsweEZGNTEsIDB4RkY1MSwgMHhGRjUxLCAweEZGQjRdLCAvLyBsZWZ0IGFycm93ICAvIEtQIDRcclxuICAgICAgICAzODogIFsweEZGNTIsIDB4RkY1MiwgMHhGRjUyLCAweEZGQjhdLCAvLyB1cCBhcnJvdyAgICAvIEtQIDhcclxuICAgICAgICAzOTogIFsweEZGNTMsIDB4RkY1MywgMHhGRjUzLCAweEZGQjZdLCAvLyByaWdodCBhcnJvdyAvIEtQIDZcclxuICAgICAgICA0MDogIFsweEZGNTQsIDB4RkY1NCwgMHhGRjU0LCAweEZGQjJdLCAvLyBkb3duIGFycm93ICAvIEtQIDJcclxuICAgICAgICA0NTogIFsweEZGNjMsIDB4RkY2MywgMHhGRjYzLCAweEZGQjBdLCAvLyBpbnNlcnQgICAgICAvIEtQIDBcclxuICAgICAgICA0NjogIFsweEZGRkYsIDB4RkZGRiwgMHhGRkZGLCAweEZGQUVdLCAvLyBkZWxldGUgICAgICAvIEtQIGRlY2ltYWxcclxuICAgICAgICA5MTogIFsweEZGRUJdLCAvLyBsZWZ0IHdpbmRvdyBrZXkgKGh5cGVyX2wpXHJcbiAgICAgICAgOTI6ICBbMHhGRjY3XSwgLy8gcmlnaHQgd2luZG93IGtleSAobWVudSBrZXk/KVxyXG4gICAgICAgIDkzOiAgbnVsbCwgICAgIC8vIHNlbGVjdCBrZXlcclxuICAgICAgICA5NjogIFsweEZGQjBdLCAvLyBLUCAwXHJcbiAgICAgICAgOTc6ICBbMHhGRkIxXSwgLy8gS1AgMVxyXG4gICAgICAgIDk4OiAgWzB4RkZCMl0sIC8vIEtQIDJcclxuICAgICAgICA5OTogIFsweEZGQjNdLCAvLyBLUCAzXHJcbiAgICAgICAgMTAwOiBbMHhGRkI0XSwgLy8gS1AgNFxyXG4gICAgICAgIDEwMTogWzB4RkZCNV0sIC8vIEtQIDVcclxuICAgICAgICAxMDI6IFsweEZGQjZdLCAvLyBLUCA2XHJcbiAgICAgICAgMTAzOiBbMHhGRkI3XSwgLy8gS1AgN1xyXG4gICAgICAgIDEwNDogWzB4RkZCOF0sIC8vIEtQIDhcclxuICAgICAgICAxMDU6IFsweEZGQjldLCAvLyBLUCA5XHJcbiAgICAgICAgMTA2OiBbMHhGRkFBXSwgLy8gS1AgbXVsdGlwbHlcclxuICAgICAgICAxMDc6IFsweEZGQUJdLCAvLyBLUCBhZGRcclxuICAgICAgICAxMDk6IFsweEZGQURdLCAvLyBLUCBzdWJ0cmFjdFxyXG4gICAgICAgIDExMDogWzB4RkZBRV0sIC8vIEtQIGRlY2ltYWxcclxuICAgICAgICAxMTE6IFsweEZGQUZdLCAvLyBLUCBkaXZpZGVcclxuICAgICAgICAxMTI6IFsweEZGQkVdLCAvLyBmMVxyXG4gICAgICAgIDExMzogWzB4RkZCRl0sIC8vIGYyXHJcbiAgICAgICAgMTE0OiBbMHhGRkMwXSwgLy8gZjNcclxuICAgICAgICAxMTU6IFsweEZGQzFdLCAvLyBmNFxyXG4gICAgICAgIDExNjogWzB4RkZDMl0sIC8vIGY1XHJcbiAgICAgICAgMTE3OiBbMHhGRkMzXSwgLy8gZjZcclxuICAgICAgICAxMTg6IFsweEZGQzRdLCAvLyBmN1xyXG4gICAgICAgIDExOTogWzB4RkZDNV0sIC8vIGY4XHJcbiAgICAgICAgMTIwOiBbMHhGRkM2XSwgLy8gZjlcclxuICAgICAgICAxMjE6IFsweEZGQzddLCAvLyBmMTBcclxuICAgICAgICAxMjI6IFsweEZGQzhdLCAvLyBmMTFcclxuICAgICAgICAxMjM6IFsweEZGQzldLCAvLyBmMTJcclxuICAgICAgICAxNDQ6IFsweEZGN0ZdLCAvLyBudW0gbG9ja1xyXG4gICAgICAgIDE0NTogWzB4RkYxNF0sIC8vIHNjcm9sbCBsb2NrXHJcbiAgICAgICAgMjI1OiBbMHhGRTAzXSAgLy8gYWx0Z3JhcGggKGlzb19sZXZlbDNfc2hpZnQpXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9mIGtub3duIEphdmFTY3JpcHQga2V5aWRlbnRpZmllcnMgd2hpY2ggZG8gbm90IG1hcCB0byB0eXBhYmxlXHJcbiAgICAgKiBjaGFyYWN0ZXJzIHRvIHRoZWlyIHVuc2hpZnRlZCBYMTEga2V5c3ltIGVxdWl2YWxlbnRzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGtleWlkZW50aWZpZXJfa2V5c3ltID0ge1xyXG4gICAgICAgIFwiQWdhaW5cIjogWzB4RkY2Nl0sXHJcbiAgICAgICAgXCJBbGxDYW5kaWRhdGVzXCI6IFsweEZGM0RdLFxyXG4gICAgICAgIFwiQWxwaGFudW1lcmljXCI6IFsweEZGMzBdLFxyXG4gICAgICAgIFwiQWx0XCI6IFsweEZGRTksIDB4RkZFOSwgMHhGRTAzXSxcclxuICAgICAgICBcIkF0dG5cIjogWzB4RkQwRV0sXHJcbiAgICAgICAgXCJBbHRHcmFwaFwiOiBbMHhGRTAzXSxcclxuICAgICAgICBcIkFycm93RG93blwiOiBbMHhGRjU0XSxcclxuICAgICAgICBcIkFycm93TGVmdFwiOiBbMHhGRjUxXSxcclxuICAgICAgICBcIkFycm93UmlnaHRcIjogWzB4RkY1M10sXHJcbiAgICAgICAgXCJBcnJvd1VwXCI6IFsweEZGNTJdLFxyXG4gICAgICAgIFwiQmFja3NwYWNlXCI6IFsweEZGMDhdLFxyXG4gICAgICAgIFwiQ2Fwc0xvY2tcIjogWzB4RkZFNV0sXHJcbiAgICAgICAgXCJDYW5jZWxcIjogWzB4RkY2OV0sXHJcbiAgICAgICAgXCJDbGVhclwiOiBbMHhGRjBCXSxcclxuICAgICAgICBcIkNvbnZlcnRcIjogWzB4RkYyMV0sXHJcbiAgICAgICAgXCJDb3B5XCI6IFsweEZEMTVdLFxyXG4gICAgICAgIFwiQ3JzZWxcIjogWzB4RkQxQ10sXHJcbiAgICAgICAgXCJDclNlbFwiOiBbMHhGRDFDXSxcclxuICAgICAgICBcIkNvZGVJbnB1dFwiOiBbMHhGRjM3XSxcclxuICAgICAgICBcIkNvbXBvc2VcIjogWzB4RkYyMF0sXHJcbiAgICAgICAgXCJDb250cm9sXCI6IFsweEZGRTMsIDB4RkZFMywgMHhGRkU0XSxcclxuICAgICAgICBcIkNvbnRleHRNZW51XCI6IFsweEZGNjddLFxyXG4gICAgICAgIFwiRGVsZXRlXCI6IFsweEZGRkZdLFxyXG4gICAgICAgIFwiRG93blwiOiBbMHhGRjU0XSxcclxuICAgICAgICBcIkVuZFwiOiBbMHhGRjU3XSxcclxuICAgICAgICBcIkVudGVyXCI6IFsweEZGMERdLFxyXG4gICAgICAgIFwiRXJhc2VFb2ZcIjogWzB4RkQwNl0sXHJcbiAgICAgICAgXCJFc2NhcGVcIjogWzB4RkYxQl0sXHJcbiAgICAgICAgXCJFeGVjdXRlXCI6IFsweEZGNjJdLFxyXG4gICAgICAgIFwiRXhzZWxcIjogWzB4RkQxRF0sXHJcbiAgICAgICAgXCJFeFNlbFwiOiBbMHhGRDFEXSxcclxuICAgICAgICBcIkYxXCI6IFsweEZGQkVdLFxyXG4gICAgICAgIFwiRjJcIjogWzB4RkZCRl0sXHJcbiAgICAgICAgXCJGM1wiOiBbMHhGRkMwXSxcclxuICAgICAgICBcIkY0XCI6IFsweEZGQzFdLFxyXG4gICAgICAgIFwiRjVcIjogWzB4RkZDMl0sXHJcbiAgICAgICAgXCJGNlwiOiBbMHhGRkMzXSxcclxuICAgICAgICBcIkY3XCI6IFsweEZGQzRdLFxyXG4gICAgICAgIFwiRjhcIjogWzB4RkZDNV0sXHJcbiAgICAgICAgXCJGOVwiOiBbMHhGRkM2XSxcclxuICAgICAgICBcIkYxMFwiOiBbMHhGRkM3XSxcclxuICAgICAgICBcIkYxMVwiOiBbMHhGRkM4XSxcclxuICAgICAgICBcIkYxMlwiOiBbMHhGRkM5XSxcclxuICAgICAgICBcIkYxM1wiOiBbMHhGRkNBXSxcclxuICAgICAgICBcIkYxNFwiOiBbMHhGRkNCXSxcclxuICAgICAgICBcIkYxNVwiOiBbMHhGRkNDXSxcclxuICAgICAgICBcIkYxNlwiOiBbMHhGRkNEXSxcclxuICAgICAgICBcIkYxN1wiOiBbMHhGRkNFXSxcclxuICAgICAgICBcIkYxOFwiOiBbMHhGRkNGXSxcclxuICAgICAgICBcIkYxOVwiOiBbMHhGRkQwXSxcclxuICAgICAgICBcIkYyMFwiOiBbMHhGRkQxXSxcclxuICAgICAgICBcIkYyMVwiOiBbMHhGRkQyXSxcclxuICAgICAgICBcIkYyMlwiOiBbMHhGRkQzXSxcclxuICAgICAgICBcIkYyM1wiOiBbMHhGRkQ0XSxcclxuICAgICAgICBcIkYyNFwiOiBbMHhGRkQ1XSxcclxuICAgICAgICBcIkZpbmRcIjogWzB4RkY2OF0sXHJcbiAgICAgICAgXCJHcm91cEZpcnN0XCI6IFsweEZFMENdLFxyXG4gICAgICAgIFwiR3JvdXBMYXN0XCI6IFsweEZFMEVdLFxyXG4gICAgICAgIFwiR3JvdXBOZXh0XCI6IFsweEZFMDhdLFxyXG4gICAgICAgIFwiR3JvdXBQcmV2aW91c1wiOiBbMHhGRTBBXSxcclxuICAgICAgICBcIkZ1bGxXaWR0aFwiOiBudWxsLFxyXG4gICAgICAgIFwiSGFsZldpZHRoXCI6IG51bGwsXHJcbiAgICAgICAgXCJIYW5ndWxNb2RlXCI6IFsweEZGMzFdLFxyXG4gICAgICAgIFwiSGFua2FrdVwiOiBbMHhGRjI5XSxcclxuICAgICAgICBcIkhhbmphTW9kZVwiOiBbMHhGRjM0XSxcclxuICAgICAgICBcIkhlbHBcIjogWzB4RkY2QV0sXHJcbiAgICAgICAgXCJIaXJhZ2FuYVwiOiBbMHhGRjI1XSxcclxuICAgICAgICBcIkhpcmFnYW5hS2F0YWthbmFcIjogWzB4RkYyN10sXHJcbiAgICAgICAgXCJIb21lXCI6IFsweEZGNTBdLFxyXG4gICAgICAgIFwiSHlwZXJcIjogWzB4RkZFRCwgMHhGRkVELCAweEZGRUVdLFxyXG4gICAgICAgIFwiSW5zZXJ0XCI6IFsweEZGNjNdLFxyXG4gICAgICAgIFwiSmFwYW5lc2VIaXJhZ2FuYVwiOiBbMHhGRjI1XSxcclxuICAgICAgICBcIkphcGFuZXNlS2F0YWthbmFcIjogWzB4RkYyNl0sXHJcbiAgICAgICAgXCJKYXBhbmVzZVJvbWFqaVwiOiBbMHhGRjI0XSxcclxuICAgICAgICBcIkp1bmphTW9kZVwiOiBbMHhGRjM4XSxcclxuICAgICAgICBcIkthbmFNb2RlXCI6IFsweEZGMkRdLFxyXG4gICAgICAgIFwiS2FuamlNb2RlXCI6IFsweEZGMjFdLFxyXG4gICAgICAgIFwiS2F0YWthbmFcIjogWzB4RkYyNl0sXHJcbiAgICAgICAgXCJMZWZ0XCI6IFsweEZGNTFdLFxyXG4gICAgICAgIFwiTWV0YVwiOiBbMHhGRkU3LCAweEZGRTcsIDB4RkZFOF0sXHJcbiAgICAgICAgXCJNb2RlQ2hhbmdlXCI6IFsweEZGN0VdLFxyXG4gICAgICAgIFwiTnVtTG9ja1wiOiBbMHhGRjdGXSxcclxuICAgICAgICBcIlBhZ2VEb3duXCI6IFsweEZGNTZdLFxyXG4gICAgICAgIFwiUGFnZVVwXCI6IFsweEZGNTVdLFxyXG4gICAgICAgIFwiUGF1c2VcIjogWzB4RkYxM10sXHJcbiAgICAgICAgXCJQbGF5XCI6IFsweEZEMTZdLFxyXG4gICAgICAgIFwiUHJldmlvdXNDYW5kaWRhdGVcIjogWzB4RkYzRV0sXHJcbiAgICAgICAgXCJQcmludFNjcmVlblwiOiBbMHhGRjYxXSxcclxuICAgICAgICBcIlJlZG9cIjogWzB4RkY2Nl0sXHJcbiAgICAgICAgXCJSaWdodFwiOiBbMHhGRjUzXSxcclxuICAgICAgICBcIlJvbWFuQ2hhcmFjdGVyc1wiOiBudWxsLFxyXG4gICAgICAgIFwiU2Nyb2xsXCI6IFsweEZGMTRdLFxyXG4gICAgICAgIFwiU2VsZWN0XCI6IFsweEZGNjBdLFxyXG4gICAgICAgIFwiU2VwYXJhdG9yXCI6IFsweEZGQUNdLFxyXG4gICAgICAgIFwiU2hpZnRcIjogWzB4RkZFMSwgMHhGRkUxLCAweEZGRTJdLFxyXG4gICAgICAgIFwiU2luZ2xlQ2FuZGlkYXRlXCI6IFsweEZGM0NdLFxyXG4gICAgICAgIFwiU3VwZXJcIjogWzB4RkZFQiwgMHhGRkVCLCAweEZGRUNdLFxyXG4gICAgICAgIFwiVGFiXCI6IFsweEZGMDldLFxyXG4gICAgICAgIFwiVUlLZXlJbnB1dERvd25BcnJvd1wiOiBbMHhGRjU0XSxcclxuICAgICAgICBcIlVJS2V5SW5wdXRFc2NhcGVcIjogWzB4RkYxQl0sXHJcbiAgICAgICAgXCJVSUtleUlucHV0TGVmdEFycm93XCI6IFsweEZGNTFdLFxyXG4gICAgICAgIFwiVUlLZXlJbnB1dFJpZ2h0QXJyb3dcIjogWzB4RkY1M10sXHJcbiAgICAgICAgXCJVSUtleUlucHV0VXBBcnJvd1wiOiBbMHhGRjUyXSxcclxuICAgICAgICBcIlVwXCI6IFsweEZGNTJdLFxyXG4gICAgICAgIFwiVW5kb1wiOiBbMHhGRjY1XSxcclxuICAgICAgICBcIldpblwiOiBbMHhGRkVCXSxcclxuICAgICAgICBcIlplbmtha3VcIjogWzB4RkYyOF0sXHJcbiAgICAgICAgXCJaZW5rYWt1SGFua2FrdVwiOiBbMHhGRjJBXVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBrZXlzeW1zIHdoaWNoIHNob3VsZCBub3QgcmVwZWF0IHdoZW4gaGVsZCBkb3duLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIG5vX3JlcGVhdCA9IHtcclxuICAgICAgICAweEZFMDM6IHRydWUsIC8vIElTTyBMZXZlbCAzIFNoaWZ0IChBbHRHcilcclxuICAgICAgICAweEZGRTE6IHRydWUsIC8vIExlZnQgc2hpZnRcclxuICAgICAgICAweEZGRTI6IHRydWUsIC8vIFJpZ2h0IHNoaWZ0XHJcbiAgICAgICAgMHhGRkUzOiB0cnVlLCAvLyBMZWZ0IGN0cmwgXHJcbiAgICAgICAgMHhGRkU0OiB0cnVlLCAvLyBSaWdodCBjdHJsIFxyXG4gICAgICAgIDB4RkZFNTogdHJ1ZSwgLy8gQ2FwcyBMb2NrXHJcbiAgICAgICAgMHhGRkU3OiB0cnVlLCAvLyBMZWZ0IG1ldGEgXHJcbiAgICAgICAgMHhGRkU4OiB0cnVlLCAvLyBSaWdodCBtZXRhIFxyXG4gICAgICAgIDB4RkZFOTogdHJ1ZSwgLy8gTGVmdCBhbHRcclxuICAgICAgICAweEZGRUE6IHRydWUsIC8vIFJpZ2h0IGFsdFxyXG4gICAgICAgIDB4RkZFQjogdHJ1ZSwgLy8gTGVmdCBoeXBlclxyXG4gICAgICAgIDB4RkZFQzogdHJ1ZSAgLy8gUmlnaHQgaHlwZXJcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgbW9kaWZpZXJzIGFuZCB0aGVpciBzdGF0ZXMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMubW9kaWZpZXJzID0gbmV3IEd1YWNhbW9sZS5LZXlib2FyZC5Nb2RpZmllclN0YXRlKCk7XHJcbiAgICAgICAgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdGF0ZSBvZiBldmVyeSBrZXksIGluZGV4ZWQgYnkga2V5c3ltLiBJZiBhIHBhcnRpY3VsYXIga2V5IGlzXHJcbiAgICAgKiBwcmVzc2VkLCB0aGUgdmFsdWUgb2YgcHJlc3NlZCBmb3IgdGhhdCBrZXlzeW0gd2lsbCBiZSB0cnVlLiBJZiBhIGtleVxyXG4gICAgICogaXMgbm90IGN1cnJlbnRseSBwcmVzc2VkLCBpdCB3aWxsIG5vdCBiZSBkZWZpbmVkLiBcclxuICAgICAqL1xyXG4gICAgdGhpcy5wcmVzc2VkID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3RhdGUgb2YgZXZlcnkga2V5LCBpbmRleGVkIGJ5IGtleXN5bSwgZm9yIHN0cmljdGx5IHRob3NlIGtleXMgd2hvc2VcclxuICAgICAqIHN0YXR1cyBoYXMgYmVlbiBpbmRpcmVjdGx5IGRldGVybWluZWQgdGhvcnVnaCBvYnNlcnZhdGlvbiBvZiBvdGhlciBrZXlcclxuICAgICAqIGV2ZW50cy4gSWYgYSBwYXJ0aWN1bGFyIGtleSBpcyBpbXBsaWNpdGx5IHByZXNzZWQsIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogaW1wbGljaXRseVByZXNzZWQgZm9yIHRoYXQga2V5c3ltIHdpbGwgYmUgdHJ1ZS4gSWYgYSBrZXlcclxuICAgICAqIGlzIG5vdCBjdXJyZW50bHkgaW1wbGljaXRseSBwcmVzc2VkICh0aGUga2V5IGlzIG5vdCBwcmVzc2VkIE9SIHRoZSBzdGF0ZVxyXG4gICAgICogb2YgdGhlIGtleSBpcyBleHBsaWNpdGx5IGtub3duKSwgaXQgd2lsbCBub3QgYmUgZGVmaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5bGUge09iamVjdC48TnVtYmVyLCBCb29sZWFuPn1cclxuICAgICAqL1xyXG4gICAgdmFyIGltcGxpY2l0bHlQcmVzc2VkID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGFzdCByZXN1bHQgb2YgY2FsbGluZyB0aGUgb25rZXlkb3duIGhhbmRsZXIgZm9yIGVhY2gga2V5LCBpbmRleGVkXHJcbiAgICAgKiBieSBrZXlzeW0uIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50L2FsbG93IGRlZmF1bHQgYWN0aW9ucyBmb3Iga2V5IGV2ZW50cyxcclxuICAgICAqIGV2ZW4gd2hlbiB0aGUgb25rZXlkb3duIGhhbmRsZXIgY2Fubm90IGJlIGNhbGxlZCBhZ2FpbiBiZWNhdXNlIHRoZSBrZXlcclxuICAgICAqIGlzICh0aGVvcmV0aWNhbGx5KSBzdGlsbCBwcmVzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBsYXN0X2tleWRvd25fcmVzdWx0ID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUga2V5c3ltIG1vc3QgcmVjZW50bHkgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4ga2V5Y29kZSB3aGVuIGtleWRvd25cclxuICAgICAqIGZpcmVkLiBUaGlzIG9iamVjdCBtYXBzIGtleWNvZGVzIHRvIGtleXN5bXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPE51bWJlciwgTnVtYmVyPn1cclxuICAgICAqL1xyXG4gICAgdmFyIHJlY2VudEtleXN5bSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGltZW91dCBiZWZvcmUga2V5IHJlcGVhdCBzdGFydHMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIga2V5X3JlcGVhdF90aW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVydmFsIHdoaWNoIHByZXNzZXMgYW5kIHJlbGVhc2VzIHRoZSBsYXN0IGtleSBwcmVzc2VkIHdoaWxlIHRoYXRcclxuICAgICAqIGtleSBpcyBzdGlsbCBiZWluZyBoZWxkIGRvd24uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIga2V5X3JlcGVhdF9pbnRlcnZhbCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBrZXlzeW1zIGluZGV4ZWQgYnkgbG9jYXRpb24sIHJldHVybnMgdGhlIGtleXN5bVxyXG4gICAgICogZm9yIHRoZSBnaXZlbiBsb2NhdGlvbiwgb3IgdGhlIGtleXN5bSBmb3IgdGhlIHN0YW5kYXJkIGxvY2F0aW9uIGlmXHJcbiAgICAgKiB1bmRlZmluZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBrZXlzeW1zXHJcbiAgICAgKiAgICAgQW4gYXJyYXkgb2Yga2V5c3ltcywgd2hlcmUgdGhlIGluZGV4IG9mIHRoZSBrZXlzeW0gaW4gdGhlIGFycmF5IGlzXHJcbiAgICAgKiAgICAgdGhlIGxvY2F0aW9uIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhdGlvblxyXG4gICAgICogICAgIFRoZSBsb2NhdGlvbiBvbiB0aGUga2V5Ym9hcmQgY29ycmVzcG9uZGluZyB0byB0aGUga2V5IHByZXNzZWQsIGFzXHJcbiAgICAgKiAgICAgZGVmaW5lZCBhdDogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtS2V5Ym9hcmRFdmVudFxyXG4gICAgICovXHJcbiAgICB2YXIgZ2V0X2tleXN5bSA9IGZ1bmN0aW9uIGdldF9rZXlzeW0oa2V5c3ltcywgbG9jYXRpb24pIHtcclxuXHJcbiAgICAgICAgaWYgKCFrZXlzeW1zKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGtleXN5bXNbbG9jYXRpb25dIHx8IGtleXN5bXNbMF07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBrZXlzeW0gY29ycmVzcG9uZHMgdG8gYSBwcmludGFibGUgY2hhcmFjdGVyLFxyXG4gICAgICogZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrZXlzeW1cclxuICAgICAqICAgICBUaGUga2V5c3ltIHRvIGNoZWNrLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogICAgIHRydWUgaWYgdGhlIGdpdmVuIGtleXN5bSBjb3JyZXNwb25kcyB0byBhIHByaW50YWJsZSBjaGFyYWN0ZXIsXHJcbiAgICAgKiAgICAgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgaXNQcmludGFibGUgPSBmdW5jdGlvbiBpc1ByaW50YWJsZShrZXlzeW0pIHtcclxuXHJcbiAgICAgICAgLy8gS2V5c3ltcyB3aXRoIFVuaWNvZGUgZXF1aXZhbGVudHMgYXJlIHByaW50YWJsZVxyXG4gICAgICAgIHJldHVybiAoa2V5c3ltID49IDB4MDAgJiYga2V5c3ltIDw9IDB4RkYpXHJcbiAgICAgICAgICAgIHx8IChrZXlzeW0gJiAweEZGRkYwMDAwKSA9PT0gMHgwMTAwMDAwMDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGtleXN5bV9mcm9tX2tleV9pZGVudGlmaWVyKGlkZW50aWZpZXIsIGxvY2F0aW9uLCBzaGlmdGVkKSB7XHJcblxyXG4gICAgICAgIGlmICghaWRlbnRpZmllcilcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIHZhciB0eXBlZENoYXJhY3RlcjtcclxuXHJcbiAgICAgICAgLy8gSWYgaWRlbnRpZmllciBpcyBVK3h4eHgsIGRlY29kZSBVbmljb2RlIGNoYXJhY3RlciBcclxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeExvY2F0aW9uID0gaWRlbnRpZmllci5pbmRleE9mKFwiVStcIik7XHJcbiAgICAgICAgaWYgKHVuaWNvZGVQcmVmaXhMb2NhdGlvbiA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBoZXggPSBpZGVudGlmaWVyLnN1YnN0cmluZyh1bmljb2RlUHJlZml4TG9jYXRpb24rMik7XHJcbiAgICAgICAgICAgIHR5cGVkQ2hhcmFjdGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBzaW5nbGUgY2hhcmFjdGVyIGFuZCBub3Qga2V5cGFkLCB1c2UgdGhhdCBhcyB0eXBlZCBjaGFyYWN0ZXJcclxuICAgICAgICBlbHNlIGlmIChpZGVudGlmaWVyLmxlbmd0aCA9PT0gMSAmJiBsb2NhdGlvbiAhPT0gMylcclxuICAgICAgICAgICAgdHlwZWRDaGFyYWN0ZXIgPSBpZGVudGlmaWVyO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGxvb2sgdXAgY29ycmVzcG9uZGluZyBrZXlzeW1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBnZXRfa2V5c3ltKGtleWlkZW50aWZpZXJfa2V5c3ltW2lkZW50aWZpZXJdLCBsb2NhdGlvbik7XHJcblxyXG4gICAgICAgIC8vIEFsdGVyIGNhc2UgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgaWYgKHNoaWZ0ZWQgPT09IHRydWUpXHJcbiAgICAgICAgICAgIHR5cGVkQ2hhcmFjdGVyID0gdHlwZWRDaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcclxuICAgICAgICBlbHNlIGlmIChzaGlmdGVkID09PSBmYWxzZSlcclxuICAgICAgICAgICAgdHlwZWRDaGFyYWN0ZXIgPSB0eXBlZENoYXJhY3Rlci50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICAvLyBHZXQgY29kZXBvaW50XHJcbiAgICAgICAgdmFyIGNvZGVwb2ludCA9IHR5cGVkQ2hhcmFjdGVyLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgcmV0dXJuIGtleXN5bV9mcm9tX2NoYXJjb2RlKGNvZGVwb2ludCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzQ29udHJvbENoYXJhY3Rlcihjb2RlcG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gY29kZXBvaW50IDw9IDB4MUYgfHwgKGNvZGVwb2ludCA+PSAweDdGICYmIGNvZGVwb2ludCA8PSAweDlGKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrZXlzeW1fZnJvbV9jaGFyY29kZShjb2RlcG9pbnQpIHtcclxuXHJcbiAgICAgICAgLy8gS2V5c3ltcyBmb3IgY29udHJvbCBjaGFyYWN0ZXJzXHJcbiAgICAgICAgaWYgKGlzQ29udHJvbENoYXJhY3Rlcihjb2RlcG9pbnQpKSByZXR1cm4gMHhGRjAwIHwgY29kZXBvaW50O1xyXG5cclxuICAgICAgICAvLyBLZXlzeW1zIGZvciBBU0NJSSBjaGFyc1xyXG4gICAgICAgIGlmIChjb2RlcG9pbnQgPj0gMHgwMDAwICYmIGNvZGVwb2ludCA8PSAweDAwRkYpXHJcbiAgICAgICAgICAgIHJldHVybiBjb2RlcG9pbnQ7XHJcblxyXG4gICAgICAgIC8vIEtleXN5bXMgZm9yIFVuaWNvZGVcclxuICAgICAgICBpZiAoY29kZXBvaW50ID49IDB4MDEwMCAmJiBjb2RlcG9pbnQgPD0gMHgxMEZGRkYpXHJcbiAgICAgICAgICAgIHJldHVybiAweDAxMDAwMDAwIHwgY29kZXBvaW50O1xyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24ga2V5c3ltX2Zyb21fa2V5Y29kZShrZXlDb2RlLCBsb2NhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBnZXRfa2V5c3ltKGtleWNvZGVLZXlzeW1zW2tleUNvZGVdLCBsb2NhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZXVyaXN0aWNhbGx5IGRldGVjdHMgaWYgdGhlIGxlZ2FjeSBrZXlJZGVudGlmaWVyIHByb3BlcnR5IG9mXHJcbiAgICAgKiBhIGtleWRvd24va2V5dXAgZXZlbnQgbG9va3MgaW5jb3JyZWN0bHkgZGVyaXZlZC4gQ2hyb21lLCBhbmRcclxuICAgICAqIHByZXN1bWFibHkgb3RoZXJzLCB3aWxsIHByb2R1Y2UgdGhlIGtleUlkZW50aWZpZXIgYnkgYXNzdW1pbmdcclxuICAgICAqIHRoZSBrZXlDb2RlIGlzIHRoZSBVbmljb2RlIGNvZGVwb2ludCBmb3IgdGhhdCBrZXkuIFRoaXMgaXMgbm90XHJcbiAgICAgKiBjb3JyZWN0IGluIGFsbCBjYXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtleUNvZGVcclxuICAgICAqICAgICBUaGUga2V5Q29kZSBmcm9tIGEgYnJvd3NlciBrZXlkb3duL2tleXVwIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlJZGVudGlmaWVyXHJcbiAgICAgKiAgICAgVGhlIGxlZ2FjeSBrZXlJZGVudGlmaWVyIGZyb20gYSBicm93c2VyIGtleWRvd24va2V5dXAgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKiAgICAgdHJ1ZSBpZiB0aGUga2V5SWRlbnRpZmllciBsb29rcyBzYW5lLCBmYWxzZSBpZiB0aGUga2V5SWRlbnRpZmllclxyXG4gICAgICogICAgIGFwcGVhcnMgaW5jb3JyZWN0bHkgZGVyaXZlZCBvciBpcyBtaXNzaW5nIGVudGlyZWx5LlxyXG4gICAgICovXHJcbiAgICB2YXIga2V5X2lkZW50aWZpZXJfc2FuZSA9IGZ1bmN0aW9uIGtleV9pZGVudGlmaWVyX3NhbmUoa2V5Q29kZSwga2V5SWRlbnRpZmllcikge1xyXG5cclxuICAgICAgICAvLyBNaXNzaW5nIGlkZW50aWZpZXIgaXMgbm90IHNhbmVcclxuICAgICAgICBpZiAoIWtleUlkZW50aWZpZXIpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gQXNzdW1lIG5vbi1Vbmljb2RlIGtleUlkZW50aWZpZXIgdmFsdWVzIGFyZSBzYW5lXHJcbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXhMb2NhdGlvbiA9IGtleUlkZW50aWZpZXIuaW5kZXhPZihcIlUrXCIpO1xyXG4gICAgICAgIGlmICh1bmljb2RlUHJlZml4TG9jYXRpb24gPT09IC0xKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIFVuaWNvZGUgY29kZXBvaW50IGlzbid0IGlkZW50aWNhbCB0byB0aGUga2V5Q29kZSxcclxuICAgICAgICAvLyB0aGVuIHRoZSBpZGVudGlmaWVyIGlzIGxpa2VseSBjb3JyZWN0XHJcbiAgICAgICAgdmFyIGNvZGVwb2ludCA9IHBhcnNlSW50KGtleUlkZW50aWZpZXIuc3Vic3RyaW5nKHVuaWNvZGVQcmVmaXhMb2NhdGlvbisyKSwgMTYpO1xyXG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBjb2RlcG9pbnQpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAvLyBUaGUga2V5Q29kZXMgZm9yIEEtWiBhbmQgMC05IGFyZSBhY3R1YWxseSBpZGVudGljYWwgdG8gdGhlaXJcclxuICAgICAgICAvLyBVbmljb2RlIGNvZGVwb2ludHNcclxuICAgICAgICBpZiAoKGtleUNvZGUgPj0gNjUgJiYga2V5Q29kZSA8PSA5MCkgfHwgKGtleUNvZGUgPj0gNDggJiYga2V5Q29kZSA8PSA1NykpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAvLyBUaGUga2V5SWRlbnRpZmllciBkb2VzIE5PVCBhcHBlYXIgc2FuZVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFya3MgYSBrZXkgYXMgcHJlc3NlZCwgZmlyaW5nIHRoZSBrZXlkb3duIGV2ZW50IGlmIHJlZ2lzdGVyZWQuIEtleVxyXG4gICAgICogcmVwZWF0IGZvciB0aGUgcHJlc3NlZCBrZXkgd2lsbCBzdGFydCBhZnRlciBhIGRlbGF5IGlmIHRoYXQga2V5IGlzXHJcbiAgICAgKiBub3QgYSBtb2RpZmllci4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGRlcGVuZHMgb24gdGhlXHJcbiAgICAgKiByZXR1cm4gdmFsdWUgb2YgdGhlIGtleWRvd24gZXZlbnQgaGFuZGxlciwgaWYgYW55LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga2V5c3ltIFRoZSBrZXlzeW0gb2YgdGhlIGtleSB0byBwcmVzcy5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgZXZlbnQgc2hvdWxkIE5PVCBiZSBjYW5jZWxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnByZXNzID0gZnVuY3Rpb24oa2V5c3ltKSB7XHJcblxyXG4gICAgICAgIC8vIERvbid0IGJvdGhlciB3aXRoIHByZXNzaW5nIHRoZSBrZXkgaWYgdGhlIGtleSBpcyB1bmtub3duXHJcbiAgICAgICAgaWYgKGtleXN5bSA9PT0gbnVsbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBPbmx5IHByZXNzIGlmIHJlbGVhc2VkXHJcbiAgICAgICAgaWYgKCFndWFjX2tleWJvYXJkLnByZXNzZWRba2V5c3ltXSkge1xyXG5cclxuICAgICAgICAgICAgLy8gTWFyayBrZXkgYXMgcHJlc3NlZFxyXG4gICAgICAgICAgICBndWFjX2tleWJvYXJkLnByZXNzZWRba2V5c3ltXSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBTZW5kIGtleSBldmVudFxyXG4gICAgICAgICAgICBpZiAoZ3VhY19rZXlib2FyZC5vbmtleWRvd24pIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBndWFjX2tleWJvYXJkLm9ua2V5ZG93bihrZXlzeW0pO1xyXG4gICAgICAgICAgICAgICAgbGFzdF9rZXlkb3duX3Jlc3VsdFtrZXlzeW1dID0gcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0b3AgYW55IGN1cnJlbnQgcmVwZWF0XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGtleV9yZXBlYXRfdGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChrZXlfcmVwZWF0X2ludGVydmFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXBlYXQgYWZ0ZXIgYSBkZWxheSBhcyBsb25nIGFzIHByZXNzZWRcclxuICAgICAgICAgICAgICAgIGlmICghbm9fcmVwZWF0W2tleXN5bV0pXHJcbiAgICAgICAgICAgICAgICAgICAga2V5X3JlcGVhdF90aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleV9yZXBlYXRfaW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFjX2tleWJvYXJkLm9ua2V5dXAoa2V5c3ltKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQub25rZXlkb3duKGtleXN5bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCA1MDApO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJldHVybiB0aGUgbGFzdCBrZXlkb3duIHJlc3VsdCBieSBkZWZhdWx0LCByZXNvcnQgdG8gZmFsc2UgaWYgdW5rbm93blxyXG4gICAgICAgIHJldHVybiBsYXN0X2tleWRvd25fcmVzdWx0W2tleXN5bV0gfHwgZmFsc2U7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcmtzIGEga2V5IGFzIHJlbGVhc2VkLCBmaXJpbmcgdGhlIGtleXVwIGV2ZW50IGlmIHJlZ2lzdGVyZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrZXlzeW0gVGhlIGtleXN5bSBvZiB0aGUga2V5IHRvIHJlbGVhc2UuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZSA9IGZ1bmN0aW9uKGtleXN5bSkge1xyXG5cclxuICAgICAgICAvLyBPbmx5IHJlbGVhc2UgaWYgcHJlc3NlZFxyXG4gICAgICAgIGlmIChndWFjX2tleWJvYXJkLnByZXNzZWRba2V5c3ltXSkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gTWFyayBrZXkgYXMgcmVsZWFzZWRcclxuICAgICAgICAgICAgZGVsZXRlIGd1YWNfa2V5Ym9hcmQucHJlc3NlZFtrZXlzeW1dO1xyXG4gICAgICAgICAgICBkZWxldGUgaW1wbGljaXRseVByZXNzZWRba2V5c3ltXTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0b3AgcmVwZWF0XHJcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoa2V5X3JlcGVhdF90aW1lb3V0KTtcclxuICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoa2V5X3JlcGVhdF9pbnRlcnZhbCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZW5kIGtleSBldmVudFxyXG4gICAgICAgICAgICBpZiAoa2V5c3ltICE9PSBudWxsICYmIGd1YWNfa2V5Ym9hcmQub25rZXl1cClcclxuICAgICAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQub25rZXl1cChrZXlzeW0pO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByZXNzZXMgYW5kIHJlbGVhc2VzIHRoZSBrZXlzIG5lY2Vzc2FyeSB0byB0eXBlIHRoZSBnaXZlbiBzdHJpbmcgb2ZcclxuICAgICAqIHRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gICAgICogICAgIFRoZSBzdHJpbmcgdG8gdHlwZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy50eXBlID0gZnVuY3Rpb24gdHlwZShzdHIpIHtcclxuXHJcbiAgICAgICAgLy8gUHJlc3MvcmVsZWFzZSB0aGUga2V5IGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZ1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUga2V5c3ltIG9mIGN1cnJlbnQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgIHZhciBjb2RlcG9pbnQgPSBzdHIuY29kZVBvaW50QXQgPyBzdHIuY29kZVBvaW50QXQoaSkgOiBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgdmFyIGtleXN5bSA9IGtleXN5bV9mcm9tX2NoYXJjb2RlKGNvZGVwb2ludCk7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmVzcyBhbmQgcmVsZWFzZSBrZXkgZm9yIGN1cnJlbnQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQucHJlc3Moa2V5c3ltKTtcclxuICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5yZWxlYXNlKGtleXN5bSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBzdGF0ZSBvZiB0aGlzIGtleWJvYXJkLCByZWxlYXNpbmcgYWxsIGtleXMsIGFuZCBmaXJpbmcga2V5dXBcclxuICAgICAqIGV2ZW50cyBmb3IgZWFjaCByZWxlYXNlZCBrZXkuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLy8gUmVsZWFzZSBhbGwgcHJlc3NlZCBrZXlzXHJcbiAgICAgICAgZm9yICh2YXIga2V5c3ltIGluIGd1YWNfa2V5Ym9hcmQucHJlc3NlZClcclxuICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5yZWxlYXNlKHBhcnNlSW50KGtleXN5bSkpO1xyXG5cclxuICAgICAgICAvLyBDbGVhciBldmVudCBsb2dcclxuICAgICAgICBldmVudExvZyA9IFtdO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiB0aGUgcmVtb3RlIGFuZCBsb2NhbCBzdGF0ZSBvZiBhIHBhcnRpY3VsYXIga2V5LCByZXN5bmNocm9uaXplcyB0aGVcclxuICAgICAqIHJlbW90ZSBzdGF0ZSBvZiB0aGF0IGtleSB3aXRoIHRoZSBsb2NhbCBzdGF0ZSB0aHJvdWdoIHByZXNzaW5nIG9yXHJcbiAgICAgKiByZWxlYXNpbmcga2V5c3ltcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdGVTdGF0ZVxyXG4gICAgICogICAgIFdoZXRoZXIgdGhlIGtleSBpcyBjdXJyZW50bHkgcHJlc3NlZCByZW1vdGVseS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxvY2FsU3RhdGVcclxuICAgICAqICAgICBXaGV0aGVyIHRoZSBrZXkgaXMgY3VycmVudGx5IHByZXNzZWQgcmVtb3RlbHkgbG9jYWxseS4gSWYgdGhlIHN0YXRlXHJcbiAgICAgKiAgICAgb2YgdGhlIGtleSBpcyBub3Qga25vd24sIHRoaXMgbWF5IGJlIHVuZGVmaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBrZXlzeW1zXHJcbiAgICAgKiAgICAgVGhlIGtleXN5bXMgd2hpY2ggcmVwcmVzZW50IHRoZSBrZXkgYmVpbmcgdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0tleUV2ZW50fSBrZXlFdmVudFxyXG4gICAgICogICAgIEd1YWNhbW9sZSdzIGN1cnJlbnQgYmVzdCBpbnRlcnByZXRhdGlvbiBvZiB0aGUga2V5IGV2ZW50IGJlaW5nXHJcbiAgICAgKiAgICAgcHJvY2Vzc2VkLlxyXG4gICAgICovXHJcbiAgICB2YXIgdXBkYXRlTW9kaWZpZXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU1vZGlmaWVyU3RhdGUocmVtb3RlU3RhdGUsXHJcbiAgICAgICAgbG9jYWxTdGF0ZSwga2V5c3ltcywga2V5RXZlbnQpIHtcclxuXHJcbiAgICAgICAgdmFyIGk7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCB0cnVzdCBjaGFuZ2VzIGluIG1vZGlmaWVyIHN0YXRlIGZvciBldmVudHMgZGlyZWN0bHkgaW52b2x2aW5nXHJcbiAgICAgICAgLy8gdGhhdCBtb2RpZmllcjogKDEpIHRoZSBmbGFnIG1heSBlcnJvbmVvdXNseSBiZSBjbGVhcmVkIGRlc3BpdGVcclxuICAgICAgICAvLyBhbm90aGVyIHZlcnNpb24gb2YgdGhlIHNhbWUga2V5IHN0aWxsIGJlaW5nIGhlbGQgYW5kICgyKSB0aGUgY2hhbmdlXHJcbiAgICAgICAgLy8gaW4gZmxhZyBtYXkgYmUgZHVlIHRvIHRoZSBjdXJyZW50IGV2ZW50IGJlaW5nIHByb2Nlc3NlZCwgdGh1c1xyXG4gICAgICAgIC8vIHVwZGF0aW5nIHRoaW5ncyBoZXJlIGlzIGF0IGJlc3QgcmVkdW5kYW50IGFuZCBhdCB3b3JzdCBpbmNvcnJlY3RcclxuICAgICAgICBpZiAoa2V5c3ltcy5pbmRleE9mKGtleUV2ZW50LmtleXN5bSkgIT09IC0xKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIFJlbGVhc2UgYWxsIHJlbGF0ZWQga2V5cyBpZiBtb2RpZmllciBpcyBpbXBsaWNpdGx5IHJlbGVhc2VkXHJcbiAgICAgICAgaWYgKHJlbW90ZVN0YXRlICYmIGxvY2FsU3RhdGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzeW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBndWFjX2tleWJvYXJkLnJlbGVhc2Uoa2V5c3ltc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXNzIGlmIG1vZGlmaWVyIGlzIGltcGxpY2l0bHkgcHJlc3NlZFxyXG4gICAgICAgIGVsc2UgaWYgKCFyZW1vdGVTdGF0ZSAmJiBsb2NhbFN0YXRlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCBtb2RpZmllciBmbGFnIGlzbid0IGFscmVhZHkgcHJlc3NlZCBvciBhbHJlYWR5IHNldFxyXG4gICAgICAgICAgICAvLyBkdWUgdG8gYW5vdGhlciB2ZXJzaW9uIG9mIHRoZSBzYW1lIGtleSBiZWluZyBoZWxkIGRvd25cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXN5bXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChndWFjX2tleWJvYXJkLnByZXNzZWRba2V5c3ltc1tpXV0pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYXJrIGFzIGltcGxpY2l0bHkgcHJlc3NlZCBvbmx5IGlmIHRoZXJlIGlzIG90aGVyIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgIC8vIHdpdGhpbiB0aGUga2V5IGV2ZW50IHJlbGF0aW5nIHRvIGEgZGlmZmVyZW50IGtleS4gU29tZVxyXG4gICAgICAgICAgICAvLyBwbGF0Zm9ybXMsIHN1Y2ggYXMgaU9TLCB3aWxsIHNlbmQgZXNzZW50aWFsbHkgZW1wdHkga2V5IGV2ZW50c1xyXG4gICAgICAgICAgICAvLyBmb3IgbW9kaWZpZXIga2V5cywgdXNpbmcgb25seSB0aGUgbW9kaWZpZXIgZmxhZ3MgdG8gc2lnbmFsIHRoZVxyXG4gICAgICAgICAgICAvLyBpZGVudGl0eSBvZiB0aGUga2V5LlxyXG4gICAgICAgICAgICB2YXIga2V5c3ltID0ga2V5c3ltc1swXTtcclxuICAgICAgICAgICAgaWYgKGtleUV2ZW50LmtleXN5bSlcclxuICAgICAgICAgICAgICAgIGltcGxpY2l0bHlQcmVzc2VkW2tleXN5bV0gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5wcmVzcyhrZXlzeW0pO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEga2V5Ym9hcmQgZXZlbnQsIHVwZGF0ZXMgdGhlIGxvY2FsIG1vZGlmaWVyIHN0YXRlIGFuZCByZW1vdGVcclxuICAgICAqIGtleSBzdGF0ZSBiYXNlZCBvbiB0aGUgbW9kaWZpZXIgZmxhZ3Mgd2l0aGluIHRoZSBldmVudC4gVGhpcyBmdW5jdGlvblxyXG4gICAgICogcGF5cyBubyBhdHRlbnRpb24gdG8ga2V5Y29kZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxyXG4gICAgICogICAgIFRoZSBrZXlib2FyZCBldmVudCBjb250YWluaW5nIHRoZSBmbGFncyB0byB1cGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtLZXlFdmVudH0ga2V5RXZlbnRcclxuICAgICAqICAgICBHdWFjYW1vbGUncyBjdXJyZW50IGJlc3QgaW50ZXJwcmV0YXRpb24gb2YgdGhlIGtleSBldmVudCBiZWluZ1xyXG4gICAgICogICAgIHByb2Nlc3NlZC5cclxuICAgICAqL1xyXG4gICAgdmFyIHN5bmNNb2RpZmllclN0YXRlcyA9IGZ1bmN0aW9uIHN5bmNNb2RpZmllclN0YXRlcyhlLCBrZXlFdmVudCkge1xyXG5cclxuICAgICAgICAvLyBHZXQgc3RhdGVcclxuICAgICAgICB2YXIgc3RhdGUgPSBHdWFjYW1vbGUuS2V5Ym9hcmQuTW9kaWZpZXJTdGF0ZS5mcm9tS2V5Ym9hcmRFdmVudChlKTtcclxuXHJcbiAgICAgICAgLy8gUmVzeW5jIHN0YXRlIG9mIGFsdFxyXG4gICAgICAgIHVwZGF0ZU1vZGlmaWVyU3RhdGUoZ3VhY19rZXlib2FyZC5tb2RpZmllcnMuYWx0LCBzdGF0ZS5hbHQsIFtcclxuICAgICAgICAgICAgMHhGRkU5LCAvLyBMZWZ0IGFsdFxyXG4gICAgICAgICAgICAweEZGRUEsIC8vIFJpZ2h0IGFsdFxyXG4gICAgICAgICAgICAweEZFMDMgIC8vIEFsdEdyXHJcbiAgICAgICAgXSwga2V5RXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBSZXN5bmMgc3RhdGUgb2Ygc2hpZnRcclxuICAgICAgICB1cGRhdGVNb2RpZmllclN0YXRlKGd1YWNfa2V5Ym9hcmQubW9kaWZpZXJzLnNoaWZ0LCBzdGF0ZS5zaGlmdCwgW1xyXG4gICAgICAgICAgICAweEZGRTEsIC8vIExlZnQgc2hpZnRcclxuICAgICAgICAgICAgMHhGRkUyICAvLyBSaWdodCBzaGlmdFxyXG4gICAgICAgIF0sIGtleUV2ZW50KTtcclxuXHJcbiAgICAgICAgLy8gUmVzeW5jIHN0YXRlIG9mIGN0cmxcclxuICAgICAgICB1cGRhdGVNb2RpZmllclN0YXRlKGd1YWNfa2V5Ym9hcmQubW9kaWZpZXJzLmN0cmwsIHN0YXRlLmN0cmwsIFtcclxuICAgICAgICAgICAgMHhGRkUzLCAvLyBMZWZ0IGN0cmxcclxuICAgICAgICAgICAgMHhGRkU0ICAvLyBSaWdodCBjdHJsXHJcbiAgICAgICAgXSwga2V5RXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBSZXN5bmMgc3RhdGUgb2YgbWV0YVxyXG4gICAgICAgIHVwZGF0ZU1vZGlmaWVyU3RhdGUoZ3VhY19rZXlib2FyZC5tb2RpZmllcnMubWV0YSwgc3RhdGUubWV0YSwgW1xyXG4gICAgICAgICAgICAweEZGRTcsIC8vIExlZnQgbWV0YVxyXG4gICAgICAgICAgICAweEZGRTggIC8vIFJpZ2h0IG1ldGFcclxuICAgICAgICBdLCBrZXlFdmVudCk7XHJcblxyXG4gICAgICAgIC8vIFJlc3luYyBzdGF0ZSBvZiBoeXBlclxyXG4gICAgICAgIHVwZGF0ZU1vZGlmaWVyU3RhdGUoZ3VhY19rZXlib2FyZC5tb2RpZmllcnMuaHlwZXIsIHN0YXRlLmh5cGVyLCBbXHJcbiAgICAgICAgICAgIDB4RkZFQiwgLy8gTGVmdCBoeXBlclxyXG4gICAgICAgICAgICAweEZGRUMgIC8vIFJpZ2h0IGh5cGVyXHJcbiAgICAgICAgXSwga2V5RXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcclxuICAgICAgICBndWFjX2tleWJvYXJkLm1vZGlmaWVycyA9IHN0YXRlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYWxsIGN1cnJlbnRseSBwcmVzc2VkIGtleXMgd2VyZSBpbXBsaWNpdGx5IHByZXNzZWQuIEFcclxuICAgICAqIGtleSBpcyBpbXBsaWNpdGx5IHByZXNzZWQgaWYgaXRzIHN0YXR1cyB3YXMgaW5mZXJyZWQgaW5kaXJlY3RseSBmcm9tXHJcbiAgICAgKiBpbnNwZWN0aW9uIG9mIG90aGVyIGtleSBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogICAgIHRydWUgaWYgYWxsIGN1cnJlbnRseSBwcmVzc2VkIGtleXMgd2VyZSBpbXBsaWNpdGx5IHByZXNzZWQsIGZhbHNlXHJcbiAgICAgKiAgICAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgaXNTdGF0ZUltcGxpY2l0ID0gZnVuY3Rpb24gaXNTdGF0ZUltcGxpY2l0KCkge1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXlzeW0gaW4gZ3VhY19rZXlib2FyZC5wcmVzc2VkKSB7XHJcbiAgICAgICAgICAgIGlmICghaW1wbGljaXRseVByZXNzZWRba2V5c3ltXSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyB0aHJvdWdoIHRoZSBldmVudCBsb2csIHJlbW92aW5nIGV2ZW50cyBmcm9tIHRoZSBoZWFkIG9mIHRoZSBsb2dcclxuICAgICAqIHdoZW4gdGhlIGNvcnJlc3BvbmRpbmcgdHJ1ZSBrZXkgcHJlc3NlcyBhcmUga25vd24gKG9yIGFzIGtub3duIGFzIHRoZXlcclxuICAgICAqIGNhbiBiZSkuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgbGF0ZXN0IGV2ZW50IHNob3VsZFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgYmUgcHJldmVudGVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbnRlcnByZXRfZXZlbnRzKCkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3QgcHJldmVudCBkZWZhdWx0IGlmIG5vIGV2ZW50IGNvdWxkIGJlIGludGVycHJldGVkXHJcbiAgICAgICAgdmFyIGhhbmRsZWRfZXZlbnQgPSBpbnRlcnByZXRfZXZlbnQoKTtcclxuICAgICAgICBpZiAoIWhhbmRsZWRfZXZlbnQpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJwcmV0IGFzIG11Y2ggYXMgcG9zc2libGVcclxuICAgICAgICB2YXIgbGFzdF9ldmVudDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGxhc3RfZXZlbnQgPSBoYW5kbGVkX2V2ZW50O1xyXG4gICAgICAgICAgICBoYW5kbGVkX2V2ZW50ID0gaW50ZXJwcmV0X2V2ZW50KCk7XHJcbiAgICAgICAgfSB3aGlsZSAoaGFuZGxlZF9ldmVudCAhPT0gbnVsbCk7XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IGtleWJvYXJkIHN0YXRlIGlmIHdlIGNhbm5vdCBleHBlY3QgdG8gcmVjZWl2ZSBhbnkgZnVydGhlclxyXG4gICAgICAgIC8vIGtleXVwIGV2ZW50c1xyXG4gICAgICAgIGlmIChpc1N0YXRlSW1wbGljaXQoKSlcclxuICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5yZXNldCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gbGFzdF9ldmVudC5kZWZhdWx0UHJldmVudGVkO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbGVhc2VzIEN0cmwrQWx0LCBpZiBib3RoIGFyZSBjdXJyZW50bHkgcHJlc3NlZCBhbmQgdGhlIGdpdmVuIGtleXN5bVxyXG4gICAgICogbG9va3MgbGlrZSBhIGtleSB0aGF0IG1heSByZXF1aXJlIEFsdEdyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga2V5c3ltIFRoZSBrZXkgdGhhdCB3YXMganVzdCBwcmVzc2VkLlxyXG4gICAgICovXHJcbiAgICB2YXIgcmVsZWFzZV9zaW11bGF0ZWRfYWx0Z3IgPSBmdW5jdGlvbiByZWxlYXNlX3NpbXVsYXRlZF9hbHRncihrZXlzeW0pIHtcclxuXHJcbiAgICAgICAgLy8gQm90aCBDdHJsK0FsdCBtdXN0IGJlIHByZXNzZWQgaWYgc2ltdWxhdGVkIEFsdEdyIGlzIGluIHVzZVxyXG4gICAgICAgIGlmICghZ3VhY19rZXlib2FyZC5tb2RpZmllcnMuY3RybCB8fCAhZ3VhY19rZXlib2FyZC5tb2RpZmllcnMuYWx0KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIEFzc3VtZSBbQS1aXSBuZXZlciByZXF1aXJlIEFsdEdyXHJcbiAgICAgICAgaWYgKGtleXN5bSA+PSAweDAwNDEgJiYga2V5c3ltIDw9IDB4MDA1QSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBBc3N1bWUgW2Etel0gbmV2ZXIgcmVxdWlyZSBBbHRHclxyXG4gICAgICAgIGlmIChrZXlzeW0gPj0gMHgwMDYxICYmIGtleXN5bSA8PSAweDAwN0EpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gUmVsZWFzZSBDdHJsK0FsdCBpZiB0aGUga2V5c3ltIGlzIHByaW50YWJsZVxyXG4gICAgICAgIGlmIChrZXlzeW0gPD0gMHhGRiB8fCAoa2V5c3ltICYgMHhGRjAwMDAwMCkgPT09IDB4MDEwMDAwMDApIHtcclxuICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5yZWxlYXNlKDB4RkZFMyk7IC8vIExlZnQgY3RybCBcclxuICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5yZWxlYXNlKDB4RkZFNCk7IC8vIFJpZ2h0IGN0cmwgXHJcbiAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQucmVsZWFzZSgweEZGRTkpOyAvLyBMZWZ0IGFsdFxyXG4gICAgICAgICAgICBndWFjX2tleWJvYXJkLnJlbGVhc2UoMHhGRkVBKTsgLy8gUmlnaHQgYWx0XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyB0aHJvdWdoIHRoZSBldmVudCBsb2csIGludGVycHJldGluZyB0aGUgZmlyc3QgZXZlbnQsIGlmIHBvc3NpYmxlLFxyXG4gICAgICogYW5kIHJldHVybmluZyB0aGF0IGV2ZW50LiBJZiBubyBldmVudHMgY2FuIGJlIGludGVycHJldGVkLCBkdWUgdG8gYVxyXG4gICAgICogdG90YWwgbGFjayBvZiBldmVudHMgb3IgdGhlIG5lZWQgZm9yIG1vcmUgZXZlbnRzLCBudWxsIGlzIHJldHVybmVkLiBBbnlcclxuICAgICAqIGludGVycHJldGVkIGV2ZW50cyBhcmUgYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gdGhlIGxvZy5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm4ge0tleUV2ZW50fVxyXG4gICAgICogICAgIFRoZSBmaXJzdCBrZXkgZXZlbnQgaW4gdGhlIGxvZywgaWYgaXQgY2FuIGJlIGludGVycHJldGVkLCBvciBudWxsXHJcbiAgICAgKiAgICAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgaW50ZXJwcmV0X2V2ZW50ID0gZnVuY3Rpb24gaW50ZXJwcmV0X2V2ZW50KCkge1xyXG5cclxuICAgICAgICAvLyBQZWVrIGF0IGZpcnN0IGV2ZW50IGluIGxvZ1xyXG4gICAgICAgIHZhciBmaXJzdCA9IGV2ZW50TG9nWzBdO1xyXG4gICAgICAgIGlmICghZmlyc3QpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAvLyBLZXlkb3duIGV2ZW50XHJcbiAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgS2V5ZG93bkV2ZW50KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIga2V5c3ltID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGFjY2VwdGVkX2V2ZW50cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZXZlbnQgaXRzZWxmIGlzIHJlbGlhYmxlLCBubyBuZWVkIHRvIHdhaXQgZm9yIG90aGVyIGV2ZW50c1xyXG4gICAgICAgICAgICBpZiAoZmlyc3QucmVsaWFibGUpIHtcclxuICAgICAgICAgICAgICAgIGtleXN5bSA9IGZpcnN0LmtleXN5bTtcclxuICAgICAgICAgICAgICAgIGFjY2VwdGVkX2V2ZW50cyA9IGV2ZW50TG9nLnNwbGljZSgwLCAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYga2V5ZG93biBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIGtleXByZXNzLCB1c2UgdGhlIGluZGljYXRlZCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRMb2dbMV0gaW5zdGFuY2VvZiBLZXlwcmVzc0V2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzeW0gPSBldmVudExvZ1sxXS5rZXlzeW07XHJcbiAgICAgICAgICAgICAgICBhY2NlcHRlZF9ldmVudHMgPSBldmVudExvZy5zcGxpY2UoMCwgMik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGtleWRvd24gaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW55dGhpbmcgZWxzZSwgdGhlbiBub1xyXG4gICAgICAgICAgICAvLyBrZXlwcmVzcyBjYW4gcG9zc2libHkgb2NjdXIgdG8gY2xhcmlmeSB0aGlzIGV2ZW50LCBhbmQgd2UgbXVzdFxyXG4gICAgICAgICAgICAvLyBoYW5kbGUgaXQgbm93XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TG9nWzFdKSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzeW0gPSBmaXJzdC5rZXlzeW07XHJcbiAgICAgICAgICAgICAgICBhY2NlcHRlZF9ldmVudHMgPSBldmVudExvZy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpcmUgYSBrZXkgcHJlc3MgaWYgdmFsaWQgZXZlbnRzIHdlcmUgZm91bmRcclxuICAgICAgICAgICAgaWYgKGFjY2VwdGVkX2V2ZW50cy5sZW5ndGggPiAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGtleXN5bSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZV9zaW11bGF0ZWRfYWx0Z3Ioa2V5c3ltKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9ICFndWFjX2tleWJvYXJkLnByZXNzKGtleXN5bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjZW50S2V5c3ltW2ZpcnN0LmtleUNvZGVdID0ga2V5c3ltO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWxlYXNlIHRoZSBrZXkgbm93IGlmIHdlIGNhbm5vdCByZWx5IG9uIHRoZSBhc3NvY2lhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2V5dXAgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0LmtleXVwUmVsaWFibGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQucmVsZWFzZShrZXlzeW0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgd2hldGhlciBkZWZhdWx0IHdhcyBwcmV2ZW50ZWRcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YWNjZXB0ZWRfZXZlbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRlZF9ldmVudHNbaV0uZGVmYXVsdFByZXZlbnRlZCA9IGRlZmF1bHRQcmV2ZW50ZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSAvLyBlbmQgaWYga2V5ZG93blxyXG5cclxuICAgICAgICAvLyBLZXl1cCBldmVudFxyXG4gICAgICAgIGVsc2UgaWYgKGZpcnN0IGluc3RhbmNlb2YgS2V5dXBFdmVudCAmJiAhcXVpcmtzLmtleXVwVW5yZWxpYWJsZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gUmVsZWFzZSBzcGVjaWZpYyBrZXkgaWYga25vd25cclxuICAgICAgICAgICAgdmFyIGtleXN5bSA9IGZpcnN0LmtleXN5bTtcclxuICAgICAgICAgICAgaWYgKGtleXN5bSkge1xyXG4gICAgICAgICAgICAgICAgZ3VhY19rZXlib2FyZC5yZWxlYXNlKGtleXN5bSk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVjZW50S2V5c3ltW2ZpcnN0LmtleUNvZGVdO1xyXG4gICAgICAgICAgICAgICAgZmlyc3QuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZmFsbCBiYWNrIHRvIHJlbGVhc2luZyBhbGwga2V5c1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TG9nLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgIH0gLy8gZW5kIGlmIGtleXVwXHJcblxyXG4gICAgICAgIC8vIElnbm9yZSBhbnkgb3RoZXIgdHlwZSBvZiBldmVudCAoa2V5cHJlc3MgYnkgaXRzZWxmIGlzIGludmFsaWQsIGFuZFxyXG4gICAgICAgIC8vIHVucmVsaWFibGUga2V5dXAgZXZlbnRzIHNob3VsZCBzaW1wbHkgYmUgZHVtcGVkKVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TG9nLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgIC8vIE5vIGV2ZW50IGludGVycHJldGVkXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGtleWJvYXJkIGxvY2F0aW9uIG9mIHRoZSBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlblxyXG4gICAgICoga2V5Ym9hcmQgZXZlbnQuIFRoZSBsb2NhdGlvbiBkaWZmZXJlbnRpYXRlcyBrZXkgZXZlbnRzIHdoaWNoIG90aGVyd2lzZVxyXG4gICAgICogaGF2ZSB0aGUgc2FtZSBrZXljb2RlLCBzdWNoIGFzIGxlZnQgc2hpZnQgdnMuIHJpZ2h0IHNoaWZ0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcclxuICAgICAqICAgICBBIEphdmFTY3JpcHQga2V5Ym9hcmQgZXZlbnQsIGFzIHJlY2VpdmVkIHRocm91Z2ggdGhlIERPTSB2aWEgYVxyXG4gICAgICogICAgIFwia2V5ZG93blwiLCBcImtleXVwXCIsIG9yIFwia2V5cHJlc3NcIiBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiAgICAgVGhlIGxvY2F0aW9uIG9mIHRoZSBrZXkgZXZlbnQgb24gdGhlIGtleWJvYXJkLCBhcyBkZWZpbmVkIGF0OlxyXG4gICAgICogICAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLUtleWJvYXJkRXZlbnRcclxuICAgICAqL1xyXG4gICAgdmFyIGdldEV2ZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRFdmVudExvY2F0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgLy8gVXNlIHN0YW5kYXJkIGxvY2F0aW9uLCBpZiBwb3NzaWJsZVxyXG4gICAgICAgIGlmICgnbG9jYXRpb24nIGluIGUpXHJcbiAgICAgICAgICAgIHJldHVybiBlLmxvY2F0aW9uO1xyXG5cclxuICAgICAgICAvLyBGYWlsaW5nIHRoYXQsIGF0dGVtcHQgdG8gdXNlIGRlcHJlY2F0ZWQga2V5TG9jYXRpb25cclxuICAgICAgICBpZiAoJ2tleUxvY2F0aW9uJyBpbiBlKVxyXG4gICAgICAgICAgICByZXR1cm4gZS5rZXlMb2NhdGlvbjtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gbG9jYXRpb24gaXMgYXZhaWxhYmxlLCBhc3N1bWUgbGVmdCBzaWRlXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIG1hcmsgdGhlIGdpdmVuIEV2ZW50IGFzIGhhdmluZyBiZWVuIGhhbmRsZWQgYnkgdGhpc1xyXG4gICAgICogR3VhY2Ftb2xlLktleWJvYXJkLiBJZiB0aGUgRXZlbnQgaGFzIGFscmVhZHkgYmVlbiBtYXJrZWQgYXMgaGFuZGxlZCxcclxuICAgICAqIGZhbHNlIGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgICAqICAgICBUaGUgRXZlbnQgdG8gbWFyay5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqICAgICB0cnVlIGlmIHRoZSBnaXZlbiBFdmVudCB3YXMgc3VjY2Vzc2Z1bGx5IG1hcmtlZCwgZmFsc2UgaWYgdGhlIGdpdmVuXHJcbiAgICAgKiAgICAgRXZlbnQgd2FzIGFscmVhZHkgbWFya2VkLlxyXG4gICAgICovXHJcbiAgICB2YXIgbWFya0V2ZW50ID0gZnVuY3Rpb24gbWFya0V2ZW50KGUpIHtcclxuXHJcbiAgICAgICAgLy8gRmFpbCBpZiBldmVudCBpcyBhbHJlYWR5IG1hcmtlZFxyXG4gICAgICAgIGlmIChlW0VWRU5UX01BUktFUl0pXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gTWFyayBldmVudCBvdGhlcndpc2VcclxuICAgICAgICBlW0VWRU5UX01BUktFUl0gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGdpdmVuIEVsZW1lbnQsIGF1dG9tYXRpY2FsbHkgdHJhbnNsYXRpbmdcclxuICAgICAqIHJlY2VpdmVkIGtleSwgaW5wdXQsIGFuZCBjb21wb3NpdGlvbiBldmVudHMgaW50byBzaW1wbGUga2V5ZG93bi9rZXl1cFxyXG4gICAgICogZXZlbnRzIHNpZ25hbGxlZCB0aHJvdWdoIHRoaXMgR3VhY2Ftb2xlLktleWJvYXJkJ3Mgb25rZXlkb3duIGFuZFxyXG4gICAgICogb25rZXl1cCBoYW5kbGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnR9IGVsZW1lbnRcclxuICAgICAqICAgICBUaGUgRWxlbWVudCB0byBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvIGZvciB0aGUgc2FrZSBvZiBoYW5kbGluZ1xyXG4gICAgICogICAgIGtleSBvciBpbnB1dCBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMubGlzdGVuVG8gPSBmdW5jdGlvbiBsaXN0ZW5UbyhlbGVtZW50KSB7XHJcblxyXG4gICAgICAgIC8vIFdoZW4ga2V5IHByZXNzZWRcclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgaW50ZXJjZXB0IGlmIGhhbmRsZXIgc2V0XHJcbiAgICAgICAgICAgIGlmICghZ3VhY19rZXlib2FyZC5vbmtleWRvd24pIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIElnbm9yZSBldmVudHMgd2hpY2ggaGF2ZSBhbHJlYWR5IGJlZW4gaGFuZGxlZFxyXG4gICAgICAgICAgICBpZiAoIW1hcmtFdmVudChlKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdmFyIGtleUNvZGU7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuZXZlbnQpIGtleUNvZGUgPSB3aW5kb3cuZXZlbnQua2V5Q29kZTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZS53aGljaCkga2V5Q29kZSA9IGUud2hpY2g7XHJcblxyXG4gICAgICAgICAgICAvLyBGaXggbW9kaWZpZXIgc3RhdGVzXHJcbiAgICAgICAgICAgIHZhciBrZXlkb3duRXZlbnQgPSBuZXcgS2V5ZG93bkV2ZW50KGtleUNvZGUsIGUua2V5SWRlbnRpZmllciwgZS5rZXksIGdldEV2ZW50TG9jYXRpb24oZSkpO1xyXG4gICAgICAgICAgICBzeW5jTW9kaWZpZXJTdGF0ZXMoZSwga2V5ZG93bkV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIElnbm9yZSAoYnV0IGRvIG5vdCBwcmV2ZW50KSB0aGUgXCJjb21wb3NpdGlvblwiIGtleWNvZGUgc2VudCBieSBzb21lXHJcbiAgICAgICAgICAgIC8vIGJyb3dzZXJzIHdoZW4gYW4gSU1FIGlzIGluIHVzZSAoc2VlOiBodHRwOi8vbGlzdHMudzMub3JnL0FyY2hpdmVzL1B1YmxpYy93d3ctZG9tLzIwMTBKdWxTZXAvYXR0LTAxODIva2V5Q29kZS1zcGVjLmh0bWwpXHJcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSAyMjkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBMb2cgZXZlbnRcclxuICAgICAgICAgICAgZXZlbnRMb2cucHVzaChrZXlkb3duRXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gSW50ZXJwcmV0IGFzIG1hbnkgZXZlbnRzIGFzIHBvc3NpYmxlLCBwcmV2ZW50IGRlZmF1bHQgaWYgaW5kaWNhdGVkXHJcbiAgICAgICAgICAgIGlmIChpbnRlcnByZXRfZXZlbnRzKCkpXHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAvLyBXaGVuIGtleSBwcmVzc2VkXHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBpbnRlcmNlcHQgaWYgaGFuZGxlciBzZXRcclxuICAgICAgICAgICAgaWYgKCFndWFjX2tleWJvYXJkLm9ua2V5ZG93biAmJiAhZ3VhY19rZXlib2FyZC5vbmtleXVwKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBJZ25vcmUgZXZlbnRzIHdoaWNoIGhhdmUgYWxyZWFkeSBiZWVuIGhhbmRsZWRcclxuICAgICAgICAgICAgaWYgKCFtYXJrRXZlbnQoZSkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZTtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5ldmVudCkgY2hhckNvZGUgPSB3aW5kb3cuZXZlbnQua2V5Q29kZTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZS53aGljaCkgY2hhckNvZGUgPSBlLndoaWNoO1xyXG5cclxuICAgICAgICAgICAgLy8gRml4IG1vZGlmaWVyIHN0YXRlc1xyXG4gICAgICAgICAgICB2YXIga2V5cHJlc3NFdmVudCA9IG5ldyBLZXlwcmVzc0V2ZW50KGNoYXJDb2RlKTtcclxuICAgICAgICAgICAgc3luY01vZGlmaWVyU3RhdGVzKGUsIGtleXByZXNzRXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gTG9nIGV2ZW50XHJcbiAgICAgICAgICAgIGV2ZW50TG9nLnB1c2goa2V5cHJlc3NFdmVudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnRlcnByZXQgYXMgbWFueSBldmVudHMgYXMgcG9zc2libGUsIHByZXZlbnQgZGVmYXVsdCBpZiBpbmRpY2F0ZWRcclxuICAgICAgICAgICAgaWYgKGludGVycHJldF9ldmVudHMoKSlcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIFdoZW4ga2V5IHJlbGVhc2VkXHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBpbnRlcmNlcHQgaWYgaGFuZGxlciBzZXRcclxuICAgICAgICAgICAgaWYgKCFndWFjX2tleWJvYXJkLm9ua2V5dXApIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIElnbm9yZSBldmVudHMgd2hpY2ggaGF2ZSBhbHJlYWR5IGJlZW4gaGFuZGxlZFxyXG4gICAgICAgICAgICBpZiAoIW1hcmtFdmVudChlKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGtleUNvZGU7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuZXZlbnQpIGtleUNvZGUgPSB3aW5kb3cuZXZlbnQua2V5Q29kZTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZS53aGljaCkga2V5Q29kZSA9IGUud2hpY2g7XHJcblxyXG4gICAgICAgICAgICAvLyBGaXggbW9kaWZpZXIgc3RhdGVzXHJcbiAgICAgICAgICAgIHZhciBrZXl1cEV2ZW50ID0gbmV3IEtleXVwRXZlbnQoa2V5Q29kZSwgZS5rZXlJZGVudGlmaWVyLCBlLmtleSwgZ2V0RXZlbnRMb2NhdGlvbihlKSk7XHJcbiAgICAgICAgICAgIHN5bmNNb2RpZmllclN0YXRlcyhlLCBrZXl1cEV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIExvZyBldmVudCwgY2FsbCBmb3IgaW50ZXJwcmV0YXRpb25cclxuICAgICAgICAgICAgZXZlbnRMb2cucHVzaChrZXl1cEV2ZW50KTtcclxuICAgICAgICAgICAgaW50ZXJwcmV0X2V2ZW50cygpO1xyXG5cclxuICAgICAgICB9LCB0cnVlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlcyB0aGUgZ2l2ZW4gXCJpbnB1dFwiIGV2ZW50LCB0eXBpbmcgdGhlIGRhdGEgd2l0aGluIHRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqIElmIHRoZSBldmVudCBpcyBjb21wbGV0ZSAodGV4dCBpcyBwcm92aWRlZCksIGhhbmRsaW5nIG9mIFwiY29tcG9zaXRpb25lbmRcIlxyXG4gICAgICAgICAqIGV2ZW50cyBpcyBzdXNwZW5kZWQsIGFzIHN1Y2ggZXZlbnRzIG1heSBjb25mbGljdCB3aXRoIGlucHV0IGV2ZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtJbnB1dEV2ZW50fSBlXHJcbiAgICAgICAgICogICAgIFRoZSBcImlucHV0XCIgZXZlbnQgdG8gaGFuZGxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBoYW5kbGVJbnB1dCA9IGZ1bmN0aW9uIGhhbmRsZUlucHV0KGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgaW50ZXJjZXB0IGlmIGhhbmRsZXIgc2V0XHJcbiAgICAgICAgICAgIGlmICghZ3VhY19rZXlib2FyZC5vbmtleWRvd24gJiYgIWd1YWNfa2V5Ym9hcmQub25rZXl1cCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gSWdub3JlIGV2ZW50cyB3aGljaCBoYXZlIGFscmVhZHkgYmVlbiBoYW5kbGVkXHJcbiAgICAgICAgICAgIGlmICghbWFya0V2ZW50KGUpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBUeXBlIGFsbCBjb250ZW50IHdyaXR0ZW5cclxuICAgICAgICAgICAgaWYgKGUuZGF0YSAmJiAhZS5pc0NvbXBvc2luZykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29tcG9zaXRpb25lbmRcIiwgaGFuZGxlQ29tcG9zaXRpb24sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQudHlwZShlLmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgdGhlIGdpdmVuIFwiY29tcG9zaXRpb25lbmRcIiBldmVudCwgdHlwaW5nIHRoZSBkYXRhIHdpdGhpbiB0aGVcclxuICAgICAgICAgKiBjb21wb3NlZCB0ZXh0LiBJZiB0aGUgZXZlbnQgaXMgY29tcGxldGUgKGNvbXBvc2VkIHRleHQgaXMgcHJvdmlkZWQpLFxyXG4gICAgICAgICAqIGhhbmRsaW5nIG9mIFwiaW5wdXRcIiBldmVudHMgaXMgc3VzcGVuZGVkLCBhcyBzdWNoIGV2ZW50cyBtYXkgY29uZmxpY3RcclxuICAgICAgICAgKiB3aXRoIGNvbXBvc2l0aW9uIGV2ZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtDb21wb3NpdGlvbkV2ZW50fSBlXHJcbiAgICAgICAgICogICAgIFRoZSBcImNvbXBvc2l0aW9uZW5kXCIgZXZlbnQgdG8gaGFuZGxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBoYW5kbGVDb21wb3NpdGlvbiA9IGZ1bmN0aW9uIGhhbmRsZUNvbXBvc2l0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgaW50ZXJjZXB0IGlmIGhhbmRsZXIgc2V0XHJcbiAgICAgICAgICAgIGlmICghZ3VhY19rZXlib2FyZC5vbmtleWRvd24gJiYgIWd1YWNfa2V5Ym9hcmQub25rZXl1cCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gSWdub3JlIGV2ZW50cyB3aGljaCBoYXZlIGFscmVhZHkgYmVlbiBoYW5kbGVkXHJcbiAgICAgICAgICAgIGlmICghbWFya0V2ZW50KGUpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBUeXBlIGFsbCBjb250ZW50IHdyaXR0ZW5cclxuICAgICAgICAgICAgaWYgKGUuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgaGFuZGxlSW5wdXQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGd1YWNfa2V5Ym9hcmQudHlwZShlLmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdHlwZSB0ZXh0IGVudGVyZWQgaW50byB0aGUgd3JhcHBlZCBmaWVsZFxyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGhhbmRsZUlucHV0LCBmYWxzZSk7XHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29tcG9zaXRpb25lbmRcIiwgaGFuZGxlQ29tcG9zaXRpb24sIGZhbHNlKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIExpc3RlbiB0byBnaXZlbiBlbGVtZW50LCBpZiBhbnlcclxuICAgIGlmIChlbGVtZW50KVxyXG4gICAgICAgIGd1YWNfa2V5Ym9hcmQubGlzdGVuVG8oZWxlbWVudCk7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSB1bmlxdWUgbnVtZXJpY2FsIGlkZW50aWZpZXIgdG8gYXNzaWduIHRvIHRoZSBuZXh0IEd1YWNhbW9sZS5LZXlib2FyZFxyXG4gKiBpbnN0YW5jZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHR5cGUge051bWJlcn1cclxuICovXHJcbkd1YWNhbW9sZS5LZXlib2FyZC5fbmV4dElEID0gMDtcclxuXHJcbi8qKlxyXG4gKiBUaGUgc3RhdGUgb2YgYWxsIHN1cHBvcnRlZCBrZXlib2FyZCBtb2RpZmllcnMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuR3VhY2Ftb2xlLktleWJvYXJkLk1vZGlmaWVyU3RhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHNoaWZ0IGlzIGN1cnJlbnRseSBwcmVzc2VkLlxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2hpZnQgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIGN0cmwgaXMgY3VycmVudGx5IHByZXNzZWQuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdHJsID0gZmFsc2U7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBhbHQgaXMgY3VycmVudGx5IHByZXNzZWQuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5hbHQgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIG1ldGEgKGFwcGxlIGtleSkgaXMgY3VycmVudGx5IHByZXNzZWQuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tZXRhID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIGh5cGVyICh3aW5kb3dzIGtleSkgaXMgY3VycmVudGx5IHByZXNzZWQuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5oeXBlciA9IGZhbHNlO1xyXG4gICAgXHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbW9kaWZpZXIgc3RhdGUgYXBwbGljYWJsZSB0byB0aGUga2V5Ym9hcmQgZXZlbnQgZ2l2ZW4uXHJcbiAqIFxyXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUgVGhlIGtleWJvYXJkIGV2ZW50IHRvIHJlYWQuXHJcbiAqIEByZXR1cm5zIHtHdWFjYW1vbGUuS2V5Ym9hcmQuTW9kaWZpZXJTdGF0ZX0gVGhlIGN1cnJlbnQgc3RhdGUgb2Yga2V5Ym9hcmRcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnMuXHJcbiAqL1xyXG5HdWFjYW1vbGUuS2V5Ym9hcmQuTW9kaWZpZXJTdGF0ZS5mcm9tS2V5Ym9hcmRFdmVudCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgIFxyXG4gICAgdmFyIHN0YXRlID0gbmV3IEd1YWNhbW9sZS5LZXlib2FyZC5Nb2RpZmllclN0YXRlKCk7XHJcblxyXG4gICAgLy8gQXNzaWduIHN0YXRlcyBmcm9tIG9sZCBmbGFnc1xyXG4gICAgc3RhdGUuc2hpZnQgPSBlLnNoaWZ0S2V5O1xyXG4gICAgc3RhdGUuY3RybCAgPSBlLmN0cmxLZXk7XHJcbiAgICBzdGF0ZS5hbHQgICA9IGUuYWx0S2V5O1xyXG4gICAgc3RhdGUubWV0YSAgPSBlLm1ldGFLZXk7XHJcblxyXG4gICAgLy8gVXNlIERPTTMgZ2V0TW9kaWZpZXJTdGF0ZSgpIGZvciBvdGhlcnNcclxuICAgIGlmIChlLmdldE1vZGlmaWVyU3RhdGUpIHtcclxuICAgICAgICBzdGF0ZS5oeXBlciA9IGUuZ2V0TW9kaWZpZXJTdGF0ZShcIk9TXCIpXHJcbiAgICAgICAgICAgICAgICAgICB8fCBlLmdldE1vZGlmaWVyU3RhdGUoXCJTdXBlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgfHwgZS5nZXRNb2RpZmllclN0YXRlKFwiSHlwZXJcIilcclxuICAgICAgICAgICAgICAgICAgIHx8IGUuZ2V0TW9kaWZpZXJTdGF0ZShcIldpblwiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgICBcclxufTtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEFic3RyYWN0IG9yZGVyZWQgZHJhd2luZyBzdXJmYWNlLiBFYWNoIExheWVyIGNvbnRhaW5zIGEgY2FudmFzIGVsZW1lbnQgYW5kXHJcbiAqIHByb3ZpZGVzIHNpbXBsZSBkcmF3aW5nIGluc3RydWN0aW9ucyBmb3IgZHJhd2luZyB0byB0aGF0IGNhbnZhcyBlbGVtZW50LFxyXG4gKiBob3dldmVyIHVubGlrZSB0aGUgY2FudmFzIGVsZW1lbnQgaXRzZWxmLCBkcmF3aW5nIG9wZXJhdGlvbnMgb24gYSBMYXllciBhcmVcclxuICogZ3VhcmFudGVlZCB0byBydW4gaW4gb3JkZXIsIGV2ZW4gaWYgc3VjaCBhbiBvcGVyYXRpb24gbXVzdCB3YWl0IGZvciBhbiBpbWFnZVxyXG4gKiB0byBsb2FkIGJlZm9yZSBjb21wbGV0aW5nLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIFxyXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBMYXllciwgaW4gcGl4ZWxzLiBUaGUgY2FudmFzIGVsZW1lbnRcclxuICogICAgICAgICAgICAgICAgICAgICAgIGJhY2tpbmcgdGhpcyBMYXllciB3aWxsIGJlIGdpdmVuIHRoaXMgd2lkdGguXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICBcclxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBMYXllciwgaW4gcGl4ZWxzLiBUaGUgY2FudmFzIGVsZW1lbnRcclxuICogICAgICAgICAgICAgICAgICAgICAgICBiYWNraW5nIHRoaXMgTGF5ZXIgd2lsbCBiZSBnaXZlbiB0aGlzIGhlaWdodC5cclxuICovXHJcbkd1YWNhbW9sZS5MYXllciA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIExheWVyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGxheWVyID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoZSB3aWR0aCBvciBoZWlnaHQgb2YgYSBsYXllciBtdXN0IGNoYW5nZSBiZWZvcmVcclxuICAgICAqIHRoZSB1bmRlcmx5aW5nIGNhbnZhcyBpcyByZXNpemVkLiBUaGUgdW5kZXJseWluZyBjYW52YXMgd2lsbCBiZSBrZXB0IGF0XHJcbiAgICAgKiBkaW1lbnNpb25zIHdoaWNoIGFyZSBpbnRlZ2VyIG11bHRpcGxlcyBvZiB0aGlzIGZhY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAdHlwZSBOdW1iZXJcclxuICAgICAqL1xyXG4gICAgdmFyIENBTlZBU19TSVpFX0ZBQ1RPUiA9IDY0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNhbnZhcyBlbGVtZW50IGJhY2tpbmcgdGhpcyBMYXllci5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIDJEIGRpc3BsYXkgY29udGV4dCBvZiB0aGUgY2FudmFzIGVsZW1lbnQgYmFja2luZyB0aGlzIExheWVyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgY29udGV4dC5zYXZlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBsYXllciBoYXMgbm90IHlldCBiZWVuIGRyYXduIHRvLiBPbmNlIGFueSBkcmF3IG9wZXJhdGlvblxyXG4gICAgICogd2hpY2ggYWZmZWN0cyB0aGUgdW5kZXJseWluZyBjYW52YXMgaXMgaW52b2tlZCwgdGhpcyBmbGFnIHdpbGwgYmUgc2V0IHRvXHJcbiAgICAgKiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUgQm9vbGVhblxyXG4gICAgICovXHJcbiAgICB2YXIgZW1wdHkgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBhIG5ldyBwYXRoIHNob3VsZCBiZSBzdGFydGVkIHdpdGggdGhlIG5leHQgcGF0aCBkcmF3aW5nXHJcbiAgICAgKiBvcGVyYXRpb25zLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHBhdGhDbG9zZWQgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBzdGF0ZXMgb24gdGhlIHN0YXRlIHN0YWNrLlxyXG4gICAgICogXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhlcmUgd2lsbCBBTFdBWVMgYmUgb25lIGVsZW1lbnQgb24gdGhlIHN0YWNrLCBidXQgdGhhdFxyXG4gICAgICogZWxlbWVudCBpcyBub3QgZXhwb3NlZC4gSXQgaXMgb25seSB1c2VkIHRvIHJlc2V0IHRoZSBsYXllciB0byBpdHNcclxuICAgICAqIGluaXRpYWwgc3RhdGUuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBzdGFja1NpemUgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9mIGFsbCBHdWFjYW1vbGUgY2hhbm5lbCBtYXNrcyB0byBIVE1MNSBjYW52YXMgY29tcG9zaXRlIG9wZXJhdGlvblxyXG4gICAgICogbmFtZXMuIE5vdCBhbGwgY2hhbm5lbCBtYXNrIGNvbWJpbmF0aW9ucyBhcmUgY3VycmVudGx5IGltcGxlbWVudGVkLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGNvbXBvc2l0ZU9wZXJhdGlvbiA9IHtcclxuICAgICAvKiAweDAgTk9UIElNUExFTUVOVEVEICovXHJcbiAgICAgICAgMHgxOiBcImRlc3RpbmF0aW9uLWluXCIsXHJcbiAgICAgICAgMHgyOiBcImRlc3RpbmF0aW9uLW91dFwiLFxyXG4gICAgIC8qIDB4MyBOT1QgSU1QTEVNRU5URUQgKi9cclxuICAgICAgICAweDQ6IFwic291cmNlLWluXCIsXHJcbiAgICAgLyogMHg1IE5PVCBJTVBMRU1FTlRFRCAqL1xyXG4gICAgICAgIDB4NjogXCJzb3VyY2UtYXRvcFwiLFxyXG4gICAgIC8qIDB4NyBOT1QgSU1QTEVNRU5URUQgKi9cclxuICAgICAgICAweDg6IFwic291cmNlLW91dFwiLFxyXG4gICAgICAgIDB4OTogXCJkZXN0aW5hdGlvbi1hdG9wXCIsXHJcbiAgICAgICAgMHhBOiBcInhvclwiLFxyXG4gICAgICAgIDB4QjogXCJkZXN0aW5hdGlvbi1vdmVyXCIsXHJcbiAgICAgICAgMHhDOiBcImNvcHlcIixcclxuICAgICAvKiAweEQgTk9UIElNUExFTUVOVEVEICovXHJcbiAgICAgICAgMHhFOiBcInNvdXJjZS1vdmVyXCIsXHJcbiAgICAgICAgMHhGOiBcImxpZ2h0ZXJcIlxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZXMgdGhlIGNhbnZhcyBlbGVtZW50IGJhY2tpbmcgdGhpcyBMYXllci4gVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seVxyXG4gICAgICogYmUgdXNlZCBpbnRlcm5hbGx5LlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtuZXdXaWR0aD0wXVxyXG4gICAgICogICAgIFRoZSBuZXcgd2lkdGggdG8gYXNzaWduIHRvIHRoaXMgTGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtuZXdIZWlnaHQ9MF1cclxuICAgICAqICAgICBUaGUgbmV3IGhlaWdodCB0byBhc3NpZ24gdG8gdGhpcyBMYXllci5cclxuICAgICAqL1xyXG4gICAgdmFyIHJlc2l6ZSA9IGZ1bmN0aW9uIHJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgc2l6ZSB0byB6ZXJvXHJcbiAgICAgICAgbmV3V2lkdGggPSBuZXdXaWR0aCB8fCAwO1xyXG4gICAgICAgIG5ld0hlaWdodCA9IG5ld0hlaWdodCB8fCAwO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IGRpbWVuc2lvbnMgb2YgaW50ZXJuYWwgY2FudmFzXHJcbiAgICAgICAgdmFyIGNhbnZhc1dpZHRoICA9IE1hdGguY2VpbChuZXdXaWR0aCAgLyBDQU5WQVNfU0laRV9GQUNUT1IpICogQ0FOVkFTX1NJWkVfRkFDVE9SO1xyXG4gICAgICAgIHZhciBjYW52YXNIZWlnaHQgPSBNYXRoLmNlaWwobmV3SGVpZ2h0IC8gQ0FOVkFTX1NJWkVfRkFDVE9SKSAqIENBTlZBU19TSVpFX0ZBQ1RPUjtcclxuXHJcbiAgICAgICAgLy8gUmVzaXplIG9ubHkgaWYgY2FudmFzIGRpbWVuc2lvbnMgYXJlIGFjdHVhbGx5IGNoYW5naW5nXHJcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDb3B5IG9sZCBkYXRhIG9ubHkgaWYgcmVsZXZhbnQgYW5kIG5vbi1lbXB0eVxyXG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghZW1wdHkgJiYgY2FudmFzLndpZHRoICE9PSAwICYmIGNhbnZhcy5oZWlnaHQgIT09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY2FudmFzIGFuZCBjb250ZXh0IGZvciBob2xkaW5nIG9sZCBkYXRhXHJcbiAgICAgICAgICAgICAgICBvbGREYXRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICAgICAgICAgIG9sZERhdGEud2lkdGggPSBNYXRoLm1pbihsYXllci53aWR0aCwgbmV3V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgb2xkRGF0YS5oZWlnaHQgPSBNYXRoLm1pbihsYXllci5oZWlnaHQsIG5ld0hlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG9sZERhdGFDb250ZXh0ID0gb2xkRGF0YS5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29weSBpbWFnZSBkYXRhIGZyb20gY3VycmVudFxyXG4gICAgICAgICAgICAgICAgb2xkRGF0YUNvbnRleHQuZHJhd0ltYWdlKGNhbnZhcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgb2xkRGF0YS53aWR0aCwgb2xkRGF0YS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIG9sZERhdGEud2lkdGgsIG9sZERhdGEuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGNvbXBvc2l0ZSBvcGVyYXRpb25cclxuICAgICAgICAgICAgdmFyIG9sZENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzaXplIGNhbnZhc1xyXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlZHJhdyBvbGQgZGF0YSwgaWYgYW55XHJcbiAgICAgICAgICAgIGlmIChvbGREYXRhKVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2Uob2xkRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAwLCAwLCBvbGREYXRhLndpZHRoLCBvbGREYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAwLCAwLCBvbGREYXRhLndpZHRoLCBvbGREYXRhLmhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXN0b3JlIGNvbXBvc2l0ZSBvcGVyYXRpb25cclxuICAgICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBvbGRDb21wb3NpdGVPcGVyYXRpb247XHJcblxyXG4gICAgICAgICAgICAvLyBBY2tub3dsZWRnZSByZXNldCBvZiBzdGFjayAoaGFwcGVucyBvbiByZXNpemUgb2YgY2FudmFzKVxyXG4gICAgICAgICAgICBzdGFja1NpemUgPSAwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGUgY2FudmFzIHNpemUgaXMgbm90IGNoYW5naW5nLCBtYW51YWxseSBmb3JjZSBzdGF0ZSByZXNldFxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgbGF5ZXIucmVzZXQoKTtcclxuXHJcbiAgICAgICAgLy8gQXNzaWduIG5ldyBsYXllciBkaW1lbnNpb25zXHJcbiAgICAgICAgbGF5ZXIud2lkdGggPSBuZXdXaWR0aDtcclxuICAgICAgICBsYXllci5oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIHRoZSBYIGFuZCBZIGNvb3JkaW5hdGVzIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiBhIHJlY3RhbmdsZVxyXG4gICAgICogYW5kIHRoZSByZWN0YW5nbGUncyB3aWR0aCBhbmQgaGVpZ2h0LCByZXNpemUgdGhlIGJhY2tpbmcgY2FudmFzIGVsZW1lbnRcclxuICAgICAqIGFzIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhhdCB0aGUgcmVjdGFuZ2xlIGZpdHMgd2l0aGluIHRoZSBjYW52YXNcclxuICAgICAqIGVsZW1lbnQncyBjb29yZGluYXRlIHNwYWNlLiBUaGlzIGZ1bmN0aW9uIHdpbGwgb25seSBtYWtlIHRoZSBjYW52YXNcclxuICAgICAqIGxhcmdlci4gSWYgdGhlIHJlY3RhbmdsZSBhbHJlYWR5IGZpdHMgd2l0aGluIHRoZSBjYW52YXMgZWxlbWVudCdzXHJcbiAgICAgKiBjb29yZGluYXRlIHNwYWNlLCB0aGUgY2FudmFzIGlzIGxlZnQgdW5jaGFuZ2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgdG8gZml0LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgdG8gZml0LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIHdpZHRoIG9mIHRoZSB0aGUgcmVjdGFuZ2xlIHRvIGZpdC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSBoZWlnaHQgb2YgdGhlIHRoZSByZWN0YW5nbGUgdG8gZml0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmaXRSZWN0KHgsIHksIHcsIGgpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDYWxjdWxhdGUgYm91bmRzXHJcbiAgICAgICAgdmFyIG9wQm91bmRYID0gdyArIHg7XHJcbiAgICAgICAgdmFyIG9wQm91bmRZID0gaCArIHk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIG1heCB3aWR0aFxyXG4gICAgICAgIHZhciByZXNpemVXaWR0aDtcclxuICAgICAgICBpZiAob3BCb3VuZFggPiBsYXllci53aWR0aClcclxuICAgICAgICAgICAgcmVzaXplV2lkdGggPSBvcEJvdW5kWDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJlc2l6ZVdpZHRoID0gbGF5ZXIud2lkdGg7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBtYXggaGVpZ2h0XHJcbiAgICAgICAgdmFyIHJlc2l6ZUhlaWdodDtcclxuICAgICAgICBpZiAob3BCb3VuZFkgPiBsYXllci5oZWlnaHQpXHJcbiAgICAgICAgICAgIHJlc2l6ZUhlaWdodCA9IG9wQm91bmRZO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmVzaXplSGVpZ2h0ID0gbGF5ZXIuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBSZXNpemUgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgbGF5ZXIucmVzaXplKHJlc2l6ZVdpZHRoLCByZXNpemVIZWlnaHQpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0byB0cnVlIGlmIHRoaXMgTGF5ZXIgc2hvdWxkIHJlc2l6ZSBpdHNlbGYgdG8gYWNjb21vZGF0ZSB0aGVcclxuICAgICAqIGRpbWVuc2lvbnMgb2YgYW55IGRyYXdpbmcgb3BlcmF0aW9uLCBhbmQgZmFsc2UgKHRoZSBkZWZhdWx0KSBvdGhlcndpc2UuXHJcbiAgICAgKiBcclxuICAgICAqIE5vdGUgdGhhdCBzZXR0aW5nIHRoaXMgcHJvcGVydHkgdGFrZXMgZWZmZWN0IGltbWVkaWF0ZWx5LCBhbmQgdGh1cyBtYXlcclxuICAgICAqIHRha2UgZWZmZWN0IG9uIG9wZXJhdGlvbnMgdGhhdCB3ZXJlIHN0YXJ0ZWQgaW4gdGhlIHBhc3QgYnV0IGhhdmUgbm90XHJcbiAgICAgKiB5ZXQgY29tcGxldGVkLiBJZiB5b3Ugd2lzaCB0aGUgc2V0dGluZyBvZiB0aGlzIGZsYWcgdG8gb25seSBtb2RpZnlcclxuICAgICAqIGZ1dHVyZSBvcGVyYXRpb25zLCB5b3Ugd2lsbCBuZWVkIHRvIG1ha2UgdGhlIHNldHRpbmcgb2YgdGhpcyBmbGFnIGFuXHJcbiAgICAgKiBvcGVyYXRpb24gd2l0aCBzeW5jKCkuXHJcbiAgICAgKiBcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBTZXQgYXV0b3NpemUgdG8gdHJ1ZSBmb3IgYWxsIGZ1dHVyZSBvcGVyYXRpb25zXHJcbiAgICAgKiBsYXllci5zeW5jKGZ1bmN0aW9uKCkge1xyXG4gICAgICogICAgIGxheWVyLmF1dG9zaXplID0gdHJ1ZTtcclxuICAgICAqIH0pO1xyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXV0b3NpemUgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoaXMgbGF5ZXIuXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhpcyBsYXllci5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FudmFzIGVsZW1lbnQgYmFja2luZyB0aGlzIExheWVyLiBOb3RlIHRoYXQgdGhlIGRpbWVuc2lvbnNcclxuICAgICAqIG9mIHRoZSBjYW52YXMgbWF5IG5vdCBleGFjdGx5IG1hdGNoIHRob3NlIG9mIHRoZSBMYXllciwgYXMgcmVzaXppbmcgYVxyXG4gICAgICogY2FudmFzIHdoaWxlIG1haW50YWluaW5nIGl0cyBzdGF0ZSBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH1cclxuICAgICAqICAgICBUaGUgY2FudmFzIGVsZW1lbnQgYmFja2luZyB0aGlzIExheWVyLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldENhbnZhcyA9IGZ1bmN0aW9uIGdldENhbnZhcygpIHtcclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgY2FudmFzIGVsZW1lbnQgY29udGFpbmluZyB0aGUgc2FtZSBpbWFnZSBhcyB0aGlzIExheWVyLlxyXG4gICAgICogVW5saWtlIGdldENhbnZhcygpLCB0aGUgY2FudmFzIGVsZW1lbnQgcmV0dXJuZWQgaXMgZ3VhcmFudGVlZCB0byBoYXZlXHJcbiAgICAgKiB0aGUgZXhhY3Qgc2FtZSBkaW1lbnNpb25zIGFzIHRoZSBMYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9XHJcbiAgICAgKiAgICAgQSBuZXcgY2FudmFzIGVsZW1lbnQgY29udGFpbmluZyBhIGNvcHkgb2YgdGhlIGltYWdlIGNvbnRlbnQgdGhpc1xyXG4gICAgICogICAgIExheWVyLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnRvQ2FudmFzID0gZnVuY3Rpb24gdG9DYW52YXMoKSB7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgY2FudmFzIGhhdmluZyBzYW1lIGRpbWVuc2lvbnNcclxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gbGF5ZXIud2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGxheWVyLmhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gQ29weSBpbWFnZSBjb250ZW50cyB0byBuZXcgY2FudmFzXHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShsYXllci5nZXRDYW52YXMoKSwgMCwgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiBjYW52YXM7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIHNpemUgb2YgdGhpcyBMYXllciB0byB0aGUgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodC4gUmVzaXppbmdcclxuICAgICAqIGlzIG9ubHkgYXR0ZW1wdGVkIGlmIHRoZSBuZXcgc2l6ZSBwcm92aWRlZCBpcyBhY3R1YWxseSBkaWZmZXJlbnQgZnJvbVxyXG4gICAgICogdGhlIGN1cnJlbnQgc2l6ZS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld1dpZHRoIFRoZSBuZXcgd2lkdGggdG8gYXNzaWduIHRvIHRoaXMgTGF5ZXIuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbmV3SGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IHRvIGFzc2lnbiB0byB0aGlzIExheWVyLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uKG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcclxuICAgICAgICBpZiAobmV3V2lkdGggIT09IGxheWVyLndpZHRoIHx8IG5ld0hlaWdodCAhPT0gbGF5ZXIuaGVpZ2h0KVxyXG4gICAgICAgICAgICByZXNpemUobmV3V2lkdGgsIG5ld0hlaWdodCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIHNwZWNpZmllZCBpbWFnZSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuIFRoZSBpbWFnZSBzcGVjaWZpZWRcclxuICAgICAqIG11c3QgYWxyZWFkeSBiZSBsb2FkZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiAgICAgVGhlIGRlc3RpbmF0aW9uIFggY29vcmRpbmF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogICAgIFRoZSBkZXN0aW5hdGlvbiBZIGNvb3JkaW5hdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtDYW52YXNJbWFnZVNvdXJjZX0gaW1hZ2VcclxuICAgICAqICAgICBUaGUgaW1hZ2UgdG8gZHJhdy4gTm90ZSB0aGF0IHRoaXMgaXMgbm90IGEgVVJMLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYXdJbWFnZSA9IGZ1bmN0aW9uKHgsIHksIGltYWdlKSB7XHJcbiAgICAgICAgaWYgKGxheWVyLmF1dG9zaXplKSBmaXRSZWN0KHgsIHksIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCB4LCB5KTtcclxuICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZmVyIGEgcmVjdGFuZ2xlIG9mIGltYWdlIGRhdGEgZnJvbSBvbmUgTGF5ZXIgdG8gdGhpcyBMYXllciB1c2luZyB0aGVcclxuICAgICAqIHNwZWNpZmllZCB0cmFuc2ZlciBmdW5jdGlvbi5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IHNyY0xheWVyIFRoZSBMYXllciB0byBjb3B5IGltYWdlIGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3MgY29vcmRpbmF0ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzIGNvb3JkaW5hdGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3cgVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXInc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZSBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmNoIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgTGF5ZXIncyBjb29yZGluYXRlIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGRlc3RpbmF0aW9uIFggY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBkZXN0aW5hdGlvbiBZIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2ZlckZ1bmN0aW9uIFRoZSB0cmFuc2ZlciBmdW5jdGlvbiB0byB1c2UgdG9cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXIgZGF0YSBmcm9tIHNvdXJjZSB0b1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmFuc2ZlciA9IGZ1bmN0aW9uKHNyY0xheWVyLCBzcmN4LCBzcmN5LCBzcmN3LCBzcmNoLCB4LCB5LCB0cmFuc2ZlckZ1bmN0aW9uKSB7XHJcblxyXG4gICAgICAgIHZhciBzcmNDYW52YXMgPSBzcmNMYXllci5nZXRDYW52YXMoKTtcclxuXHJcbiAgICAgICAgLy8gSWYgZW50aXJlIHJlY3RhbmdsZSBvdXRzaWRlIHNvdXJjZSBjYW52YXMsIHN0b3BcclxuICAgICAgICBpZiAoc3JjeCA+PSBzcmNDYW52YXMud2lkdGggfHwgc3JjeSA+PSBzcmNDYW52YXMuaGVpZ2h0KSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgY2xpcCByZWN0YW5nbGUgdG8gYXJlYVxyXG4gICAgICAgIGlmIChzcmN4ICsgc3JjdyA+IHNyY0NhbnZhcy53aWR0aClcclxuICAgICAgICAgICAgc3JjdyA9IHNyY0NhbnZhcy53aWR0aCAtIHNyY3g7XHJcblxyXG4gICAgICAgIGlmIChzcmN5ICsgc3JjaCA+IHNyY0NhbnZhcy5oZWlnaHQpXHJcbiAgICAgICAgICAgIHNyY2ggPSBzcmNDYW52YXMuaGVpZ2h0IC0gc3JjeTtcclxuXHJcbiAgICAgICAgLy8gU3RvcCBpZiBub3RoaW5nIHRvIGRyYXcuXHJcbiAgICAgICAgaWYgKHNyY3cgPT09IDAgfHwgc3JjaCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAobGF5ZXIuYXV0b3NpemUpIGZpdFJlY3QoeCwgeSwgc3Jjdywgc3JjaCk7XHJcblxyXG4gICAgICAgIC8vIEdldCBpbWFnZSBkYXRhIGZyb20gc3JjIGFuZCBkc3RcclxuICAgICAgICB2YXIgc3JjID0gc3JjTGF5ZXIuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YShzcmN4LCBzcmN5LCBzcmN3LCBzcmNoKTtcclxuICAgICAgICB2YXIgZHN0ID0gY29udGV4dC5nZXRJbWFnZURhdGEoeCAsIHksIHNyY3csIHNyY2gpO1xyXG5cclxuICAgICAgICAvLyBBcHBseSB0cmFuc2ZlciBmb3IgZWFjaCBwaXhlbFxyXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxzcmN3KnNyY2gqNDsgaSs9NCkge1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHNvdXJjZSBwaXhlbCBlbnZpcm9ubWVudFxyXG4gICAgICAgICAgICB2YXIgc3JjX3BpeGVsID0gbmV3IEd1YWNhbW9sZS5MYXllci5QaXhlbChcclxuICAgICAgICAgICAgICAgIHNyYy5kYXRhW2ldLFxyXG4gICAgICAgICAgICAgICAgc3JjLmRhdGFbaSsxXSxcclxuICAgICAgICAgICAgICAgIHNyYy5kYXRhW2krMl0sXHJcbiAgICAgICAgICAgICAgICBzcmMuZGF0YVtpKzNdXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gR2V0IGRlc3RpbmF0aW9uIHBpeGVsIGVudmlyb25tZW50XHJcbiAgICAgICAgICAgIHZhciBkc3RfcGl4ZWwgPSBuZXcgR3VhY2Ftb2xlLkxheWVyLlBpeGVsKFxyXG4gICAgICAgICAgICAgICAgZHN0LmRhdGFbaV0sXHJcbiAgICAgICAgICAgICAgICBkc3QuZGF0YVtpKzFdLFxyXG4gICAgICAgICAgICAgICAgZHN0LmRhdGFbaSsyXSxcclxuICAgICAgICAgICAgICAgIGRzdC5kYXRhW2krM11cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHRyYW5zZmVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIHRyYW5zZmVyRnVuY3Rpb24oc3JjX3BpeGVsLCBkc3RfcGl4ZWwpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSBwaXhlbCBkYXRhXHJcbiAgICAgICAgICAgIGRzdC5kYXRhW2kgIF0gPSBkc3RfcGl4ZWwucmVkO1xyXG4gICAgICAgICAgICBkc3QuZGF0YVtpKzFdID0gZHN0X3BpeGVsLmdyZWVuO1xyXG4gICAgICAgICAgICBkc3QuZGF0YVtpKzJdID0gZHN0X3BpeGVsLmJsdWU7XHJcbiAgICAgICAgICAgIGRzdC5kYXRhW2krM10gPSBkc3RfcGl4ZWwuYWxwaGE7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhdyBpbWFnZSBkYXRhXHJcbiAgICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoZHN0LCB4LCB5KTtcclxuICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQdXQgYSByZWN0YW5nbGUgb2YgaW1hZ2UgZGF0YSBmcm9tIG9uZSBMYXllciB0byB0aGlzIExheWVyIGRpcmVjdGx5XHJcbiAgICAgKiB3aXRob3V0IHBlcmZvcm1pbmcgYW55IGFscGhhIGJsZW5kaW5nLiBTaW1wbHkgY29weSB0aGUgZGF0YS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IHNyY0xheWVyIFRoZSBMYXllciB0byBjb3B5IGltYWdlIGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3MgY29vcmRpbmF0ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzIGNvb3JkaW5hdGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3cgVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXInc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZSBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmNoIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgTGF5ZXIncyBjb29yZGluYXRlIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGRlc3RpbmF0aW9uIFggY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBkZXN0aW5hdGlvbiBZIGNvb3JkaW5hdGUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucHV0ID0gZnVuY3Rpb24oc3JjTGF5ZXIsIHNyY3gsIHNyY3ksIHNyY3csIHNyY2gsIHgsIHkpIHtcclxuXHJcbiAgICAgICAgdmFyIHNyY0NhbnZhcyA9IHNyY0xheWVyLmdldENhbnZhcygpO1xyXG5cclxuICAgICAgICAvLyBJZiBlbnRpcmUgcmVjdGFuZ2xlIG91dHNpZGUgc291cmNlIGNhbnZhcywgc3RvcFxyXG4gICAgICAgIGlmIChzcmN4ID49IHNyY0NhbnZhcy53aWR0aCB8fCBzcmN5ID49IHNyY0NhbnZhcy5oZWlnaHQpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBjbGlwIHJlY3RhbmdsZSB0byBhcmVhXHJcbiAgICAgICAgaWYgKHNyY3ggKyBzcmN3ID4gc3JjQ2FudmFzLndpZHRoKVxyXG4gICAgICAgICAgICBzcmN3ID0gc3JjQ2FudmFzLndpZHRoIC0gc3JjeDtcclxuXHJcbiAgICAgICAgaWYgKHNyY3kgKyBzcmNoID4gc3JjQ2FudmFzLmhlaWdodClcclxuICAgICAgICAgICAgc3JjaCA9IHNyY0NhbnZhcy5oZWlnaHQgLSBzcmN5O1xyXG5cclxuICAgICAgICAvLyBTdG9wIGlmIG5vdGhpbmcgdG8gZHJhdy5cclxuICAgICAgICBpZiAoc3JjdyA9PT0gMCB8fCBzcmNoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChsYXllci5hdXRvc2l6ZSkgZml0UmVjdCh4LCB5LCBzcmN3LCBzcmNoKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IGltYWdlIGRhdGEgZnJvbSBzcmMgYW5kIGRzdFxyXG4gICAgICAgIHZhciBzcmMgPSBzcmNMYXllci5nZXRDYW52YXMoKS5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKHNyY3gsIHNyY3ksIHNyY3csIHNyY2gpO1xyXG4gICAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKHNyYywgeCwgeSk7XHJcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weSBhIHJlY3RhbmdsZSBvZiBpbWFnZSBkYXRhIGZyb20gb25lIExheWVyIHRvIHRoaXMgTGF5ZXIuIFRoaXNcclxuICAgICAqIG9wZXJhdGlvbiB3aWxsIGNvcHkgZXhhY3RseSB0aGUgaW1hZ2UgZGF0YSB0aGF0IHdpbGwgYmUgZHJhd24gb25jZSBhbGxcclxuICAgICAqIG9wZXJhdGlvbnMgb2YgdGhlIHNvdXJjZSBMYXllciB0aGF0IHdlcmUgcGVuZGluZyBhdCB0aGUgdGltZSB0aGlzXHJcbiAgICAgKiBmdW5jdGlvbiB3YXMgY2FsbGVkIGFyZSBjb21wbGV0ZS4gVGhpcyBvcGVyYXRpb24gd2lsbCBub3QgYWx0ZXIgdGhlXHJcbiAgICAgKiBzaXplIG9mIHRoZSBzb3VyY2UgTGF5ZXIgZXZlbiBpZiBpdHMgYXV0b3NpemUgcHJvcGVydHkgaXMgc2V0IHRvIHRydWUuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBzcmNMYXllciBUaGUgTGF5ZXIgdG8gY29weSBpbWFnZSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHNvdXJjZSBMYXllcidzIGNvb3JkaW5hdGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHNwYWNlIHRvIGNvcHkgZGF0YSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNyY3kgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2UgTGF5ZXIncyBjb29yZGluYXRlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcmN3IFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgc291cmNlIExheWVyJ3NcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUgc3BhY2UgdG8gY29weSBkYXRhIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3JjaCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUgd2l0aGluIHRoZSBzb3VyY2VcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIExheWVyJ3MgY29vcmRpbmF0ZSBzcGFjZSB0byBjb3B5IGRhdGEgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBkZXN0aW5hdGlvbiBYIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgZGVzdGluYXRpb24gWSBjb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvcHkgPSBmdW5jdGlvbihzcmNMYXllciwgc3JjeCwgc3JjeSwgc3Jjdywgc3JjaCwgeCwgeSkge1xyXG5cclxuICAgICAgICB2YXIgc3JjQ2FudmFzID0gc3JjTGF5ZXIuZ2V0Q2FudmFzKCk7XHJcblxyXG4gICAgICAgIC8vIElmIGVudGlyZSByZWN0YW5nbGUgb3V0c2lkZSBzb3VyY2UgY2FudmFzLCBzdG9wXHJcbiAgICAgICAgaWYgKHNyY3ggPj0gc3JjQ2FudmFzLndpZHRoIHx8IHNyY3kgPj0gc3JjQ2FudmFzLmhlaWdodCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGNsaXAgcmVjdGFuZ2xlIHRvIGFyZWFcclxuICAgICAgICBpZiAoc3JjeCArIHNyY3cgPiBzcmNDYW52YXMud2lkdGgpXHJcbiAgICAgICAgICAgIHNyY3cgPSBzcmNDYW52YXMud2lkdGggLSBzcmN4O1xyXG5cclxuICAgICAgICBpZiAoc3JjeSArIHNyY2ggPiBzcmNDYW52YXMuaGVpZ2h0KVxyXG4gICAgICAgICAgICBzcmNoID0gc3JjQ2FudmFzLmhlaWdodCAtIHNyY3k7XHJcblxyXG4gICAgICAgIC8vIFN0b3AgaWYgbm90aGluZyB0byBkcmF3LlxyXG4gICAgICAgIGlmIChzcmN3ID09PSAwIHx8IHNyY2ggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKGxheWVyLmF1dG9zaXplKSBmaXRSZWN0KHgsIHksIHNyY3csIHNyY2gpO1xyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHNyY0NhbnZhcywgc3JjeCwgc3JjeSwgc3Jjdywgc3JjaCwgeCwgeSwgc3Jjdywgc3JjaCk7XHJcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIGEgbmV3IHBhdGggYXQgdGhlIHNwZWNpZmllZCBwb2ludC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gZHJhdy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGRyYXcuXHJcbiAgICAgKi9cclxuICAgIHRoaXMubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IHBhdGggaWYgY3VycmVudCBwYXRoIGlzIGNsb3NlZFxyXG4gICAgICAgIGlmIChwYXRoQ2xvc2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIHBhdGhDbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGxheWVyLmF1dG9zaXplKSBmaXRSZWN0KHgsIHksIDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIHNwZWNpZmllZCBsaW5lIHRvIHRoZSBjdXJyZW50IHBhdGguXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSB0byBkcmF3LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmxpbmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTdGFydCBhIG5ldyBwYXRoIGlmIGN1cnJlbnQgcGF0aCBpcyBjbG9zZWRcclxuICAgICAgICBpZiAocGF0aENsb3NlZCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBwYXRoQ2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChsYXllci5hdXRvc2l6ZSkgZml0UmVjdCh4LCB5LCAwLCAwKTtcclxuICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcclxuICAgICAgICBcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIHNwZWNpZmllZCBhcmMgdG8gdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgd2hpY2hcclxuICAgICAqICAgICAgICAgICAgICAgICAgIHdpbGwgY29udGFpbiB0aGUgYXJjLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgd2hpY2hcclxuICAgICAqICAgICAgICAgICAgICAgICAgIHdpbGwgY29udGFpbiB0aGUgYXJjLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZSBUaGUgc3RhcnRpbmcgYW5nbGUgb2YgdGhlIGFyYywgaW4gcmFkaWFucy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRBbmdsZSBUaGUgZW5kaW5nIGFuZ2xlIG9mIHRoZSBhcmMsIGluIHJhZGlhbnMuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5lZ2F0aXZlIFdoZXRoZXIgdGhlIGFyYyBzaG91bGQgYmUgZHJhd24gaW4gb3JkZXIgb2ZcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVhc2luZyBhbmdsZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5hcmMgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBuZWdhdGl2ZSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IHBhdGggaWYgY3VycmVudCBwYXRoIGlzIGNsb3NlZFxyXG4gICAgICAgIGlmIChwYXRoQ2xvc2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIHBhdGhDbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGxheWVyLmF1dG9zaXplKSBmaXRSZWN0KHgsIHksIDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIG5lZ2F0aXZlKTtcclxuICAgICAgICBcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBuZXcgcGF0aCBhdCB0aGUgc3BlY2lmaWVkIHBvaW50LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3AxeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNwMXkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNwMnkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBlbmRwb2ludCBvZiB0aGUgY3VydmUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmRwb2ludCBvZiB0aGUgY3VydmUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VydmVUbyA9IGZ1bmN0aW9uKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTdGFydCBhIG5ldyBwYXRoIGlmIGN1cnJlbnQgcGF0aCBpcyBjbG9zZWRcclxuICAgICAgICBpZiAocGF0aENsb3NlZCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBwYXRoQ2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChsYXllci5hdXRvc2l6ZSkgZml0UmVjdCh4LCB5LCAwLCAwKTtcclxuICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XHJcbiAgICAgICAgXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGggYnkgY29ubmVjdGluZyB0aGUgZW5kIHBvaW50IHdpdGggdGhlIHN0YXJ0XHJcbiAgICAgKiBwb2ludCAoaWYgYW55KSB3aXRoIGEgc3RyYWlnaHQgbGluZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgcGF0aENsb3NlZCA9IHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlIHRvIHRoZSBjdXJyZW50IHBhdGguXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSB0byBkcmF3LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgdG8gZHJhdy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZSB0byBkcmF3LlxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IHBhdGggaWYgY3VycmVudCBwYXRoIGlzIGNsb3NlZFxyXG4gICAgICAgIGlmIChwYXRoQ2xvc2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIHBhdGhDbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGxheWVyLmF1dG9zaXplKSBmaXRSZWN0KHgsIHksIHcsIGgpO1xyXG4gICAgICAgIGNvbnRleHQucmVjdCh4LCB5LCB3LCBoKTtcclxuICAgICAgICBcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGlwIGFsbCBmdXR1cmUgZHJhd2luZyBvcGVyYXRpb25zIGJ5IHRoZSBjdXJyZW50IHBhdGguIFRoZSBjdXJyZW50IHBhdGhcclxuICAgICAqIGlzIGltcGxpY2l0bHkgY2xvc2VkLiBUaGUgY3VycmVudCBwYXRoIGNhbiBjb250aW51ZSB0byBiZSByZXVzZWRcclxuICAgICAqIGZvciBvdGhlciBvcGVyYXRpb25zIChzdWNoIGFzIGZpbGxDb2xvcigpKSBidXQgYSBuZXcgcGF0aCB3aWxsIGJlIHN0YXJ0ZWRcclxuICAgICAqIG9uY2UgYSBwYXRoIGRyYXdpbmcgb3BlcmF0aW9uIChwYXRoKCkgb3IgcmVjdCgpKSBpcyB1c2VkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaXAgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLy8gU2V0IG5ldyBjbGlwcGluZyByZWdpb25cclxuICAgICAgICBjb250ZXh0LmNsaXAoKTtcclxuXHJcbiAgICAgICAgLy8gUGF0aCBub3cgaW1wbGljaXRseSBjbG9zZWRcclxuICAgICAgICBwYXRoQ2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Ryb2tlIHRoZSBjdXJyZW50IHBhdGggd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG9yLiBUaGUgY3VycmVudCBwYXRoXHJcbiAgICAgKiBpcyBpbXBsaWNpdGx5IGNsb3NlZC4gVGhlIGN1cnJlbnQgcGF0aCBjYW4gY29udGludWUgdG8gYmUgcmV1c2VkXHJcbiAgICAgKiBmb3Igb3RoZXIgb3BlcmF0aW9ucyAoc3VjaCBhcyBjbGlwKCkpIGJ1dCBhIG5ldyBwYXRoIHdpbGwgYmUgc3RhcnRlZFxyXG4gICAgICogb25jZSBhIHBhdGggZHJhd2luZyBvcGVyYXRpb24gKHBhdGgoKSBvciByZWN0KCkpIGlzIHVzZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYXAgVGhlIGxpbmUgY2FwIHN0eWxlLiBDYW4gYmUgXCJyb3VuZFwiLCBcInNxdWFyZVwiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBvciBcImJ1dHRcIi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBqb2luIFRoZSBsaW5lIGpvaW4gc3R5bGUuIENhbiBiZSBcInJvdW5kXCIsIFwiYmV2ZWxcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG9yIFwibWl0ZXJcIi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aGlja25lc3MgVGhlIGxpbmUgdGhpY2tuZXNzIGluIHBpeGVscy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIFRoZSByZWQgY29tcG9uZW50IG9mIHRoZSBjb2xvciB0byBmaWxsLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGcgVGhlIGdyZWVuIGNvbXBvbmVudCBvZiB0aGUgY29sb3IgdG8gZmlsbC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBibHVlIGNvbXBvbmVudCBvZiB0aGUgY29sb3IgdG8gZmlsbC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBhbHBoYSBjb21wb25lbnQgb2YgdGhlIGNvbG9yIHRvIGZpbGwuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBmdW5jdGlvbihjYXAsIGpvaW4sIHRoaWNrbmVzcywgciwgZywgYiwgYSkge1xyXG5cclxuICAgICAgICAvLyBTdHJva2Ugd2l0aCBjb2xvclxyXG4gICAgICAgIGNvbnRleHQubGluZUNhcCA9IGNhcDtcclxuICAgICAgICBjb250ZXh0LmxpbmVKb2luID0gam9pbjtcclxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRoaWNrbmVzcztcclxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLFwiICsgYS8yNTUuMCArIFwiKVwiO1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gUGF0aCBub3cgaW1wbGljaXRseSBjbG9zZWRcclxuICAgICAgICBwYXRoQ2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsbHMgdGhlIGN1cnJlbnQgcGF0aCB3aXRoIHRoZSBzcGVjaWZpZWQgY29sb3IuIFRoZSBjdXJyZW50IHBhdGhcclxuICAgICAqIGlzIGltcGxpY2l0bHkgY2xvc2VkLiBUaGUgY3VycmVudCBwYXRoIGNhbiBjb250aW51ZSB0byBiZSByZXVzZWRcclxuICAgICAqIGZvciBvdGhlciBvcGVyYXRpb25zIChzdWNoIGFzIGNsaXAoKSkgYnV0IGEgbmV3IHBhdGggd2lsbCBiZSBzdGFydGVkXHJcbiAgICAgKiBvbmNlIGEgcGF0aCBkcmF3aW5nIG9wZXJhdGlvbiAocGF0aCgpIG9yIHJlY3QoKSkgaXMgdXNlZC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgVGhlIHJlZCBjb21wb25lbnQgb2YgdGhlIGNvbG9yIHRvIGZpbGwuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZyBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIHRoZSBjb2xvciB0byBmaWxsLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIGJsdWUgY29tcG9uZW50IG9mIHRoZSBjb2xvciB0byBmaWxsLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGFscGhhIGNvbXBvbmVudCBvZiB0aGUgY29sb3IgdG8gZmlsbC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5maWxsQ29sb3IgPSBmdW5jdGlvbihyLCBnLCBiLCBhKSB7XHJcblxyXG4gICAgICAgIC8vIEZpbGwgd2l0aCBjb2xvclxyXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLFwiICsgYS8yNTUuMCArIFwiKVwiO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIFBhdGggbm93IGltcGxpY2l0bHkgY2xvc2VkXHJcbiAgICAgICAgcGF0aENsb3NlZCA9IHRydWU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cm9rZSB0aGUgY3VycmVudCBwYXRoIHdpdGggdGhlIGltYWdlIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGxheWVyLiBUaGVcclxuICAgICAqIGltYWdlIGRhdGEgd2lsbCBiZSB0aWxlZCBpbmZpbml0ZWx5IHdpdGhpbiB0aGUgc3Ryb2tlLiBUaGUgY3VycmVudCBwYXRoXHJcbiAgICAgKiBpcyBpbXBsaWNpdGx5IGNsb3NlZC4gVGhlIGN1cnJlbnQgcGF0aCBjYW4gY29udGludWUgdG8gYmUgcmV1c2VkXHJcbiAgICAgKiBmb3Igb3RoZXIgb3BlcmF0aW9ucyAoc3VjaCBhcyBjbGlwKCkpIGJ1dCBhIG5ldyBwYXRoIHdpbGwgYmUgc3RhcnRlZFxyXG4gICAgICogb25jZSBhIHBhdGggZHJhd2luZyBvcGVyYXRpb24gKHBhdGgoKSBvciByZWN0KCkpIGlzIHVzZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYXAgVGhlIGxpbmUgY2FwIHN0eWxlLiBDYW4gYmUgXCJyb3VuZFwiLCBcInNxdWFyZVwiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBvciBcImJ1dHRcIi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBqb2luIFRoZSBsaW5lIGpvaW4gc3R5bGUuIENhbiBiZSBcInJvdW5kXCIsIFwiYmV2ZWxcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG9yIFwibWl0ZXJcIi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aGlja25lc3MgVGhlIGxpbmUgdGhpY2tuZXNzIGluIHBpeGVscy5cclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLkxheWVyfSBzcmNMYXllciBUaGUgbGF5ZXIgdG8gdXNlIGFzIGEgcmVwZWF0aW5nIHBhdHRlcm5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoaW4gdGhlIHN0cm9rZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdHJva2VMYXllciA9IGZ1bmN0aW9uKGNhcCwgam9pbiwgdGhpY2tuZXNzLCBzcmNMYXllcikge1xyXG5cclxuICAgICAgICAvLyBTdHJva2Ugd2l0aCBpbWFnZSBkYXRhXHJcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gY2FwO1xyXG4gICAgICAgIGNvbnRleHQubGluZUpvaW4gPSBqb2luO1xyXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGhpY2tuZXNzO1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oXHJcbiAgICAgICAgICAgIHNyY0xheWVyLmdldENhbnZhcygpLFxyXG4gICAgICAgICAgICBcInJlcGVhdFwiXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIFBhdGggbm93IGltcGxpY2l0bHkgY2xvc2VkXHJcbiAgICAgICAgcGF0aENsb3NlZCA9IHRydWU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGxzIHRoZSBjdXJyZW50IHBhdGggd2l0aCB0aGUgaW1hZ2Ugd2l0aGluIHRoZSBzcGVjaWZpZWQgbGF5ZXIuIFRoZVxyXG4gICAgICogaW1hZ2UgZGF0YSB3aWxsIGJlIHRpbGVkIGluZmluaXRlbHkgd2l0aGluIHRoZSBzdHJva2UuIFRoZSBjdXJyZW50IHBhdGhcclxuICAgICAqIGlzIGltcGxpY2l0bHkgY2xvc2VkLiBUaGUgY3VycmVudCBwYXRoIGNhbiBjb250aW51ZSB0byBiZSByZXVzZWRcclxuICAgICAqIGZvciBvdGhlciBvcGVyYXRpb25zIChzdWNoIGFzIGNsaXAoKSkgYnV0IGEgbmV3IHBhdGggd2lsbCBiZSBzdGFydGVkXHJcbiAgICAgKiBvbmNlIGEgcGF0aCBkcmF3aW5nIG9wZXJhdGlvbiAocGF0aCgpIG9yIHJlY3QoKSkgaXMgdXNlZC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTGF5ZXJ9IHNyY0xheWVyIFRoZSBsYXllciB0byB1c2UgYXMgYSByZXBlYXRpbmcgcGF0dGVyblxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhpbiB0aGUgZmlsbC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5maWxsTGF5ZXIgPSBmdW5jdGlvbihzcmNMYXllcikge1xyXG5cclxuICAgICAgICAvLyBGaWxsIHdpdGggaW1hZ2UgZGF0YSBcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihcclxuICAgICAgICAgICAgc3JjTGF5ZXIuZ2V0Q2FudmFzKCksXHJcbiAgICAgICAgICAgIFwicmVwZWF0XCJcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIFBhdGggbm93IGltcGxpY2l0bHkgY2xvc2VkXHJcbiAgICAgICAgcGF0aENsb3NlZCA9IHRydWU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFB1c2ggY3VycmVudCBsYXllciBzdGF0ZSBvbnRvIHN0YWNrLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLy8gU2F2ZSBjdXJyZW50IHN0YXRlIG9udG8gc3RhY2tcclxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgICAgICBzdGFja1NpemUrKztcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9wIGxheWVyIHN0YXRlIG9mZiBzdGFjay5cclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3AgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLy8gUmVzdG9yZSBjdXJyZW50IHN0YXRlIGZyb20gc3RhY2tcclxuICAgICAgICBpZiAoc3RhY2tTaXplID4gMCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgc3RhY2tTaXplLS07XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgbGF5ZXIsIGNsZWFyaW5nIHRoZSBzdGFjaywgdGhlIGN1cnJlbnQgcGF0aCwgYW5kIGFueSB0cmFuc2Zvcm1cclxuICAgICAqIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBDbGVhciBzdGFja1xyXG4gICAgICAgIHdoaWxlIChzdGFja1NpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICBzdGFja1NpemUtLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgdG8gaW5pdGlhbCBzdGF0ZVxyXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG5cclxuICAgICAgICAvLyBDbGVhciBwYXRoXHJcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBwYXRoQ2xvc2VkID0gZmFsc2U7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGdpdmVuIGFmZmluZSB0cmFuc2Zvcm0gKGRlZmluZWQgd2l0aCBzaXggdmFsdWVzIGZyb20gdGhlXHJcbiAgICAgKiB0cmFuc2Zvcm0ncyBtYXRyaXgpLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIHRoaXJkIHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVGhlIGZvdXJ0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlIFRoZSBmaWZ0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmIFRoZSBzaXh0aCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oXHJcbiAgICAgICAgICAgIGEsIGIsIGMsXHJcbiAgICAgICAgICAgIGQsIGUsIGZcclxuICAgICAgICAgIC8qMCwgMCwgMSovXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBhZmZpbmUgdHJhbnNmb3JtIChkZWZpbmVkIHdpdGggc2l4IHZhbHVlcyBmcm9tIHRoZVxyXG4gICAgICogdHJhbnNmb3JtJ3MgbWF0cml4KS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhZmZpbmUgdHJhbnNmb3JtJ3MgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSB0aGlyZCB2YWx1ZSBpbiB0aGUgYWZmaW5lIHRyYW5zZm9ybSdzIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkIFRoZSBmb3VydGggdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZSBUaGUgZmlmdGggdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZiBUaGUgc2l4dGggdmFsdWUgaW4gdGhlIGFmZmluZSB0cmFuc2Zvcm0ncyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJhbnNmb3JtID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKFxyXG4gICAgICAgICAgICBhLCBiLCBjLFxyXG4gICAgICAgICAgICBkLCBlLCBmXHJcbiAgICAgICAgICAvKjAsIDAsIDEqL1xyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY2hhbm5lbCBtYXNrIGZvciBmdXR1cmUgb3BlcmF0aW9ucyBvbiB0aGlzIExheWVyLlxyXG4gICAgICogXHJcbiAgICAgKiBUaGUgY2hhbm5lbCBtYXNrIGlzIGEgR3VhY2Ftb2xlLXNwZWNpZmljIGNvbXBvc2l0aW5nIG9wZXJhdGlvbiBpZGVudGlmaWVyXHJcbiAgICAgKiB3aXRoIGEgc2luZ2xlIGJpdCByZXByZXNlbnRpbmcgZWFjaCBvZiBmb3VyIGNoYW5uZWxzIChpbiBvcmRlcik6IHNvdXJjZVxyXG4gICAgICogaW1hZ2Ugd2hlcmUgZGVzdGluYXRpb24gdHJhbnNwYXJlbnQsIHNvdXJjZSB3aGVyZSBkZXN0aW5hdGlvbiBvcGFxdWUsXHJcbiAgICAgKiBkZXN0aW5hdGlvbiB3aGVyZSBzb3VyY2UgdHJhbnNwYXJlbnQsIGFuZCBkZXN0aW5hdGlvbiB3aGVyZSBzb3VyY2VcclxuICAgICAqIG9wYXF1ZS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1hc2sgVGhlIGNoYW5uZWwgbWFzayBmb3IgZnV0dXJlIG9wZXJhdGlvbnMgb24gdGhpc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgTGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2V0Q2hhbm5lbE1hc2sgPSBmdW5jdGlvbihtYXNrKSB7XHJcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb25bbWFza107XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWl0ZXIgbGltaXQgZm9yIHN0cm9rZSBvcGVyYXRpb25zIHVzaW5nIHRoZSBtaXRlciBqb2luLiBUaGlzXHJcbiAgICAgKiBsaW1pdCBpcyB0aGUgbWF4aW11bSByYXRpbyBvZiB0aGUgc2l6ZSBvZiB0aGUgbWl0ZXIgam9pbiB0byB0aGUgc3Ryb2tlXHJcbiAgICAgKiB3aWR0aC4gSWYgdGhpcyByYXRpbyBpcyBleGNlZWRlZCwgdGhlIG1pdGVyIHdpbGwgbm90IGJlIGRyYXduIGZvciB0aGF0XHJcbiAgICAgKiBqb2ludCBvZiB0aGUgcGF0aC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0IFRoZSBtaXRlciBsaW1pdCBmb3Igc3Ryb2tlIG9wZXJhdGlvbnMgdXNpbmcgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgbWl0ZXIgam9pbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXRNaXRlckxpbWl0ID0gZnVuY3Rpb24obGltaXQpIHtcclxuICAgICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBsaW1pdDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBjYW52YXMgZGltZW5zaW9uc1xyXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIC8vIEV4cGxpY2l0bHkgcmVuZGVyIGNhbnZhcyBiZWxvdyBvdGhlciBlbGVtZW50cyBpbiB0aGUgbGF5ZXIgKHN1Y2ggYXNcclxuICAgIC8vIGNoaWxkIGxheWVycykuIENocm9tZSBhbmQgb3RoZXJzIG1heSBmYWlsIHRvIHJlbmRlciBsYXllcnMgcHJvcGVybHlcclxuICAgIC8vIHdpdGhvdXQgdGhpcy5cclxuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAtMTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQ2hhbm5lbCBtYXNrIGZvciB0aGUgY29tcG9zaXRlIG9wZXJhdGlvbiBcInJvdXRcIi5cclxuICovXHJcbkd1YWNhbW9sZS5MYXllci5ST1VUICA9IDB4MjtcclxuXHJcbi8qKlxyXG4gKiBDaGFubmVsIG1hc2sgZm9yIHRoZSBjb21wb3NpdGUgb3BlcmF0aW9uIFwiYXRvcFwiLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkxheWVyLkFUT1AgID0gMHg2O1xyXG5cclxuLyoqXHJcbiAqIENoYW5uZWwgbWFzayBmb3IgdGhlIGNvbXBvc2l0ZSBvcGVyYXRpb24gXCJ4b3JcIi5cclxuICovXHJcbkd1YWNhbW9sZS5MYXllci5YT1IgICA9IDB4QTtcclxuXHJcbi8qKlxyXG4gKiBDaGFubmVsIG1hc2sgZm9yIHRoZSBjb21wb3NpdGUgb3BlcmF0aW9uIFwicm92ZXJcIi5cclxuICovXHJcbkd1YWNhbW9sZS5MYXllci5ST1ZFUiA9IDB4QjtcclxuXHJcbi8qKlxyXG4gKiBDaGFubmVsIG1hc2sgZm9yIHRoZSBjb21wb3NpdGUgb3BlcmF0aW9uIFwib3ZlclwiLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkxheWVyLk9WRVIgID0gMHhFO1xyXG5cclxuLyoqXHJcbiAqIENoYW5uZWwgbWFzayBmb3IgdGhlIGNvbXBvc2l0ZSBvcGVyYXRpb24gXCJwbHVzXCIuXHJcbiAqL1xyXG5HdWFjYW1vbGUuTGF5ZXIuUExVUyAgPSAweEY7XHJcblxyXG4vKipcclxuICogQ2hhbm5lbCBtYXNrIGZvciB0aGUgY29tcG9zaXRlIG9wZXJhdGlvbiBcInJpblwiLlxyXG4gKiBCZXdhcmUgdGhhdCBXZWJLaXQtYmFzZWQgYnJvd3NlcnMgbWF5IGxlYXZlIHRoZSBjb250ZW50cyBvZiB0aGUgZGVzdGlvbmF0aW9uXHJcbiAqIGxheWVyIHdoZXJlIHRoZSBzb3VyY2UgbGF5ZXIgaXMgdHJhbnNwYXJlbnQsIGRlc3BpdGUgdGhlIGRlZmluaXRpb24gb2YgdGhpc1xyXG4gKiBvcGVyYXRpb24uXHJcbiAqL1xyXG5HdWFjYW1vbGUuTGF5ZXIuUklOICAgPSAweDE7XHJcblxyXG4vKipcclxuICogQ2hhbm5lbCBtYXNrIGZvciB0aGUgY29tcG9zaXRlIG9wZXJhdGlvbiBcImluXCIuXHJcbiAqIEJld2FyZSB0aGF0IFdlYktpdC1iYXNlZCBicm93c2VycyBtYXkgbGVhdmUgdGhlIGNvbnRlbnRzIG9mIHRoZSBkZXN0aW9uYXRpb25cclxuICogbGF5ZXIgd2hlcmUgdGhlIHNvdXJjZSBsYXllciBpcyB0cmFuc3BhcmVudCwgZGVzcGl0ZSB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzXHJcbiAqIG9wZXJhdGlvbi5cclxuICovXHJcbkd1YWNhbW9sZS5MYXllci5JTiAgICA9IDB4NDtcclxuXHJcbi8qKlxyXG4gKiBDaGFubmVsIG1hc2sgZm9yIHRoZSBjb21wb3NpdGUgb3BlcmF0aW9uIFwib3V0XCIuXHJcbiAqIEJld2FyZSB0aGF0IFdlYktpdC1iYXNlZCBicm93c2VycyBtYXkgbGVhdmUgdGhlIGNvbnRlbnRzIG9mIHRoZSBkZXN0aW9uYXRpb25cclxuICogbGF5ZXIgd2hlcmUgdGhlIHNvdXJjZSBsYXllciBpcyB0cmFuc3BhcmVudCwgZGVzcGl0ZSB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzXHJcbiAqIG9wZXJhdGlvbi5cclxuICovXHJcbkd1YWNhbW9sZS5MYXllci5PVVQgICA9IDB4ODtcclxuXHJcbi8qKlxyXG4gKiBDaGFubmVsIG1hc2sgZm9yIHRoZSBjb21wb3NpdGUgb3BlcmF0aW9uIFwicmF0b3BcIi5cclxuICogQmV3YXJlIHRoYXQgV2ViS2l0LWJhc2VkIGJyb3dzZXJzIG1heSBsZWF2ZSB0aGUgY29udGVudHMgb2YgdGhlIGRlc3Rpb25hdGlvblxyXG4gKiBsYXllciB3aGVyZSB0aGUgc291cmNlIGxheWVyIGlzIHRyYW5zcGFyZW50LCBkZXNwaXRlIHRoZSBkZWZpbml0aW9uIG9mIHRoaXNcclxuICogb3BlcmF0aW9uLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkxheWVyLlJBVE9QID0gMHg5O1xyXG5cclxuLyoqXHJcbiAqIENoYW5uZWwgbWFzayBmb3IgdGhlIGNvbXBvc2l0ZSBvcGVyYXRpb24gXCJzcmNcIi5cclxuICogQmV3YXJlIHRoYXQgV2ViS2l0LWJhc2VkIGJyb3dzZXJzIG1heSBsZWF2ZSB0aGUgY29udGVudHMgb2YgdGhlIGRlc3Rpb25hdGlvblxyXG4gKiBsYXllciB3aGVyZSB0aGUgc291cmNlIGxheWVyIGlzIHRyYW5zcGFyZW50LCBkZXNwaXRlIHRoZSBkZWZpbml0aW9uIG9mIHRoaXNcclxuICogb3BlcmF0aW9uLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkxheWVyLlNSQyAgID0gMHhDO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBzaW5nbGUgcGl4ZWwgb2YgaW1hZ2UgZGF0YS4gQWxsIGNvbXBvbmVudHMgaGF2ZSBhIG1pbmltdW0gdmFsdWVcclxuICogb2YgMCBhbmQgYSBtYXhpbXVtIHZhbHVlIG9mIDI1NS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBcclxuICogQHBhcmFtIHtOdW1iZXJ9IHIgVGhlIHJlZCBjb21wb25lbnQgb2YgdGhpcyBwaXhlbC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGcgVGhlIGdyZWVuIGNvbXBvbmVudCBvZiB0aGlzIHBpeGVsLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgYmx1ZSBjb21wb25lbnQgb2YgdGhpcyBwaXhlbC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGFscGhhIGNvbXBvbmVudCBvZiB0aGlzIHBpeGVsLlxyXG4gKi9cclxuR3VhY2Ftb2xlLkxheWVyLlBpeGVsID0gZnVuY3Rpb24ociwgZywgYiwgYSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlZCBjb21wb25lbnQgb2YgdGhpcyBwaXhlbCwgd2hlcmUgMCBpcyB0aGUgbWluaW11bSB2YWx1ZSxcclxuICAgICAqIGFuZCAyNTUgaXMgdGhlIG1heGltdW0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVkICAgPSByO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGdyZWVuIGNvbXBvbmVudCBvZiB0aGlzIHBpeGVsLCB3aGVyZSAwIGlzIHRoZSBtaW5pbXVtIHZhbHVlLFxyXG4gICAgICogYW5kIDI1NSBpcyB0aGUgbWF4aW11bS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5ncmVlbiA9IGc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmx1ZSBjb21wb25lbnQgb2YgdGhpcyBwaXhlbCwgd2hlcmUgMCBpcyB0aGUgbWluaW11bSB2YWx1ZSxcclxuICAgICAqIGFuZCAyNTUgaXMgdGhlIG1heGltdW0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYmx1ZSAgPSBiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFscGhhIGNvbXBvbmVudCBvZiB0aGlzIHBpeGVsLCB3aGVyZSAwIGlzIHRoZSBtaW5pbXVtIHZhbHVlLFxyXG4gICAgICogYW5kIDI1NSBpcyB0aGUgbWF4aW11bS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5hbHBoYSA9IGE7XHJcblxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgY3Jvc3MtYnJvd3NlciBtb3VzZSBldmVudHMgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gVGhlIGV2ZW50cyBvZlxyXG4gKiB0aGUgZ2l2ZW4gZWxlbWVudCBhcmUgYXV0b21hdGljYWxseSBwb3B1bGF0ZWQgd2l0aCBoYW5kbGVycyB0aGF0IHRyYW5zbGF0ZVxyXG4gKiBtb3VzZSBldmVudHMgaW50byBhIG5vbi1icm93c2VyLXNwZWNpZmljIGV2ZW50IHByb3ZpZGVkIGJ5IHRoZVxyXG4gKiBHdWFjYW1vbGUuTW91c2UgaW5zdGFuY2UuXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBFbGVtZW50IHRvIHVzZSB0byBwcm92aWRlIG1vdXNlIGV2ZW50cy5cclxuICovXHJcbkd1YWNhbW9sZS5Nb3VzZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIEd1YWNhbW9sZS5Nb3VzZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX21vdXNlID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgbW91c2Vtb3ZlIGV2ZW50cyB0byByZXF1aXJlIGJlZm9yZSByZS1lbmFibGluZyBtb3VzZVxyXG4gICAgICogZXZlbnQgaGFuZGxpbmcgYWZ0ZXIgcmVjZWl2aW5nIGEgdG91Y2ggZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMudG91Y2hNb3VzZVRocmVzaG9sZCA9IDM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWluaW11bSBhbW91bnQgb2YgcGl4ZWxzIHNjcm9sbGVkIHJlcXVpcmVkIGZvciBhIHNpbmdsZSBzY3JvbGwgYnV0dG9uXHJcbiAgICAgKiBjbGljay5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zY3JvbGxUaHJlc2hvbGQgPSA1MztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgcGl4ZWxzIHRvIHNjcm9sbCBwZXIgbGluZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5QSVhFTFNfUEVSX0xJTkUgPSAxODtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgcGl4ZWxzIHRvIHNjcm9sbCBwZXIgcGFnZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5QSVhFTFNfUEVSX1BBR0UgPSB0aGlzLlBJWEVMU19QRVJfTElORSAqIDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgbW91c2Ugc3RhdGUuIFRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgc3RhdGUgYXJlIHVwZGF0ZWQgd2hlblxyXG4gICAgICogbW91c2UgZXZlbnRzIGZpcmUuIFRoaXMgc3RhdGUgb2JqZWN0IGlzIGFsc28gcGFzc2VkIGluIGFzIGEgcGFyYW1ldGVyIHRvXHJcbiAgICAgKiB0aGUgaGFuZGxlciBvZiBhbnkgbW91c2UgZXZlbnRzLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLk1vdXNlLlN0YXRlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ldyBHdWFjYW1vbGUuTW91c2UuU3RhdGUoXHJcbiAgICAgICAgMCwgMCwgXHJcbiAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXHJcbiAgICApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHVzZXIgcHJlc3NlcyBhIG1vdXNlIGJ1dHRvbiBkb3duIG92ZXIgdGhlIGVsZW1lbnRcclxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEd1YWNhbW9sZS5Nb3VzZS5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5Nb3VzZS5TdGF0ZX0gc3RhdGUgVGhlIGN1cnJlbnQgbW91c2Ugc3RhdGUuXHJcbiAgICAgKi9cclxuXHR0aGlzLm9ubW91c2Vkb3duID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSB1c2VyIHJlbGVhc2VzIGEgbW91c2UgYnV0dG9uIGRvd24gb3ZlciB0aGUgZWxlbWVudFxyXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoaXMgR3VhY2Ftb2xlLk1vdXNlLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLk1vdXNlLlN0YXRlfSBzdGF0ZSBUaGUgY3VycmVudCBtb3VzZSBzdGF0ZS5cclxuICAgICAqL1xyXG5cdHRoaXMub25tb3VzZXVwID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSB1c2VyIG1vdmVzIHRoZSBtb3VzZSBvdmVyIHRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aFxyXG4gICAgICogdGhpcyBHdWFjYW1vbGUuTW91c2UuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTW91c2UuU3RhdGV9IHN0YXRlIFRoZSBjdXJyZW50IG1vdXNlIHN0YXRlLlxyXG4gICAgICovXHJcblx0dGhpcy5vbm1vdXNlbW92ZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbW91c2UgbGVhdmVzIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBlbGVtZW50IGFzc29jaWF0ZWRcclxuICAgICAqIHdpdGggdGhpcyBHdWFjYW1vbGUuTW91c2UuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICovXHJcblx0dGhpcy5vbm1vdXNlb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvdW50ZXIgb2YgbW91c2UgZXZlbnRzIHRvIGlnbm9yZS4gVGhpcyBkZWNyZW1lbnRlZCBieSBtb3VzZW1vdmUsIGFuZFxyXG4gICAgICogd2hpbGUgbm9uLXplcm8sIG1vdXNlIGV2ZW50cyB3aWxsIGhhdmUgbm8gZWZmZWN0LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGlnbm9yZV9tb3VzZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdW11bGF0aXZlIHNjcm9sbCBkZWx0YSBhbW91bnQuIFRoaXMgdmFsdWUgaXMgYWNjdW11bGF0ZWQgdGhyb3VnaCBzY3JvbGxcclxuICAgICAqIGV2ZW50cyBhbmQgcmVzdWx0cyBpbiBzY3JvbGwgYnV0dG9uIGNsaWNrcyBpZiBpdCBleGNlZWRzIGEgY2VydGFpblxyXG4gICAgICogdGhyZXNob2xkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBzY3JvbGxfZGVsdGEgPSAwO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNhbmNlbEV2ZW50KGUpIHtcclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJsb2NrIGNvbnRleHQgbWVudSBzbyByaWdodC1jbGljayBnZXRzIHNlbnQgcHJvcGVybHlcclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBjYW5jZWxFdmVudChlKTtcclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICBjYW5jZWxFdmVudChlKTtcclxuXHJcbiAgICAgICAgLy8gSWYgaWdub3JpbmcgZXZlbnRzLCBkZWNyZW1lbnQgY291bnRlclxyXG4gICAgICAgIGlmIChpZ25vcmVfbW91c2UpIHtcclxuICAgICAgICAgICAgaWdub3JlX21vdXNlLS07XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGd1YWNfbW91c2UuY3VycmVudFN0YXRlLmZyb21DbGllbnRQb3NpdGlvbihlbGVtZW50LCBlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblxyXG4gICAgICAgIGlmIChndWFjX21vdXNlLm9ubW91c2Vtb3ZlKVxyXG4gICAgICAgICAgICBndWFjX21vdXNlLm9ubW91c2Vtb3ZlKGd1YWNfbW91c2UuY3VycmVudFN0YXRlKTtcclxuXHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgY2FuY2VsRXZlbnQoZSk7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBoYW5kbGUgaWYgaWdub3JpbmcgZXZlbnRzXHJcbiAgICAgICAgaWYgKGlnbm9yZV9tb3VzZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGUuYnV0dG9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGd1YWNfbW91c2UuY3VycmVudFN0YXRlLmxlZnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGd1YWNfbW91c2UuY3VycmVudFN0YXRlLm1pZGRsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUucmlnaHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZ3VhY19tb3VzZS5vbm1vdXNlZG93bilcclxuICAgICAgICAgICAgZ3VhY19tb3VzZS5vbm1vdXNlZG93bihndWFjX21vdXNlLmN1cnJlbnRTdGF0ZSk7XHJcblxyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICBjYW5jZWxFdmVudChlKTtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IGhhbmRsZSBpZiBpZ25vcmluZyBldmVudHNcclxuICAgICAgICBpZiAoaWdub3JlX21vdXNlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHN3aXRjaCAoZS5idXR0b24pIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUubGVmdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGd1YWNfbW91c2UuY3VycmVudFN0YXRlLm1pZGRsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGd1YWNfbW91c2UuY3VycmVudFN0YXRlLnJpZ2h0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChndWFjX21vdXNlLm9ubW91c2V1cClcclxuICAgICAgICAgICAgZ3VhY19tb3VzZS5vbm1vdXNldXAoZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUpO1xyXG5cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgIC8vIEdldCBwYXJlbnQgb2YgdGhlIGVsZW1lbnQgdGhlIG1vdXNlIHBvaW50ZXIgaXMgbGVhdmluZ1xyXG4gICAgICAgXHRpZiAoIWUpIGUgPSB3aW5kb3cuZXZlbnQ7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgbW91c2VvdXQgaXMgZHVlIHRvIGFjdHVhbGx5IExFQVZJTkcgdGhlIGVsZW1lbnRcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gZS5yZWxhdGVkVGFyZ2V0IHx8IGUudG9FbGVtZW50O1xyXG4gICAgICAgIHdoaWxlICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gZWxlbWVudClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYW5jZWxFdmVudChlKTtcclxuXHJcbiAgICAgICAgLy8gUmVsZWFzZSBhbGwgYnV0dG9uc1xyXG4gICAgICAgIGlmIChndWFjX21vdXNlLmN1cnJlbnRTdGF0ZS5sZWZ0XHJcbiAgICAgICAgICAgIHx8IGd1YWNfbW91c2UuY3VycmVudFN0YXRlLm1pZGRsZVxyXG4gICAgICAgICAgICB8fCBndWFjX21vdXNlLmN1cnJlbnRTdGF0ZS5yaWdodCkge1xyXG5cclxuICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUubGVmdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBndWFjX21vdXNlLmN1cnJlbnRTdGF0ZS5taWRkbGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUucmlnaHQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChndWFjX21vdXNlLm9ubW91c2V1cClcclxuICAgICAgICAgICAgICAgIGd1YWNfbW91c2Uub25tb3VzZXVwKGd1YWNfbW91c2UuY3VycmVudFN0YXRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZpcmUgb25tb3VzZW91dCBldmVudFxyXG4gICAgICAgIGlmIChndWFjX21vdXNlLm9ubW91c2VvdXQpXHJcbiAgICAgICAgICAgIGd1YWNfbW91c2Uub25tb3VzZW91dCgpO1xyXG5cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAvLyBPdmVycmlkZSBzZWxlY3Rpb24gb24gbW91c2UgZXZlbnQgZWxlbWVudC5cclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBjYW5jZWxFdmVudChlKTtcclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAvLyBJZ25vcmUgYWxsIHBlbmRpbmcgbW91c2UgZXZlbnRzIHdoZW4gdG91Y2ggZXZlbnRzIGFyZSB0aGUgYXBwYXJlbnQgc291cmNlXHJcbiAgICBmdW5jdGlvbiBpZ25vcmVQZW5kaW5nTW91c2VFdmVudHMoKSB7IGlnbm9yZV9tb3VzZSA9IGd1YWNfbW91c2UudG91Y2hNb3VzZVRocmVzaG9sZDsgfVxyXG5cclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCAgaWdub3JlUGVuZGluZ01vdXNlRXZlbnRzLCBmYWxzZSk7XHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGlnbm9yZVBlbmRpbmdNb3VzZUV2ZW50cywgZmFsc2UpO1xyXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgICBpZ25vcmVQZW5kaW5nTW91c2VFdmVudHMsIGZhbHNlKTtcclxuXHJcbiAgICAvLyBTY3JvbGwgd2hlZWwgc3VwcG9ydFxyXG4gICAgZnVuY3Rpb24gbW91c2V3aGVlbF9oYW5kbGVyKGUpIHtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGFwcHJveGltYXRlIHNjcm9sbCBhbW91bnQgKGluIHBpeGVscylcclxuICAgICAgICB2YXIgZGVsdGEgPSBlLmRlbHRhWSB8fCAtZS53aGVlbERlbHRhWSB8fCAtZS53aGVlbERlbHRhO1xyXG5cclxuICAgICAgICAvLyBJZiBzdWNjZXNzZnVsbHkgcmV0cmlldmVkIHNjcm9sbCBhbW91bnQsIGNvbnZlcnQgdG8gcGl4ZWxzIGlmIG5vdFxyXG4gICAgICAgIC8vIGFscmVhZHkgaW4gcGl4ZWxzXHJcbiAgICAgICAgaWYgKGRlbHRhKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiBkZWx0YSB3YXMgbGluZXNcclxuICAgICAgICAgICAgaWYgKGUuZGVsdGFNb2RlID09PSAxKVxyXG4gICAgICAgICAgICAgICAgZGVsdGEgPSBlLmRlbHRhWSAqIGd1YWNfbW91c2UuUElYRUxTX1BFUl9MSU5FO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCB0byBwaXhlbHMgaWYgZGVsdGEgd2FzIHBhZ2VzXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGUuZGVsdGFNb2RlID09PSAyKVxyXG4gICAgICAgICAgICAgICAgZGVsdGEgPSBlLmRlbHRhWSAqIGd1YWNfbW91c2UuUElYRUxTX1BFUl9QQUdFO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIGxlZ2FjeSBtb3VzZXdoZWVsIGV2ZW50IGFuZCBsaW5lIHNjcm9sbGluZ1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZGVsdGEgPSBlLmRldGFpbCAqIGd1YWNfbW91c2UuUElYRUxTX1BFUl9MSU5FO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVwZGF0ZSBvdmVyYWxsIGRlbHRhXHJcbiAgICAgICAgc2Nyb2xsX2RlbHRhICs9IGRlbHRhO1xyXG5cclxuICAgICAgICAvLyBVcFxyXG4gICAgICAgIGlmIChzY3JvbGxfZGVsdGEgPD0gLWd1YWNfbW91c2Uuc2Nyb2xsVGhyZXNob2xkKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXBlYXRlZGx5IGNsaWNrIHRoZSB1cCBidXR0b24gdW50aWwgaW5zdWZmaWNpZW50IGRlbHRhIHJlbWFpbnNcclxuICAgICAgICAgICAgZG8ge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChndWFjX21vdXNlLm9ubW91c2Vkb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUudXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGd1YWNfbW91c2Uub25tb3VzZWRvd24oZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChndWFjX21vdXNlLm9ubW91c2V1cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGd1YWNfbW91c2UuY3VycmVudFN0YXRlLnVwID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5vbm1vdXNldXAoZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNjcm9sbF9kZWx0YSArPSBndWFjX21vdXNlLnNjcm9sbFRocmVzaG9sZDtcclxuXHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHNjcm9sbF9kZWx0YSA8PSAtZ3VhY19tb3VzZS5zY3JvbGxUaHJlc2hvbGQpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzZXQgZGVsdGFcclxuICAgICAgICAgICAgc2Nyb2xsX2RlbHRhID0gMDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEb3duXHJcbiAgICAgICAgaWYgKHNjcm9sbF9kZWx0YSA+PSBndWFjX21vdXNlLnNjcm9sbFRocmVzaG9sZCkge1xyXG5cclxuICAgICAgICAgICAgLy8gUmVwZWF0ZWRseSBjbGljayB0aGUgZG93biBidXR0b24gdW50aWwgaW5zdWZmaWNpZW50IGRlbHRhIHJlbWFpbnNcclxuICAgICAgICAgICAgZG8ge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChndWFjX21vdXNlLm9ubW91c2Vkb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUuZG93biA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5vbm1vdXNlZG93bihndWFjX21vdXNlLmN1cnJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGd1YWNfbW91c2Uub25tb3VzZXVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3VhY19tb3VzZS5jdXJyZW50U3RhdGUuZG93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGd1YWNfbW91c2Uub25tb3VzZXVwKGd1YWNfbW91c2UuY3VycmVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxfZGVsdGEgLT0gZ3VhY19tb3VzZS5zY3JvbGxUaHJlc2hvbGQ7XHJcblxyXG4gICAgICAgICAgICB9IHdoaWxlIChzY3JvbGxfZGVsdGEgPj0gZ3VhY19tb3VzZS5zY3JvbGxUaHJlc2hvbGQpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzZXQgZGVsdGFcclxuICAgICAgICAgICAgc2Nyb2xsX2RlbHRhID0gMDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYW5jZWxFdmVudChlKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIG1vdXNld2hlZWxfaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgICAgIG1vdXNld2hlZWxfaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsICAgICAgICAgIG1vdXNld2hlZWxfaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyBDU1MzIGN1cnNvciBzdHlsaW5nLCBpbmNsdWRpbmcgaG90c3BvdFxyXG4gICAgICogY29vcmRpbmF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB2YXIgQ1NTM19DVVJTT1JfU1VQUE9SVEVEID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gY3Vyc29yIHByb3BlcnR5IGF0IGFsbCwgdGhlbiBubyBzdXBwb3J0XHJcbiAgICAgICAgaWYgKCEoXCJjdXJzb3JcIiBpbiBkaXYuc3R5bGUpKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHNpbXBsZSAxeDEgUE5HXHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS5jdXJzb3IgPSBcInVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgXCJBUU1BQUFBbDIxYktBQUFBQTFCTVZFWC8vLytueEJ2SVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBcIkFBQUFDa2xFUVZRSTEyTmdBQUFBQWdBQjRpRzhNd0FBXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiQUFCSlJVNUVya0pnZ2c9PSkgMCAwLCBhdXRvXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFZlcmlmeSBjdXJzb3IgcHJvcGVydHkgaXMgc2V0IHRvIFVSTCB3aXRoIGhvdHNwb3RcclxuICAgICAgICByZXR1cm4gL1xcYnVybFxcKFteKCldKlxcKVxccyswXFxzKzBcXGIvLnRlc3QoZGl2LnN0eWxlLmN1cnNvciB8fCBcIlwiKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgbG9jYWwgbW91c2UgY3Vyc29yIHRvIHRoZSBnaXZlbiBjYW52YXMsIGhhdmluZyB0aGUgZ2l2ZW5cclxuICAgICAqIGhvdHNwb3QgY29vcmRpbmF0ZXMuIFRoaXMgYWZmZWN0cyBzdHlsaW5nIG9mIHRoZSBlbGVtZW50IGJhY2tpbmcgdGhpc1xyXG4gICAgICogR3VhY2Ftb2xlLk1vdXNlIG9ubHksIGFuZCBtYXkgZmFpbCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0IGZvclxyXG4gICAgICogc2V0dGluZyB0aGUgbW91c2UgY3Vyc29yLlxyXG4gICAgICogXHJcbiAgICAgKiBJZiBzZXR0aW5nIHRoZSBsb2NhbCBjdXJzb3IgaXMgZGVzaXJlZCwgaXQgaXMgdXAgdG8gdGhlIGltcGxlbWVudGF0aW9uXHJcbiAgICAgKiB0byBkbyBzb21ldGhpbmcgZWxzZSwgc3VjaCBhcyB1c2UgdGhlIHNvZnR3YXJlIGN1cnNvciBidWlsdCBpbnRvXHJcbiAgICAgKiBHdWFjYW1vbGUuRGlzcGxheSwgaWYgdGhlIGxvY2FsIGN1cnNvciBjYW5ub3QgYmUgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBUaGUgY3Vyc29yIGltYWdlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFgtY29vcmRpbmF0ZSBvZiB0aGUgY3Vyc29yIGhvdHNwb3QuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWS1jb29yZGluYXRlIG9mIHRoZSBjdXJzb3IgaG90c3BvdC5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGN1cnNvciB3YXMgc3VjY2Vzc2Z1bGx5IHNldCwgZmFsc2UgaWYgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICBjdXJzb3IgY291bGQgbm90IGJlIHNldCBmb3IgYW55IHJlYXNvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXRDdXJzb3IgPSBmdW5jdGlvbihjYW52YXMsIHgsIHkpIHtcclxuXHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzZXQgdmlhIENTUzMgY3Vyc29yIHN0eWxpbmdcclxuICAgICAgICBpZiAoQ1NTM19DVVJTT1JfU1VQUE9SVEVEKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuY3Vyc29yID0gXCJ1cmwoXCIgKyBkYXRhVVJMICsgXCIpIFwiICsgeCArIFwiIFwiICsgeSArIFwiLCBhdXRvXCI7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZXR0aW5nIGN1cnNvciBmYWlsZWRcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogU2ltcGxlIGNvbnRhaW5lciBmb3IgcHJvcGVydGllcyBkZXNjcmliaW5nIHRoZSBzdGF0ZSBvZiBhIG1vdXNlLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyIGluIHBpeGVscy5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgcG9zaXRpb24gb2YgdGhlIG1vdXNlIHBvaW50ZXIgaW4gcGl4ZWxzLlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGxlZnQgV2hldGhlciB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgcHJlc3NlZC4gXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbWlkZGxlIFdoZXRoZXIgdGhlIG1pZGRsZSBtb3VzZSBidXR0b24gaXMgcHJlc3NlZC4gXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmlnaHQgV2hldGhlciB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQuIFxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHVwIFdoZXRoZXIgdGhlIHVwIG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkICh0aGUgZm91cnRoXHJcbiAqICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLCB1c3VhbGx5IHBhcnQgb2YgYSBzY3JvbGwgd2hlZWwpLiBcclxuICogQHBhcmFtIHtCb29sZWFufSBkb3duIFdoZXRoZXIgdGhlIGRvd24gbW91c2UgYnV0dG9uIGlzIHByZXNzZWQgKHRoZSBmaWZ0aFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLCB1c3VhbGx5IHBhcnQgb2YgYSBzY3JvbGwgd2hlZWwpLiBcclxuICovXHJcbkd1YWNhbW9sZS5Nb3VzZS5TdGF0ZSA9IGZ1bmN0aW9uKHgsIHksIGxlZnQsIG1pZGRsZSwgcmlnaHQsIHVwLCBkb3duKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuTW91c2UuU3RhdGUuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY19zdGF0ZSA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBYIHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyLlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy54ID0geDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IFkgcG9zaXRpb24gb2YgdGhlIG1vdXNlIHBvaW50ZXIuXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IHByZXNzZWQuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIG1pZGRsZSBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IHByZXNzZWQuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5taWRkbGUgPSBtaWRkbGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSByaWdodCBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IHByZXNzZWQuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgdXAgbW91c2UgYnV0dG9uIGlzIGN1cnJlbnRseSBwcmVzc2VkLiBUaGlzIGlzIHRoZSBmb3VydGhcclxuICAgICAqIG1vdXNlIGJ1dHRvbiwgYXNzb2NpYXRlZCB3aXRoIHVwd2FyZCBzY3JvbGxpbmcgb2YgdGhlIG1vdXNlIHNjcm9sbFxyXG4gICAgICogd2hlZWwuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy51cCA9IHVwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgZG93biBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IHByZXNzZWQuIFRoaXMgaXMgdGhlIGZpZnRoIFxyXG4gICAgICogbW91c2UgYnV0dG9uLCBhc3NvY2lhdGVkIHdpdGggZG93bndhcmQgc2Nyb2xsaW5nIG9mIHRoZSBtb3VzZSBzY3JvbGxcclxuICAgICAqIHdoZWVsLlxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZG93biA9IGRvd247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiByZXByZXNlbnRlZCB3aXRoaW4gdGhpcyBzdGF0ZSBvYmplY3QgYnkgdGhlIGdpdmVuXHJcbiAgICAgKiBlbGVtZW50IGFuZCBjbGllbnRYL2NsaWVudFkgY29vcmRpbmF0ZXMgKGNvbW1vbmx5IGF2YWlsYWJsZSB3aXRoaW4gZXZlbnRcclxuICAgICAqIG9iamVjdHMpLiBQb3NpdGlvbiBpcyB0cmFuc2xhdGVkIGZyb20gY2xpZW50WC9jbGllbnRZIChyZWxhdGl2ZSB0b1xyXG4gICAgICogdmlld3BvcnQpIHRvIGVsZW1lbnQtcmVsYXRpdmUgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0aGUgY29vcmRpbmF0ZXMgc2hvdWxkIGJlIHJlbGF0aXZlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdG8uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2xpZW50WCBUaGUgWCBjb29yZGluYXRlIHRvIHRyYW5zbGF0ZSwgdmlld3BvcnQtcmVsYXRpdmUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2xpZW50WSBUaGUgWSBjb29yZGluYXRlIHRvIHRyYW5zbGF0ZSwgdmlld3BvcnQtcmVsYXRpdmUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJvbUNsaWVudFBvc2l0aW9uID0gZnVuY3Rpb24oZWxlbWVudCwgY2xpZW50WCwgY2xpZW50WSkge1xyXG4gICAgXHJcbiAgICAgICAgZ3VhY19zdGF0ZS54ID0gY2xpZW50WCAtIGVsZW1lbnQub2Zmc2V0TGVmdDtcclxuICAgICAgICBndWFjX3N0YXRlLnkgPSBjbGllbnRZIC0gZWxlbWVudC5vZmZzZXRUb3A7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgaXMgYWxsIEpVU1Qgc28gd2UgY2FuIGdldCB0aGUgbW91c2UgcG9zaXRpb24gd2l0aGluIHRoZSBlbGVtZW50XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xyXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgIShwYXJlbnQgPT09IGRvY3VtZW50LmJvZHkpKSB7XHJcbiAgICAgICAgICAgIGd1YWNfc3RhdGUueCAtPSBwYXJlbnQub2Zmc2V0TGVmdCAtIHBhcmVudC5zY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICBndWFjX3N0YXRlLnkgLT0gcGFyZW50Lm9mZnNldFRvcCAgLSBwYXJlbnQuc2Nyb2xsVG9wO1xyXG5cclxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Lm9mZnNldFBhcmVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVsZW1lbnQgdWx0aW1hdGVseSBkZXBlbmRzIG9uIHBvc2l0aW9uaW5nIHdpdGhpbiBkb2N1bWVudCBib2R5LFxyXG4gICAgICAgIC8vIHRha2UgZG9jdW1lbnQgc2Nyb2xsIGludG8gYWNjb3VudC4gXHJcbiAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZG9jdW1lbnRTY3JvbGxMZWZ0ID0gZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICB2YXIgZG9jdW1lbnRTY3JvbGxUb3AgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xyXG5cclxuICAgICAgICAgICAgZ3VhY19zdGF0ZS54IC09IHBhcmVudC5vZmZzZXRMZWZ0IC0gZG9jdW1lbnRTY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICBndWFjX3N0YXRlLnkgLT0gcGFyZW50Lm9mZnNldFRvcCAgLSBkb2N1bWVudFNjcm9sbFRvcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgY3Jvc3MtYnJvd3NlciByZWxhdGl2ZSB0b3VjaCBldmVudCB0cmFuc2xhdGlvbiBmb3IgYSBnaXZlbiBlbGVtZW50LlxyXG4gKiBcclxuICogVG91Y2ggZXZlbnRzIGFyZSB0cmFuc2xhdGVkIGludG8gbW91c2UgZXZlbnRzIGFzIGlmIHRoZSB0b3VjaGVzIG9jY3VycmVkXHJcbiAqIG9uIGEgdG91Y2hwYWQgKGRyYWcgdG8gcHVzaCB0aGUgbW91c2UgcG9pbnRlciwgdGFwIHRvIGNsaWNrKS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIEVsZW1lbnQgdG8gdXNlIHRvIHByb3ZpZGUgdG91Y2ggZXZlbnRzLlxyXG4gKi9cclxuR3VhY2Ftb2xlLk1vdXNlLlRvdWNocGFkID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLk1vdXNlLlRvdWNocGFkLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNfdG91Y2hwYWQgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRpc3RhbmNlIGEgdHdvLWZpbmdlciB0b3VjaCBtdXN0IG1vdmUgcGVyIHNjcm9sbHdoZWVsIGV2ZW50LCBpblxyXG4gICAgICogcGl4ZWxzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjcm9sbFRocmVzaG9sZCA9IDIwICogKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciBhIHRvdWNoIHRvIGVuZCBmb3IgdGhlXHJcbiAgICAgKiBnZXN0dXJlIHRvIGJlIGNvbnNpZGVyZWQgYSBjbGljay5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jbGlja1RpbWluZ1RocmVzaG9sZCA9IDI1MDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwaXhlbHMgdG8gYWxsb3cgYSB0b3VjaCB0byBtb3ZlIGZvciB0aGUgZ2VzdHVyZSB0b1xyXG4gICAgICogYmUgY29uc2lkZXJlZCBhIGNsaWNrLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaWNrTW92ZVRocmVzaG9sZCA9IDEwICogKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgbW91c2Ugc3RhdGUuIFRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgc3RhdGUgYXJlIHVwZGF0ZWQgd2hlblxyXG4gICAgICogbW91c2UgZXZlbnRzIGZpcmUuIFRoaXMgc3RhdGUgb2JqZWN0IGlzIGFsc28gcGFzc2VkIGluIGFzIGEgcGFyYW1ldGVyIHRvXHJcbiAgICAgKiB0aGUgaGFuZGxlciBvZiBhbnkgbW91c2UgZXZlbnRzLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLk1vdXNlLlN0YXRlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ldyBHdWFjYW1vbGUuTW91c2UuU3RhdGUoXHJcbiAgICAgICAgMCwgMCwgXHJcbiAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXHJcbiAgICApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgYSBtb3VzZSBidXR0b24gaXMgZWZmZWN0aXZlbHkgcHJlc3NlZC4gVGhpcyBjYW4gaGFwcGVuXHJcbiAgICAgKiBhcyBwYXJ0IG9mIGEgXCJjbGlja1wiIGdlc3R1cmUgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyIGJ5IHRhcHBpbmcgb25lXHJcbiAgICAgKiBvciBtb3JlIGZpbmdlcnMgb3ZlciB0aGUgdG91Y2hwYWQgZWxlbWVudCwgYXMgcGFydCBvZiBhIFwic2Nyb2xsXCJcclxuICAgICAqIGdlc3R1cmUgaW5pdGlhdGVkIGJ5IGRyYWdnaW5nIHR3byBmaW5nZXJzIHVwIG9yIGRvd24sIGV0Yy5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5Nb3VzZS5TdGF0ZX0gc3RhdGUgVGhlIGN1cnJlbnQgbW91c2Ugc3RhdGUuXHJcbiAgICAgKi9cclxuXHR0aGlzLm9ubW91c2Vkb3duID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIGEgbW91c2UgYnV0dG9uIGlzIGVmZmVjdGl2ZWx5IHJlbGVhc2VkLiBUaGlzIGNhbiBoYXBwZW5cclxuICAgICAqIGFzIHBhcnQgb2YgYSBcImNsaWNrXCIgZ2VzdHVyZSBpbml0aWF0ZWQgYnkgdGhlIHVzZXIgYnkgdGFwcGluZyBvbmVcclxuICAgICAqIG9yIG1vcmUgZmluZ2VycyBvdmVyIHRoZSB0b3VjaHBhZCBlbGVtZW50LCBhcyBwYXJ0IG9mIGEgXCJzY3JvbGxcIlxyXG4gICAgICogZ2VzdHVyZSBpbml0aWF0ZWQgYnkgZHJhZ2dpbmcgdHdvIGZpbmdlcnMgdXAgb3IgZG93biwgZXRjLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLk1vdXNlLlN0YXRlfSBzdGF0ZSBUaGUgY3VycmVudCBtb3VzZSBzdGF0ZS5cclxuICAgICAqL1xyXG5cdHRoaXMub25tb3VzZXVwID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSB1c2VyIG1vdmVzIHRoZSBtb3VzZSBieSBkcmFnZ2luZyB0aGVpciBmaW5nZXIgb3ZlclxyXG4gICAgICogdGhlIHRvdWNocGFkIGVsZW1lbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTW91c2UuU3RhdGV9IHN0YXRlIFRoZSBjdXJyZW50IG1vdXNlIHN0YXRlLlxyXG4gICAgICovXHJcblx0dGhpcy5vbm1vdXNlbW92ZSA9IG51bGw7XHJcblxyXG4gICAgdmFyIHRvdWNoX2NvdW50ID0gMDtcclxuICAgIHZhciBsYXN0X3RvdWNoX3ggPSAwO1xyXG4gICAgdmFyIGxhc3RfdG91Y2hfeSA9IDA7XHJcbiAgICB2YXIgbGFzdF90b3VjaF90aW1lID0gMDtcclxuICAgIHZhciBwaXhlbHNfbW92ZWQgPSAwO1xyXG5cclxuICAgIHZhciB0b3VjaF9idXR0b25zID0ge1xyXG4gICAgICAgIDE6IFwibGVmdFwiLFxyXG4gICAgICAgIDI6IFwicmlnaHRcIixcclxuICAgICAgICAzOiBcIm1pZGRsZVwiXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBnZXN0dXJlX2luX3Byb2dyZXNzID0gZmFsc2U7XHJcbiAgICB2YXIgY2xpY2tfcmVsZWFzZV90aW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAvLyBJZiB3ZSdyZSBoYW5kbGluZyBhIGdlc3R1cmUgQU5EIHRoaXMgaXMgdGhlIGxhc3QgdG91Y2hcclxuICAgICAgICBpZiAoZ2VzdHVyZV9pbl9wcm9ncmVzcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IGNvcnJlc3BvbmRpbmcgbW91c2UgYnV0dG9uXHJcbiAgICAgICAgICAgIHZhciBidXR0b24gPSB0b3VjaF9idXR0b25zW3RvdWNoX2NvdW50XTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG1vdXNlIGFscmVhZHkgZG93biwgcmVsZWFzZSBhbmFkIGNsZWFyIHRpbWVvdXRcclxuICAgICAgICAgICAgaWYgKGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlW2J1dHRvbl0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJlIGJ1dHRvbiB1cCBldmVudFxyXG4gICAgICAgICAgICAgICAgZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGVbYnV0dG9uXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGd1YWNfdG91Y2hwYWQub25tb3VzZXVwKVxyXG4gICAgICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQub25tb3VzZXVwKGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aW1lb3V0LCBpZiBzZXRcclxuICAgICAgICAgICAgICAgIGlmIChjbGlja19yZWxlYXNlX3RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNsaWNrX3JlbGVhc2VfdGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tfcmVsZWFzZV90aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHNpbmdsZSB0YXAgZGV0ZWN0ZWQgKGJhc2VkIG9uIHRpbWUgYW5kIGRpc3RhbmNlKVxyXG4gICAgICAgICAgICBpZiAodGltZSAtIGxhc3RfdG91Y2hfdGltZSA8PSBndWFjX3RvdWNocGFkLmNsaWNrVGltaW5nVGhyZXNob2xkXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgcGl4ZWxzX21vdmVkIDwgZ3VhY190b3VjaHBhZC5jbGlja01vdmVUaHJlc2hvbGQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJlIGJ1dHRvbiBkb3duIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZVtidXR0b25dID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChndWFjX3RvdWNocGFkLm9ubW91c2Vkb3duKVxyXG4gICAgICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQub25tb3VzZWRvd24oZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlbGF5IG1vdXNlIHVwIC0gbW91c2UgdXAgc2hvdWxkIGJlIGNhbmNlbGVkIGlmXHJcbiAgICAgICAgICAgICAgICAvLyB0b3VjaHN0YXJ0IHdpdGhpbiB0aW1lb3V0LlxyXG4gICAgICAgICAgICAgICAgY2xpY2tfcmVsZWFzZV90aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSBidXR0b24gdXAgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZVtidXR0b25dID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGd1YWNfdG91Y2hwYWQub25tb3VzZXVwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBndWFjX3RvdWNocGFkLm9ubW91c2V1cChndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2VzdHVyZSBub3cgb3ZlclxyXG4gICAgICAgICAgICAgICAgICAgIGdlc3R1cmVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9LCBndWFjX3RvdWNocGFkLmNsaWNrVGltaW5nVGhyZXNob2xkKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCB3YWl0aW5nIHRvIHNlZSBpZiB0aGlzIGlzIGEgY2xpY2ssIHN0b3AgZ2VzdHVyZVxyXG4gICAgICAgICAgICBpZiAoIWNsaWNrX3JlbGVhc2VfdGltZW91dClcclxuICAgICAgICAgICAgICAgIGdlc3R1cmVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAvLyBUcmFjayBudW1iZXIgb2YgdG91Y2hlcywgYnV0IG5vIG1vcmUgdGhhbiB0aHJlZVxyXG4gICAgICAgIHRvdWNoX2NvdW50ID0gTWF0aC5taW4oZS50b3VjaGVzLmxlbmd0aCwgMyk7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIHRpbWVvdXQsIGlmIHNldFxyXG4gICAgICAgIGlmIChjbGlja19yZWxlYXNlX3RpbWVvdXQpIHtcclxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChjbGlja19yZWxlYXNlX3RpbWVvdXQpO1xyXG4gICAgICAgICAgICBjbGlja19yZWxlYXNlX3RpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVjb3JkIGluaXRpYWwgdG91Y2ggbG9jYXRpb24gYW5kIHRpbWUgZm9yIHRvdWNoIG1vdmVtZW50XHJcbiAgICAgICAgLy8gYW5kIHRhcCBnZXN0dXJlc1xyXG4gICAgICAgIGlmICghZ2VzdHVyZV9pbl9wcm9ncmVzcykge1xyXG5cclxuICAgICAgICAgICAgLy8gU3RvcCBtb3VzZSBldmVudHMgd2hpbGUgdG91Y2hpbmdcclxuICAgICAgICAgICAgZ2VzdHVyZV9pbl9wcm9ncmVzcyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWNvcmQgdG91Y2ggbG9jYXRpb24gYW5kIHRpbWVcclxuICAgICAgICAgICAgdmFyIHN0YXJ0aW5nX3RvdWNoID0gZS50b3VjaGVzWzBdO1xyXG4gICAgICAgICAgICBsYXN0X3RvdWNoX3ggPSBzdGFydGluZ190b3VjaC5jbGllbnRYO1xyXG4gICAgICAgICAgICBsYXN0X3RvdWNoX3kgPSBzdGFydGluZ190b3VjaC5jbGllbnRZO1xyXG4gICAgICAgICAgICBsYXN0X3RvdWNoX3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgcGl4ZWxzX21vdmVkID0gMDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIC8vIEdldCBjaGFuZ2UgaW4gdG91Y2ggbG9jYXRpb25cclxuICAgICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07XHJcbiAgICAgICAgdmFyIGRlbHRhX3ggPSB0b3VjaC5jbGllbnRYIC0gbGFzdF90b3VjaF94O1xyXG4gICAgICAgIHZhciBkZWx0YV95ID0gdG91Y2guY2xpZW50WSAtIGxhc3RfdG91Y2hfeTtcclxuXHJcbiAgICAgICAgLy8gVHJhY2sgcGl4ZWxzIG1vdmVkXHJcbiAgICAgICAgcGl4ZWxzX21vdmVkICs9IE1hdGguYWJzKGRlbHRhX3gpICsgTWF0aC5hYnMoZGVsdGFfeSk7XHJcblxyXG4gICAgICAgIC8vIElmIG9ubHkgb25lIHRvdWNoIGludm9sdmVkLCB0aGlzIGlzIG1vdXNlIG1vdmVcclxuICAgICAgICBpZiAodG91Y2hfY291bnQgPT09IDEpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIHZlbG9jaXR5IGluIE1hbmhhdHRlbiBwaXhlbHMgcGVyIG1pbGxpc2Vjb25kXHJcbiAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IHBpeGVsc19tb3ZlZCAvIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxhc3RfdG91Y2hfdGltZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTY2FsZSBtb3VzZSBtb3ZlbWVudCByZWxhdGl2ZSB0byB2ZWxvY2l0eVxyXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAxICsgdmVsb2NpdHk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgbW91c2UgbG9jYXRpb25cclxuICAgICAgICAgICAgZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGUueCArPSBkZWx0YV94KnNjYWxlO1xyXG4gICAgICAgICAgICBndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZS55ICs9IGRlbHRhX3kqc2NhbGU7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmV2ZW50IG1vdXNlIGZyb20gbGVhdmluZyBzY3JlZW5cclxuXHJcbiAgICAgICAgICAgIGlmIChndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZS54IDwgMClcclxuICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlLnggPSAwO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZS54ID49IGVsZW1lbnQub2Zmc2V0V2lkdGgpXHJcbiAgICAgICAgICAgICAgICBndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZS54ID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGUueSA8IDApXHJcbiAgICAgICAgICAgICAgICBndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZS55ID0gMDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGUueSA+PSBlbGVtZW50Lm9mZnNldEhlaWdodClcclxuICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlLnkgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIDE7XHJcblxyXG4gICAgICAgICAgICAvLyBGaXJlIG1vdmVtZW50IGV2ZW50LCBpZiBkZWZpbmVkXHJcbiAgICAgICAgICAgIGlmIChndWFjX3RvdWNocGFkLm9ubW91c2Vtb3ZlKVxyXG4gICAgICAgICAgICAgICAgZ3VhY190b3VjaHBhZC5vbm1vdXNlbW92ZShndWFjX3RvdWNocGFkLmN1cnJlbnRTdGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdG91Y2ggbG9jYXRpb25cclxuICAgICAgICAgICAgbGFzdF90b3VjaF94ID0gdG91Y2guY2xpZW50WDtcclxuICAgICAgICAgICAgbGFzdF90b3VjaF95ID0gdG91Y2guY2xpZW50WTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbnRlcnByZXQgdHdvLWZpbmdlciBzd2lwZSBhcyBzY3JvbGx3aGVlbFxyXG4gICAgICAgIGVsc2UgaWYgKHRvdWNoX2NvdW50ID09PSAyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBjaGFuZ2UgaW4gbG9jYXRpb24gcGFzc2VzIHRocmVzaG9sZCBmb3Igc2Nyb2xsXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YV95KSA+PSBndWFjX3RvdWNocGFkLnNjcm9sbFRocmVzaG9sZCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlY2lkZSBidXR0b24gYmFzZWQgb24gWSBtb3ZlbWVudCBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgIHZhciBidXR0b247XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFfeSA+IDApIGJ1dHRvbiA9IFwiZG93blwiO1xyXG4gICAgICAgICAgICAgICAgZWxzZSAgICAgICAgICAgICBidXR0b24gPSBcInVwXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmlyZSBidXR0b24gZG93biBldmVudFxyXG4gICAgICAgICAgICAgICAgZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGVbYnV0dG9uXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3VhY190b3VjaHBhZC5vbm1vdXNlZG93bilcclxuICAgICAgICAgICAgICAgICAgICBndWFjX3RvdWNocGFkLm9ubW91c2Vkb3duKGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJlIGJ1dHRvbiB1cCBldmVudFxyXG4gICAgICAgICAgICAgICAgZ3VhY190b3VjaHBhZC5jdXJyZW50U3RhdGVbYnV0dG9uXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGd1YWNfdG91Y2hwYWQub25tb3VzZXVwKVxyXG4gICAgICAgICAgICAgICAgICAgIGd1YWNfdG91Y2hwYWQub25tb3VzZXVwKGd1YWNfdG91Y2hwYWQuY3VycmVudFN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0b3VjaCBsb2NhdGlvbiBhZnRlciBhIHNjcm9sbCBoYXMgYmVlblxyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0ZWRcclxuICAgICAgICAgICAgICAgIGxhc3RfdG91Y2hfeCA9IHRvdWNoLmNsaWVudFg7XHJcbiAgICAgICAgICAgICAgICBsYXN0X3RvdWNoX3kgPSB0b3VjaC5jbGllbnRZO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBjcm9zcy1icm93c2VyIGFic29sdXRlIHRvdWNoIGV2ZW50IHRyYW5zbGF0aW9uIGZvciBhIGdpdmVuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIFRvdWNoIGV2ZW50cyBhcmUgdHJhbnNsYXRlZCBpbnRvIG1vdXNlIGV2ZW50cyBhcyBpZiB0aGUgdG91Y2hlcyBvY2N1cnJlZFxyXG4gKiBvbiBhIHRvdWNoc2NyZWVuICh0YXBwaW5nIGFueXdoZXJlIG9uIHRoZSBzY3JlZW4gY2xpY2tzIGF0IHRoYXQgcG9pbnQsXHJcbiAqIGxvbmctcHJlc3MgdG8gcmlnaHQtY2xpY2spLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBFbGVtZW50IHRvIHVzZSB0byBwcm92aWRlIHRvdWNoIGV2ZW50cy5cclxuICovXHJcbkd1YWNhbW9sZS5Nb3VzZS5Ub3VjaHNjcmVlbiA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIEd1YWNhbW9sZS5Nb3VzZS5Ub3VjaHNjcmVlbi5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjX3RvdWNoc2NyZWVuID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgYSBnZXN0dXJlIGlzIGtub3duIHRvIGJlIGluIHByb2dyZXNzLiBJZiBmYWxzZSwgdG91Y2ggZXZlbnRzXHJcbiAgICAgKiB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGdlc3R1cmVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdGFydCBYIGxvY2F0aW9uIG9mIGEgZ2VzdHVyZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBnZXN0dXJlX3N0YXJ0X3ggPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0YXJ0IFkgbG9jYXRpb24gb2YgYSBnZXN0dXJlLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGdlc3R1cmVfc3RhcnRfeSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGltZW91dCBhc3NvY2lhdGVkIHdpdGggdGhlIGRlbGF5ZWQsIGNhbmNlbGxhYmxlIGNsaWNrIHJlbGVhc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGNsaWNrX3JlbGVhc2VfdGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGltZW91dCBhc3NvY2lhdGVkIHdpdGggbG9uZy1wcmVzcyBmb3IgcmlnaHQgY2xpY2suXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGxvbmdfcHJlc3NfdGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGlzdGFuY2UgYSB0d28tZmluZ2VyIHRvdWNoIG11c3QgbW92ZSBwZXIgc2Nyb2xsd2hlZWwgZXZlbnQsIGluXHJcbiAgICAgKiBwaXhlbHMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2Nyb2xsVGhyZXNob2xkID0gMjAgKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIGEgdG91Y2ggdG8gZW5kIGZvciB0aGVcclxuICAgICAqIGdlc3R1cmUgdG8gYmUgY29uc2lkZXJlZCBhIGNsaWNrLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaWNrVGltaW5nVGhyZXNob2xkID0gMjUwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHBpeGVscyB0byBhbGxvdyBhIHRvdWNoIHRvIG1vdmUgZm9yIHRoZSBnZXN0dXJlIHRvXHJcbiAgICAgKiBiZSBjb25zaWRlcmVkIGEgY2xpY2suXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xpY2tNb3ZlVGhyZXNob2xkID0gMTYgKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgYSBwcmVzcyBtdXN0IGJlIGhlbGQgZm9yIGxvbmcgcHJlc3MgdG8gYmVcclxuICAgICAqIGRldGVjdGVkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmxvbmdQcmVzc1RocmVzaG9sZCA9IDUwMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IG1vdXNlIHN0YXRlLiBUaGUgcHJvcGVydGllcyBvZiB0aGlzIHN0YXRlIGFyZSB1cGRhdGVkIHdoZW5cclxuICAgICAqIG1vdXNlIGV2ZW50cyBmaXJlLiBUaGlzIHN0YXRlIG9iamVjdCBpcyBhbHNvIHBhc3NlZCBpbiBhcyBhIHBhcmFtZXRlciB0b1xyXG4gICAgICogdGhlIGhhbmRsZXIgb2YgYW55IG1vdXNlIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLk1vdXNlLlN0YXRlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ldyBHdWFjYW1vbGUuTW91c2UuU3RhdGUoXHJcbiAgICAgICAgMCwgMCxcclxuICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2VcclxuICAgICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciBhIG1vdXNlIGJ1dHRvbiBpcyBlZmZlY3RpdmVseSBwcmVzc2VkLiBUaGlzIGNhbiBoYXBwZW5cclxuICAgICAqIGFzIHBhcnQgb2YgYSBcIm1vdXNlZG93blwiIGdlc3R1cmUgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyIGJ5IHByZXNzaW5nIG9uZVxyXG4gICAgICogZmluZ2VyIG92ZXIgdGhlIHRvdWNoc2NyZWVuIGVsZW1lbnQsIGFzIHBhcnQgb2YgYSBcInNjcm9sbFwiIGdlc3R1cmVcclxuICAgICAqIGluaXRpYXRlZCBieSBkcmFnZ2luZyB0d28gZmluZ2VycyB1cCBvciBkb3duLCBldGMuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5Nb3VzZS5TdGF0ZX0gc3RhdGUgVGhlIGN1cnJlbnQgbW91c2Ugc3RhdGUuXHJcbiAgICAgKi9cclxuXHR0aGlzLm9ubW91c2Vkb3duID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIGEgbW91c2UgYnV0dG9uIGlzIGVmZmVjdGl2ZWx5IHJlbGVhc2VkLiBUaGlzIGNhbiBoYXBwZW5cclxuICAgICAqIGFzIHBhcnQgb2YgYSBcIm1vdXNldXBcIiBnZXN0dXJlIGluaXRpYXRlZCBieSB0aGUgdXNlciBieSByZW1vdmluZyB0aGVcclxuICAgICAqIGZpbmdlciBwcmVzc2VkIGFnYWluc3QgdGhlIHRvdWNoc2NyZWVuIGVsZW1lbnQsIG9yIGFzIHBhcnQgb2YgYSBcInNjcm9sbFwiXHJcbiAgICAgKiBnZXN0dXJlIGluaXRpYXRlZCBieSBkcmFnZ2luZyB0d28gZmluZ2VycyB1cCBvciBkb3duLCBldGMuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5Nb3VzZS5TdGF0ZX0gc3RhdGUgVGhlIGN1cnJlbnQgbW91c2Ugc3RhdGUuXHJcbiAgICAgKi9cclxuXHR0aGlzLm9ubW91c2V1cCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2UgYnkgZHJhZ2dpbmcgdGhlaXIgZmluZ2VyIG92ZXJcclxuICAgICAqIHRoZSB0b3VjaHNjcmVlbiBlbGVtZW50LiBOb3RlIHRoYXQgdW5saWtlIEd1YWNhbW9sZS5Nb3VzZS5Ub3VjaHBhZCxcclxuICAgICAqIGRyYWdnaW5nIGEgZmluZ2VyIG92ZXIgdGhlIHRvdWNoc2NyZWVuIGVsZW1lbnQgd2lsbCBhbHdheXMgY2F1c2VcclxuICAgICAqIHRoZSBtb3VzZSBidXR0b24gdG8gYmUgZWZmZWN0aXZlbHkgZG93biwgYXMgaWYgY2xpY2tpbmctYW5kLWRyYWdnaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuTW91c2UuU3RhdGV9IHN0YXRlIFRoZSBjdXJyZW50IG1vdXNlIHN0YXRlLlxyXG4gICAgICovXHJcblx0dGhpcy5vbm1vdXNlbW92ZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVzc2VzIHRoZSBnaXZlbiBtb3VzZSBidXR0b24sIGlmIGl0IGlzbid0IGFscmVhZHkgcHJlc3NlZC4gVmFsaWRcclxuICAgICAqIGJ1dHRvbiB2YWx1ZXMgYXJlIFwibGVmdFwiLCBcIm1pZGRsZVwiLCBcInJpZ2h0XCIsIFwidXBcIiwgYW5kIFwiZG93blwiLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYnV0dG9uIFRoZSBtb3VzZSBidXR0b24gdG8gcHJlc3MuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHByZXNzX2J1dHRvbihidXR0b24pIHtcclxuICAgICAgICBpZiAoIWd1YWNfdG91Y2hzY3JlZW4uY3VycmVudFN0YXRlW2J1dHRvbl0pIHtcclxuICAgICAgICAgICAgZ3VhY190b3VjaHNjcmVlbi5jdXJyZW50U3RhdGVbYnV0dG9uXSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChndWFjX3RvdWNoc2NyZWVuLm9ubW91c2Vkb3duKVxyXG4gICAgICAgICAgICAgICAgZ3VhY190b3VjaHNjcmVlbi5vbm1vdXNlZG93bihndWFjX3RvdWNoc2NyZWVuLmN1cnJlbnRTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVsZWFzZXMgdGhlIGdpdmVuIG1vdXNlIGJ1dHRvbiwgaWYgaXQgaXNuJ3QgYWxyZWFkeSByZWxlYXNlZC4gVmFsaWRcclxuICAgICAqIGJ1dHRvbiB2YWx1ZXMgYXJlIFwibGVmdFwiLCBcIm1pZGRsZVwiLCBcInJpZ2h0XCIsIFwidXBcIiwgYW5kIFwiZG93blwiLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYnV0dG9uIFRoZSBtb3VzZSBidXR0b24gdG8gcmVsZWFzZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVsZWFzZV9idXR0b24oYnV0dG9uKSB7XHJcbiAgICAgICAgaWYgKGd1YWNfdG91Y2hzY3JlZW4uY3VycmVudFN0YXRlW2J1dHRvbl0pIHtcclxuICAgICAgICAgICAgZ3VhY190b3VjaHNjcmVlbi5jdXJyZW50U3RhdGVbYnV0dG9uXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoZ3VhY190b3VjaHNjcmVlbi5vbm1vdXNldXApXHJcbiAgICAgICAgICAgICAgICBndWFjX3RvdWNoc2NyZWVuLm9ubW91c2V1cChndWFjX3RvdWNoc2NyZWVuLmN1cnJlbnRTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xpY2tzIChwcmVzc2VzIGFuZCByZWxlYXNlcykgdGhlIGdpdmVuIG1vdXNlIGJ1dHRvbi4gVmFsaWQgYnV0dG9uXHJcbiAgICAgKiB2YWx1ZXMgYXJlIFwibGVmdFwiLCBcIm1pZGRsZVwiLCBcInJpZ2h0XCIsIFwidXBcIiwgYW5kIFwiZG93blwiLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYnV0dG9uIFRoZSBtb3VzZSBidXR0b24gdG8gY2xpY2suXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsaWNrX2J1dHRvbihidXR0b24pIHtcclxuICAgICAgICBwcmVzc19idXR0b24oYnV0dG9uKTtcclxuICAgICAgICByZWxlYXNlX2J1dHRvbihidXR0b24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIG1vdXNlIHRvIHRoZSBnaXZlbiBjb29yZGluYXRlcy4gVGhlc2UgY29vcmRpbmF0ZXMgbXVzdCBiZVxyXG4gICAgICogcmVsYXRpdmUgdG8gdGhlIGJyb3dzZXIgd2luZG93LCBhcyB0aGV5IHdpbGwgYmUgdHJhbnNsYXRlZCBiYXNlZCBvblxyXG4gICAgICogdGhlIHRvdWNoIGV2ZW50IHRhcmdldCdzIGxvY2F0aW9uIHdpdGhpbiB0aGUgYnJvd3NlciB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIG1vdXNlIHBvaW50ZXIuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBtb3VzZSBwb2ludGVyLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtb3ZlX21vdXNlKHgsIHkpIHtcclxuICAgICAgICBndWFjX3RvdWNoc2NyZWVuLmN1cnJlbnRTdGF0ZS5mcm9tQ2xpZW50UG9zaXRpb24oZWxlbWVudCwgeCwgeSk7XHJcbiAgICAgICAgaWYgKGd1YWNfdG91Y2hzY3JlZW4ub25tb3VzZW1vdmUpXHJcbiAgICAgICAgICAgIGd1YWNfdG91Y2hzY3JlZW4ub25tb3VzZW1vdmUoZ3VhY190b3VjaHNjcmVlbi5jdXJyZW50U3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiB0b3VjaCBldmVudCBleGNlZWRzIHRoZSBtb3ZlbWVudCB0aHJlc2hvbGQgZm9yXHJcbiAgICAgKiBjbGlja2luZywgYmFzZWQgb24gd2hlcmUgdGhlIHRvdWNoIGdlc3R1cmUgYmVnYW4uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZSBUaGUgdG91Y2ggZXZlbnQgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBtb3ZlbWVudCB0aHJlc2hvbGQgaXMgZXhjZWVkZWQsIGZhbHNlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZpbmdlcl9tb3ZlZChlKSB7XHJcbiAgICAgICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF07XHJcbiAgICAgICAgdmFyIGRlbHRhX3ggPSB0b3VjaC5jbGllbnRYIC0gZ2VzdHVyZV9zdGFydF94O1xyXG4gICAgICAgIHZhciBkZWx0YV95ID0gdG91Y2guY2xpZW50WSAtIGdlc3R1cmVfc3RhcnRfeTtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGRlbHRhX3gqZGVsdGFfeCArIGRlbHRhX3kqZGVsdGFfeSkgPj0gZ3VhY190b3VjaHNjcmVlbi5jbGlja01vdmVUaHJlc2hvbGQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCZWdpbnMgYSBuZXcgZ2VzdHVyZSBhdCB0aGUgbG9jYXRpb24gb2YgdGhlIGZpcnN0IHRvdWNoIGluIHRoZSBnaXZlblxyXG4gICAgICogdG91Y2ggZXZlbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGUgVGhlIHRvdWNoIGV2ZW50IGJlZ2lubmluZyB0aGlzIG5ldyBnZXN0dXJlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiZWdpbl9nZXN0dXJlKGUpIHtcclxuICAgICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07XHJcbiAgICAgICAgZ2VzdHVyZV9pbl9wcm9ncmVzcyA9IHRydWU7XHJcbiAgICAgICAgZ2VzdHVyZV9zdGFydF94ID0gdG91Y2guY2xpZW50WDtcclxuICAgICAgICBnZXN0dXJlX3N0YXJ0X3kgPSB0b3VjaC5jbGllbnRZO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5kIHRoZSBjdXJyZW50IGdlc3R1cmUgZW50aXJlbHkuIFdhaXQgZm9yIGFsbCB0b3VjaGVzIHRvIGJlIGRvbmUgYmVmb3JlXHJcbiAgICAgKiByZXN1bWluZyBnZXN0dXJlIGRldGVjdGlvbi5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZW5kX2dlc3R1cmUoKSB7XHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChjbGlja19yZWxlYXNlX3RpbWVvdXQpO1xyXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQobG9uZ19wcmVzc190aW1lb3V0KTtcclxuICAgICAgICBnZXN0dXJlX2luX3Byb2dyZXNzID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3QgaGFuZGxlIGlmIG5vIGdlc3R1cmVcclxuICAgICAgICBpZiAoIWdlc3R1cmVfaW5fcHJvZ3Jlc3MpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gSWdub3JlIGlmIG1vcmUgdGhhbiBvbmUgdG91Y2hcclxuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMCB8fCBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICBlbmRfZ2VzdHVyZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb25nLXByZXNzLCBpZiBhbnksIGlzIG92ZXJcclxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGxvbmdfcHJlc3NfdGltZW91dCk7XHJcblxyXG4gICAgICAgIC8vIEFsd2F5cyByZWxlYXNlIG1vdXNlIGJ1dHRvbiBpZiBwcmVzc2VkXHJcbiAgICAgICAgcmVsZWFzZV9idXR0b24oXCJsZWZ0XCIpO1xyXG5cclxuICAgICAgICAvLyBJZiBmaW5nZXIgaGFzbid0IG1vdmVkIGVub3VnaCB0byBjYW5jZWwgdGhlIGNsaWNrXHJcbiAgICAgICAgaWYgKCFmaW5nZXJfbW92ZWQoZSkpIHtcclxuXHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vdCB5ZXQgcHJlc3NlZCwgcHJlc3MgYW5kIHN0YXJ0IGRlbGF5IHJlbGVhc2VcclxuICAgICAgICAgICAgaWYgKCFndWFjX3RvdWNoc2NyZWVuLmN1cnJlbnRTdGF0ZS5sZWZ0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgIG1vdmVfbW91c2UodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XHJcbiAgICAgICAgICAgICAgICBwcmVzc19idXR0b24oXCJsZWZ0XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbGVhc2UgYnV0dG9uIGFmdGVyIGEgZGVsYXksIGlmIG5vdCBjYW5jZWxlZFxyXG4gICAgICAgICAgICAgICAgY2xpY2tfcmVsZWFzZV90aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZV9idXR0b24oXCJsZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZF9nZXN0dXJlKCk7XHJcbiAgICAgICAgICAgICAgICB9LCBndWFjX3RvdWNoc2NyZWVuLmNsaWNrVGltaW5nVGhyZXNob2xkKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSAvLyBlbmQgaWYgZmluZ2VyIG5vdCBtb3ZlZFxyXG5cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgLy8gSWdub3JlIGlmIG1vcmUgdGhhbiBvbmUgdG91Y2hcclxuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICBlbmRfZ2VzdHVyZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIC8vIE5ldyB0b3VjaCBiZWdpbnMgYSBuZXcgZ2VzdHVyZVxyXG4gICAgICAgIGJlZ2luX2dlc3R1cmUoZSk7XHJcblxyXG4gICAgICAgIC8vIEtlZXAgYnV0dG9uIHByZXNzZWQgaWYgdGFwIGFmdGVyIGxlZnQgY2xpY2tcclxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNsaWNrX3JlbGVhc2VfdGltZW91dCk7XHJcblxyXG4gICAgICAgIC8vIENsaWNrIHJpZ2h0IGJ1dHRvbiBpZiB0aGlzIHR1cm5zIGludG8gYSBsb25nLXByZXNzXHJcbiAgICAgICAgbG9uZ19wcmVzc190aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXTtcclxuICAgICAgICAgICAgbW92ZV9tb3VzZSh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcclxuICAgICAgICAgICAgY2xpY2tfYnV0dG9uKFwicmlnaHRcIik7XHJcbiAgICAgICAgICAgIGVuZF9nZXN0dXJlKCk7XHJcbiAgICAgICAgfSwgZ3VhY190b3VjaHNjcmVlbi5sb25nUHJlc3NUaHJlc2hvbGQpO1xyXG5cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3QgaGFuZGxlIGlmIG5vIGdlc3R1cmVcclxuICAgICAgICBpZiAoIWdlc3R1cmVfaW5fcHJvZ3Jlc3MpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gQ2FuY2VsIGxvbmcgcHJlc3MgaWYgZmluZ2VyIG1vdmVkXHJcbiAgICAgICAgaWYgKGZpbmdlcl9tb3ZlZChlKSlcclxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChsb25nX3ByZXNzX3RpbWVvdXQpO1xyXG5cclxuICAgICAgICAvLyBJZ25vcmUgaWYgbW9yZSB0aGFuIG9uZSB0b3VjaFxyXG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGVuZF9nZXN0dXJlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBtb3VzZSBwb3NpdGlvbiBpZiBkcmFnZ2luZ1xyXG4gICAgICAgIGlmIChndWFjX3RvdWNoc2NyZWVuLmN1cnJlbnRTdGF0ZS5sZWZ0KSB7XHJcblxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgc3RhdGVcclxuICAgICAgICAgICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdO1xyXG4gICAgICAgICAgICBtb3ZlX21vdXNlKHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxufTtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4vKipcclxuICogVGhlIG5hbWVzcGFjZSB1c2VkIGJ5IHRoZSBHdWFjYW1vbGUgSmF2YVNjcmlwdCBBUEkuIEFic29sdXRlbHkgYWxsIGNsYXNzZXNcclxuICogZGVmaW5lZCBieSB0aGUgR3VhY2Ftb2xlIEphdmFTY3JpcHQgQVBJIHdpbGwgYmUgd2l0aGluIHRoaXMgbmFtZXNwYWNlLlxyXG4gKlxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQW4gb2JqZWN0IHVzZWQgYnkgdGhlIEd1YWNhbW9sZSBjbGllbnQgdG8gaG91c2UgYXJiaXRyYXJpbHktbWFueSBuYW1lZFxyXG4gKiBpbnB1dCBhbmQgb3V0cHV0IHN0cmVhbXMuXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuQ2xpZW50fSBjbGllbnRcclxuICogICAgIFRoZSBjbGllbnQgb3duaW5nIHRoaXMgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuICogICAgIFRoZSBpbmRleCBvZiB0aGlzIG9iamVjdC5cclxuICovXHJcbkd1YWNhbW9sZS5PYmplY3QgPSBmdW5jdGlvbiBndWFjYW1vbGVPYmplY3QoY2xpZW50LCBpbmRleCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLk9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5PYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHZhciBndWFjT2JqZWN0ID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBvZiBzdHJlYW0gbmFtZSB0byBjb3JyZXNwb25kaW5nIHF1ZXVlIG9mIGNhbGxiYWNrcy4gVGhlIHF1ZXVlIG9mXHJcbiAgICAgKiBjYWxsYmFja3MgaXMgZ3VhcmFudGVlZCB0byBiZSBpbiBvcmRlciBvZiByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uW10+fVxyXG4gICAgICovXHJcbiAgICB2YXIgYm9keUNhbGxiYWNrcyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbmQgcmV0dXJucyB0aGUgY2FsbGJhY2sgYXQgdGhlIGhlYWQgb2YgdGhlIGNhbGxiYWNrIHF1ZXVlIGZvclxyXG4gICAgICogdGhlIHN0cmVhbSBoYXZpbmcgdGhlIGdpdmVuIG5hbWUuIElmIG5vIHN1Y2ggY2FsbGJhY2tzIGV4aXN0LCBudWxsIGlzXHJcbiAgICAgKiByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUgc3RyZWFtIHRvIHJldHJpZXZlIGEgY2FsbGJhY2sgZm9yLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICAgICAqICAgICBUaGUgbmV4dCBjYWxsYmFjayBhc3NvY2lhdGVkIHdpdGggdGhlIHN0cmVhbSBoYXZpbmcgdGhlIGdpdmVuIG5hbWUsXHJcbiAgICAgKiAgICAgb3IgbnVsbCBpZiBubyBzdWNoIGNhbGxiYWNrIGV4aXN0cy5cclxuICAgICAqL1xyXG4gICAgdmFyIGRlcXVldWVCb2R5Q2FsbGJhY2sgPSBmdW5jdGlvbiBkZXF1ZXVlQm9keUNhbGxiYWNrKG5hbWUpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2tzIGRlZmluZWQsIHNpbXBseSByZXR1cm4gbnVsbFxyXG4gICAgICAgIHZhciBjYWxsYmFja3MgPSBib2R5Q2FsbGJhY2tzW25hbWVdO1xyXG4gICAgICAgIGlmICghY2FsbGJhY2tzKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBwdWxsIG9mZiBmaXJzdCBjYWxsYmFjaywgZGVsZXRpbmcgdGhlIHF1ZXVlIGlmIGVtcHR5XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzLnNoaWZ0KCk7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Q2FsbGJhY2tzW25hbWVdO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gZm91bmQgY2FsbGJhY2tcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2s7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGdpdmVuIGNhbGxiYWNrIHRvIHRoZSB0YWlsIG9mIHRoZSBjYWxsYmFjayBxdWV1ZSBmb3IgdGhlIHN0cmVhbVxyXG4gICAgICogaGF2aW5nIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAgICogICAgIFRoZSBuYW1lIG9mIHRoZSBzdHJlYW0gdG8gYXNzb2NpYXRlIHdpdGggdGhlIGdpdmVuIGNhbGxiYWNrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgKiAgICAgVGhlIGNhbGxiYWNrIHRvIGFkZCB0byB0aGUgcXVldWUgb2YgdGhlIHN0cmVhbSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgICovXHJcbiAgICB2YXIgZW5xdWV1ZUJvZHlDYWxsYmFjayA9IGZ1bmN0aW9uIGVucXVldWVCb2R5Q2FsbGJhY2sobmFtZSwgY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgLy8gR2V0IGNhbGxiYWNrIHF1ZXVlIGJ5IG5hbWUsIGNyZWF0aW5nIGZpcnN0IGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIHZhciBjYWxsYmFja3MgPSBib2R5Q2FsbGJhY2tzW25hbWVdO1xyXG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgICAgICBib2R5Q2FsbGJhY2tzW25hbWVdID0gY2FsbGJhY2tzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGNhbGxiYWNrIHRvIGVuZCBvZiBxdWV1ZVxyXG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IHJlY2VpdmVzIHRoZSBib2R5IG9mIGEgcmVxdWVzdGVkIGlucHV0IHN0cmVhbS5cclxuICAgICAqIEJ5IGRlZmF1bHQsIGFsbCBvYmplY3RzIHdpbGwgaW52b2tlIHRoZSBjYWxsYmFja3MgcHJvdmlkZWQgdG8gdGhlaXJcclxuICAgICAqIHJlcXVlc3RJbnB1dFN0cmVhbSgpIGZ1bmN0aW9ucyBiYXNlZCBvbiB0aGUgbmFtZSBvZiB0aGUgc3RyZWFtXHJcbiAgICAgKiByZXF1ZXN0ZWQuIFRoaXMgYmVoYXZpb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc3BlY2lmeWluZyBhIGRpZmZlcmVudFxyXG4gICAgICogaGFuZGxlciBoZXJlLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuSW5wdXRTdHJlYW19IGlucHV0U3RyZWFtXHJcbiAgICAgKiAgICAgVGhlIGlucHV0IHN0cmVhbSBvZiB0aGUgcmVjZWl2ZWQgYm9keS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICAgICAqICAgICBUaGUgbWltZXR5cGUgb2YgdGhlIGRhdGEgYmVpbmcgcmVjZWl2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUgc3RyZWFtIHdob3NlIGJvZHkgaGFzIGJlZW4gcmVjZWl2ZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25ib2R5ID0gZnVuY3Rpb24gZGVmYXVsdEJvZHlIYW5kbGVyKGlucHV0U3RyZWFtLCBtaW1ldHlwZSwgbmFtZSkge1xyXG5cclxuICAgICAgICAvLyBDYWxsIHF1ZXVlZCBjYWxsYmFjayBmb3IgdGhlIHJlY2VpdmVkIGJvZHksIGlmIGFueVxyXG4gICAgICAgIHZhciBjYWxsYmFjayA9IGRlcXVldWVCb2R5Q2FsbGJhY2sobmFtZSk7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKVxyXG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dFN0cmVhbSwgbWltZXR5cGUpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGlzIG9iamVjdCBpcyBiZWluZyB1bmRlZmluZWQuIE9uY2UgdW5kZWZpbmVkLCBubyBmdXJ0aGVyXHJcbiAgICAgKiBjb21tdW5pY2F0aW9uIGludm9sdmluZyB0aGlzIG9iamVjdCBtYXkgb2NjdXIuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICovXHJcbiAgICB0aGlzLm9udW5kZWZpbmUgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdHMgcmVhZCBhY2Nlc3MgdG8gdGhlIGlucHV0IHN0cmVhbSBoYXZpbmcgdGhlIGdpdmVuIG5hbWUuIElmXHJcbiAgICAgKiBzdWNjZXNzZnVsLCBhIG5ldyBpbnB1dCBzdHJlYW0gd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgKiAgICAgVGhlIG5hbWUgb2YgdGhlIGlucHV0IHN0cmVhbSB0byByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtib2R5Q2FsbGJhY2tdXHJcbiAgICAgKiAgICAgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIHRoZSBib2R5IG9mIHRoZSByZXF1ZXN0ZWQgaW5wdXQgc3RyZWFtXHJcbiAgICAgKiAgICAgaXMgcmVjZWl2ZWQuIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBwcm92aWRlZCBhIEd1YWNhbW9sZS5JbnB1dFN0cmVhbVxyXG4gICAgICogICAgIGFuZCBpdHMgbWltZXR5cGUgYXMgaXRzIHR3byBvbmx5IGFyZ3VtZW50cy4gSWYgdGhlIG9uYm9keSBoYW5kbGVyIG9mXHJcbiAgICAgKiAgICAgdGhpcyBvYmplY3QgaXMgb3ZlcnJpZGRlbiwgdGhpcyBjYWxsYmFjayB3aWxsIG5vdCBiZSBpbnZva2VkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlcXVlc3RJbnB1dFN0cmVhbSA9IGZ1bmN0aW9uIHJlcXVlc3RJbnB1dFN0cmVhbShuYW1lLCBib2R5Q2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgLy8gUXVldWUgYm9keSBjYWxsYmFjayBpZiBwcm92aWRlZFxyXG4gICAgICAgIGlmIChib2R5Q2FsbGJhY2spXHJcbiAgICAgICAgICAgIGVucXVldWVCb2R5Q2FsbGJhY2sobmFtZSwgYm9keUNhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCByZXF1ZXN0IGZvciBpbnB1dCBzdHJlYW1cclxuICAgICAgICBjbGllbnQucmVxdWVzdE9iamVjdElucHV0U3RyZWFtKGd1YWNPYmplY3QuaW5kZXgsIG5hbWUpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG91dHB1dCBzdHJlYW0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgb2JqZWN0IGFuZCBoYXZpbmcgdGhlXHJcbiAgICAgKiBnaXZlbiBtaW1ldHlwZSBhbmQgbmFtZS4gVGhlIGxlZ2FsaXR5IG9mIGEgbWltZXR5cGUgYW5kIG5hbWUgaXMgZGljdGF0ZWRcclxuICAgICAqIGJ5IHRoZSBvYmplY3QgaXRzZWxmLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gICAgICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgZGF0YSB3aGljaCB3aWxsIGJlIHNlbnQgdG8gdGhlIG91dHB1dCBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAqICAgICBUaGUgZGVmaW5lZCBuYW1lIG9mIGFuIG91dHB1dCBzdHJlYW0gd2l0aGluIHRoaXMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtHdWFjYW1vbGUuT3V0cHV0U3RyZWFtfVxyXG4gICAgICogICAgIEFuIG91dHB1dCBzdHJlYW0gd2hpY2ggd2lsbCB3cml0ZSBibG9icyB0byB0aGUgbmFtZWQgb3V0cHV0IHN0cmVhbVxyXG4gICAgICogICAgIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNyZWF0ZU91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uIGNyZWF0ZU91dHB1dFN0cmVhbShtaW1ldHlwZSwgbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBjbGllbnQuY3JlYXRlT2JqZWN0T3V0cHV0U3RyZWFtKGd1YWNPYmplY3QuaW5kZXgsIG1pbWV0eXBlLCBuYW1lKTtcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSByZXNlcnZlZCBuYW1lIGRlbm90aW5nIHRoZSByb290IHN0cmVhbSBvZiBhbnkgb2JqZWN0LiBUaGUgY29udGVudHMgb2ZcclxuICogdGhlIHJvb3Qgc3RyZWFtIE1VU1QgYmUgYSBKU09OIG1hcCBvZiBzdHJlYW0gbmFtZSB0byBtaW1ldHlwZS5cclxuICpcclxuICogQGNvbnN0YW50XHJcbiAqIEB0eXBlIHtTdHJpbmd9XHJcbiAqL1xyXG5HdWFjYW1vbGUuT2JqZWN0LlJPT1RfU1RSRUFNID0gJy8nO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBtaW1ldHlwZSBvZiBhIHN0cmVhbSBjb250YWluaW5nIEpTT04gd2hpY2ggbWFwcyBhdmFpbGFibGUgc3RyZWFtIG5hbWVzXHJcbiAqIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgbWltZXR5cGUuIFRoZSByb290IHN0cmVhbSBvZiBhIEd1YWNhbW9sZS5PYmplY3QgTVVTVFxyXG4gKiBoYXZlIHRoaXMgbWltZXR5cGUuXHJcbiAqXHJcbiAqIEBjb25zdGFudFxyXG4gKiBAdHlwZSB7U3RyaW5nfVxyXG4gKi9cclxuR3VhY2Ftb2xlLk9iamVjdC5TVFJFQU1fSU5ERVhfTUlNRVRZUEUgPSAnYXBwbGljYXRpb24vdm5kLmdseXB0b2Rvbi5ndWFjYW1vbGUuc3RyZWFtLWluZGV4K2pzb24nO1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogRHluYW1pYyBvbi1zY3JlZW4ga2V5Ym9hcmQuIEdpdmVuIHRoZSBsYXlvdXQgb2JqZWN0IGZvciBhbiBvbi1zY3JlZW5cclxuICoga2V5Ym9hcmQsIHRoaXMgb2JqZWN0IHdpbGwgY29uc3RydWN0IGEgY2xpY2thYmxlIG9uLXNjcmVlbiBrZXlib2FyZCB3aXRoIGl0c1xyXG4gKiBvd24ga2V5IGV2ZW50cy5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuTGF5b3V0fSBsYXlvdXRcclxuICogICAgIFRoZSBsYXlvdXQgb2YgdGhlIG9uLXNjcmVlbiBrZXlib2FyZCB0byBkaXNwbGF5LlxyXG4gKi9cclxuR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQgPSBmdW5jdGlvbihsYXlvdXQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmR9XHJcbiAgICAgKi9cclxuICAgIHZhciBvc2sgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9mIGN1cnJlbnRseS1zZXQgbW9kaWZpZXJzIHRvIHRoZSBrZXlzeW0gYXNzb2NpYXRlZCB3aXRoIHRoZWlyXHJcbiAgICAgKiBvcmlnaW5hbCBwcmVzcy4gV2hlbiB0aGUgbW9kaWZpZXIgaXMgY2xlYXJlZCwgdGhpcyBrZXlzeW0gbXVzdCBiZVxyXG4gICAgICogcmVsZWFzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgTnVtYmVyPn1cclxuICAgICAqL1xyXG4gICAgdmFyIG1vZGlmaWVyS2V5c3ltcyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9mIGFsbCBrZXkgbmFtZXMgdG8gdGhlaXIgY3VycmVudCBwcmVzc2VkIHN0YXRlcy4gSWYgYSBrZXkgaXMgbm90XHJcbiAgICAgKiBwcmVzc2VkLCBpdCBtYXkgbm90IGJlIGluIHRoaXMgbWFwIGF0IGFsbCwgYnV0IGFsbCBwcmVzc2VkIGtleXMgd2lsbFxyXG4gICAgICogaGF2ZSBhIGNvcnJlc3BvbmRpbmcgbWFwcGluZyB0byB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIEJvb2xlYW4+fVxyXG4gICAgICovXHJcbiAgICB2YXIgcHJlc3NlZCA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsIHNjYWxhYmxlIGVsZW1lbnRzIHdoaWNoIGFyZSBwYXJ0IG9mIHRoZSBvbi1zY3JlZW4ga2V5Ym9hcmQuIEVhY2hcclxuICAgICAqIHNjYWxhYmxlIGVsZW1lbnQgaXMgY2FyZWZ1bGx5IGNvbnRyb2xsZWQgdG8gZW5zdXJlIHRoZSBpbnRlcmZhY2UgbGF5b3V0XHJcbiAgICAgKiBhbmQgc2l6aW5nIHJlbWFpbnMgY29uc3RhbnQsIGV2ZW4gb24gYnJvd3NlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2VcclxuICAgICAqIGV4cGVyaWVuY2Ugcm91bmRpbmcgZXJyb3IgZHVlIHRvIHVuaXQgY29udmVyc2lvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtTY2FsZWRFbGVtZW50W119XHJcbiAgICAgKi9cclxuICAgIHZhciBzY2FsZWRFbGVtZW50cyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIENTUyBjbGFzcyB0byBhbiBlbGVtZW50LlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICAgICAqICAgICBUaGUgZWxlbWVudCB0byBhZGQgYSBjbGFzcyB0by5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NuYW1lXHJcbiAgICAgKiAgICAgVGhlIG5hbWUgb2YgdGhlIGNsYXNzIHRvIGFkZC5cclxuICAgICAqL1xyXG4gICAgdmFyIGFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NuYW1lKSB7XHJcblxyXG4gICAgICAgIC8vIElmIGNsYXNzTGlzdCBzdXBwb3J0ZWQsIHVzZSB0aGF0XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KVxyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NuYW1lKTtcclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzaW1wbHkgYXBwZW5kIHRoZSBjbGFzc1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc25hbWU7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBDU1MgY2xhc3MgZnJvbSBhbiBlbGVtZW50LlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICAgICAqICAgICBUaGUgZWxlbWVudCB0byByZW1vdmUgYSBjbGFzcyBmcm9tLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc25hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUgY2xhc3MgdG8gcmVtb3ZlLlxyXG4gICAgICovXHJcbiAgICB2YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc25hbWUpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgY2xhc3NMaXN0IHN1cHBvcnRlZCwgdXNlIHRoYXRcclxuICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpXHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc25hbWUpO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIG1hbnVhbGx5IGZpbHRlciBvdXQgY2xhc3NlcyB3aXRoIGdpdmVuIG5hbWVcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKC8oW14gXSspWyBdKi9nLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTWF0Y2hpbmdDbGFzc2VzKG1hdGNoLCB0ZXN0Q2xhc3NuYW1lKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNhbWUgY2xhc3MsIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0Q2xhc3NuYW1lID09PSBjbGFzc25hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFsbG93XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ291bnRlciBvZiBtb3VzZSBldmVudHMgdG8gaWdub3JlLiBUaGlzIGRlY3JlbWVudGVkIGJ5IG1vdXNlbW92ZSwgYW5kXHJcbiAgICAgKiB3aGlsZSBub24temVybywgbW91c2UgZXZlbnRzIHdpbGwgaGF2ZSBubyBlZmZlY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBpZ25vcmVNb3VzZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZ25vcmVzIGFsbCBwZW5kaW5nIG1vdXNlIGV2ZW50cyB3aGVuIHRvdWNoIGV2ZW50cyBhcmUgdGhlIGFwcGFyZW50XHJcbiAgICAgKiBzb3VyY2UuIE1vdXNlIGV2ZW50cyBhcmUgaWdub3JlZCB1bnRpbCBhdCBsZWFzdCB0b3VjaE1vdXNlVGhyZXNob2xkXHJcbiAgICAgKiBtb3VzZSBldmVudHMgb2NjdXIgd2l0aG91dCBjb3JyZXNwb25kaW5nIHRvdWNoIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgaWdub3JlUGVuZGluZ01vdXNlRXZlbnRzID0gZnVuY3Rpb24gaWdub3JlUGVuZGluZ01vdXNlRXZlbnRzKCkge1xyXG4gICAgICAgIGlnbm9yZU1vdXNlID0gb3NrLnRvdWNoTW91c2VUaHJlc2hvbGQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gZWxlbWVudCB3aG9zZSBkaW1lbnNpb25zIGFyZSBtYWludGFpbmVkIGFjY29yZGluZyB0byBhbiBhcmJpdHJhcnlcclxuICAgICAqIHNjYWxlLiBUaGUgY29udmVyc2lvbiBmYWN0b3IgZm9yIHRoZXNlIGFyYml0cmFyeSB1bml0cyB0byBwaXhlbHMgaXNcclxuICAgICAqIHByb3ZpZGVkIGxhdGVyIHZpYSBhIGNhbGwgdG8gc2NhbGUoKS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICAgICAqICAgICBUaGUgZWxlbWVudCB3aG9zZSBzY2FsZSBzaG91bGQgYmUgbWFpbnRhaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcclxuICAgICAqICAgICBUaGUgd2lkdGggb2YgdGhlIGVsZW1lbnQsIGluIGFyYml0cmFyeSB1bml0cywgcmVsYXRpdmUgdG8gb3RoZXJcclxuICAgICAqICAgICBTY2FsZWRFbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XHJcbiAgICAgKiAgICAgVGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCwgaW4gYXJiaXRyYXJ5IHVuaXRzLCByZWxhdGl2ZSB0byBvdGhlclxyXG4gICAgICogICAgIFNjYWxlZEVsZW1lbnRzLlxyXG4gICAgICogICAgIFxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2NhbGVGb250PWZhbHNlXVxyXG4gICAgICogICAgIFdoZXRoZXIgdGhlIGxpbmUgaGVpZ2h0IGFuZCBmb250IHNpemUgc2hvdWxkIGJlIHNjYWxlZCBhcyB3ZWxsLlxyXG4gICAgICovXHJcbiAgICB2YXIgU2NhbGVkRWxlbWVudCA9IGZ1bmN0aW9uIFNjYWxlZEVsZW1lbnQoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgc2NhbGVGb250KSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGlzIFNjYWxlZEVsZW1lbnQsIGluIGFyYml0cmFyeSB1bml0cywgcmVsYXRpdmUgdG9cclxuICAgICAgICAgKiBvdGhlciBTY2FsZWRFbGVtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGlzIFNjYWxlZEVsZW1lbnQsIGluIGFyYml0cmFyeSB1bml0cywgcmVsYXRpdmUgdG9cclxuICAgICAgICAgKiBvdGhlciBTY2FsZWRFbGVtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzaXplcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50LCB1cGRhdGluZyBpdHMgZGltZW5zaW9ucyBhY2NvcmRpbmcgdG9cclxuICAgICAgICAgKiB0aGUgZ2l2ZW4gcGl4ZWxzIHBlciB1bml0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBpeGVsc1xyXG4gICAgICAgICAqICAgICBUaGUgbnVtYmVyIG9mIHBpeGVscyB0byBhc3NpZ24gcGVyIGFyYml0cmFyeSB1bml0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBmdW5jdGlvbihwaXhlbHMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFNjYWxlIGVsZW1lbnQgd2lkdGgvaGVpZ2h0XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggID0gKHdpZHRoICAqIHBpeGVscykgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKGhlaWdodCAqIHBpeGVscykgKyBcInB4XCI7XHJcblxyXG4gICAgICAgICAgICAvLyBTY2FsZSBmb250LCBpZiByZXF1ZXN0ZWRcclxuICAgICAgICAgICAgaWYgKHNjYWxlRm9udCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5saW5lSGVpZ2h0ID0gKGhlaWdodCAqIHBpeGVscykgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmZvbnRTaXplICAgPSBwaXhlbHMgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGFsbCBtb2RpZmllcnMgaGF2aW5nIHRoZSBnaXZlbiBuYW1lcyBhcmUgY3VycmVudGx5XHJcbiAgICAgKiBhY3RpdmUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG5hbWVzXHJcbiAgICAgKiAgICAgVGhlIG5hbWVzIG9mIGFsbCBtb2RpZmllcnMgdG8gdGVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqICAgICB0cnVlIGlmIGFsbCBzcGVjaWZpZWQgbW9kaWZpZXJzIGFyZSBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBtb2RpZmllcnNQcmVzc2VkID0gZnVuY3Rpb24gbW9kaWZpZXJzUHJlc3NlZChuYW1lcykge1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgcmVxdWlyZWQgbW9kaWZpZXJzIGFyZSBub3QgcHJlc3NlZCwgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRlc3Qgd2hldGhlciBjdXJyZW50IG1vZGlmaWVyIGlzIHByZXNzZWRcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcclxuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBtb2RpZmllcktleXN5bXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgYWxsIHJlcXVpcmVkIG1vZGlmaWVycyBhcmUgcHJlc3NlZFxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaW5nbGUgbWF0Y2hpbmcgS2V5IG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBvZiB0aGVcclxuICAgICAqIGdpdmVuIG5hbWUsIHdoZXJlIHRoYXQgS2V5IG9iamVjdCdzIHJlcXVpcmVtZW50cyAoc3VjaCBhcyBwcmVzc2VkXHJcbiAgICAgKiBtb2RpZmllcnMpIGFyZSBhbGwgY3VycmVudGx5IHNhdGlzZmllZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleU5hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHJldHJpZXZlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5LZXl9XHJcbiAgICAgKiAgICAgVGhlIEtleSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBuYW1lLCB3aGVyZSB0aGF0IG9iamVjdCdzXHJcbiAgICAgKiAgICAgcmVxdWlyZW1lbnRzIGFyZSBhbGwgY3VycmVudGx5IHNhdGlzZmllZCwgb3IgbnVsbCBpZiBubyBzdWNoIEtleVxyXG4gICAgICogICAgIGNhbiBiZSBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgdmFyIGdldEFjdGl2ZUtleSA9IGZ1bmN0aW9uIGdldEFjdGl2ZUtleShrZXlOYW1lKSB7XHJcblxyXG4gICAgICAgIC8vIEdldCBrZXkgYXJyYXkgZm9yIGdpdmVuIG5hbWVcclxuICAgICAgICB2YXIga2V5cyA9IG9zay5rZXlzW2tleU5hbWVdO1xyXG4gICAgICAgIGlmICgha2V5cylcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIC8vIEZpbmQgbGFzdCBtYXRjaGluZyBrZXlcclxuICAgICAgICBmb3IgKHZhciBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IGNhbmRpZGF0ZSBrZXlcclxuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGtleXNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBhbGwgcmVxdWlyZWQgbW9kaWZpZXJzIGFyZSBwcmVzc2VkLCB1c2UgdGhhdCBrZXlcclxuICAgICAgICAgICAgaWYgKG1vZGlmaWVyc1ByZXNzZWQoY2FuZGlkYXRlLnJlcXVpcmVzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm8gdmFsaWQga2V5XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByZXNzZXMgdGhlIGtleSBoYXZpbmcgdGhlIGdpdmVuIG5hbWUsIHVwZGF0aW5nIHRoZSBhc3NvY2lhdGVkIGtleVxyXG4gICAgICogZWxlbWVudCB3aXRoIHRoZSBcImd1YWMta2V5Ym9hcmQtcHJlc3NlZFwiIENTUyBjbGFzcy4gSWYgdGhlIGtleSBpc1xyXG4gICAgICogYWxyZWFkeSBwcmVzc2VkLCB0aGlzIGZ1bmN0aW9uIGhhcyBubyBlZmZlY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlOYW1lXHJcbiAgICAgKiAgICAgVGhlIG5hbWUgb2YgdGhlIGtleSB0byBwcmVzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5RWxlbWVudFxyXG4gICAgICogICAgIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxyXG4gICAgICovXHJcbiAgICB2YXIgcHJlc3MgPSBmdW5jdGlvbiBwcmVzcyhrZXlOYW1lLCBrZXlFbGVtZW50KSB7XHJcblxyXG4gICAgICAgIC8vIFByZXNzIGtleSBpZiBub3QgeWV0IHByZXNzZWRcclxuICAgICAgICBpZiAoIXByZXNzZWRba2V5TmFtZV0pIHtcclxuXHJcbiAgICAgICAgICAgIGFkZENsYXNzKGtleUVsZW1lbnQsIFwiZ3VhYy1rZXlib2FyZC1wcmVzc2VkXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQga2V5IGJhc2VkIG9uIG1vZGlmaWVyIHN0YXRlXHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRBY3RpdmVLZXkoa2V5TmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgbW9kaWZpZXIgc3RhdGVcclxuICAgICAgICAgICAgaWYgKGtleS5tb2RpZmllcikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCBjbGFzc25hbWUgZm9yIG1vZGlmaWVyXHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZXJDbGFzcyA9IFwiZ3VhYy1rZXlib2FyZC1tb2RpZmllci1cIiArIGdldENTU05hbWUoa2V5Lm1vZGlmaWVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSBvcmlnaW5hbGx5LXByZXNzZWQga2V5c3ltLCBpZiBtb2RpZmllciB3YXMgYWxyZWFkeSBwcmVzc2VkXHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxLZXlzeW0gPSBtb2RpZmllcktleXN5bXNba2V5Lm1vZGlmaWVyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBY3RpdmF0ZSBtb2RpZmllciBpZiBub3QgcHJlc3NlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbEtleXN5bSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGtleWJvYXJkLCBtb2RpZmllckNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcktleXN5bXNba2V5Lm1vZGlmaWVyXSA9IGtleS5rZXlzeW07XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCBrZXkgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3NrLm9ua2V5ZG93bilcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3NrLm9ua2V5ZG93bihrZXkua2V5c3ltKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGVhY3RpdmF0ZSBpZiBub3QgcHJlc3NlZFxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGtleWJvYXJkLCBtb2RpZmllckNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbW9kaWZpZXJLZXlzeW1zW2tleS5tb2RpZmllcl07XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCBrZXkgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3NrLm9ua2V5dXApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9zay5vbmtleXVwKG9yaWdpbmFsS2V5c3ltKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBub3QgbW9kaWZpZXIsIHNlbmQga2V5IGV2ZW50IG5vd1xyXG4gICAgICAgICAgICBlbHNlIGlmIChvc2sub25rZXlkb3duKVxyXG4gICAgICAgICAgICAgICAgb3NrLm9ua2V5ZG93bihrZXkua2V5c3ltKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1hcmsga2V5IGFzIHByZXNzZWRcclxuICAgICAgICAgICAgcHJlc3NlZFtrZXlOYW1lXSA9IHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVsZWFzZXMgdGhlIGtleSBoYXZpbmcgdGhlIGdpdmVuIG5hbWUsIHJlbW92aW5nIHRoZVxyXG4gICAgICogXCJndWFjLWtleWJvYXJkLXByZXNzZWRcIiBDU1MgY2xhc3MgZnJvbSB0aGUgYXNzb2NpYXRlZCBlbGVtZW50LiBJZiB0aGVcclxuICAgICAqIGtleSBpcyBhbHJlYWR5IHJlbGVhc2VkLCB0aGlzIGZ1bmN0aW9uIGhhcyBubyBlZmZlY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlOYW1lXHJcbiAgICAgKiAgICAgVGhlIG5hbWUgb2YgdGhlIGtleSB0byByZWxlYXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlFbGVtZW50XHJcbiAgICAgKiAgICAgVGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXHJcbiAgICAgKi9cclxuICAgIHZhciByZWxlYXNlID0gZnVuY3Rpb24gcmVsZWFzZShrZXlOYW1lLCBrZXlFbGVtZW50KSB7XHJcblxyXG4gICAgICAgIC8vIFJlbGVhc2Uga2V5IGlmIGN1cnJlbnRseSBwcmVzc2VkXHJcbiAgICAgICAgaWYgKHByZXNzZWRba2V5TmFtZV0pIHtcclxuXHJcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGtleUVsZW1lbnQsIFwiZ3VhYy1rZXlib2FyZC1wcmVzc2VkXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQga2V5IGJhc2VkIG9uIG1vZGlmaWVyIHN0YXRlXHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRBY3RpdmVLZXkoa2V5TmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZW5kIGtleSBldmVudCBpZiBub3QgYSBtb2RpZmllciBrZXlcclxuICAgICAgICAgICAgaWYgKCFrZXkubW9kaWZpZXIgJiYgb3NrLm9ua2V5dXApXHJcbiAgICAgICAgICAgICAgICBvc2sub25rZXl1cChrZXkua2V5c3ltKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1hcmsga2V5IGFzIHJlbGVhc2VkXHJcbiAgICAgICAgICAgIHByZXNzZWRba2V5TmFtZV0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gQ3JlYXRlIGtleWJvYXJkXHJcbiAgICB2YXIga2V5Ym9hcmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAga2V5Ym9hcmQuY2xhc3NOYW1lID0gXCJndWFjLWtleWJvYXJkXCI7XHJcblxyXG4gICAgLy8gRG8gbm90IGFsbG93IHNlbGVjdGlvbiBvciBtb3VzZSBtb3ZlbWVudCB0byBwcm9wYWdhdGUvcmVnaXN0ZXIuXHJcbiAgICBrZXlib2FyZC5vbnNlbGVjdHN0YXJ0ID1cclxuICAgIGtleWJvYXJkLm9ubW91c2Vtb3ZlICAgPVxyXG4gICAga2V5Ym9hcmQub25tb3VzZXVwICAgICA9XHJcbiAgICBrZXlib2FyZC5vbm1vdXNlZG93biAgID0gZnVuY3Rpb24gaGFuZGxlTW91c2VFdmVudHMoZSkge1xyXG5cclxuICAgICAgICAvLyBJZiBpZ25vcmluZyBldmVudHMsIGRlY3JlbWVudCBjb3VudGVyXHJcbiAgICAgICAgaWYgKGlnbm9yZU1vdXNlKVxyXG4gICAgICAgICAgICBpZ25vcmVNb3VzZS0tO1xyXG5cclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBtb3VzZW1vdmUgZXZlbnRzIHRvIHJlcXVpcmUgYmVmb3JlIHJlLWVuYWJsaW5nIG1vdXNlXHJcbiAgICAgKiBldmVudCBoYW5kbGluZyBhZnRlciByZWNlaXZpbmcgYSB0b3VjaCBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRvdWNoTW91c2VUaHJlc2hvbGQgPSAzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBvbiB0aGlzIEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrZXlzeW0gVGhlIGtleXN5bSBvZiB0aGUga2V5IGJlaW5nIHByZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25rZXlkb3duID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IG9uIHRoaXMgR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuXHJcbiAgICAgKiBcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtleXN5bSBUaGUga2V5c3ltIG9mIHRoZSBrZXkgYmVpbmcgcmVsZWFzZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25rZXl1cCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUga2V5Ym9hcmQgbGF5b3V0IHByb3ZpZGVkIGF0IHRpbWUgb2YgY29uc3RydWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5MYXlvdXR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGF5b3V0ID0gbmV3IEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLkxheW91dChsYXlvdXQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBlbnRpcmUgb24tc2NyZWVuIGtleWJvYXJkLlxyXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9IFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGVudGlyZSBvbi1zY3JlZW4ga2V5Ym9hcmQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBrZXlib2FyZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIGFsbCBlbGVtZW50cyB3aXRoaW4gdGhpcyBHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZCBzdWNoIHRoYXRcclxuICAgICAqIHRoZSB3aWR0aCBpcyBjbG9zZSB0byBidXQgZG9lcyBub3QgZXhjZWVkIHRoZSBzcGVjaWZpZWQgd2lkdGguIFRoZVxyXG4gICAgICogaGVpZ2h0IG9mIHRoZSBrZXlib2FyZCBpcyBkZXRlcm1pbmVkIGJhc2VkIG9uIHRoZSB3aWR0aC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCB0byByZXNpemUgdGhpcyBHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHRvLCBpbiBwaXhlbHMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzaXplID0gZnVuY3Rpb24od2lkdGgpIHtcclxuXHJcbiAgICAgICAgLy8gR2V0IHBpeGVsIHNpemUgb2YgYSB1bml0XHJcbiAgICAgICAgdmFyIHVuaXQgPSBNYXRoLmZsb29yKHdpZHRoICogMTAgLyBvc2subGF5b3V0LndpZHRoKSAvIDEwO1xyXG5cclxuICAgICAgICAvLyBSZXNpemUgYWxsIHNjYWxlZCBlbGVtZW50c1xyXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxzY2FsZWRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVkRWxlbWVudCA9IHNjYWxlZEVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBzY2FsZWRFbGVtZW50LnNjYWxlKHVuaXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gdGhlIG5hbWUgb2YgYSBrZXkgYW5kIGl0cyBjb3JyZXNwb25kaW5nIGRlZmluaXRpb24sIHdoaWNoIG1heSBiZVxyXG4gICAgICogYW4gYXJyYXkgb2Yga2V5cyBvYmplY3RzLCBhIG51bWJlciAoa2V5c3ltKSwgYSBzdHJpbmcgKGtleSB0aXRsZSksIG9yIGFcclxuICAgICAqIHNpbmdsZSBrZXkgb2JqZWN0LCByZXR1cm5zIGFuIGFycmF5IG9mIGtleSBvYmplY3RzLCBkZXJpdmluZyBhbnkgbWlzc2luZ1xyXG4gICAgICogcHJvcGVydGllcyBhcyBuZWVkZWQsIGFuZCBlbnN1cmluZyB0aGUga2V5IG5hbWUgaXMgZGVmaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICAqICAgICBUaGUgbmFtZSBvZiB0aGUga2V5IGJlaW5nIGNvZXJjZWQgaW50byBhbiBhcnJheSBvZiBLZXkgb2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8R3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuS2V5fEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleVtdfSBvYmplY3RcclxuICAgICAqICAgICBUaGUgb2JqZWN0IGRlZmluaW5nIHRoZSBiZWhhdmlvciBvZiB0aGUga2V5IGhhdmluZyB0aGUgZ2l2ZW4gbmFtZSxcclxuICAgICAqICAgICB3aGljaCBtYXkgYmUgdGhlIHRpdGxlIG9mIHRoZSBrZXkgKGEgc3RyaW5nKSwgdGhlIGtleXN5bSAoYSBudW1iZXIpLFxyXG4gICAgICogICAgIGEgc2luZ2xlIEtleSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIEtleSBvYmplY3RzLlxyXG4gICAgICogICAgIFxyXG4gICAgICogQHJldHVybnMge0d1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleVtdfVxyXG4gICAgICogICAgIEFuIGFycmF5IG9mIGFsbCBrZXlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cclxuICAgICAqL1xyXG4gICAgdmFyIGFzS2V5QXJyYXkgPSBmdW5jdGlvbiBhc0tleUFycmF5KG5hbWUsIG9iamVjdCkge1xyXG5cclxuICAgICAgICAvLyBJZiBhbHJlYWR5IGFuIGFycmF5LCBqdXN0IGNvZXJjZSBpbnRvIGEgdHJ1ZSBLZXlbXSBcclxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2gobmV3IEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleShvYmplY3RbaV0sIG5hbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlcml2ZSBrZXkgb2JqZWN0IGZyb20ga2V5c3ltIGlmIHRoYXQncyBhbGwgd2UgaGF2ZVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gW25ldyBHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5LZXkoe1xyXG4gICAgICAgICAgICAgICAgbmFtZSAgIDogbmFtZSxcclxuICAgICAgICAgICAgICAgIGtleXN5bSA6IG9iamVjdFxyXG4gICAgICAgICAgICB9KV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXJpdmUga2V5IG9iamVjdCBmcm9tIHRpdGxlIGlmIHRoYXQncyBhbGwgd2UgaGF2ZVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gW25ldyBHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5LZXkoe1xyXG4gICAgICAgICAgICAgICAgbmFtZSAgOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgdGl0bGUgOiBvYmplY3RcclxuICAgICAgICAgICAgfSldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaXQncyBhbHJlYWR5IGEga2V5IG9iamVjdCwganVzdCBub3QgYW4gYXJyYXlcclxuICAgICAgICByZXR1cm4gW25ldyBHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5LZXkob2JqZWN0LCBuYW1lKV07XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSByYXRoZXIgZm9yZ2l2aW5nIGtleSBtYXBwaW5nIGFsbG93ZWQgYnlcclxuICAgICAqIEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLkxheW91dCBpbnRvIGEgcmlnb3JvdXMgbWFwcGluZyBvZiBrZXkgbmFtZVxyXG4gICAgICogdG8ga2V5IGRlZmluaXRpb24sIHdoZXJlIHRoZSBrZXkgZGVmaW5pdGlvbiBpcyBhbHdheXMgYW4gYXJyYXkgb2YgS2V5XHJcbiAgICAgKiBvYmplY3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBOdW1iZXJ8U3RyaW5nfEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleXxHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5LZXlbXT59IGtleXNcclxuICAgICAqICAgICBBIG1hcHBpbmcgb2Yga2V5IG5hbWUgdG8ga2V5IGRlZmluaXRpb24sIHdoZXJlIHRoZSBrZXkgZGVmaW5pdGlvbiBpc1xyXG4gICAgICogICAgIHRoZSB0aXRsZSBvZiB0aGUga2V5IChhIHN0cmluZyksIHRoZSBrZXlzeW0gKGEgbnVtYmVyKSwgYSBzaW5nbGVcclxuICAgICAqICAgICBLZXkgb2JqZWN0LCBvciBhbiBhcnJheSBvZiBLZXkgb2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxTdHJpbmcsIEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleVtdPn1cclxuICAgICAqICAgICBBIG1vcmUtcHJlZGljdGFibGUgbWFwcGluZyBvZiBrZXkgbmFtZSB0byBrZXkgZGVmaW5pdGlvbiwgd2hlcmUgdGhlXHJcbiAgICAgKiAgICAga2V5IGRlZmluaXRpb24gaXMgYWx3YXlzIHNpbXBseSBhbiBhcnJheSBvZiBLZXkgb2JqZWN0cy5cclxuICAgICAqL1xyXG4gICAgdmFyIGdldEtleXMgPSBmdW5jdGlvbiBnZXRLZXlzKGtleXMpIHtcclxuXHJcbiAgICAgICAgdmFyIGtleUFycmF5cyA9IHt9O1xyXG5cclxuICAgICAgICAvLyBDb2VyY2UgYWxsIGtleXMgaW50byBpbmRpdmlkdWFsIGtleSBhcnJheXNcclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGxheW91dC5rZXlzKSB7XHJcbiAgICAgICAgICAgIGtleUFycmF5c1tuYW1lXSA9IGFzS2V5QXJyYXkobmFtZSwga2V5c1tuYW1lXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ga2V5QXJyYXlzO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2YgYWxsIGtleSBuYW1lcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIHNldCBvZiBrZXlzLiBFYWNoIGtleSBuYW1lXHJcbiAgICAgKiBtYXkgY29ycmVzcG9uZCB0byBtdWx0aXBsZSBrZXlzIGR1ZSB0byB0aGUgZWZmZWN0IG9mIG1vZGlmaWVycy5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleVtdPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5rZXlzID0gZ2V0S2V5cyhsYXlvdXQua2V5cyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBhcmJpdHJhcnkgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiBzb21lIGNvbXBvbmVudCBvZiB0aGVcclxuICAgICAqIG9uLXNjcmVlbiBrZXlib2FyZCwgcmV0dXJucyBhIHN0cmluZyBmb3JtYXR0ZWQgZm9yIHVzZSBhcyBhIENTUyBjbGFzc1xyXG4gICAgICogbmFtZS4gVGhlIHJlc3VsdCB3aWxsIGJlIGxvd2VyY2FzZS4gV29yZCBib3VuZGFyaWVzIHByZXZpb3VzbHkgZGVub3RlZFxyXG4gICAgICogYnkgQ2FtZWxDYXNlIHdpbGwgYmUgcmVwbGFjZWQgYnkgaW5kaXZpZHVhbCBoeXBoZW5zLCBhcyB3aWxsIGFsbFxyXG4gICAgICogY29udGlndW91cyBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgKiAgICAgQW4gYXJiaXRyYXJ5IHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2Ygc29tZSBjb21wb25lbnQgb2YgdGhlXHJcbiAgICAgKiAgICAgb24tc2NyZWVuIGtleWJvYXJkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgKiAgICAgQSBzdHJpbmcgZm9ybWF0dGVkIGZvciB1c2UgYXMgYSBDU1MgY2xhc3MgbmFtZS5cclxuICAgICAqL1xyXG4gICAgdmFyIGdldENTU05hbWUgPSBmdW5jdGlvbiBnZXRDU1NOYW1lKG5hbWUpIHtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBuYW1lIGZyb20gcG9zc2libHktQ2FtZWxDYXNlIHRvIGh5cGhlbmF0ZWQgbG93ZXJjYXNlXHJcbiAgICAgICAgdmFyIGNzc05hbWUgPSBuYW1lXHJcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKVxyXG4gICAgICAgICAgICAgICAucmVwbGFjZSgvW15BLVphLXowLTldKy9nLCAnLScpXHJcbiAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gY3NzTmFtZTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBET00gZWxlbWVudHMgdG8gdGhlIGdpdmVuIGVsZW1lbnQgYXMgZGljdGF0ZWQgYnkgdGhlIGxheW91dFxyXG4gICAgICogc3RydWN0dXJlIG9iamVjdCBwcm92aWRlZC4gSWYgYSBuYW1lIGlzIHByb3ZpZGVkLCBhbiBhZGRpdGlvbmFsIENTU1xyXG4gICAgICogY2xhc3MsIHByZXBlbmRlZCB3aXRoIFwiZ3VhYy1rZXlib2FyZC1cIiwgd2lsbCBiZSBhZGRlZCB0byB0aGUgdG9wLWxldmVsXHJcbiAgICAgKiBlbGVtZW50LlxyXG4gICAgICogXHJcbiAgICAgKiBJZiB0aGUgbGF5b3V0IHN0cnVjdHVyZSBvYmplY3QgaXMgYW4gYXJyYXksIGFsbCBlbGVtZW50cyB3aXRoaW4gdGhhdFxyXG4gICAgICogYXJyYXkgd2lsbCBiZSByZWN1cnNpdmVseSBhcHBlbmRlZCBhcyBjaGlsZHJlbiBvZiBhIGdyb3VwLCBhbmQgdGhlXHJcbiAgICAgKiB0b3AtbGV2ZWwgZWxlbWVudCB3aWxsIGJlIGdpdmVuIHRoZSBDU1MgY2xhc3MgXCJndWFjLWtleWJvYXJkLWdyb3VwXCIuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIGxheW91dCBzdHJ1Y3R1cmUgb2JqZWN0IGlzIGFuIG9iamVjdCwgYWxsIHByb3BlcnRpZXMgd2l0aGluIHRoYXRcclxuICAgICAqIG9iamVjdCB3aWxsIGJlIHJlY3Vyc2l2ZWx5IGFwcGVuZGVkIGFzIGNoaWxkcmVuIG9mIGEgZ3JvdXAsIGFuZCB0aGVcclxuICAgICAqIHRvcC1sZXZlbCBlbGVtZW50IHdpbGwgYmUgZ2l2ZW4gdGhlIENTUyBjbGFzcyBcImd1YWMta2V5Ym9hcmQtZ3JvdXBcIi4gVGhlXHJcbiAgICAgKiBuYW1lIG9mIGVhY2ggcHJvcGVydHkgd2lsbCBiZSBhcHBsaWVkIGFzIHRoZSBuYW1lIG9mIGVhY2ggY2hpbGQgb2JqZWN0XHJcbiAgICAgKiBmb3IgdGhlIHNha2Ugb2YgQ1NTLiBFYWNoIHByb3BlcnR5IHdpbGwgYmUgYWRkZWQgaW4gc29ydGVkIG9yZGVyLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBsYXlvdXQgc3RydWN0dXJlIG9iamVjdCBpcyBhIHN0cmluZywgdGhlIGtleSBoYXZpbmcgdGhhdCBuYW1lXHJcbiAgICAgKiB3aWxsIGJlIGFwcGVuZGVkLiBUaGUga2V5IHdpbGwgYmUgZ2l2ZW4gdGhlIENTUyBjbGFzc1xyXG4gICAgICogXCJndWFjLWtleWJvYXJkLWtleVwiIGFuZCBcImd1YWMta2V5Ym9hcmQta2V5LU5BTUVcIiwgd2hlcmUgTkFNRSBpcyB0aGUgbmFtZVxyXG4gICAgICogb2YgdGhlIGtleS4gSWYgdGhlIG5hbWUgb2YgdGhlIGtleSBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIsIHRoaXMgd2lsbFxyXG4gICAgICogZmlyc3QgYmUgdHJhbnNmb3JtZWQgaW50byB0aGUgQy1zdHlsZSBoZXhhZGVjaW1hbCBsaXRlcmFsIGZvciB0aGVcclxuICAgICAqIFVuaWNvZGUgY29kZXBvaW50IG9mIHRoYXQgY2hhcmFjdGVyLiBGb3IgZXhhbXBsZSwgdGhlIGtleSBcIkFcIiB3b3VsZFxyXG4gICAgICogYmVjb21lIFwiZ3VhYy1rZXlib2FyZC1rZXktMHg0MVwiLlxyXG4gICAgICogXHJcbiAgICAgKiBJZiB0aGUgbGF5b3V0IHN0cnVjdHVyZSBvYmplY3QgaXMgYSBudW1iZXIsIGEgZ2FwIG9mIHRoYXQgc2l6ZSB3aWxsIGJlXHJcbiAgICAgKiBpbnNlcnRlZC4gVGhlIGdhcCB3aWxsIGJlIGdpdmVuIHRoZSBDU1MgY2xhc3MgXCJndWFjLWtleWJvYXJkLWdhcFwiLCBhbmRcclxuICAgICAqIHdpbGwgYmUgc2NhbGVkIGFjY29yZGluZyB0byB0aGUgc2FtZSBzaXplIHVuaXRzIGFzIGVhY2gga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICAgICAqICAgICBUaGUgZWxlbWVudCB0byBhcHBlbmQgZWxlbWVudHMgdG8uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfE51bWJlcn0gb2JqZWN0XHJcbiAgICAgKiAgICAgVGhlIGxheW91dCBzdHJ1Y3R1cmUgb2JqZWN0IHRvIHVzZSB3aGVuIGNvbnN0cnVjdGluZyB0aGUgZWxlbWVudHMgdG9cclxuICAgICAqICAgICBhcHBlbmQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXVxyXG4gICAgICogICAgIFRoZSBuYW1lIG9mIHRoZSB0b3AtbGV2ZWwgZWxlbWVudCBiZWluZyBhcHBlbmRlZCwgaWYgYW55LlxyXG4gICAgICovXHJcbiAgICB2YXIgYXBwZW5kRWxlbWVudHMgPSBmdW5jdGlvbiBhcHBlbmRFbGVtZW50cyhlbGVtZW50LCBvYmplY3QsIG5hbWUpIHtcclxuXHJcbiAgICAgICAgdmFyIGk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBkaXYgd2hpY2ggd2lsbCBiZWNvbWUgdGhlIGdyb3VwIG9yIGtleVxyXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGNsYXNzIGJhc2VkIG9uIG5hbWUsIGlmIG5hbWUgZ2l2ZW5cclxuICAgICAgICBpZiAobmFtZSlcclxuICAgICAgICAgICAgYWRkQ2xhc3MoZGl2LCAnZ3VhYy1rZXlib2FyZC0nICsgZ2V0Q1NTTmFtZShuYW1lKSk7XHJcblxyXG4gICAgICAgIC8vIElmIGFuIGFycmF5LCBhcHBlbmQgZWFjaCBlbGVtZW50XHJcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgZ3JvdXAgY2xhc3NcclxuICAgICAgICAgICAgYWRkQ2xhc3MoZGl2LCAnZ3VhYy1rZXlib2FyZC1ncm91cCcpO1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIGFsbCBlbGVtZW50cyBvZiBhcnJheVxyXG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIGFwcGVuZEVsZW1lbnRzKGRpdiwgb2JqZWN0W2ldKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBhbiBvYmplY3QsIGFwcGVuZCBlYWNoIHByb3BlcnR5IHZhbHVlXHJcbiAgICAgICAgZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgT2JqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgZ3JvdXAgY2xhc3NcclxuICAgICAgICAgICAgYWRkQ2xhc3MoZGl2LCAnZ3VhYy1rZXlib2FyZC1ncm91cCcpO1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIGFsbCBjaGlsZHJlbiwgc29ydGVkIGJ5IG5hbWVcclxuICAgICAgICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMob2JqZWN0KS5zb3J0KCk7XHJcbiAgICAgICAgICAgIGZvciAoaT0wOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICBhcHBlbmRFbGVtZW50cyhkaXYsIG9iamVjdFtuYW1lXSwgbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBhIG51bWJlciwgY3JlYXRlIGFzIGEgZ2FwIFxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgZ2FwIGNsYXNzXHJcbiAgICAgICAgICAgIGFkZENsYXNzKGRpdiwgJ2d1YWMta2V5Ym9hcmQtZ2FwJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWludGFpbiBzY2FsZVxyXG4gICAgICAgICAgICBzY2FsZWRFbGVtZW50cy5wdXNoKG5ldyBTY2FsZWRFbGVtZW50KGRpdiwgb2JqZWN0LCBvYmplY3QpKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBhIHN0cmluZywgY3JlYXRlIGFzIGEga2V5XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGtleSBuYW1lIGlzIG9ubHkgb25lIGNoYXJhY3RlciwgdXNlIGNvZGVwb2ludCBmb3IgbmFtZVxyXG4gICAgICAgICAgICB2YXIga2V5TmFtZSA9IG9iamVjdDtcclxuICAgICAgICAgICAgaWYgKGtleU5hbWUubGVuZ3RoID09PSAxKVxyXG4gICAgICAgICAgICAgICAga2V5TmFtZSA9ICcweCcgKyBrZXlOYW1lLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIGtleSBjb250YWluZXIgY2xhc3NcclxuICAgICAgICAgICAgYWRkQ2xhc3MoZGl2LCAnZ3VhYy1rZXlib2FyZC1rZXktY29udGFpbmVyJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUga2V5IGVsZW1lbnQgd2hpY2ggd2lsbCBjb250YWluIGFsbCBwb3NzaWJsZSBjYXBzXHJcbiAgICAgICAgICAgIHZhciBrZXlFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGtleUVsZW1lbnQuY2xhc3NOYW1lID0gJ2d1YWMta2V5Ym9hcmQta2V5ICdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnZ3VhYy1rZXlib2FyZC1rZXktJyArIGdldENTU05hbWUoa2V5TmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgYWxsIGFzc29jaWF0ZWQga2V5cyBhcyBjYXBzIHdpdGhpbiBET01cclxuICAgICAgICAgICAgdmFyIGtleXMgPSBvc2sua2V5c1tvYmplY3RdO1xyXG4gICAgICAgICAgICBpZiAoa2V5cykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpPTA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGtleVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY2FwIGVsZW1lbnQgZm9yIGtleVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FwRWxlbWVudC5jbGFzc05hbWUgICA9ICdndWFjLWtleWJvYXJkLWNhcCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FwRWxlbWVudC50ZXh0Q29udGVudCA9IGtleS50aXRsZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGNsYXNzZXMgZm9yIGFueSByZXF1aXJlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGogPCBrZXkucmVxdWlyZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVpcmVtZW50ID0ga2V5LnJlcXVpcmVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhjYXBFbGVtZW50LCAnZ3VhYy1rZXlib2FyZC1yZXF1aXJlcy0nICsgZ2V0Q1NTTmFtZShyZXF1aXJlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhrZXlFbGVtZW50LCAnZ3VhYy1rZXlib2FyZC11c2VzLScgICAgICsgZ2V0Q1NTTmFtZShyZXF1aXJlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGNhcCB0byBrZXkgd2l0aGluIERPTVxyXG4gICAgICAgICAgICAgICAgICAgIGtleUVsZW1lbnQuYXBwZW5kQ2hpbGQoY2FwRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQga2V5IHRvIERPTSwgbWFpbnRhaW4gc2NhbGVcclxuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGtleUVsZW1lbnQpO1xyXG4gICAgICAgICAgICBzY2FsZWRFbGVtZW50cy5wdXNoKG5ldyBTY2FsZWRFbGVtZW50KGRpdiwgb3NrLmxheW91dC5rZXlXaWR0aHNbb2JqZWN0XSB8fCAxLCAxLCB0cnVlKSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBhIHRvdWNoIGV2ZW50IHdoaWNoIHJlc3VsdHMgaW4gdGhlIHByZXNzaW5nIG9mIGFuIE9TS1xyXG4gICAgICAgICAgICAgKiBrZXkuIFRvdWNoIGV2ZW50cyB3aWxsIHJlc3VsdCBpbiBtb3VzZSBldmVudHMgYmVpbmcgaWdub3JlZCBmb3JcclxuICAgICAgICAgICAgICogdG91Y2hNb3VzZVRocmVzaG9sZCBldmVudHMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxyXG4gICAgICAgICAgICAgKiAgICAgVGhlIHRvdWNoIGV2ZW50IGJlaW5nIGhhbmRsZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgdG91Y2hQcmVzcyA9IGZ1bmN0aW9uIHRvdWNoUHJlc3MoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgaWdub3JlTW91c2UgPSBvc2sudG91Y2hNb3VzZVRocmVzaG9sZDtcclxuICAgICAgICAgICAgICAgIHByZXNzKG9iamVjdCwga2V5RWxlbWVudCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBhIHRvdWNoIGV2ZW50IHdoaWNoIHJlc3VsdHMgaW4gdGhlIHJlbGVhc2Ugb2YgYW4gT1NLXHJcbiAgICAgICAgICAgICAqIGtleS4gVG91Y2ggZXZlbnRzIHdpbGwgcmVzdWx0IGluIG1vdXNlIGV2ZW50cyBiZWluZyBpZ25vcmVkIGZvclxyXG4gICAgICAgICAgICAgKiB0b3VjaE1vdXNlVGhyZXNob2xkIGV2ZW50cy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXHJcbiAgICAgICAgICAgICAqICAgICBUaGUgdG91Y2ggZXZlbnQgYmVpbmcgaGFuZGxlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciB0b3VjaFJlbGVhc2UgPSBmdW5jdGlvbiB0b3VjaFJlbGVhc2UoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgaWdub3JlTW91c2UgPSBvc2sudG91Y2hNb3VzZVRocmVzaG9sZDtcclxuICAgICAgICAgICAgICAgIHJlbGVhc2Uob2JqZWN0LCBrZXlFbGVtZW50KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGEgbW91c2UgZXZlbnQgd2hpY2ggcmVzdWx0cyBpbiB0aGUgcHJlc3Npbmcgb2YgYW4gT1NLXHJcbiAgICAgICAgICAgICAqIGtleS4gSWYgbW91c2UgZXZlbnRzIGFyZSBjdXJyZW50bHkgYmVpbmcgaWdub3JlZCwgdGhpcyBoYW5kbGVyXHJcbiAgICAgICAgICAgICAqIGRvZXMgbm90aGluZy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXHJcbiAgICAgICAgICAgICAqICAgICBUaGUgdG91Y2ggZXZlbnQgYmVpbmcgaGFuZGxlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBtb3VzZVByZXNzID0gZnVuY3Rpb24gbW91c2VQcmVzcyhlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlTW91c2UgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlc3Mob2JqZWN0LCBrZXlFbGVtZW50KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGEgbW91c2UgZXZlbnQgd2hpY2ggcmVzdWx0cyBpbiB0aGUgcmVsZWFzZSBvZiBhbiBPU0tcclxuICAgICAgICAgICAgICoga2V5LiBJZiBtb3VzZSBldmVudHMgYXJlIGN1cnJlbnRseSBiZWluZyBpZ25vcmVkLCB0aGlzIGhhbmRsZXJcclxuICAgICAgICAgICAgICogZG9lcyBub3RoaW5nLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcclxuICAgICAgICAgICAgICogICAgIFRoZSB0b3VjaCBldmVudCBiZWluZyBoYW5kbGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIG1vdXNlUmVsZWFzZSA9IGZ1bmN0aW9uIG1vdXNlUmVsZWFzZShlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlTW91c2UgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZShvYmplY3QsIGtleUVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIHRvdWNoIGV2ZW50cyBvbiBrZXlcclxuICAgICAgICAgICAga2V5RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0b3VjaFByZXNzLCAgIHRydWUpO1xyXG4gICAgICAgICAgICBrZXlFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAgIHRvdWNoUmVsZWFzZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgbW91c2UgZXZlbnRzIG9uIGtleVxyXG4gICAgICAgICAgICBrZXlFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VQcmVzcywgICB0cnVlKTtcclxuICAgICAgICAgICAga2V5RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCAgIG1vdXNlUmVsZWFzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGtleUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsICBtb3VzZVJlbGVhc2UsIHRydWUpO1xyXG5cclxuICAgICAgICB9IC8vIGVuZCBpZiBvYmplY3QgaXMga2V5IG5hbWVcclxuXHJcbiAgICAgICAgLy8gQWRkIG5ld2x5LWNyZWF0ZWQgZ3JvdXAva2V5XHJcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkaXYpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gQ3JlYXRlIGtleWJvYXJkIGxheW91dCBpbiBET01cclxuICAgIGFwcGVuZEVsZW1lbnRzKGtleWJvYXJkLCBsYXlvdXQubGF5b3V0KTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBlbnRpcmUgb24tc2NyZWVuIGtleWJvYXJkIGxheW91dCwgaW5jbHVkaW5nIGFsbCBhdmFpbGFibGVcclxuICoga2V5cywgdGhlaXIgYmVoYXZpb3JzLCBhbmQgdGhlaXIgcmVsYXRpdmUgcG9zaXRpb24gYW5kIHNpemluZy5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuTGF5b3V0fE9iamVjdH0gdGVtcGxhdGVcclxuICogICAgIFRoZSBvYmplY3Qgd2hvc2UgaWRlbnRpY2FsbHktbmFtZWQgcHJvcGVydGllcyB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxyXG4gKiAgICAgdGhlIHByb3BlcnRpZXMgb2YgdGhpcyBsYXlvdXQuXHJcbiAqL1xyXG5HdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5MYXlvdXQgPSBmdW5jdGlvbih0ZW1wbGF0ZSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxhbmd1YWdlIG9mIGtleWJvYXJkIGxheW91dCwgc3VjaCBhcyBcImVuX1VTXCIuIFRoaXMgcHJvcGVydHkgaXMgZm9yXHJcbiAgICAgKiBpbmZvcm1hdGlvbmFsIHB1cnBvc2VzIG9ubHksIGJ1dCBpdCBpcyByZWNvbW1lbmQgdG8gY29uZm9ybSB0byB0aGVcclxuICAgICAqIFtsYW5ndWFnZSBjb2RlXV9bY291bnRyeSBjb2RlXSBmb3JtYXQuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5sYW5ndWFnZSA9IHRlbXBsYXRlLmxhbmd1YWdlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR5cGUgb2Yga2V5Ym9hcmQgbGF5b3V0LCBzdWNoIGFzIFwicXdlcnR5XCIuIFRoaXMgcHJvcGVydHkgaXMgZm9yXHJcbiAgICAgKiBpbmZvcm1hdGlvbmFsIHB1cnBvc2VzIG9ubHksIGFuZCBkb2VzIG5vdCBjb25mb3JtIHRvIGFueSBzdGFuZGFyZC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGUgPSB0ZW1wbGF0ZS50eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9mIGtleSBuYW1lIHRvIGNvcnJlc3BvbmRpbmcga2V5c3ltLCB0aXRsZSwgb3Iga2V5IG9iamVjdC4gSWYgb25seVxyXG4gICAgICogdGhlIGtleXN5bSBvciB0aXRsZSBpcyBwcm92aWRlZCwgdGhlIGtleSBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkXHJcbiAgICAgKiBpbXBsaWNpdGx5LiBJbiBhbGwgY2FzZXMsIHRoZSBuYW1lIHByb3BlcnR5IG9mIHRoZSBrZXkgb2JqZWN0IHdpbGwgYmVcclxuICAgICAqIHRha2VuIGZyb20gdGhlIG5hbWUgZ2l2ZW4gaW4gdGhlIG1hcHBpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge09iamVjdC48U3RyaW5nLCBOdW1iZXJ8U3RyaW5nfEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLktleXxHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5LZXlbXT59XHJcbiAgICAgKi9cclxuICAgIHRoaXMua2V5cyA9IHRlbXBsYXRlLmtleXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcmJpdHJhcmlseSBuZXN0ZWQsIGFyYml0cmFyaWx5IGdyb3VwZWQga2V5IG5hbWVzLiBUaGUgY29udGVudHMgb2YgdGhlXHJcbiAgICAgKiBsYXlvdXQgd2lsbCBiZSB0cmF2ZXJzZWQgdG8gcHJvZHVjZSBhbiBpZGVudGljYWxseS1uZXN0ZWQgZ3JvdXBpbmcgb2ZcclxuICAgICAqIGtleXMgaW4gdGhlIERPTSB0cmVlLiBBbGwgc3RyaW5ncyB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG8gdGhlaXJcclxuICAgICAqIGNvcnJlc3BvbmRpbmcgc2V0cyBvZiBrZXlzLCB3aGlsZSBhbGwgb2JqZWN0cyBhbmQgYXJyYXlzIHdpbGwgYmVcclxuICAgICAqIHRyYW5zZm9ybWVkIGludG8gbmFtZWQgZ3JvdXBzIGFuZCBhbm9ueW1vdXMgZ3JvdXBzIHJlc3BlY3RpdmVseS4gQW55XHJcbiAgICAgKiBudW1iZXJzIHByZXNlbnQgd2lsbCBiZSB0cmFuc2Zvcm1lZCBpbnRvIGdhcHMgb2YgdGhhdCBzaXplLCBzY2FsZWRcclxuICAgICAqIGFjY29yZGluZyB0byB0aGUgc2FtZSB1bml0cyBhcyBlYWNoIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxheW91dCA9IHRlbXBsYXRlLmxheW91dDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgZW50aXJlIGtleWJvYXJkLCBpbiBhcmJpdHJhcnkgdW5pdHMuIFRoZSB3aWR0aCBvZiBlYWNoXHJcbiAgICAgKiBrZXkgaXMgcmVsYXRpdmUgdG8gdGhpcyB3aWR0aCwgYXMgYm90aCB3aWR0aCB2YWx1ZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW5cclxuICAgICAqIHRoZSBzYW1lIHVuaXRzLiBUaGUgY29udmVyc2lvbiBmYWN0b3IgYmV0d2VlbiB0aGVzZSB1bml0cyBhbmQgcGl4ZWxzIGlzXHJcbiAgICAgKiBkZXJpdmVkIGxhdGVyIHZpYSBhIGNhbGwgdG8gcmVzaXplKCkgb24gdGhlIEd1YWNhbW9sZS5PblNjcmVlbktleWJvYXJkLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMud2lkdGggPSB0ZW1wbGF0ZS53aWR0aDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiBlYWNoIGtleSwgaW4gYXJiaXRyYXJ5IHVuaXRzLCByZWxhdGl2ZSB0byBvdGhlciBrZXlzIGluXHJcbiAgICAgKiB0aGlzIGxheW91dC4gVGhlIHRydWUgcGl4ZWwgc2l6ZSBvZiBlYWNoIGtleSB3aWxsIGJlIGRldGVybWluZWQgYnkgdGhlXHJcbiAgICAgKiBvdmVyYWxsIHNpemUgb2YgdGhlIGtleWJvYXJkLiBJZiBub3QgZGVmaW5lZCBoZXJlLCB0aGUgd2lkdGggb2YgZWFjaFxyXG4gICAgICoga2V5IHdpbGwgZGVmYXVsdCB0byAxLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgTnVtYmVyPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5rZXlXaWR0aHMgPSB0ZW1wbGF0ZS5rZXlXaWR0aHMgfHwge307XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBzaW5nbGUga2V5LCBvciBhIHNpbmdsZSBwb3NzaWJsZSBiZWhhdmlvciBvZiBhIGtleS4gRWFjaCBrZXlcclxuICogb24gdGhlIG9uLXNjcmVlbiBrZXlib2FyZCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGFzc29jaWF0ZWRcclxuICogR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuS2V5LCB3aGV0aGVyIHRoYXQga2V5IGlzIGV4cGxpY2l0bHkgZGVmaW5lZCBvclxyXG4gKiBpbXBsaWVkLCBhbmQgbWF5IGhhdmUgbXVsdGlwbGUgR3VhY2Ftb2xlLk9uU2NyZWVuS2V5Ym9hcmQuS2V5IGlmIGJlaGF2aW9yXHJcbiAqIGRlcGVuZHMgb24gbW9kaWZpZXIgc3RhdGVzLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5LZXl8T2JqZWN0fSB0ZW1wbGF0ZVxyXG4gKiAgICAgVGhlIG9iamVjdCB3aG9zZSBpZGVudGljYWxseS1uYW1lZCBwcm9wZXJ0aWVzIHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXHJcbiAqICAgICB0aGUgcHJvcGVydGllcyBvZiB0aGlzIGtleS5cclxuICogICAgIFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdXHJcbiAqICAgICBUaGUgbmFtZSB0byB1c2UgaW5zdGVhZCBvZiBhbnkgbmFtZSBwcm92aWRlZCB3aXRoaW4gdGhlIHRlbXBsYXRlLCBpZlxyXG4gKiAgICAgYW55LiBJZiBvbWl0dGVkLCB0aGUgbmFtZSB3aXRoaW4gdGhlIHRlbXBsYXRlIHdpbGwgYmUgdXNlZCwgYXNzdW1pbmcgdGhlXHJcbiAqICAgICB0ZW1wbGF0ZSBjb250YWlucyBhIG5hbWUuXHJcbiAqL1xyXG5HdWFjYW1vbGUuT25TY3JlZW5LZXlib2FyZC5LZXkgPSBmdW5jdGlvbih0ZW1wbGF0ZSwgbmFtZSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHVuaXF1ZSBuYW1lIGlkZW50aWZ5aW5nIHRoaXMga2V5IHdpdGhpbiB0aGUga2V5Ym9hcmQgbGF5b3V0LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgdGVtcGxhdGUubmFtZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBodW1hbi1yZWFkYWJsZSB0aXRsZSB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyIHdpdGhpbiB0aGVcclxuICAgICAqIGtleS4gSWYgbm90IHByb3ZpZGVkLCB0aGlzIHdpbGwgYmUgZGVyaXZlZCBmcm9tIHRoZSBrZXkgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRpdGxlID0gdGVtcGxhdGUudGl0bGUgfHwgdGhpcy5uYW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGtleXN5bSB0byBiZSBwcmVzc2VkL3JlbGVhc2VkIHdoZW4gdGhpcyBrZXkgaXMgcHJlc3NlZC9yZWxlYXNlZC4gSWZcclxuICAgICAqIG5vdCBwcm92aWRlZCwgdGhpcyB3aWxsIGJlIGRlcml2ZWQgZnJvbSB0aGUgdGl0bGUgaWYgdGhlIHRpdGxlIGlzIGFcclxuICAgICAqIHNpbmdsZSBjaGFyYWN0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5rZXlzeW0gPSB0ZW1wbGF0ZS5rZXlzeW0gfHwgKGZ1bmN0aW9uIGRlcml2ZUtleXN5bSh0aXRsZSkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3QgZGVyaXZlIGtleXN5bSBpZiB0aXRsZSBpcyBub3QgZXhhY3RseSBvbmUgY2hhcmFjdGVyXHJcbiAgICAgICAgaWYgKCF0aXRsZSB8fCB0aXRsZS5sZW5ndGggIT09IDEpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAvLyBGb3IgY2hhcmFjdGVycyBiZXR3ZWVuIFUrMDAwMCBhbmQgVSswMEZGLCB0aGUga2V5c3ltIGlzIHRoZSBjb2RlcG9pbnRcclxuICAgICAgICB2YXIgY2hhckNvZGUgPSB0aXRsZS5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSAweDAwMDAgJiYgY2hhckNvZGUgPD0gMHgwMEZGKVxyXG4gICAgICAgICAgICByZXR1cm4gY2hhckNvZGU7XHJcblxyXG4gICAgICAgIC8vIEZvciBjaGFyYWN0ZXJzIGJldHdlZW4gVSswMTAwIGFuZCBVKzEwRkZGRiwgdGhlIGtleXN5bSBpcyB0aGUgY29kZXBvaW50IG9yJ2Qgd2l0aCAweDAxMDAwMDAwXHJcbiAgICAgICAgaWYgKGNoYXJDb2RlID49IDB4MDEwMCAmJiBjaGFyQ29kZSA8PSAweDEwRkZGRilcclxuICAgICAgICAgICAgcmV0dXJuIDB4MDEwMDAwMDAgfCBjaGFyQ29kZTtcclxuXHJcbiAgICAgICAgLy8gVW5hYmxlIHRvIGRlcml2ZSBrZXlzeW1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9KSh0aGlzLnRpdGxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBtb2RpZmllciBzZXQgd2hlbiB0aGUga2V5IGlzIHByZXNzZWQgYW5kIGNsZWFyZWQgd2hlblxyXG4gICAgICogdGhpcyBrZXkgaXMgcmVsZWFzZWQsIGlmIGFueS4gVGhlIG5hbWVzIG9mIG1vZGlmaWVycyBhcmUgZGlzdGluY3QgZnJvbVxyXG4gICAgICogdGhlIG5hbWVzIG9mIGtleXM7IGJvdGggdGhlIFwiUmlnaHRTaGlmdFwiIGFuZCBcIkxlZnRTaGlmdFwiIGtleXMgbWF5IHNldFxyXG4gICAgICogdGhlIFwic2hpZnRcIiBtb2RpZmllciwgZm9yIGV4YW1wbGUuIEJ5IGRlZmF1bHQsIHRoZSBrZXkgd2lsbCBhZmZlY3Qgbm9cclxuICAgICAqIG1vZGlmaWVycy5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5tb2RpZmllciA9IHRlbXBsYXRlLm1vZGlmaWVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgZWFjaCBtb2RpZmllciByZXF1aXJlZCBmb3IgdGhpcyBrZXkgdG9cclxuICAgICAqIGhhdmUgYW4gZWZmZWN0LiBGb3IgZXhhbXBsZSwgYSBsb3dlcmNhc2UgbGV0dGVyIG1heSByZXF1aXJlIG5vdGhpbmcsXHJcbiAgICAgKiB3aGlsZSBhbiB1cHBlcmNhc2UgbGV0dGVyIHdvdWxkIHJlcXVpcmUgXCJzaGlmdFwiLCBhc3N1bWluZyB0aGUgU2hpZnQga2V5XHJcbiAgICAgKiBpcyBuYW1lZCBcInNoaWZ0XCIgd2l0aGluIHRoZSBsYXlvdXQuIEJ5IGRlZmF1bHQsIHRoZSBrZXkgd2lsbCByZXF1aXJlXHJcbiAgICAgKiBubyBtb2RpZmllcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1N0cmluZ1tdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlcXVpcmVzID0gdGVtcGxhdGUucmVxdWlyZXMgfHwgW107XHJcblxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQWJzdHJhY3Qgc3RyZWFtIHdoaWNoIGNhbiByZWNlaXZlIGRhdGEuXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuQ2xpZW50fSBjbGllbnQgVGhlIGNsaWVudCBvd25pbmcgdGhpcyBzdHJlYW0uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhpcyBzdHJlYW0uXHJcbiAqL1xyXG5HdWFjYW1vbGUuT3V0cHV0U3RyZWFtID0gZnVuY3Rpb24oY2xpZW50LCBpbmRleCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgc3RyZWFtLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNfc3RyZWFtID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGlzIHN0cmVhbS5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIGFuIGFja25vd2xlZGdlbWVudCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIsIGluZGljYXRpbmdcclxuICAgICAqIHRoYXQgYSBzdHJlYW0gb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQsIG9yIGFuIGVycm9yIGhhcyBvY2N1cnJlZC5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5TdGF0dXN9IHN0YXR1cyBUaGUgc3RhdHVzIG9mIHRoZSBvcGVyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25hY2sgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIHRoZSBnaXZlbiBiYXNlNjQtZW5jb2RlZCBkYXRhIHRvIHRoaXMgc3RyZWFtIGFzIGEgYmxvYi5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgVGhlIGJhc2U2NC1lbmNvZGVkIGRhdGEgdG8gc2VuZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5kQmxvYiA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICBjbGllbnQuc2VuZEJsb2IoZ3VhY19zdHJlYW0uaW5kZXgsIGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyB0aGlzIHN0cmVhbS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5kRW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2xpZW50LmVuZFN0cmVhbShndWFjX3N0cmVhbS5pbmRleCk7XHJcbiAgICB9O1xyXG5cclxufTtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIFNpbXBsZSBHdWFjYW1vbGUgcHJvdG9jb2wgcGFyc2VyIHRoYXQgaW52b2tlcyBhbiBvbmluc3RydWN0aW9uIGV2ZW50IHdoZW5cclxuICogZnVsbCBpbnN0cnVjdGlvbnMgYXJlIGF2YWlsYWJsZSBmcm9tIGRhdGEgcmVjZWl2ZWQgdmlhIHJlY2VpdmUoKS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuR3VhY2Ftb2xlLlBhcnNlciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgcGFyc2VyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHBhcnNlciA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBvZiByZWNlaXZlZCBkYXRhLiBUaGlzIGJ1ZmZlciBncm93cyB1bnRpbCBhIGZ1bGxcclxuICAgICAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLiBBZnRlciBhIGZ1bGwgZWxlbWVudCBpcyBhdmFpbGFibGUsIHRoYXQgZWxlbWVudFxyXG4gICAgICogaXMgZmx1c2hlZCBpbnRvIHRoZSBlbGVtZW50IGJ1ZmZlci5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGJ1ZmZlciA9IFwiXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWZmZXIgb2YgYWxsIHJlY2VpdmVkLCBjb21wbGV0ZSBlbGVtZW50cy4gQWZ0ZXIgYW4gZW50aXJlIGluc3RydWN0aW9uXHJcbiAgICAgKiBpcyByZWFkLCB0aGlzIGJ1ZmZlciBpcyBmbHVzaGVkLCBhbmQgYSBuZXcgaW5zdHJ1Y3Rpb24gYmVnaW5zLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZWxlbWVudF9idWZmZXIgPSBbXTtcclxuXHJcbiAgICAvLyBUaGUgbG9jYXRpb24gb2YgdGhlIGxhc3QgZWxlbWVudCdzIHRlcm1pbmF0b3JcclxuICAgIHZhciBlbGVtZW50X2VuZCA9IC0xO1xyXG5cclxuICAgIC8vIFdoZXJlIHRvIHN0YXJ0IHRoZSBuZXh0IGxlbmd0aCBzZWFyY2ggb3IgdGhlIG5leHQgZWxlbWVudFxyXG4gICAgdmFyIHN0YXJ0X2luZGV4ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgdGhlIGdpdmVuIGluc3RydWN0aW9uIGRhdGEgcGFja2V0IHRvIHRoZSBpbnRlcm5hbCBidWZmZXIgb2ZcclxuICAgICAqIHRoaXMgR3VhY2Ftb2xlLlBhcnNlciwgZXhlY3V0aW5nIGFsbCBjb21wbGV0ZWQgaW5zdHJ1Y3Rpb25zIGF0XHJcbiAgICAgKiB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgYnVmZmVyLCBpZiBhbnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCBUaGUgaW5zdHJ1Y3Rpb24gZGF0YSB0byByZWNlaXZlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlY2VpdmUgPSBmdW5jdGlvbihwYWNrZXQpIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGUgYnVmZmVyIGFzIG5lY2Vzc2FyeVxyXG4gICAgICAgIGlmIChzdGFydF9pbmRleCA+IDQwOTYgJiYgZWxlbWVudF9lbmQgPj0gc3RhcnRfaW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHJpbmcoc3RhcnRfaW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzZXQgcGFyc2UgcmVsYXRpdmUgdG8gdHJ1bmNhdGlvblxyXG4gICAgICAgICAgICBlbGVtZW50X2VuZCAtPSBzdGFydF9pbmRleDtcclxuICAgICAgICAgICAgc3RhcnRfaW5kZXggPSAwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBkYXRhIHRvIGJ1ZmZlclxyXG4gICAgICAgIGJ1ZmZlciArPSBwYWNrZXQ7XHJcblxyXG4gICAgICAgIC8vIFdoaWxlIHNlYXJjaCBpcyB3aXRoaW4gY3VycmVudGx5IHJlY2VpdmVkIGRhdGFcclxuICAgICAgICB3aGlsZSAoZWxlbWVudF9lbmQgPCBidWZmZXIubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgd2FpdGluZyBmb3IgZWxlbWVudCBkYXRhXHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50X2VuZCA+PSBzdGFydF9pbmRleCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIG5vdyBoYXZlIGVub3VnaCBkYXRhIGZvciB0aGUgZWxlbWVudC4gUGFyc2UuXHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGJ1ZmZlci5zdWJzdHJpbmcoc3RhcnRfaW5kZXgsIGVsZW1lbnRfZW5kKTtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hdG9yID0gYnVmZmVyLnN1YnN0cmluZyhlbGVtZW50X2VuZCwgZWxlbWVudF9lbmQrMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGVsZW1lbnQgdG8gYXJyYXlcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRfYnVmZmVyLnB1c2goZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbGFzdCBlbGVtZW50LCBoYW5kbGUgaW5zdHJ1Y3Rpb25cclxuICAgICAgICAgICAgICAgIGlmICh0ZXJtaW5hdG9yID09IFwiO1wiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBvcGNvZGVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3Bjb2RlID0gZWxlbWVudF9idWZmZXIuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBpbnN0cnVjdGlvbiBoYW5kbGVyLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIub25pbnN0cnVjdGlvbiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIub25pbnN0cnVjdGlvbihvcGNvZGUsIGVsZW1lbnRfYnVmZmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50X2J1ZmZlci5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRlcm1pbmF0b3IgIT0gJywnKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgdGVybWluYXRvci5cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgc2VhcmNoaW5nIGZvciBsZW5ndGggYXQgY2hhcmFjdGVyIGFmdGVyXHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHRlcm1pbmF0b3JcclxuICAgICAgICAgICAgICAgIHN0YXJ0X2luZGV4ID0gZWxlbWVudF9lbmQgKyAxO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBlbmQgb2YgbGVuZ3RoXHJcbiAgICAgICAgICAgIHZhciBsZW5ndGhfZW5kID0gYnVmZmVyLmluZGV4T2YoXCIuXCIsIHN0YXJ0X2luZGV4KTtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aF9lbmQgIT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBsZW5ndGhcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJzZUludChidWZmZXIuc3Vic3RyaW5nKGVsZW1lbnRfZW5kKzEsIGxlbmd0aF9lbmQpKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihsZW5ndGgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi1udW1lcmljIGNoYXJhY3RlciBpbiBlbGVtZW50IGxlbmd0aC5cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHN0YXJ0IG9mIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIHN0YXJ0X2luZGV4ID0gbGVuZ3RoX2VuZCArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGxvY2F0aW9uIG9mIGVsZW1lbnQgdGVybWluYXRvclxyXG4gICAgICAgICAgICAgICAgZWxlbWVudF9lbmQgPSBzdGFydF9pbmRleCArIGxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIElmIG5vIHBlcmlvZCB5ZXQsIGNvbnRpbnVlIHNlYXJjaCB3aGVuIG1vcmUgZGF0YVxyXG4gICAgICAgICAgICAvLyBpcyByZWNlaXZlZFxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0X2luZGV4ID0gYnVmZmVyLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gLy8gZW5kIHBhcnNlIGxvb3BcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgb25jZSBmb3IgZXZlcnkgY29tcGxldGUgR3VhY2Ftb2xlIGluc3RydWN0aW9uIHJlY2VpdmVkLCBpbiBvcmRlci5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3Bjb2RlIFRoZSBHdWFjYW1vbGUgaW5zdHJ1Y3Rpb24gb3Bjb2RlLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1ldGVycyBUaGUgcGFyYW1ldGVycyBwcm92aWRlZCBmb3IgdGhlIGluc3RydWN0aW9uLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBhbnkuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25pbnN0cnVjdGlvbiA9IG51bGw7XHJcblxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQSBkZXNjcmlwdGlvbiBvZiB0aGUgZm9ybWF0IG9mIHJhdyBQQ00gYXVkaW8sIHN1Y2ggYXMgdGhhdCB1c2VkIGJ5XHJcbiAqIEd1YWNhbW9sZS5SYXdBdWRpb1BsYXllciBhbmQgR3VhY2Ftb2xlLlJhd0F1ZGlvUmVjb3JkZXIuIFRoaXMgb2JqZWN0XHJcbiAqIGRlc2NyaWJlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHBlciBzYW1wbGUsIHRoZSBudW1iZXIgb2YgY2hhbm5lbHMsIGFuZCB0aGVcclxuICogb3ZlcmFsbCBzYW1wbGUgcmF0ZS5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLlJhd0F1ZGlvRm9ybWF0fE9iamVjdH0gdGVtcGxhdGVcclxuICogICAgIFRoZSBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBzaG91bGQgYmUgY29waWVkIGludG8gdGhlIGNvcnJlc3BvbmRpbmdcclxuICogICAgIHByb3BlcnRpZXMgb2YgdGhlIG5ldyBHdWFjYW1vbGUuUmF3QXVkaW9Gb3JtYXQuXHJcbiAqL1xyXG5HdWFjYW1vbGUuUmF3QXVkaW9Gb3JtYXQgPSBmdW5jdGlvbiBSYXdBdWRpb0Zvcm1hdCh0ZW1wbGF0ZSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBieXRlcyBpbiBlYWNoIHNhbXBsZSBvZiBhdWRpbyBkYXRhLiBUaGlzIHZhbHVlIGlzXHJcbiAgICAgKiBpbmRlcGVuZGVudCBvZiB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYnl0ZXNQZXJTYW1wbGUgPSB0ZW1wbGF0ZS5ieXRlc1BlclNhbXBsZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgYXVkaW8gY2hhbm5lbHMgKGllOiAxIGZvciBtb25vLCAyIGZvciBzdGVyZW8pLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2hhbm5lbHMgPSB0ZW1wbGF0ZS5jaGFubmVscztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgc2Vjb25kLCBwZXIgY2hhbm5lbC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJhdGUgPSB0ZW1wbGF0ZS5yYXRlO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIGdpdmVuIG1pbWV0eXBlLCByZXR1cm5pbmcgYSBuZXcgR3VhY2Ftb2xlLlJhd0F1ZGlvRm9ybWF0XHJcbiAqIHdoaWNoIGRlc2NyaWJlcyB0aGUgdHlwZSBvZiByYXcgYXVkaW8gZGF0YSByZXByZXNlbnRlZCBieSB0aGF0IG1pbWV0eXBlLiBJZlxyXG4gKiB0aGUgbWltZXR5cGUgaXMgbm90IGEgc3VwcG9ydGVkIHJhdyBhdWRpbyBkYXRhIG1pbWV0eXBlLCBudWxsIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICogICAgIFRoZSBhdWRpbyBtaW1ldHlwZSB0byBwYXJzZS5cclxuICpcclxuICogQHJldHVybnMge0d1YWNhbW9sZS5SYXdBdWRpb0Zvcm1hdH1cclxuICogICAgIEEgbmV3IEd1YWNhbW9sZS5SYXdBdWRpb0Zvcm1hdCB3aGljaCBkZXNjcmliZXMgdGhlIHR5cGUgb2YgcmF3XHJcbiAqICAgICBhdWRpbyBkYXRhIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBtaW1ldHlwZSwgb3IgbnVsbCBpZiB0aGUgZ2l2ZW5cclxuICogICAgIG1pbWV0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAqL1xyXG5HdWFjYW1vbGUuUmF3QXVkaW9Gb3JtYXQucGFyc2UgPSBmdW5jdGlvbiBwYXJzZUZvcm1hdChtaW1ldHlwZSkge1xyXG5cclxuICAgIHZhciBieXRlc1BlclNhbXBsZTtcclxuXHJcbiAgICAvLyBSYXRlIGlzIGFic29sdXRlbHkgcmVxdWlyZWQgLSBpZiBudWxsIGlzIHN0aWxsIHByZXNlbnQgbGF0ZXIsIHRoZVxyXG4gICAgLy8gbWltZXR5cGUgbXVzdCBub3QgYmUgc3VwcG9ydGVkXHJcbiAgICB2YXIgcmF0ZSA9IG51bGw7XHJcblxyXG4gICAgLy8gRGVmYXVsdCBmb3IgYm90aCBcImF1ZGlvL0w4XCIgYW5kIFwiYXVkaW8vTDE2XCIgaXMgb25lIGNoYW5uZWxcclxuICAgIHZhciBjaGFubmVscyA9IDE7XHJcblxyXG4gICAgLy8gXCJhdWRpby9MOFwiIGhhcyBvbmUgYnl0ZSBwZXIgc2FtcGxlXHJcbiAgICBpZiAobWltZXR5cGUuc3Vic3RyaW5nKDAsIDkpID09PSAnYXVkaW8vTDg7Jykge1xyXG4gICAgICAgIG1pbWV0eXBlID0gbWltZXR5cGUuc3Vic3RyaW5nKDkpO1xyXG4gICAgICAgIGJ5dGVzUGVyU2FtcGxlID0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBcImF1ZGlvL0wxNlwiIGhhcyB0d28gYnl0ZXMgcGVyIHNhbXBsZVxyXG4gICAgZWxzZSBpZiAobWltZXR5cGUuc3Vic3RyaW5nKDAsIDEwKSA9PT0gJ2F1ZGlvL0wxNjsnKSB7XHJcbiAgICAgICAgbWltZXR5cGUgPSBtaW1ldHlwZS5zdWJzdHJpbmcoMTApO1xyXG4gICAgICAgIGJ5dGVzUGVyU2FtcGxlID0gMjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbGwgb3RoZXIgdHlwZXMgYXJlIHVuc3VwcG9ydGVkXHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgLy8gUGFyc2UgYWxsIHBhcmFtZXRlcnNcclxuICAgIHZhciBwYXJhbWV0ZXJzID0gbWltZXR5cGUuc3BsaXQoJywnKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICB2YXIgcGFyYW1ldGVyID0gcGFyYW1ldGVyc1tpXTtcclxuXHJcbiAgICAgICAgLy8gQWxsIHBhcmFtZXRlcnMgbXVzdCBoYXZlIGFuIGVxdWFscyBzaWduIHNlcGFyYXRpbmcgbmFtZSBmcm9tIHZhbHVlXHJcbiAgICAgICAgdmFyIGVxdWFscyA9IHBhcmFtZXRlci5pbmRleE9mKCc9Jyk7XHJcbiAgICAgICAgaWYgKGVxdWFscyA9PT0gLTEpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAvLyBQYXJzZSBuYW1lIGFuZCB2YWx1ZSBmcm9tIHBhcmFtZXRlciBzdHJpbmdcclxuICAgICAgICB2YXIgbmFtZSAgPSBwYXJhbWV0ZXIuc3Vic3RyaW5nKDAsIGVxdWFscyk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1ldGVyLnN1YnN0cmluZyhlcXVhbHMrMSk7XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBlYWNoIHN1cHBvcnRlZCBwYXJhbWV0ZXJcclxuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE51bWJlciBvZiBhdWRpbyBjaGFubmVsc1xyXG4gICAgICAgICAgICBjYXNlICdjaGFubmVscyc6XHJcbiAgICAgICAgICAgICAgICBjaGFubmVscyA9IHBhcnNlSW50KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy8gU2FtcGxlIHJhdGVcclxuICAgICAgICAgICAgY2FzZSAncmF0ZSc6XHJcbiAgICAgICAgICAgICAgICByYXRlID0gcGFyc2VJbnQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGwgb3RoZXIgcGFyYW1ldGVycyBhcmUgdW5zdXBwb3J0ZWRcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUaGUgcmF0ZSBwYXJhbWV0ZXIgaXMgcmVxdWlyZWRcclxuICAgIGlmIChyYXRlID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIC8vIFJldHVybiBwYXJzZWQgZm9ybWF0IGRldGFpbHNcclxuICAgIHJldHVybiBuZXcgR3VhY2Ftb2xlLlJhd0F1ZGlvRm9ybWF0KHtcclxuICAgICAgICBieXRlc1BlclNhbXBsZSA6IGJ5dGVzUGVyU2FtcGxlLFxyXG4gICAgICAgIGNoYW5uZWxzICAgICAgIDogY2hhbm5lbHMsXHJcbiAgICAgICAgcmF0ZSAgICAgICAgICAgOiByYXRlXHJcbiAgICB9KTtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIHJlY29yZGluZyBvZiBhIEd1YWNhbW9sZSBzZXNzaW9uLiBHaXZlbiBhIHtAbGluayBHdWFjYW1vbGUuVHVubmVsfSwgdGhlXHJcbiAqIEd1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBpbmNvbWluZyBHdWFjYW1vbGVcclxuICogaW5zdHJ1Y3Rpb25zLCBzdG9yaW5nIHRoZW0gZm9yIHBsYXliYWNrLiBQbGF5YmFjayBvZiB0aGUgcmVjb3JkaW5nIG1heSBiZVxyXG4gKiBjb250cm9sbGVkIHRocm91Z2ggZnVuY3Rpb24gY2FsbHMgdG8gdGhlIEd1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLCBldmVuXHJcbiAqIHdoaWxlIHRoZSByZWNvcmRpbmcgaGFzIG5vdCB5ZXQgZmluaXNoZWQgYmVpbmcgY3JlYXRlZCBvciBkb3dubG9hZGVkLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuVHVubmVsfSB0dW5uZWxcclxuICogICAgIFRoZSBHdWFjYW1vbGUuVHVubmVsIGZyb20gd2hpY2ggdGhlIGluc3RydWN0aW9ucyBvZiB0aGUgcmVjb3JkaW5nIHNob3VsZFxyXG4gKiAgICAgYmUgcmVhZC5cclxuICovXHJcbkd1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nID0gZnVuY3Rpb24gU2Vzc2lvblJlY29yZGluZyh0dW5uZWwpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIEd1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmd9XHJcbiAgICAgKi9cclxuICAgIHZhciByZWNvcmRpbmcgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgd2hpY2ggbXVzdCBoYXZlIGJlZW4gcmVhZCBiZXR3ZWVuXHJcbiAgICAgKiBrZXlmcmFtZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIEtFWUZSQU1FX0NIQVJfSU5URVJWQUwgPSAxNjM4NDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtaW5pbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgd2hpY2ggbXVzdCBlbGFwc2UgYmV0d2VlbiBrZXlmcmFtZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIEtFWUZSQU1FX1RJTUVfSU5URVJWQUwgPSA1MDAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gc3BlbmQgaW4gYW55IHBhcnRpY3VsYXIgc2VlayBvcGVyYXRpb25cclxuICAgICAqIGJlZm9yZSByZXR1cm5pbmcgY29udHJvbCB0byB0aGUgbWFpbiB0aHJlYWQsIGluIG1pbGxpc2Vjb25kcy4gU2Vla1xyXG4gICAgICogb3BlcmF0aW9ucyBleGNlZWRpbmcgdGhpcyBhbW91bnQgb2YgdGltZSB3aWxsIHByb2NlZWQgYXN5bmNocm9ub3VzbHkuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIE1BWElNVU1fU0VFS19USU1FID0gNTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBmcmFtZXMgcGFyc2VkIGZyb20gdGhlIHByb3ZpZGVkIHR1bm5lbC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLl9GcmFtZVtdfVxyXG4gICAgICovXHJcbiAgICB2YXIgZnJhbWVzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgaW5zdHJ1Y3Rpb25zIHdoaWNoIGhhdmUgYmVlbiByZWFkIHNpbmNlIHRoZSBsYXN0IGZyYW1lIHdhcyBhZGRlZCB0b1xyXG4gICAgICogdGhlIGZyYW1lcyBhcnJheS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLl9GcmFtZS5JbnN0cnVjdGlvbltdfVxyXG4gICAgICovXHJcbiAgICB2YXIgaW5zdHJ1Y3Rpb25zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXBwcm94aW1hdGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgd2hpY2ggaGF2ZSBiZWVuIHJlYWQgZnJvbSB0aGVcclxuICAgICAqIHByb3ZpZGVkIHR1bm5lbCBzaW5jZSB0aGUgbGFzdCBmcmFtZSB3YXMgZmxhZ2dlZCBmb3IgdXNlIGFzIGEga2V5ZnJhbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBjaGFyYWN0ZXJzU2luY2VMYXN0S2V5ZnJhbWUgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRpbWVzdGFtcCBvZiB0aGUgbGFzdCBmcmFtZSB3aGljaCB3YXMgZmxhZ2dlZCBmb3IgdXNlIGFzIGEga2V5ZnJhbWUuXHJcbiAgICAgKiBJZiBubyB0aW1lc3RhbXAgaGFzIHlldCBiZWVuIGZsYWdnZWQsIHRoaXMgd2lsbCBiZSAwLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgbGFzdEtleWZyYW1lVGltZXN0YW1wID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFR1bm5lbCB3aGljaCBmZWVkcyBhcmJpdHJhcnkgaW5zdHJ1Y3Rpb25zIHRvIHRoZSBjbGllbnQgdXNlZCBieSB0aGlzXHJcbiAgICAgKiBHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZyBmb3IgcGxheWJhY2sgb2YgdGhlIHNlc3Npb24gcmVjb3JkaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcuX1BsYXliYWNrVHVubmVsfVxyXG4gICAgICovXHJcbiAgICB2YXIgcGxheWJhY2tUdW5uZWwgPSBuZXcgR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcuX1BsYXliYWNrVHVubmVsKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHdWFjYW1vbGUuQ2xpZW50IGluc3RhbmNlIHVzZWQgZm9yIHZpc2libGUgcGxheWJhY2sgb2YgdGhlIHNlc3Npb25cclxuICAgICAqIHJlY29yZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5DbGllbnR9XHJcbiAgICAgKi9cclxuICAgIHZhciBwbGF5YmFja0NsaWVudCA9IG5ldyBHdWFjYW1vbGUuQ2xpZW50KHBsYXliYWNrVHVubmVsKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IGZyYW1lIHJlbmRlcmVkIHdpdGhpbiB0aGUgcGxheWJhY2sgY2xpZW50LiBJZiBubyBmcmFtZSBpc1xyXG4gICAgICogeWV0IHJlbmRlcmVkLCB0aGlzIHdpbGwgYmUgLTEuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBjdXJyZW50RnJhbWUgPSAtMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lIHdoZW4gcGxheWJhY2sgYmVnYW4sIGluIG1pbGxpc2Vjb25kcy4gSWZcclxuICAgICAqIHBsYXliYWNrIGlzIG5vdCBpbiBwcm9ncmVzcywgdGhpcyB3aWxsIGJlIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBzdGFydFZpZGVvVGltZXN0YW1wID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZWFsLXdvcmxkIHRpbWVzdGFtcCB3aGVuIHBsYXliYWNrIGJlZ2FuLCBpbiBtaWxsaXNlY29uZHMuIElmXHJcbiAgICAgKiBwbGF5YmFjayBpcyBub3QgaW4gcHJvZ3Jlc3MsIHRoaXMgd2lsbCBiZSBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgc3RhcnRSZWFsVGltZXN0YW1wID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBJRCBvZiB0aGUgdGltZW91dCB3aGljaCB3aWxsIGNvbnRpbnVlIHRoZSBpbi1wcm9ncmVzcyBzZWVrXHJcbiAgICAgKiBvcGVyYXRpb24uIElmIG5vIHNlZWsgb3BlcmF0aW9uIGlzIGluIHByb2dyZXNzLCB0aGUgSUQgc3RvcmVkIGhlcmUgKGlmXHJcbiAgICAgKiBhbnkpIHdpbGwgbm90IGJlIHZhbGlkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgc2Vla1RpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8vIFN0YXJ0IHBsYXliYWNrIGNsaWVudCBjb25uZWN0ZWRcclxuICAgIHBsYXliYWNrQ2xpZW50LmNvbm5lY3QoKTtcclxuXHJcbiAgICAvLyBIaWRlIGN1cnNvciB1bmxlc3MgbW91c2UgcG9zaXRpb24gaXMgcmVjZWl2ZWRcclxuICAgIHBsYXliYWNrQ2xpZW50LmdldERpc3BsYXkoKS5zaG93Q3Vyc29yKGZhbHNlKTtcclxuXHJcbiAgICAvLyBSZWFkIGluc3RydWN0aW9ucyBmcm9tIHByb3ZpZGVkIHR1bm5lbCwgZXh0cmFjdGluZyBlYWNoIGZyYW1lXHJcbiAgICB0dW5uZWwub25pbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIGhhbmRsZUluc3RydWN0aW9uKG9wY29kZSwgYXJncykge1xyXG5cclxuICAgICAgICAvLyBTdG9yZSBvcGNvZGUgYW5kIGFyZ3VtZW50cyBmb3IgcmVjZWl2ZWQgaW5zdHJ1Y3Rpb25cclxuICAgICAgICB2YXIgaW5zdHJ1Y3Rpb24gPSBuZXcgR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcuX0ZyYW1lLkluc3RydWN0aW9uKG9wY29kZSwgYXJncy5zbGljZSgpKTtcclxuICAgICAgICBpbnN0cnVjdGlvbnMucHVzaChpbnN0cnVjdGlvbik7XHJcbiAgICAgICAgY2hhcmFjdGVyc1NpbmNlTGFzdEtleWZyYW1lICs9IGluc3RydWN0aW9uLmdldFNpemUoKTtcclxuXHJcbiAgICAgICAgLy8gT25jZSBhIHN5bmMgaXMgcmVjZWl2ZWQsIHN0b3JlIGFsbCBpbnN0cnVjdGlvbnMgc2luY2UgdGhlIGxhc3RcclxuICAgICAgICAvLyBmcmFtZSBhcyBhIG5ldyBmcmFtZVxyXG4gICAgICAgIGlmIChvcGNvZGUgPT09ICdzeW5jJykge1xyXG5cclxuICAgICAgICAgICAgLy8gUGFyc2UgZnJhbWUgdGltZXN0YW1wIGZyb20gc3luYyBpbnN0cnVjdGlvblxyXG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gcGFyc2VJbnQoYXJnc1swXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgYSBuZXcgZnJhbWUgY29udGFpbmluZyB0aGUgaW5zdHJ1Y3Rpb25zIHJlYWQgc2luY2UgbGFzdCBmcmFtZVxyXG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBuZXcgR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcuX0ZyYW1lKHRpbWVzdGFtcCwgaW5zdHJ1Y3Rpb25zKTtcclxuICAgICAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhpcyBmcmFtZSBzaG91bGQgZXZlbnR1YWxseSBiZWNvbWUgYSBrZXlmcmFtZSBpZiBlbm91Z2ggZGF0YVxyXG4gICAgICAgICAgICAvLyBoYXMgYmVlbiBwcm9jZXNzZWQgYW5kIGVub3VnaCByZWNvcmRpbmcgdGltZSBoYXMgZWxhcHNlZCwgb3IgaWZcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgYWJzb2x1dGUgZmlyc3QgZnJhbWVcclxuICAgICAgICAgICAgaWYgKGZyYW1lcy5sZW5ndGggPT09IDEgfHwgKGNoYXJhY3RlcnNTaW5jZUxhc3RLZXlmcmFtZSA+PSBLRVlGUkFNRV9DSEFSX0lOVEVSVkFMXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgdGltZXN0YW1wIC0gbGFzdEtleWZyYW1lVGltZXN0YW1wID49IEtFWUZSQU1FX1RJTUVfSU5URVJWQUwpKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZS5rZXlmcmFtZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBsYXN0S2V5ZnJhbWVUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJzU2luY2VMYXN0S2V5ZnJhbWUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDbGVhciBzZXQgb2YgaW5zdHJ1Y3Rpb25zIGluIHByZXBhcmF0aW9uIGZvciBuZXh0IGZyYW1lXHJcbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gTm90aWZ5IHRoYXQgYWRkaXRpb25hbCBjb250ZW50IGlzIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICBpZiAocmVjb3JkaW5nLm9ucHJvZ3Jlc3MpXHJcbiAgICAgICAgICAgICAgICByZWNvcmRpbmcub25wcm9ncmVzcyhyZWNvcmRpbmcuZ2V0RHVyYXRpb24oKSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGdpdmVuIGFic29sdXRlIHRpbWVzdGFtcCB0byBhIHRpbWVzdGFtcCB3aGljaCBpcyByZWxhdGl2ZVxyXG4gICAgICogdG8gdGhlIGZpcnN0IGZyYW1lIGluIHRoZSByZWNvcmRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lc3RhbXBcclxuICAgICAqICAgICBUaGUgdGltZXN0YW1wIHRvIGNvbnZlcnQgdG8gYSByZWxhdGl2ZSB0aW1lc3RhbXAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqICAgICBUaGUgZGlmZmVyZW5jZSBpbiBtaWxsaXNlY29uZHMgYmV0d2VlbiB0aGUgZ2l2ZW4gdGltZXN0YW1wIGFuZCB0aGVcclxuICAgICAqICAgICBmaXJzdCBmcmFtZSBvZiB0aGUgcmVjb3JkaW5nLCBvciB6ZXJvIGlmIG5vIGZyYW1lcyB5ZXQgZXhpc3QuXHJcbiAgICAgKi9cclxuICAgIHZhciB0b1JlbGF0aXZlVGltZXN0YW1wID0gZnVuY3Rpb24gdG9SZWxhdGl2ZVRpbWVzdGFtcCh0aW1lc3RhbXApIHtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gZnJhbWVzIHlldCBleGlzdCwgYWxsIHRpbWVzdGFtcHMgYXJlIHplcm9cclxuICAgICAgICBpZiAoZnJhbWVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aW1lc3RhbXAgcmVsYXRpdmUgdG8gZmlyc3QgZnJhbWVcclxuICAgICAgICByZXR1cm4gdGltZXN0YW1wIC0gZnJhbWVzWzBdLnRpbWVzdGFtcDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VhcmNoZXMgdGhyb3VnaCB0aGUgZ2l2ZW4gcmVnaW9uIG9mIGZyYW1lcyBmb3IgdGhlIGZyYW1lIGhhdmluZyBhXHJcbiAgICAgKiByZWxhdGl2ZSB0aW1lc3RhbXAgY2xvc2VzdCB0byB0aGUgdGltZXN0YW1wIGdpdmVuLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluSW5kZXhcclxuICAgICAqICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGZyYW1lIGluIHRoZSByZWdpb24gKHRoZSBmcmFtZSBoYXZpbmcgdGhlXHJcbiAgICAgKiAgICAgc21hbGxlc3QgdGltZXN0YW1wKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4SW5kZXhcclxuICAgICAqICAgICBUaGUgaW5kZXggb2YgdGhlIGxhc3QgZnJhbWUgaW4gdGhlIHJlZ2lvbiAodGhlIGZyYW1lIGhhdmluZyB0aGVcclxuICAgICAqICAgICBsYXJnZXN0IHRpbWVzdGFtcCkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVzdGFtcFxyXG4gICAgICogICAgIFRoZSByZWxhdGl2ZSB0aW1lc3RhbXAgdG8gc2VhcmNoIGZvciwgd2hlcmUgemVybyBkZW5vdGVzIHRoZSBmaXJzdFxyXG4gICAgICogICAgIGZyYW1lIGluIHRoZSByZWNvcmRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqICAgICBUaGUgaW5kZXggb2YgdGhlIGZyYW1lIGhhdmluZyBhIHJlbGF0aXZlIHRpbWVzdGFtcCBjbG9zZXN0IHRvIHRoZVxyXG4gICAgICogICAgIGdpdmVuIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICB2YXIgZmluZEZyYW1lID0gZnVuY3Rpb24gZmluZEZyYW1lKG1pbkluZGV4LCBtYXhJbmRleCwgdGltZXN0YW1wKSB7XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBzZWFyY2ggaWYgdGhlIHJlZ2lvbiBjb250YWlucyBvbmx5IG9uZSBlbGVtZW50XHJcbiAgICAgICAgaWYgKG1pbkluZGV4ID09PSBtYXhJbmRleClcclxuICAgICAgICAgICAgcmV0dXJuIG1pbkluZGV4O1xyXG5cclxuICAgICAgICAvLyBTcGxpdCBzZWFyY2ggcmVnaW9uIGludG8gdHdvIGhhbHZlc1xyXG4gICAgICAgIHZhciBtaWRJbmRleCA9IE1hdGguZmxvb3IoKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMik7XHJcbiAgICAgICAgdmFyIG1pZFRpbWVzdGFtcCA9IHRvUmVsYXRpdmVUaW1lc3RhbXAoZnJhbWVzW21pZEluZGV4XS50aW1lc3RhbXApO1xyXG5cclxuICAgICAgICAvLyBJZiB0aW1lc3RhbXAgaXMgd2l0aGluIGxlc3NlciBoYWxmLCBzZWFyY2ggYWdhaW4gd2l0aGluIHRoYXQgaGFsZlxyXG4gICAgICAgIGlmICh0aW1lc3RhbXAgPCBtaWRUaW1lc3RhbXAgJiYgbWlkSW5kZXggPiBtaW5JbmRleClcclxuICAgICAgICAgICAgcmV0dXJuIGZpbmRGcmFtZShtaW5JbmRleCwgbWlkSW5kZXggLSAxLCB0aW1lc3RhbXApO1xyXG5cclxuICAgICAgICAvLyBJZiB0aW1lc3RhbXAgaXMgd2l0aGluIGdyZWF0ZXIgaGFsZiwgc2VhcmNoIGFnYWluIHdpdGhpbiB0aGF0IGhhbGZcclxuICAgICAgICBpZiAodGltZXN0YW1wID4gbWlkVGltZXN0YW1wICYmIG1pZEluZGV4IDwgbWF4SW5kZXgpXHJcbiAgICAgICAgICAgIHJldHVybiBmaW5kRnJhbWUobWlkSW5kZXggKyAxLCBtYXhJbmRleCwgdGltZXN0YW1wKTtcclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBsdWNrZWQgb3V0IGFuZCBmb3VuZCBhIGZyYW1lIHdpdGggZXhhY3RseSB0aGVcclxuICAgICAgICAvLyBkZXNpcmVkIHRpbWVzdGFtcFxyXG4gICAgICAgIHJldHVybiBtaWRJbmRleDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGF5cyB0aGUgaW5zdHJ1Y3Rpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gZnJhbWUsIHNlbmRpbmcgdGhvc2VcclxuICAgICAqIGluc3RydWN0aW9ucyB0byB0aGUgcGxheWJhY2sgY2xpZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuICAgICAqICAgICBUaGUgaW5kZXggb2YgdGhlIGZyYW1lIHdpdGhpbiB0aGUgZnJhbWVzIGFycmF5IHdoaWNoIHNob3VsZCBiZVxyXG4gICAgICogICAgIHJlcGxheWVkLlxyXG4gICAgICovXHJcbiAgICB2YXIgcmVwbGF5RnJhbWUgPSBmdW5jdGlvbiByZXBsYXlGcmFtZShpbmRleCkge1xyXG5cclxuICAgICAgICB2YXIgZnJhbWUgPSBmcmFtZXNbaW5kZXhdO1xyXG5cclxuICAgICAgICAvLyBSZXBsYXkgYWxsIGluc3RydWN0aW9ucyB3aXRoaW4gdGhlIHJldHJpZXZlZCBmcmFtZVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUuaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnN0cnVjdGlvbiA9IGZyYW1lLmluc3RydWN0aW9uc1tpXTtcclxuICAgICAgICAgICAgcGxheWJhY2tUdW5uZWwucmVjZWl2ZUluc3RydWN0aW9uKGluc3RydWN0aW9uLm9wY29kZSwgaW5zdHJ1Y3Rpb24uYXJncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdG9yZSBjbGllbnQgc3RhdGUgaWYgZnJhbWUgaXMgZmxhZ2dlZCBhcyBhIGtleWZyYW1lXHJcbiAgICAgICAgaWYgKGZyYW1lLmtleWZyYW1lICYmICFmcmFtZS5jbGllbnRTdGF0ZSkge1xyXG4gICAgICAgICAgICBwbGF5YmFja0NsaWVudC5leHBvcnRTdGF0ZShmdW5jdGlvbiBzdG9yZUNsaWVudFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZS5jbGllbnRTdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSBwbGF5YmFjayBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gZnJhbWUsIHJlc2V0dGluZyB0aGUgc3RhdGUgb2ZcclxuICAgICAqIHRoZSBwbGF5YmFjayBjbGllbnQgYW5kIHJlcGxheWluZyBmcmFtZXMgYXMgbmVjZXNzYXJ5LiBUaGUgc2Vla1xyXG4gICAgICogb3BlcmF0aW9uIHdpbGwgcHJvY2VlZCBhc3luY2hyb25vdXNseS4gSWYgYSBzZWVrIG9wZXJhdGlvbiBpcyBhbHJlYWR5IGluXHJcbiAgICAgKiBwcm9ncmVzcywgdGhhdCBzZWVrIGlzIGZpcnN0IGFib3J0ZWQuIFRoZSBwcm9ncmVzcyBvZiB0aGUgc2VlayBvcGVyYXRpb25cclxuICAgICAqIGNhbiBiZSBvYnNlcnZlZCB0aHJvdWdoIHRoZSBvbnNlZWsgaGFuZGxlciBhbmQgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuICAgICAqICAgICBUaGUgaW5kZXggb2YgdGhlIGZyYW1lIHdoaWNoIHNob3VsZCBiZWNvbWUgdGhlIG5ldyBwbGF5YmFja1xyXG4gICAgICogICAgIHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgKiAgICAgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBvbmNlIHRoZSBzZWVrIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsYXk9MF1cclxuICAgICAqICAgICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IHRoZSBzZWVrIG9wZXJhdGlvbiBzaG91bGQgYmVcclxuICAgICAqICAgICBzY2hlZHVsZWQgdG8gdGFrZS5cclxuICAgICAqL1xyXG4gICAgdmFyIHNlZWtUb0ZyYW1lID0gZnVuY3Rpb24gc2Vla1RvRnJhbWUoaW5kZXgsIGNhbGxiYWNrLCBkZWxheSkge1xyXG5cclxuICAgICAgICAvLyBBYm9ydCBhbnkgaW4tcHJvZ3Jlc3Mgc2Vla1xyXG4gICAgICAgIGFib3J0U2VlaygpO1xyXG5cclxuICAgICAgICAvLyBSZXBsYXkgZnJhbWVzIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgc2Vla1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiBjb250aW51ZVNlZWsoKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleDtcclxuXHJcbiAgICAgICAgICAgIC8vIEJhY2sgdXAgdW50aWwgc3RhcnRJbmRleCByZXByZXNlbnRzIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICAgICAgZm9yIChzdGFydEluZGV4ID0gaW5kZXg7IHN0YXJ0SW5kZXggPj0gMDsgc3RhcnRJbmRleC0tKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gZnJhbWVzW3N0YXJ0SW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgdGhlIGN1cnJlbnQgZnJhbWUsIHN0YXJ0SW5kZXggcmVwcmVzZW50c1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBzdGF0ZSBieSBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gY3VycmVudEZyYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGZyYW1lIGhhcyBhc3NvY2lhdGVkIGFic29sdXRlIHN0YXRlLCBtYWtlIHRoYXQgZnJhbWUgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHN0YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUuY2xpZW50U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBwbGF5YmFja0NsaWVudC5pbXBvcnRTdGF0ZShmcmFtZS5jbGllbnRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRvIGZyYW1lIGluZGV4IGFmdGVyIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVwbGF5IGFueSBhcHBsaWNhYmxlIGluY3JlbWVudGFsIGZyYW1lc1xyXG4gICAgICAgICAgICBmb3IgKDsgc3RhcnRJbmRleCA8PSBpbmRleDsgc3RhcnRJbmRleCsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcCBzZWVraW5nIGlmIHRoZSBvcGVyYXRpb24gaXMgdGFraW5nIHRvbyBsb25nXHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSAtIHN0YXJ0VGltZSA+PSBNQVhJTVVNX1NFRUtfVElNRSlcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICByZXBsYXlGcmFtZShzdGFydEluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ3VycmVudCBmcmFtZSBpcyBub3cgYXQgcmVxdWVzdGVkIGluZGV4XHJcbiAgICAgICAgICAgIGN1cnJlbnRGcmFtZSA9IHN0YXJ0SW5kZXggLSAxO1xyXG5cclxuICAgICAgICAgICAgLy8gTm90aWZ5IG9mIGNoYW5nZXMgaW4gcG9zaXRpb25cclxuICAgICAgICAgICAgaWYgKHJlY29yZGluZy5vbnNlZWspXHJcbiAgICAgICAgICAgICAgICByZWNvcmRpbmcub25zZWVrKHJlY29yZGluZy5nZXRQb3NpdGlvbigpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBzZWVrIG9wZXJhdGlvbiBoYXMgbm90IHlldCBjb21wbGV0ZWQsIHNjaGVkdWxlIGNvbnRpbnVhdGlvblxyXG4gICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lICE9PSBpbmRleClcclxuICAgICAgICAgICAgICAgIHNlZWtUb0ZyYW1lKGluZGV4LCBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChkZWxheSAtIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSksIDApKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vdGlmeSB0aGF0IHRoZSByZXF1ZXN0ZWQgc2VlayBoYXMgY29tcGxldGVkXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIH0sIGRlbGF5IHx8IDApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYm9ydHMgdGhlIHNlZWsgb3BlcmF0aW9uIGN1cnJlbnRseSBpbiBwcm9ncmVzcywgaWYgYW55LiBJZiBubyBzZWVrXHJcbiAgICAgKiBvcGVyYXRpb24gaXMgaW4gcHJvZ3Jlc3MsIHRoaXMgZnVuY3Rpb24gaGFzIG5vIGVmZmVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgYWJvcnRTZWVrID0gZnVuY3Rpb24gYWJvcnRTZWVrKCkge1xyXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc2Vla1RpbWVvdXQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkdmFuY2VzIHBsYXliYWNrIHRvIHRoZSBuZXh0IGZyYW1lIGluIHRoZSBmcmFtZXMgYXJyYXkgYW5kIHNjaGVkdWxlc1xyXG4gICAgICogcGxheWJhY2sgb2YgdGhlIGZyYW1lIGZvbGxvd2luZyB0aGF0IGZyYW1lIGJhc2VkIG9uIHRoZWlyIGFzc29jaWF0ZWRcclxuICAgICAqIHRpbWVzdGFtcHMuIElmIG5vIGZyYW1lcyBleGlzdCBhZnRlciB0aGUgbmV4dCBmcmFtZSwgcGxheWJhY2sgaXMgcGF1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBjb250aW51ZVBsYXliYWNrID0gZnVuY3Rpb24gY29udGludWVQbGF5YmFjaygpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgZnJhbWVzIHJlbWFpbiBhZnRlciBhZHZhbmNpbmcsIHNjaGVkdWxlIG5leHQgZnJhbWVcclxuICAgICAgICBpZiAoY3VycmVudEZyYW1lICsgMSA8IGZyYW1lcy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFB1bGwgdGhlIHVwY29taW5nIGZyYW1lXHJcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZnJhbWVzW2N1cnJlbnRGcmFtZSArIDFdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSByZWFsIHRpbWVzdGFtcCBjb3JyZXNwb25kaW5nIHRvIHdoZW4gdGhlIG5leHRcclxuICAgICAgICAgICAgLy8gZnJhbWUgYmVnaW5zXHJcbiAgICAgICAgICAgIHZhciBuZXh0UmVhbFRpbWVzdGFtcCA9IG5leHQudGltZXN0YW1wIC0gc3RhcnRWaWRlb1RpbWVzdGFtcCArIHN0YXJ0UmVhbFRpbWVzdGFtcDtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcmVsYXRpdmUgZGVsYXkgYmV0d2VlbiB0aGUgY3VycmVudCB0aW1lIGFuZFxyXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCBmcmFtZSBzdGFydFxyXG4gICAgICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1heChuZXh0UmVhbFRpbWVzdGFtcCAtIG5ldyBEYXRlKCkuZ2V0VGltZSgpLCAwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gbmV4dCBmcmFtZSBhZnRlciBlbm91Z2ggdGltZSBoYXMgZWxhcHNlZFxyXG4gICAgICAgICAgICBzZWVrVG9GcmFtZShjdXJyZW50RnJhbWUgKyAxLCBmdW5jdGlvbiBmcmFtZURlbGF5RWxhcHNlZCgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlUGxheWJhY2soKTtcclxuICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE90aGVyd2lzZSBzdG9wIHBsYXliYWNrXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZWNvcmRpbmcucGF1c2UoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiBuZXcgZnJhbWVzIGhhdmUgYmVjb21lIGF2YWlsYWJsZSB3aGlsZSB0aGUgcmVjb3JkaW5nIGlzXHJcbiAgICAgKiBiZWluZyBkb3dubG9hZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uXHJcbiAgICAgKiAgICAgVGhlIG5ldyBkdXJhdGlvbiBvZiB0aGUgcmVjb3JkaW5nLCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25wcm9ncmVzcyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciBwbGF5YmFjayBvZiB0aGUgcmVjb3JkaW5nIGhhcyBzdGFydGVkLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICovXHJcbiAgICB0aGlzLm9ucGxheSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciBwbGF5YmFjayBvZiB0aGUgcmVjb3JkaW5nIGhhcyBiZWVuIHBhdXNlZC4gVGhpcyBtYXlcclxuICAgICAqIGhhcHBlbiB3aGVuIHBsYXliYWNrIGlzIGV4cGxpY2l0bHkgcGF1c2VkIHdpdGggYSBjYWxsIHRvIHBhdXNlKCksIG9yXHJcbiAgICAgKiB3aGVuIHBsYXliYWNrIGlzIGltcGxpY2l0bHkgcGF1c2VkIGR1ZSB0byByZWFjaGluZyB0aGUgZW5kIG9mIHRoZVxyXG4gICAgICogcmVjb3JkaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudFxyXG4gICAgICovXHJcbiAgICB0aGlzLm9ucGF1c2UgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHBsYXliYWNrIHBvc2l0aW9uIHdpdGhpbiB0aGUgcmVjb3JkaW5nIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25cclxuICAgICAqICAgICBUaGUgbmV3IHBvc2l0aW9uIHdpdGhpbiB0aGUgcmVjb3JkaW5nLCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25zZWVrID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbm5lY3RzIHRoZSB1bmRlcmx5aW5nIHR1bm5lbCwgYmVnaW5uaW5nIGRvd25sb2FkIG9mIHRoZSBHdWFjYW1vbGVcclxuICAgICAqIHNlc3Npb24uIFBsYXliYWNrIG9mIHRoZSBHdWFjYW1vbGUgc2Vzc2lvbiBjYW5ub3Qgb2NjdXIgdW50aWwgYXQgbGVhc3RcclxuICAgICAqIG9uZSBmcmFtZSB3b3J0aCBvZiBpbnN0cnVjdGlvbnMgaGFzIGJlZW4gZG93bmxvYWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxyXG4gICAgICogICAgIFRoZSBkYXRhIHRvIHNlbmQgdG8gdGhlIHR1bm5lbCB3aGVuIGNvbm5lY3RpbmcuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29ubmVjdCA9IGZ1bmN0aW9uIGNvbm5lY3QoZGF0YSkge1xyXG4gICAgICAgIHR1bm5lbC5jb25uZWN0KGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc2Nvbm5lY3RzIHRoZSB1bmRlcmx5aW5nIHR1bm5lbCwgc3RvcHBpbmcgZnVydGhlciBkb3dubG9hZCBvZiB0aGVcclxuICAgICAqIEd1YWNhbW9sZSBzZXNzaW9uLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xyXG4gICAgICAgIHR1bm5lbC5kaXNjb25uZWN0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBkaXNwbGF5IG9mIHRoZSBHdWFjYW1vbGUuQ2xpZW50IHVzZWQgYnkgdGhpc1xyXG4gICAgICogR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcgZm9yIHBsYXliYWNrLiBUaGUgZGlzcGxheSBjb250YWlucyBhbiBFbGVtZW50XHJcbiAgICAgKiB3aGljaCBjYW4gYmUgYWRkZWQgdG8gdGhlIERPTSwgY2F1c2luZyB0aGUgZGlzcGxheSAoYW5kIHRodXMgcGxheWJhY2sgb2ZcclxuICAgICAqIHRoZSByZWNvcmRpbmcpIHRvIGJlY29tZSB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0d1YWNhbW9sZS5EaXNwbGF5fVxyXG4gICAgICogICAgIFRoZSB1bmRlcmx5aW5nIGRpc3BsYXkgb2YgdGhlIEd1YWNhbW9sZS5DbGllbnQgdXNlZCBieSB0aGlzXHJcbiAgICAgKiAgICAgR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcgZm9yIHBsYXliYWNrLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldERpc3BsYXkgPSBmdW5jdGlvbiBnZXREaXNwbGF5KCkge1xyXG4gICAgICAgIHJldHVybiBwbGF5YmFja0NsaWVudC5nZXREaXNwbGF5KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHBsYXliYWNrIGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqICAgICB0cnVlIGlmIHBsYXliYWNrIGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcywgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmlzUGxheWluZyA9IGZ1bmN0aW9uIGlzUGxheWluZygpIHtcclxuICAgICAgICByZXR1cm4gISFzdGFydFZpZGVvVGltZXN0YW1wO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gd2l0aGluIHRoZSByZWNvcmRpbmcsIGluXHJcbiAgICAgKiBtaWxsaXNlY29uZHMsIHdoZXJlIHplcm8gaXMgdGhlIHN0YXJ0IG9mIHRoZSByZWNvcmRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqICAgICBUaGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiB3aXRoaW4gdGhlIHJlY29yZGluZywgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XHJcblxyXG4gICAgICAgIC8vIFBvc2l0aW9uIGlzIHNpbXBseSB6ZXJvIGlmIHBsYXliYWNrIGhhcyBub3Qgc3RhcnRlZCBhdCBhbGxcclxuICAgICAgICBpZiAoY3VycmVudEZyYW1lID09PSAtMSlcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBjdXJyZW50IHBvc2l0aW9uIGFzIGEgbWlsbGlzZWNvbmQgdGltZXN0YW1wIHJlbGF0aXZlIHRvIHRoZVxyXG4gICAgICAgIC8vIHN0YXJ0IG9mIHRoZSByZWNvcmRpbmdcclxuICAgICAgICByZXR1cm4gdG9SZWxhdGl2ZVRpbWVzdGFtcChmcmFtZXNbY3VycmVudEZyYW1lXS50aW1lc3RhbXApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkdXJhdGlvbiBvZiB0aGlzIHJlY29yZGluZywgaW4gbWlsbGlzZWNvbmRzLiBJZiB0aGVcclxuICAgICAqIHJlY29yZGluZyBpcyBzdGlsbCBiZWluZyBkb3dubG9hZGVkLCB0aGlzIHZhbHVlIHdpbGwgZ3JhZHVhbGx5IGluY3JlYXNlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiAgICAgVGhlIGR1cmF0aW9uIG9mIHRoaXMgcmVjb3JkaW5nLCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiBnZXREdXJhdGlvbigpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gZnJhbWVzIHlldCBleGlzdCwgZHVyYXRpb24gaXMgemVyb1xyXG4gICAgICAgIGlmIChmcmFtZXMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuXHJcbiAgICAgICAgLy8gUmVjb3JkaW5nIGR1cmF0aW9uIGlzIHNpbXBseSB0aGUgdGltZXN0YW1wIG9mIHRoZSBsYXN0IGZyYW1lXHJcbiAgICAgICAgcmV0dXJuIHRvUmVsYXRpdmVUaW1lc3RhbXAoZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXS50aW1lc3RhbXApO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCZWdpbnMgY29udGludW91cyBwbGF5YmFjayBvZiB0aGUgcmVjb3JkaW5nIGRvd25sb2FkZWQgdGh1cyBmYXIuXHJcbiAgICAgKiBQbGF5YmFjayBvZiB0aGUgcmVjb3JkaW5nIHdpbGwgY29udGludWUgdW50aWwgcGF1c2UoKSBpcyBpbnZva2VkIG9yXHJcbiAgICAgKiB1bnRpbCBubyBmdXJ0aGVyIGZyYW1lcyBleGlzdC4gUGxheWJhY2sgaXMgaW5pdGlhbGx5IHBhdXNlZCB3aGVuIGFcclxuICAgICAqIEd1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nIGlzIGNyZWF0ZWQsIGFuZCBtdXN0IGJlIGV4cGxpY2l0bHkgc3RhcnRlZFxyXG4gICAgICogdGhyb3VnaCBhIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi4gSWYgcGxheWJhY2sgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyxcclxuICAgICAqIHRoaXMgZnVuY3Rpb24gaGFzIG5vIGVmZmVjdC4gSWYgYSBzZWVrIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzcyxcclxuICAgICAqIHBsYXliYWNrIHJlc3VtZXMgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGUgc2VlayBpcyBhYm9ydGVkIGFzIGlmXHJcbiAgICAgKiBjb21wbGV0ZWQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGxheSA9IGZ1bmN0aW9uIHBsYXkoKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHBsYXliYWNrIGlzIG5vdCBhbHJlYWR5IGluIHByb2dyZXNzIGFuZCBmcmFtZXMgcmVtYWluLFxyXG4gICAgICAgIC8vIGJlZ2luIHBsYXliYWNrXHJcbiAgICAgICAgaWYgKCFyZWNvcmRpbmcuaXNQbGF5aW5nKCkgJiYgY3VycmVudEZyYW1lICsgMSA8IGZyYW1lcy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vdGlmeSB0aGF0IHBsYXliYWNrIGlzIHN0YXJ0aW5nXHJcbiAgICAgICAgICAgIGlmIChyZWNvcmRpbmcub25wbGF5KVxyXG4gICAgICAgICAgICAgICAgcmVjb3JkaW5nLm9ucGxheSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RvcmUgdGltZXN0YW1wIG9mIHBsYXliYWNrIHN0YXJ0IGZvciByZWxhdGl2ZSBzY2hlZHVsaW5nIG9mXHJcbiAgICAgICAgICAgIC8vIGZ1dHVyZSBmcmFtZXNcclxuICAgICAgICAgICAgdmFyIG5leHQgPSBmcmFtZXNbY3VycmVudEZyYW1lICsgMV07XHJcbiAgICAgICAgICAgIHN0YXJ0VmlkZW9UaW1lc3RhbXAgPSBuZXh0LnRpbWVzdGFtcDtcclxuICAgICAgICAgICAgc3RhcnRSZWFsVGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBCZWdpbiBwbGF5YmFjayBvZiB2aWRlb1xyXG4gICAgICAgICAgICBjb250aW51ZVBsYXliYWNrKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2Vla3MgdG8gdGhlIGdpdmVuIHBvc2l0aW9uIHdpdGhpbiB0aGUgcmVjb3JkaW5nLiBJZiB0aGUgcmVjb3JkaW5nIGlzXHJcbiAgICAgKiBjdXJyZW50bHkgYmVpbmcgcGxheWVkIGJhY2ssIHBsYXliYWNrIHdpbGwgY29udGludWUgYWZ0ZXIgdGhlIHNlZWsgaXNcclxuICAgICAqIHBlcmZvcm1lZC4gSWYgdGhlIHJlY29yZGluZyBpcyBjdXJyZW50bHkgcGF1c2VkLCBwbGF5YmFjayB3aWxsIGJlXHJcbiAgICAgKiBwYXVzZWQgYWZ0ZXIgdGhlIHNlZWsgaXMgcGVyZm9ybWVkLiBJZiBhIHNlZWsgb3BlcmF0aW9uIGlzIGFscmVhZHkgaW5cclxuICAgICAqIHByb2dyZXNzLCB0aGF0IHNlZWsgaXMgZmlyc3QgYWJvcnRlZC4gVGhlIHNlZWsgb3BlcmF0aW9uIHdpbGwgcHJvY2VlZFxyXG4gICAgICogYXN5bmNocm9ub3VzbHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uXHJcbiAgICAgKiAgICAgVGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgcmVjb3JkaW5nIHRvIHNlZWsgdG8sIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdXHJcbiAgICAgKiAgICAgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBvbmNlIHRoZSBzZWVrIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlZWsgPSBmdW5jdGlvbiBzZWVrKHBvc2l0aW9uLCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgICAvLyBEbyBub3Qgc2VlayBpZiBubyBmcmFtZXMgZXhpc3RcclxuICAgICAgICBpZiAoZnJhbWVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBQYXVzZSBwbGF5YmFjaywgcHJlc2VydmluZyBwbGF5YmFjayBzdGF0ZVxyXG4gICAgICAgIHZhciBvcmlnaW5hbGx5UGxheWluZyA9IHJlY29yZGluZy5pc1BsYXlpbmcoKTtcclxuICAgICAgICByZWNvcmRpbmcucGF1c2UoKTtcclxuXHJcbiAgICAgICAgLy8gUGVyZm9ybSBzZWVrXHJcbiAgICAgICAgc2Vla1RvRnJhbWUoZmluZEZyYW1lKDAsIGZyYW1lcy5sZW5ndGggLSAxLCBwb3NpdGlvbiksIGZ1bmN0aW9uIHJlc3RvcmVQbGF5YmFja1N0YXRlKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzdG9yZSBwbGF5YmFjayBzdGF0ZVxyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxseVBsYXlpbmcpXHJcbiAgICAgICAgICAgICAgICByZWNvcmRpbmcucGxheSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gTm90aWZ5IHRoYXQgc2VlayBoYXMgY29tcGxldGVkXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaylcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXVzZXMgcGxheWJhY2sgb2YgdGhlIHJlY29yZGluZywgaWYgcGxheWJhY2sgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxyXG4gICAgICogSWYgcGxheWJhY2sgaXMgbm90IGluIHByb2dyZXNzLCB0aGlzIGZ1bmN0aW9uIGhhcyBubyBlZmZlY3QuIElmIGEgc2Vla1xyXG4gICAgICogb3BlcmF0aW9uIGlzIGluIHByb2dyZXNzLCB0aGUgc2VlayBpcyBhYm9ydGVkLiBQbGF5YmFjayBpcyBpbml0aWFsbHlcclxuICAgICAqIHBhdXNlZCB3aGVuIGEgR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcgaXMgY3JlYXRlZCwgYW5kIG11c3QgYmVcclxuICAgICAqIGV4cGxpY2l0bHkgc3RhcnRlZCB0aHJvdWdoIGEgY2FsbCB0byBwbGF5KCkuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcclxuXHJcbiAgICAgICAgLy8gQWJvcnQgYW55IGluLXByb2dyZXNzIHNlZWsgLyBwbGF5YmFja1xyXG4gICAgICAgIGFib3J0U2VlaygpO1xyXG5cclxuICAgICAgICAvLyBTdG9wIHBsYXliYWNrIG9ubHkgaWYgcGxheWJhY2sgaXMgaW4gcHJvZ3Jlc3NcclxuICAgICAgICBpZiAocmVjb3JkaW5nLmlzUGxheWluZygpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBOb3RpZnkgdGhhdCBwbGF5YmFjayBpcyBzdG9wcGluZ1xyXG4gICAgICAgICAgICBpZiAocmVjb3JkaW5nLm9ucGF1c2UpXHJcbiAgICAgICAgICAgICAgICByZWNvcmRpbmcub25wYXVzZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUGxheWJhY2sgaXMgc3RvcHBlZFxyXG4gICAgICAgICAgICBzdGFydFZpZGVvVGltZXN0YW1wID0gbnVsbDtcclxuICAgICAgICAgICAgc3RhcnRSZWFsVGltZXN0YW1wID0gbnVsbDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgc2luZ2xlIGZyYW1lIG9mIEd1YWNhbW9sZSBzZXNzaW9uIGRhdGEuIEVhY2ggZnJhbWUgaXMgbWFkZSB1cCBvZiB0aGUgc2V0XHJcbiAqIG9mIGluc3RydWN0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoYXQgZnJhbWUsIGFuZCB0aGUgdGltZXN0YW1wIGFzIGRpY3RhdGVkXHJcbiAqIGJ5IHRoZSBcInN5bmNcIiBpbnN0cnVjdGlvbiB0ZXJtaW5hdGluZyB0aGUgZnJhbWUuIE9wdGlvbmFsbHksIGEgZnJhbWUgbWF5XHJcbiAqIGFsc28gYmUgYXNzb2NpYXRlZCB3aXRoIGEgc25hcHNob3Qgb2YgR3VhY2Ftb2xlIGNsaWVudCBzdGF0ZSwgc3VjaCB0aGF0IHRoZVxyXG4gKiBmcmFtZSBjYW4gYmUgcmVuZGVyZWQgd2l0aG91dCByZXBsYXlpbmcgYWxsIHByZXZpb3VzIGZyYW1lcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lc3RhbXBcclxuICogICAgIFRoZSB0aW1lc3RhbXAgb2YgdGhpcyBmcmFtZSwgYXMgZGljdGF0ZWQgYnkgdGhlIFwic3luY1wiIGluc3RydWN0aW9uIHdoaWNoXHJcbiAqICAgICB0ZXJtaW5hdGVzIHRoZSBmcmFtZS5cclxuICpcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fRnJhbWUuSW5zdHJ1Y3Rpb25bXX0gaW5zdHJ1Y3Rpb25zXHJcbiAqICAgICBBbGwgaW5zdHJ1Y3Rpb25zIHdoaWNoIGFyZSBuZWNlc3NhcnkgdG8gZ2VuZXJhdGUgdGhpcyBmcmFtZSByZWxhdGl2ZSB0b1xyXG4gKiAgICAgdGhlIHByZXZpb3VzIGZyYW1lIGluIHRoZSBHdWFjYW1vbGUgc2Vzc2lvbi5cclxuICovXHJcbkd1YWNhbW9sZS5TZXNzaW9uUmVjb3JkaW5nLl9GcmFtZSA9IGZ1bmN0aW9uIF9GcmFtZSh0aW1lc3RhbXAsIGluc3RydWN0aW9ucykge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGlzIGZyYW1lIHNob3VsZCBiZSB1c2VkIGFzIGEga2V5ZnJhbWUgaWYgcG9zc2libGUuIFRoaXMgdmFsdWVcclxuICAgICAqIGlzIHB1cmVseSBhZHZpc29yeS4gVGhlIHN0b3JlZCBjbGllbnRTdGF0ZSBtdXN0IGV2ZW50dWFsbHkgYmUgbWFudWFsbHlcclxuICAgICAqIHNldCBmb3IgdGhlIGZyYW1lIHRvIGJlIHVzZWQgYXMgYSBrZXlmcmFtZS4gQnkgZGVmYXVsdCwgZnJhbWVzIGFyZSBub3RcclxuICAgICAqIGtleWZyYW1lcy5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMua2V5ZnJhbWUgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0aW1lc3RhbXAgb2YgdGhpcyBmcmFtZSwgYXMgZGljdGF0ZWQgYnkgdGhlIFwic3luY1wiIGluc3RydWN0aW9uIHdoaWNoXHJcbiAgICAgKiB0ZXJtaW5hdGVzIHRoZSBmcmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBpbnN0cnVjdGlvbnMgd2hpY2ggYXJlIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aGlzIGZyYW1lIHJlbGF0aXZlIHRvXHJcbiAgICAgKiB0aGUgcHJldmlvdXMgZnJhbWUgaW4gdGhlIEd1YWNhbW9sZSBzZXNzaW9uLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fRnJhbWUuSW5zdHJ1Y3Rpb25bXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNuYXBzaG90IG9mIGNsaWVudCBzdGF0ZSBhZnRlciB0aGlzIGZyYW1lIHdhcyByZW5kZXJlZCwgYXMgcmV0dXJuZWQgYnlcclxuICAgICAqIGEgY2FsbCB0byBleHBvcnRTdGF0ZSgpLiBJZiBubyBzdWNoIHNuYXBzaG90IGhhcyBiZWVuIHRha2VuLCB0aGlzIHdpbGxcclxuICAgICAqIGJlIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG4gICAgdGhpcy5jbGllbnRTdGF0ZSA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgR3VhY2Ftb2xlIHByb3RvY29sIGluc3RydWN0aW9uLiBFYWNoIEd1YWNhbW9sZSBwcm90b2NvbCBpbnN0cnVjdGlvbiBpc1xyXG4gKiBtYWRlIHVwIG9mIGFuIG9wY29kZSBhbmQgc2V0IG9mIGFyZ3VtZW50cy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcGNvZGVcclxuICogICAgIFRoZSBvcGNvZGUgb2YgdGhpcyBHdWFjYW1vbGUgaW5zdHJ1Y3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nW119IGFyZ3NcclxuICogICAgIEFsbCBhcmd1bWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgR3VhY2Ftb2xlIGluc3RydWN0aW9uLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlNlc3Npb25SZWNvcmRpbmcuX0ZyYW1lLkluc3RydWN0aW9uID0gZnVuY3Rpb24gSW5zdHJ1Y3Rpb24ob3Bjb2RlLCBhcmdzKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fRnJhbWUuSW5zdHJ1Y3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fRnJhbWUuSW5zdHJ1Y3Rpb259XHJcbiAgICAgKi9cclxuICAgIHZhciBpbnN0cnVjdGlvbiA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3Bjb2RlIG9mIHRoaXMgR3VhY2Ftb2xlIGluc3RydWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3Bjb2RlID0gb3Bjb2RlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsIGFyZ3VtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBHdWFjYW1vbGUgaW5zdHJ1Y3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1N0cmluZ1tdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYXBwcm94aW1hdGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgd2hpY2ggbWFrZSB1cCB0aGlzXHJcbiAgICAgKiBpbnN0cnVjdGlvbi4gVGhpcyB2YWx1ZSBpcyBvbmx5IGFwcHJveGltYXRlIGFzIGl0IGV4Y2x1ZGVzIHRoZSBsZW5ndGhcclxuICAgICAqIHByZWZpeGVzIGFuZCB2YXJpb3VzIGRlbGltaXRlcnMgdXNlZCBieSB0aGUgR3VhY2Ftb2xlIHByb3RvY29sOyBvbmx5XHJcbiAgICAgKiB0aGUgY29udGVudCBvZiB0aGUgb3Bjb2RlIGFuZCBlYWNoIGFyZ3VtZW50IGlzIHRha2VuIGludG8gYWNjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogICAgIFRoZSBhcHByb3hpbWF0ZSBzaXplIG9mIHRoaXMgaW5zdHJ1Y3Rpb24sIGluIGNoYXJhY3RlcnMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUoKSB7XHJcblxyXG4gICAgICAgIC8vIEluaXQgd2l0aCBsZW5ndGggb2Ygb3Bjb2RlXHJcbiAgICAgICAgdmFyIHNpemUgPSBpbnN0cnVjdGlvbi5vcGNvZGUubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBBZGQgbGVuZ3RoIG9mIGFsbCBhcmd1bWVudHNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RydWN0aW9uLmFyZ3MubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHNpemUgKz0gaW5zdHJ1Y3Rpb24uYXJnc1tpXS5sZW5ndGg7XHJcblxyXG4gICAgICAgIHJldHVybiBzaXplO1xyXG5cclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgcmVhZC1vbmx5IEd1YWNhbW9sZS5UdW5uZWwgaW1wbGVtZW50YXRpb24gd2hpY2ggc3RyZWFtcyBpbnN0cnVjdGlvbnNcclxuICogcmVjZWl2ZWQgdGhyb3VnaCBleHBsaWNpdCBjYWxscyB0byBpdHMgcmVjZWl2ZUluc3RydWN0aW9uKCkgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXVnbWVudHMge0d1YWNhbW9sZS5UdW5uZWx9XHJcbiAqL1xyXG5HdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fUGxheWJhY2tUdW5uZWwgPSBmdW5jdGlvbiBfUGxheWJhY2tUdW5uZWwoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhpcyBHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fUGxheWJhY2tUdW5uZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuU2Vzc2lvblJlY29yZGluZy5fUGxheWJhY2tUdW5uZWx9XHJcbiAgICAgKi9cclxuICAgIHZhciB0dW5uZWwgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuY29ubmVjdCA9IGZ1bmN0aW9uIGNvbm5lY3QoZGF0YSkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmdcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uIHNlbmRNZXNzYWdlKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZ1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmdcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoaXMgdHVubmVsJ3Mgb25pbnN0cnVjdGlvbiBoYW5kbGVyLCBub3RpZnlpbmcgdXNlcnMgb2YgdGhpc1xyXG4gICAgICogdHVubmVsIChzdWNoIGFzIGEgR3VhY2Ftb2xlLkNsaWVudCBpbnN0YW5jZSkgdGhhdCBhbiBpbnN0cnVjdGlvbiBoYXNcclxuICAgICAqIGJlZW4gcmVjZWl2ZWQuIElmIHRoZSBvbmluc3RydWN0aW9uIGhhbmRsZXIgaGFzIG5vdCBiZWVuIHNldCwgdGhpc1xyXG4gICAgICogZnVuY3Rpb24gaGFzIG5vIGVmZmVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3Bjb2RlXHJcbiAgICAgKiAgICAgVGhlIG9wY29kZSBvZiB0aGUgR3VhY2Ftb2xlIGluc3RydWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGFyZ3NcclxuICAgICAqICAgICBBbGwgYXJndW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEd1YWNhbW9sZSBpbnN0cnVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWNlaXZlSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiByZWNlaXZlSW5zdHJ1Y3Rpb24ob3Bjb2RlLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKHR1bm5lbC5vbmluc3RydWN0aW9uKVxyXG4gICAgICAgICAgICB0dW5uZWwub25pbnN0cnVjdGlvbihvcGNvZGUsIGFyZ3MpO1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIEd1YWNhbW9sZSA9IEd1YWNhbW9sZSB8fCB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIEd1YWNhbW9sZSBzdGF0dXMuIEVhY2ggR3VhY2Ftb2xlIHN0YXR1cyBjb25zaXN0cyBvZiBhIHN0YXR1cyBjb2RlLCBkZWZpbmVkXHJcbiAqIGJ5IHRoZSBwcm90b2NvbCwgYW5kIGFuIG9wdGlvbmFsIGh1bWFuLXJlYWRhYmxlIG1lc3NhZ2UsIHVzdWFsbHkgb25seVxyXG4gKiBpbmNsdWRlZCBmb3IgZGVidWdnaW5nIGNvbnZlbmllbmNlLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVcclxuICogICAgIFRoZSBHdWFjYW1vbGUgc3RhdHVzIGNvZGUsIGFzIGRlZmluZWQgYnkgR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdXHJcbiAqICAgICBBbiBvcHRpb25hbCBodW1hbi1yZWFkYWJsZSBtZXNzYWdlLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlN0YXR1cyA9IGZ1bmN0aW9uKGNvZGUsIG1lc3NhZ2UpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIEd1YWNhbW9sZS5TdGF0dXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY19zdGF0dXMgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIEd1YWNhbW9sZSBzdGF0dXMgY29kZS5cclxuICAgICAqIEBzZWUgR3VhY2Ftb2xlLlN0YXR1cy5Db2RlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJiaXRyYXJ5IGh1bWFuLXJlYWRhYmxlIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RhdHVzLCBpZiBhbnkuXHJcbiAgICAgKiBUaGUgaHVtYW4tcmVhZGFibGUgbWVzc2FnZSBpcyBub3QgcmVxdWlyZWQsIGFuZCBpcyBnZW5lcmFsbHkgcHJvdmlkZWRcclxuICAgICAqIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgb25seS4gRm9yIHVzZXIgZmVlZGJhY2ssIGl0IGlzIGJldHRlciB0byB0cmFuc2xhdGVcclxuICAgICAqIHRoZSBHdWFjYW1vbGUgc3RhdHVzIGNvZGUgaW50byBhIG1lc3NhZ2UuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBzdGF0dXMgcmVwcmVzZW50cyBhbiBlcnJvci5cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgc3RhdHVzIHJlcHJlc2VudHMgYW4gZXJyb3IsIGZhbHNlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmlzRXJyb3IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gZ3VhY19zdGF0dXMuY29kZSA8IDAgfHwgZ3VhY19zdGF0dXMuY29kZSA+IDB4MDBGRjtcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVudW1lcmF0aW9uIG9mIGFsbCBHdWFjYW1vbGUgc3RhdHVzIGNvZGVzLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlN0YXR1cy5Db2RlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBzdWNjZWVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJTVUNDRVNTXCI6IDB4MDAwMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZXF1ZXN0ZWQgb3BlcmF0aW9uIGlzIHVuc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiVU5TVVBQT1JURURcIjogMHgwMTAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGR1ZSB0byBhbiBpbnRlcm5hbCBmYWlsdXJlLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiU0VSVkVSX0VSUk9SXCI6IDB4MDIwMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gY291bGQgbm90IGJlIHBlcmZvcm1lZCBhcyB0aGUgc2VydmVyIGlzIGJ1c3kuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJTRVJWRVJfQlVTWVwiOiAweDAyMDEsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgYmVjYXVzZSB0aGUgdXBzdHJlYW0gc2VydmVyIGlzIG5vdFxyXG4gICAgICogcmVzcG9uZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIlVQU1RSRUFNX1RJTUVPVVRcIjogMHgwMjAyLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiB3YXMgdW5zdWNjZXNzZnVsIGR1ZSB0byBhbiBlcnJvciBvciBvdGhlcndpc2UgdW5leHBlY3RlZFxyXG4gICAgICogY29uZGl0aW9uIG9mIHRoZSB1cHN0cmVhbSBzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJVUFNUUkVBTV9FUlJPUlwiOiAweDAyMDMsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgYXMgdGhlIHJlcXVlc3RlZCByZXNvdXJjZSBkb2VzIG5vdFxyXG4gICAgICogZXhpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJSRVNPVVJDRV9OT1RfRk9VTkRcIjogMHgwMjA0LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGFzIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgaXNcclxuICAgICAqIGFscmVhZHkgaW4gdXNlLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiUkVTT1VSQ0VfQ09ORkxJQ1RcIjogMHgwMjA1LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGFzIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgaXMgbm93XHJcbiAgICAgKiBjbG9zZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJSRVNPVVJDRV9DTE9TRURcIjogMHgwMjA2LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGJlY2F1c2UgdGhlIHVwc3RyZWFtIHNlcnZlciBkb2VzXHJcbiAgICAgKiBub3QgYXBwZWFyIHRvIGV4aXN0LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiVVBTVFJFQU1fTk9UX0ZPVU5EXCI6IDB4MDIwNyxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gY291bGQgbm90IGJlIHBlcmZvcm1lZCBiZWNhdXNlIHRoZSB1cHN0cmVhbSBzZXJ2ZXIgaXMgbm90XHJcbiAgICAgKiBhdmFpbGFibGUgdG8gc2VydmljZSB0aGUgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIlVQU1RSRUFNX1VOQVZBSUxBQkxFXCI6IDB4MDIwOCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXNzaW9uIHdpdGhpbiB0aGUgdXBzdHJlYW0gc2VydmVyIGhhcyBlbmRlZCBiZWNhdXNlIGl0IGNvbmZsaWN0ZWRcclxuICAgICAqIHdpdGggYW5vdGhlciBzZXNzaW9uLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiU0VTU0lPTl9DT05GTElDVFwiOiAweDAyMDksXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2Vzc2lvbiB3aXRoaW4gdGhlIHVwc3RyZWFtIHNlcnZlciBoYXMgZW5kZWQgYmVjYXVzZSBpdCBhcHBlYXJlZCB0b1xyXG4gICAgICogYmUgaW5hY3RpdmUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJTRVNTSU9OX1RJTUVPVVRcIjogMHgwMjBBLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNlc3Npb24gd2l0aGluIHRoZSB1cHN0cmVhbSBzZXJ2ZXIgaGFzIGJlZW4gZm9yY2libHkgdGVybWluYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIlNFU1NJT05fQ0xPU0VEXCI6IDB4MDIwQixcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gY291bGQgbm90IGJlIHBlcmZvcm1lZCBiZWNhdXNlIGJhZCBwYXJhbWV0ZXJzIHdlcmUgZ2l2ZW4uXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJDTElFTlRfQkFEX1JFUVVFU1RcIjogMHgwMzAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVybWlzc2lvbiB3YXMgZGVuaWVkIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbiwgYXMgdGhlIHVzZXIgaXMgbm90IHlldFxyXG4gICAgICogYXV0aG9yaXplZCAobm90IHlldCBsb2dnZWQgaW4sIGZvciBleGFtcGxlKS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBcIkNMSUVOVF9VTkFVVEhPUklaRURcIjogMHgwMzAxLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVybWlzc2lvbiB3YXMgZGVuaWVkIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbiwgYW5kIHRoaXMgcGVybWlzc2lvbiB3aWxsXHJcbiAgICAgKiBub3QgYmUgZ3JhbnRlZCBldmVuIGlmIHRoZSB1c2VyIGlzIGF1dGhvcml6ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJDTElFTlRfRk9SQklEREVOXCI6IDB4MDMwMyxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjbGllbnQgdG9vayB0b28gbG9uZyB0byByZXNwb25kLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiQ0xJRU5UX1RJTUVPVVRcIjogMHgwMzA4LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNsaWVudCBzZW50IHRvbyBtdWNoIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJDTElFTlRfT1ZFUlJVTlwiOiAweDAzMEQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2xpZW50IHNlbnQgZGF0YSBvZiBhbiB1bnN1cHBvcnRlZCBvciB1bmV4cGVjdGVkIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJDTElFTlRfQkFEX1RZUEVcIjogMHgwMzBGLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgY3VycmVudCBjbGllbnQgaXMgYWxyZWFkeSB1c2luZyB0b29cclxuICAgICAqIG1hbnkgcmVzb3VyY2VzLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiQ0xJRU5UX1RPT19NQU5ZXCI6IDB4MDMxRFxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBHdWFjYW1vbGUgcHJvdG9jb2wgc3RhdHVzIGNvZGUgd2hpY2ggbW9zdCBjbG9zZWx5XHJcbiAqIHJlcHJlc2VudHMgdGhlIGdpdmVuIEhUVFAgc3RhdHVzIGNvZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNcclxuICogICAgIFRoZSBIVFRQIHN0YXR1cyBjb2RlIHRvIHRyYW5zbGF0ZSBpbnRvIGEgR3VhY2Ftb2xlIHByb3RvY29sIHN0YXR1c1xyXG4gKiAgICAgY29kZS5cclxuICpcclxuICogQHJldHVybnMge051bWJlcn1cclxuICogICAgIFRoZSBHdWFjYW1vbGUgcHJvdG9jb2wgc3RhdHVzIGNvZGUgd2hpY2ggbW9zdCBjbG9zZWx5IHJlcHJlc2VudHMgdGhlXHJcbiAqICAgICBnaXZlbiBIVFRQIHN0YXR1cyBjb2RlLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLmZyb21IVFRQQ29kZSA9IGZ1bmN0aW9uIGZyb21IVFRQQ29kZShzdGF0dXMpIHtcclxuXHJcbiAgICAvLyBUcmFuc2xhdGUgc3RhdHVzIGNvZGVzIHdpdGgga25vd24gZXF1aXZhbGVudHNcclxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XHJcblxyXG4gICAgICAgIC8vIEhUVFAgNDAwIC0gQmFkIHJlcXVlc3RcclxuICAgICAgICBjYXNlIDQwMDpcclxuICAgICAgICAgICAgcmV0dXJuIEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5DTElFTlRfQkFEX1JFUVVFU1Q7XHJcblxyXG4gICAgICAgIC8vIEhUVFAgNDAzIC0gRm9yYmlkZGVuXHJcbiAgICAgICAgY2FzZSA0MDM6XHJcbiAgICAgICAgICAgIHJldHVybiBHdWFjYW1vbGUuU3RhdHVzLkNvZGUuQ0xJRU5UX0ZPUkJJRERFTjtcclxuXHJcbiAgICAgICAgLy8gSFRUUCA0MDQgLSBSZXNvdXJjZSBub3QgZm91bmRcclxuICAgICAgICBjYXNlIDQwNDpcclxuICAgICAgICAgICAgcmV0dXJuIEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5SRVNPVVJDRV9OT1RfRk9VTkQ7XHJcblxyXG4gICAgICAgIC8vIEhUVFAgNDI5IC0gVG9vIG1hbnkgcmVxdWVzdHNcclxuICAgICAgICBjYXNlIDQyOTpcclxuICAgICAgICAgICAgcmV0dXJuIEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5DTElFTlRfVE9PX01BTlk7XHJcblxyXG4gICAgICAgIC8vIEhUVFAgNTAzIC0gU2VydmVyIHVuYXZhaWxhYmxlXHJcbiAgICAgICAgY2FzZSA1MDM6XHJcbiAgICAgICAgICAgIHJldHVybiBHdWFjYW1vbGUuU3RhdHVzLkNvZGUuU0VSVkVSX0JVU1k7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmF1bHQgYWxsIG90aGVyIGNvZGVzIHRvIGdlbmVyaWMgaW50ZXJuYWwgZXJyb3JcclxuICAgIHJldHVybiBHdWFjYW1vbGUuU3RhdHVzLkNvZGUuU0VSVkVSX0VSUk9SO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBHdWFjYW1vbGUgcHJvdG9jb2wgc3RhdHVzIGNvZGUgd2hpY2ggbW9zdCBjbG9zZWx5XHJcbiAqIHJlcHJlc2VudHMgdGhlIGdpdmVuIFdlYlNvY2tldCBzdGF0dXMgY29kZS5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVcclxuICogICAgIFRoZSBXZWJTb2NrZXQgc3RhdHVzIGNvZGUgdG8gdHJhbnNsYXRlIGludG8gYSBHdWFjYW1vbGUgcHJvdG9jb2xcclxuICogICAgIHN0YXR1cyBjb2RlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gKiAgICAgVGhlIEd1YWNhbW9sZSBwcm90b2NvbCBzdGF0dXMgY29kZSB3aGljaCBtb3N0IGNsb3NlbHkgcmVwcmVzZW50cyB0aGVcclxuICogICAgIGdpdmVuIFdlYlNvY2tldCBzdGF0dXMgY29kZS5cclxuICovXHJcbkd1YWNhbW9sZS5TdGF0dXMuQ29kZS5mcm9tV2ViU29ja2V0Q29kZSA9IGZ1bmN0aW9uIGZyb21XZWJTb2NrZXRDb2RlKGNvZGUpIHtcclxuXHJcbiAgICAvLyBUcmFuc2xhdGUgc3RhdHVzIGNvZGVzIHdpdGgga25vd24gZXF1aXZhbGVudHNcclxuICAgIHN3aXRjaCAoY29kZSkge1xyXG5cclxuICAgICAgICAvLyBTdWNjZXNzZnVsIGRpc2Nvbm5lY3QgKG5vIGVycm9yKVxyXG4gICAgICAgIGNhc2UgMTAwMDogLy8gTm9ybWFsIENsb3N1cmVcclxuICAgICAgICAgICAgcmV0dXJuIEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5TVUNDRVNTO1xyXG5cclxuICAgICAgICAvLyBDb2RlcyB3aGljaCBpbmRpY2F0ZSB0aGUgc2VydmVyIGlzIG5vdCByZWFjaGFibGVcclxuICAgICAgICBjYXNlIDEwMDY6IC8vIEFibm9ybWFsIENsb3N1cmUgKGFsc28gc2lnbmFsbGVkIGJ5IEphdmFTY3JpcHQgd2hlbiB0aGUgY29ubmVjdGlvbiBjYW5ub3QgYmUgb3BlbmVkIGluIHRoZSBmaXJzdCBwbGFjZSlcclxuICAgICAgICBjYXNlIDEwMTU6IC8vIFRMUyBIYW5kc2hha2VcclxuICAgICAgICAgICAgcmV0dXJuIEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5VUFNUUkVBTV9OT1RfRk9VTkQ7XHJcblxyXG4gICAgICAgIC8vIENvZGVzIHdoaWNoIGluZGljYXRlIHRoZSBzZXJ2ZXIgaXMgcmVhY2hhYmxlIGJ1dCBidXN5L3VuYXZhaWxhYmxlXHJcbiAgICAgICAgY2FzZSAxMDAxOiAvLyBHb2luZyBBd2F5XHJcbiAgICAgICAgY2FzZSAxMDEyOiAvLyBTZXJ2aWNlIFJlc3RhcnRcclxuICAgICAgICBjYXNlIDEwMTM6IC8vIFRyeSBBZ2FpbiBMYXRlclxyXG4gICAgICAgIGNhc2UgMTAxNDogLy8gQmFkIEdhdGV3YXlcclxuICAgICAgICAgICAgcmV0dXJuIEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5VUFNUUkVBTV9VTkFWQUlMQUJMRTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVmYXVsdCBhbGwgb3RoZXIgY29kZXMgdG8gZ2VuZXJpYyBpbnRlcm5hbCBlcnJvclxyXG4gICAgcmV0dXJuIEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5TRVJWRVJfRVJST1I7XHJcblxyXG59O1xyXG5cbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQSByZWFkZXIgd2hpY2ggYXV0b21hdGljYWxseSBoYW5kbGVzIHRoZSBnaXZlbiBpbnB1dCBzdHJlYW0sIHJldHVybmluZ1xyXG4gKiBzdHJpY3RseSB0ZXh0IGRhdGEuIE5vdGUgdGhhdCB0aGlzIG9iamVjdCB3aWxsIG92ZXJ3cml0ZSBhbnkgaW5zdGFsbGVkIGV2ZW50XHJcbiAqIGhhbmRsZXJzIG9uIHRoZSBnaXZlbiBHdWFjYW1vbGUuSW5wdXRTdHJlYW0uXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuSW5wdXRTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIHRoYXQgZGF0YSB3aWxsIGJlIHJlYWRcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlN0cmluZ1JlYWRlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLklucHV0U3RyZWFtLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGd1YWNfcmVhZGVyID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyYXBwZWQgR3VhY2Ftb2xlLkFycmF5QnVmZmVyUmVhZGVyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtHdWFjYW1vbGUuQXJyYXlCdWZmZXJSZWFkZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBhcnJheV9yZWFkZXIgPSBuZXcgR3VhY2Ftb2xlLkFycmF5QnVmZmVyUmVhZGVyKHN0cmVhbSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHJlbWFpbmluZyBmb3IgdGhlIGN1cnJlbnQgY29kZXBvaW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgYnl0ZXNfcmVtYWluaW5nID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IGNvZGVwb2ludCB2YWx1ZSwgYXMgY2FsY3VsYXRlZCBmcm9tIGJ5dGVzIHJlYWQgc28gZmFyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgY29kZXBvaW50ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgdGhlIGdpdmVuIFVURi04IGRhdGEgaW50byBhIFVuaWNvZGUgc3RyaW5nLiBUaGUgZGF0YSBtYXkgZW5kIGluXHJcbiAgICAgKiB0aGUgbWlkZGxlIG9mIGEgbXVsdGlieXRlIGNoYXJhY3Rlci5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciBBcmJpdHJhcnkgVVRGLTggZGF0YS5cclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQSBkZWNvZGVkIFVuaWNvZGUgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfX2RlY29kZV91dGY4KGJ1ZmZlcikge1xyXG5cclxuICAgICAgICB2YXIgdGV4dCA9IFwiXCI7XHJcblxyXG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGJ5dGVzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBieXRlXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGJ5dGVzW2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RhcnQgbmV3IGNvZGVwb2ludCBpZiBub3RoaW5nIHlldCByZWFkXHJcbiAgICAgICAgICAgIGlmIChieXRlc19yZW1haW5pbmcgPT09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAxIGJ5dGUgKDB4eHh4eHh4KVxyXG4gICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSB8IDB4N0YpID09PSAweDdGKVxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMiBieXRlICgxMTB4eHh4eClcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh2YWx1ZSB8IDB4MUYpID09PSAweERGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZXBvaW50ID0gdmFsdWUgJiAweDFGO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzX3JlbWFpbmluZyA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMyBieXRlICgxMTEweHh4eClcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh2YWx1ZSB8IDB4MEYgKT09PSAweEVGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZXBvaW50ID0gdmFsdWUgJiAweDBGO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzX3JlbWFpbmluZyA9IDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gNCBieXRlICgxMTExMHh4eClcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh2YWx1ZSB8IDB4MDcpID09PSAweEY3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZXBvaW50ID0gdmFsdWUgJiAweDA3O1xyXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzX3JlbWFpbmluZyA9IDM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW52YWxpZCBieXRlXHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcIlxcdUZGRkRcIjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIGV4aXN0aW5nIGNvZGVwb2ludCAoMTB4eHh4eHgpXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCh2YWx1ZSB8IDB4M0YpID09PSAweEJGKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29kZXBvaW50ID0gKGNvZGVwb2ludCA8PCA2KSB8ICh2YWx1ZSAmIDB4M0YpO1xyXG4gICAgICAgICAgICAgICAgYnl0ZXNfcmVtYWluaW5nLS07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgY29kZXBvaW50IGlmIGZpbmlzaGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXNfcmVtYWluaW5nID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlcG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW52YWxpZCBieXRlXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnl0ZXNfcmVtYWluaW5nID0gMDtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gXCJcXHVGRkZEXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVjZWl2ZSBibG9icyBhcyBzdHJpbmdzXHJcbiAgICBhcnJheV9yZWFkZXIub25kYXRhID0gZnVuY3Rpb24oYnVmZmVyKSB7XHJcblxyXG4gICAgICAgIC8vIERlY29kZSBVVEYtOFxyXG4gICAgICAgIHZhciB0ZXh0ID0gX19kZWNvZGVfdXRmOChidWZmZXIpO1xyXG5cclxuICAgICAgICAvLyBDYWxsIGhhbmRsZXIsIGlmIHByZXNlbnRcclxuICAgICAgICBpZiAoZ3VhY19yZWFkZXIub250ZXh0KVxyXG4gICAgICAgICAgICBndWFjX3JlYWRlci5vbnRleHQodGV4dCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTaW1wbHkgY2FsbCBvbmVuZCB3aGVuIGVuZCByZWNlaXZlZFxyXG4gICAgYXJyYXlfcmVhZGVyLm9uZW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGd1YWNfcmVhZGVyLm9uZW5kKVxyXG4gICAgICAgICAgICBndWFjX3JlYWRlci5vbmVuZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIG9uY2UgZm9yIGV2ZXJ5IGJsb2Igb2YgdGV4dCBkYXRhIHJlY2VpdmVkLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBkYXRhIHBhY2tldCByZWNlaXZlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbnRleHQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgb25jZSB0aGlzIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgbm8gZnVydGhlciBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cclxuICAgICAqIEBldmVudFxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uZW5kID0gbnVsbDtcclxuXHJcbn07XG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgd3JpdGVyIHdoaWNoIGF1dG9tYXRpY2FsbHkgd3JpdGVzIHRvIHRoZSBnaXZlbiBvdXRwdXQgc3RyZWFtIHdpdGggdGV4dFxyXG4gKiBkYXRhLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3VhY2Ftb2xlLk91dHB1dFN0cmVhbX0gc3RyZWFtIFRoZSBzdHJlYW0gdGhhdCBkYXRhIHdpbGwgYmUgd3JpdHRlblxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0by5cclxuICovXHJcbkd1YWNhbW9sZS5TdHJpbmdXcml0ZXIgPSBmdW5jdGlvbihzdHJlYW0pIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIEd1YWNhbW9sZS5TdHJpbmdXcml0ZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3VhY193cml0ZXIgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JhcHBlZCBHdWFjYW1vbGUuQXJyYXlCdWZmZXJXcml0ZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5BcnJheUJ1ZmZlcldyaXRlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIGFycmF5X3dyaXRlciA9IG5ldyBHdWFjYW1vbGUuQXJyYXlCdWZmZXJXcml0ZXIoc3RyZWFtKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGJ1ZmZlciBmb3IgVVRGLTggb3V0cHV0LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDgxOTIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBieXRlcyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlci5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBsZW5ndGggPSAwO1xyXG5cclxuICAgIC8vIFNpbXBseSBjYWxsIG9uYWNrIGZvciBhY2tub3dsZWRnZW1lbnRzXHJcbiAgICBhcnJheV93cml0ZXIub25hY2sgPSBmdW5jdGlvbihzdGF0dXMpIHtcclxuICAgICAgICBpZiAoZ3VhY193cml0ZXIub25hY2spXHJcbiAgICAgICAgICAgIGd1YWNfd3JpdGVyLm9uYWNrKHN0YXR1cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwYW5kcyB0aGUgc2l6ZSBvZiB0aGUgdW5kZXJseWluZyBidWZmZXIgYnkgdGhlIGdpdmVuIG51bWJlciBvZiBieXRlcyxcclxuICAgICAqIHVwZGF0aW5nIHRoZSBsZW5ndGggYXBwcm9wcmlhdGVseS5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBieXRlcyBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGFkZCB0byB0aGUgdW5kZXJseWluZ1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX19leHBhbmQoYnl0ZXMpIHtcclxuXHJcbiAgICAgICAgLy8gUmVzaXplIGJ1ZmZlciBpZiBtb3JlIHNwYWNlIG5lZWRlZFxyXG4gICAgICAgIGlmIChsZW5ndGgrYnl0ZXMgPj0gYnVmZmVyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3X2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KChsZW5ndGgrYnl0ZXMpKjIpO1xyXG4gICAgICAgICAgICBuZXdfYnVmZmVyLnNldChidWZmZXIpO1xyXG4gICAgICAgICAgICBidWZmZXIgPSBuZXdfYnVmZmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGVuZ3RoICs9IGJ5dGVzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgYSBzaW5nbGUgVW5pY29kZSBjaGFyYWN0ZXIgdG8gdGhlIGN1cnJlbnQgYnVmZmVyLCByZXNpemluZyB0aGVcclxuICAgICAqIGJ1ZmZlciBpZiBuZWNlc3NhcnkuIFRoZSBjaGFyYWN0ZXIgd2lsbCBiZSBlbmNvZGVkIGFzIFVURi04LlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVwb2ludCBUaGUgY29kZXBvaW50IG9mIHRoZSBVbmljb2RlIGNoYXJhY3RlciB0b1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9fYXBwZW5kX3V0ZjgoY29kZXBvaW50KSB7XHJcblxyXG4gICAgICAgIHZhciBtYXNrO1xyXG4gICAgICAgIHZhciBieXRlcztcclxuXHJcbiAgICAgICAgLy8gMSBieXRlXHJcbiAgICAgICAgaWYgKGNvZGVwb2ludCA8PSAweDdGKSB7XHJcbiAgICAgICAgICAgIG1hc2sgPSAweDAwO1xyXG4gICAgICAgICAgICBieXRlcyA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAyIGJ5dGVcclxuICAgICAgICBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHg3RkYpIHtcclxuICAgICAgICAgICAgbWFzayA9IDB4QzA7XHJcbiAgICAgICAgICAgIGJ5dGVzID0gMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDMgYnl0ZVxyXG4gICAgICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweEZGRkYpIHtcclxuICAgICAgICAgICAgbWFzayA9IDB4RTA7XHJcbiAgICAgICAgICAgIGJ5dGVzID0gMztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDQgYnl0ZVxyXG4gICAgICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweDFGRkZGRikge1xyXG4gICAgICAgICAgICBtYXNrID0gMHhGMDtcclxuICAgICAgICAgICAgYnl0ZXMgPSA0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgaW52YWxpZCBjb2RlcG9pbnQsIGFwcGVuZCByZXBsYWNlbWVudCBjaGFyYWN0ZXJcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX19hcHBlbmRfdXRmOCgweEZGRkQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPZmZzZXQgYnVmZmVyIGJ5IHNpemVcclxuICAgICAgICBfX2V4cGFuZChieXRlcyk7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IGxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0cmFpbGluZyBieXRlcywgaWYgYW55XHJcbiAgICAgICAgZm9yICh2YXIgaT0xOyBpPGJ5dGVzOyBpKyspIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldC0tXSA9IDB4ODAgfCAoY29kZXBvaW50ICYgMHgzRik7XHJcbiAgICAgICAgICAgIGNvZGVwb2ludCA+Pj0gNjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNldCBpbml0aWFsIGJ5dGVcclxuICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IG1hc2sgfCBjb2RlcG9pbnQ7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gc3RyaW5nIGFzIFVURi04LCByZXR1cm5pbmcgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZ1xyXG4gICAgICogdGhlIHJlc3VsdGluZyBieXRlcy5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBzdHJpbmcgdG8gZW5jb2RlIGFzIFVURi04LlxyXG4gICAgICogQHJldHVybiB7VWludDhBcnJheX0gVGhlIGVuY29kZWQgVVRGLTggZGF0YS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX19lbmNvZGVfdXRmOCh0ZXh0KSB7XHJcblxyXG4gICAgICAgIC8vIEZpbGwgYnVmZmVyIHdpdGggVVRGLThcclxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY29kZXBvaW50ID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICBfX2FwcGVuZF91dGY4KGNvZGVwb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGbHVzaCBidWZmZXJcclxuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgb3V0X2J1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheSgwLCBsZW5ndGgpO1xyXG4gICAgICAgICAgICBsZW5ndGggPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0X2J1ZmZlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgdGhlIGdpdmVuIHRleHQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlbmQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VuZFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoKVxyXG4gICAgICAgICAgICBhcnJheV93cml0ZXIuc2VuZERhdGEoX19lbmNvZGVfdXRmOCh0ZXh0KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmFscyB0aGF0IG5vIGZ1cnRoZXIgdGV4dCB3aWxsIGJlIHNlbnQsIGVmZmVjdGl2ZWx5IGNsb3NpbmcgdGhlXHJcbiAgICAgKiBzdHJlYW0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VuZEVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFycmF5X3dyaXRlci5zZW5kRW5kKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgZm9yIHJlY2VpdmVkIGRhdGEsIGlmIGFja25vd2xlZGdlZCBieSB0aGUgc2VydmVyLlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5TdGF0dXN9IHN0YXR1cyBUaGUgc3RhdHVzIG9mIHRoZSBvcGVyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25hY2sgPSBudWxsO1xyXG5cclxufTtcbi8qXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBHdWFjYW1vbGUgPSBHdWFjYW1vbGUgfHwge307XHJcblxyXG4vKipcclxuICogQ29yZSBvYmplY3QgcHJvdmlkaW5nIGFic3RyYWN0IGNvbW11bmljYXRpb24gZm9yIEd1YWNhbW9sZS4gVGhpcyBvYmplY3RcclxuICogaXMgYSBudWxsIGltcGxlbWVudGF0aW9uIHdob3NlIGZ1bmN0aW9ucyBkbyBub3RoaW5nLiBHdWFjYW1vbGUgYXBwbGljYXRpb25zXHJcbiAqIHNob3VsZCB1c2Uge0BsaW5rIEd1YWNhbW9sZS5IVFRQVHVubmVsfSBpbnN0ZWFkLCBvciBpbXBsZW1lbnQgdGhlaXIgb3duIHR1bm5lbCBiYXNlZFxyXG4gKiBvbiB0aGlzIG9uZS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAc2VlIEd1YWNhbW9sZS5IVFRQVHVubmVsXHJcbiAqL1xyXG5HdWFjYW1vbGUuVHVubmVsID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0IHRvIHRoZSB0dW5uZWwgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uYWwgZGF0YS4gVGhpcyBkYXRhIGlzXHJcbiAgICAgKiB0eXBpY2FsbHkgdXNlZCBmb3IgYXV0aGVudGljYXRpb24uIFRoZSBmb3JtYXQgb2YgZGF0YSBhY2NlcHRlZCBpc1xyXG4gICAgICogdXAgdG8gdGhlIHR1bm5lbCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gc2VuZCB0byB0aGUgdHVubmVsIHdoZW4gY29ubmVjdGluZy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24oZGF0YSkge307XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogRGlzY29ubmVjdCBmcm9tIHRoZSB0dW5uZWwuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge307XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogU2VuZCB0aGUgZ2l2ZW4gbWVzc2FnZSB0aHJvdWdoIHRoZSB0dW5uZWwgdG8gdGhlIHNlcnZpY2Ugb24gdGhlIG90aGVyXHJcbiAgICAgKiBzaWRlLiBBbGwgbWVzc2FnZXMgYXJlIGd1YXJhbnRlZWQgdG8gYmUgcmVjZWl2ZWQgaW4gdGhlIG9yZGVyIHNlbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7Li4uKn0gZWxlbWVudHNcclxuICAgICAqICAgICBUaGUgZWxlbWVudHMgb2YgdGhlIG1lc3NhZ2UgdG8gc2VuZCB0byB0aGUgc2VydmljZSBvbiB0aGUgb3RoZXIgc2lkZVxyXG4gICAgICogICAgIG9mIHRoZSB0dW5uZWwuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbihlbGVtZW50cykge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBzdG9yZWQgbnVtZXJpYyBzdGF0ZSBvZiB0aGlzIHR1bm5lbCwgZmlyaW5nIHRoZSBvbnN0YXRlY2hhbmdlXHJcbiAgICAgKiBldmVudCBpZiB0aGUgbmV3IHN0YXRlIGlzIGRpZmZlcmVudCBhbmQgYSBoYW5kbGVyIGhhcyBiZWVuIGRlZmluZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0ZVxyXG4gICAgICogICAgIFRoZSBuZXcgc3RhdGUgb2YgdGhpcyB0dW5uZWwuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xyXG5cclxuICAgICAgICAvLyBOb3RpZnkgb25seSBpZiBzdGF0ZSBjaGFuZ2VzXHJcbiAgICAgICAgaWYgKHN0YXRlICE9PSB0aGlzLnN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25zdGF0ZWNoYW5nZSlcclxuICAgICAgICAgICAgICAgIHRoaXMub25zdGF0ZWNoYW5nZShzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBzdG9yZWQgVVVJRCB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhpcyB0dW5uZWwsIGZpcmluZyB0aGVcclxuICAgICAqIG9udXVpZCBldmVudCBpZiBhIGhhbmRsZXIgaGFzIGJlZW4gZGVmaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHV1aWRcclxuICAgICAqICAgICBUaGUgbmV3IHN0YXRlIG9mIHRoaXMgdHVubmVsLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNldFVVSUQgPSBmdW5jdGlvbiBzZXRVVUlEKHV1aWQpIHtcclxuICAgICAgICB0aGlzLnV1aWQgPSB1dWlkO1xyXG4gICAgICAgIGlmICh0aGlzLm9udXVpZClcclxuICAgICAgICAgICAgdGhpcy5vbnV1aWQodXVpZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgdHVubmVsIGlzIGN1cnJlbnRseSBjb25uZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKiAgICAgdHJ1ZSBpZiB0aGlzIHR1bm5lbCBpcyBjdXJyZW50bHkgY29ubmVjdGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbiBpc0Nvbm5lY3RlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5PUEVOXHJcbiAgICAgICAgICAgIHx8IHRoaXMuc3RhdGUgPT09IEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuVU5TVEFCTEU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyB0dW5uZWwuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RhdGUgPSBHdWFjYW1vbGUuVHVubmVsLlN0YXRlLkNPTk5FQ1RJTkc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciBkYXRhIHRvIGJlIHJlY2VpdmVkLCBpblxyXG4gICAgICogbWlsbGlzZWNvbmRzLiBJZiBkYXRhIGlzIG5vdCByZWNlaXZlZCB3aXRoaW4gdGhpcyBhbW91bnQgb2YgdGltZSxcclxuICAgICAqIHRoZSB0dW5uZWwgaXMgY2xvc2VkIHdpdGggYW4gZXJyb3IuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDE1MDAwLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVjZWl2ZVRpbWVvdXQgPSAxNTAwMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciBkYXRhIHRvIGJlIHJlY2VpdmVkIGJlZm9yZSBjb25zaWRlcmluZ1xyXG4gICAgICogdGhlIGNvbm5lY3Rpb24gdG8gYmUgdW5zdGFibGUsIGluIG1pbGxpc2Vjb25kcy4gSWYgZGF0YSBpcyBub3QgcmVjZWl2ZWRcclxuICAgICAqIHdpdGhpbiB0aGlzIGFtb3VudCBvZiB0aW1lLCB0aGUgdHVubmVsIHN0YXR1cyBpcyB1cGRhdGVkIHRvIHdhcm4gdGhhdFxyXG4gICAgICogdGhlIGNvbm5lY3Rpb24gYXBwZWFycyB1bnJlc3BvbnNpdmUgYW5kIG1heSBjbG9zZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXNcclxuICAgICAqIDE1MDAuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5zdGFibGVUaHJlc2hvbGQgPSAxNTAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFVVSUQgdW5pcXVlbHkgaWRlbnRpZnlpbmcgdGhpcyB0dW5uZWwuIElmIG5vdCB5ZXQga25vd24sIHRoaXMgd2lsbFxyXG4gICAgICogYmUgbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnV1aWQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiB0aGUgVVVJRCB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhpcyB0dW5uZWwgaXMga25vd24uXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ31cclxuICAgICAqICAgICBUaGUgVVVJRCB1bmlxdWVseSBpZGVudGlmeWluZyB0aGlzIHR1bm5lbC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbnV1aWQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgYnkgdGhlIHR1bm5lbC5cclxuICAgICAqIFxyXG4gICAgICogQGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5TdGF0dXN9IHN0YXR1cyBBIHN0YXR1cyBvYmplY3Qgd2hpY2ggZGVzY3JpYmVzIHRoZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25lcnJvciA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgc3RhdGUgb2YgdGhlIHR1bm5lbCBjaGFuZ2VzLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0ZSBUaGUgbmV3IHN0YXRlIG9mIHRoZSBjbGllbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub25zdGF0ZWNoYW5nZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCBvbmNlIGZvciBldmVyeSBjb21wbGV0ZSBHdWFjYW1vbGUgaW5zdHJ1Y3Rpb24gcmVjZWl2ZWQsIGluIG9yZGVyLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXZlbnRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcGNvZGUgVGhlIEd1YWNhbW9sZSBpbnN0cnVjdGlvbiBvcGNvZGUuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIHByb3ZpZGVkIGZvciB0aGUgaW5zdHJ1Y3Rpb24sXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGFueS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmluc3RydWN0aW9uID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIEd1YWNhbW9sZSBwcm90b2NvbCBpbnN0cnVjdGlvbiBvcGNvZGUgcmVzZXJ2ZWQgZm9yIGFyYml0cmFyeSBpbnRlcm5hbFxyXG4gKiB1c2UgYnkgdHVubmVsIGltcGxlbWVudGF0aW9ucy4gVGhlIHZhbHVlIG9mIHRoaXMgb3Bjb2RlIGlzIGd1YXJhbnRlZWQgdG8gYmVcclxuICogdGhlIGVtcHR5IHN0cmluZyAoXCJcIikuIFR1bm5lbCBpbXBsZW1lbnRhdGlvbnMgbWF5IHVzZSB0aGlzIG9wY29kZSBmb3IgYW55XHJcbiAqIHB1cnBvc2UuIEl0IGlzIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBIVFRQIHR1bm5lbCB0byBtYXJrIHRoZSBlbmQgb2YgdGhlIEhUVFBcclxuICogcmVzcG9uc2UsIGFuZCBieSB0aGUgV2ViU29ja2V0IHR1bm5lbCB0byB0cmFuc21pdCB0aGUgdHVubmVsIFVVSUQgYW5kIHNlbmRcclxuICogY29ubmVjdGlvbiBzdGFiaWxpdHkgdGVzdCBwaW5ncy9yZXNwb25zZXMuXHJcbiAqXHJcbiAqIEBjb25zdGFudFxyXG4gKiBAdHlwZSB7U3RyaW5nfVxyXG4gKi9cclxuR3VhY2Ftb2xlLlR1bm5lbC5JTlRFUk5BTF9EQVRBX09QQ09ERSA9ICcnO1xyXG5cclxuLyoqXHJcbiAqIEFsbCBwb3NzaWJsZSB0dW5uZWwgc3RhdGVzLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY29ubmVjdGlvbiBpcyBpbiBwZW5kaW5nLiBJdCBpcyBub3QgeWV0IGtub3duIHdoZXRoZXIgY29ubmVjdGlvbiB3YXNcclxuICAgICAqIHN1Y2Nlc3NmdWwuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiQ09OTkVDVElOR1wiOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdGlvbiB3YXMgc3VjY2Vzc2Z1bCwgYW5kIGRhdGEgaXMgYmVpbmcgcmVjZWl2ZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFwiT1BFTlwiOiAxLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLiBDb25uZWN0aW9uIG1heSBub3QgaGF2ZSBiZWVuIHN1Y2Nlc3NmdWwsIHRoZVxyXG4gICAgICogdHVubmVsIG1heSBoYXZlIGJlZW4gZXhwbGljaXRseSBjbG9zZWQgYnkgZWl0aGVyIHNpZGUsIG9yIGFuIGVycm9yIG1heVxyXG4gICAgICogaGF2ZSBvY2N1cnJlZC5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJDTE9TRURcIjogMixcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIG9wZW4sIGJ1dCBjb21tdW5pY2F0aW9uIHRocm91Z2ggdGhlIHR1bm5lbCBhcHBlYXJzIHRvXHJcbiAgICAgKiBiZSBkaXNydXB0ZWQsIGFuZCB0aGUgY29ubmVjdGlvbiBtYXkgY2xvc2UgYXMgYSByZXN1bHQuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgXCJVTlNUQUJMRVwiIDogM1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHdWFjYW1vbGUgVHVubmVsIGltcGxlbWVudGVkIG92ZXIgSFRUUCB2aWEgWE1MSHR0cFJlcXVlc3QuXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1Z21lbnRzIEd1YWNhbW9sZS5UdW5uZWxcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHR1bm5lbFVSTFxyXG4gKiAgICAgVGhlIFVSTCBvZiB0aGUgSFRUUCB0dW5uZWxpbmcgc2VydmljZS5cclxuICpcclxuICogQHBhcmFtIHtCb29sZWFufSBbY3Jvc3NEb21haW49ZmFsc2VdXHJcbiAqICAgICBXaGV0aGVyIHR1bm5lbCByZXF1ZXN0cyB3aWxsIGJlIGNyb3NzLWRvbWFpbiwgYW5kIHRodXMgbXVzdCB1c2UgQ09SU1xyXG4gKiAgICAgbWVjaGFuaXNtcyBhbmQgaGVhZGVycy4gQnkgZGVmYXVsdCwgaXQgaXMgYXNzdW1lZCB0aGF0IHR1bm5lbCByZXF1ZXN0c1xyXG4gKiAgICAgd2lsbCBiZSBtYWRlIHRvIHRoZSBzYW1lIGRvbWFpbi5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtleHRyYVR1bm5lbEhlYWRlcnM9e31dXHJcbiAqICAgICBLZXkgdmFsdWUgcGFpcnMgY29udGFpbmluZyB0aGUgaGVhZGVyIG5hbWVzIGFuZCB2YWx1ZXMgb2YgYW55IGFkZGl0aW9uYWxcclxuICogICAgIGhlYWRlcnMgdG8gYmUgc2VudCBpbiB0dW5uZWwgcmVxdWVzdHMuIEJ5IGRlZmF1bHQsIG5vIGV4dHJhIGhlYWRlcnMgd2lsbFxyXG4gKiAgICAgYmUgYWRkZWQuXHJcbiAqL1xyXG5HdWFjYW1vbGUuSFRUUFR1bm5lbCA9IGZ1bmN0aW9uKHR1bm5lbFVSTCwgY3Jvc3NEb21haW4sIGV4dHJhVHVubmVsSGVhZGVycykge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgSFRUUCB0dW5uZWwuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgdHVubmVsID0gdGhpcztcclxuXHJcbiAgICB2YXIgVFVOTkVMX0NPTk5FQ1QgPSB0dW5uZWxVUkwgKyBcIj9jb25uZWN0XCI7XHJcbiAgICB2YXIgVFVOTkVMX1JFQUQgICAgPSB0dW5uZWxVUkwgKyBcIj9yZWFkOlwiO1xyXG4gICAgdmFyIFRVTk5FTF9XUklURSAgID0gdHVubmVsVVJMICsgXCI/d3JpdGU6XCI7XHJcblxyXG4gICAgdmFyIFBPTExJTkdfRU5BQkxFRCAgICAgPSAxO1xyXG4gICAgdmFyIFBPTExJTkdfRElTQUJMRUQgICAgPSAwO1xyXG5cclxuICAgIC8vIERlZmF1bHQgdG8gcG9sbGluZyAtIHdpbGwgYmUgdHVybmVkIG9mZiBhdXRvbWF0aWNhbGx5IGlmIG5vdCBuZWVkZWRcclxuICAgIHZhciBwb2xsaW5nTW9kZSA9IFBPTExJTkdfRU5BQkxFRDtcclxuXHJcbiAgICB2YXIgc2VuZGluZ01lc3NhZ2VzID0gZmFsc2U7XHJcbiAgICB2YXIgb3V0cHV0TWVzc2FnZUJ1ZmZlciA9IFwiXCI7XHJcblxyXG4gICAgLy8gSWYgcmVxdWVzdHMgYXJlIGV4cGVjdGVkIHRvIGJlIGNyb3NzLWRvbWFpbiwgdGhlIGNvb2tpZSB0aGF0IHRoZSBIVFRQXHJcbiAgICAvLyB0dW5uZWwgZGVwZW5kcyBvbiB3aWxsIG9ubHkgYmUgc2VudCBpZiB3aXRoQ3JlZGVudGlhbHMgaXMgdHJ1ZVxyXG4gICAgdmFyIHdpdGhDcmVkZW50aWFscyA9ICEhY3Jvc3NEb21haW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCByZWNlaXZlIHRpbWVvdXQgSUQsIGlmIGFueS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciByZWNlaXZlX3RpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGFiaWxpdHkgdGltZW91dCBJRCwgaWYgYW55LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgdW5zdGFibGVUaW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IGNvbm5lY3Rpb24gc3RhYmlsaXR5IHRlc3QgcGluZyBpbnRlcnZhbCBJRCwgaWYgYW55LiBUaGlzXHJcbiAgICAgKiB3aWxsIG9ubHkgYmUgc2V0IHVwb24gc3VjY2Vzc2Z1bCBjb25uZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgcGluZ0ludGVydmFsID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmV0d2VlbiBjb25uZWN0aW9uIHN0YWJpbGl0eSB0ZXN0XHJcbiAgICAgKiBwaW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgUElOR19GUkVRVUVOQ1kgPSA1MDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRpdGlvbmFsIGhlYWRlcnMgdG8gYmUgc2VudCBpbiB0dW5uZWwgcmVxdWVzdHMuIFRoaXMgZGljdGlvbmFyeSBjYW4gYmVcclxuICAgICAqIHBvcHVsYXRlZCB3aXRoIGtleS92YWx1ZSBoZWFkZXIgcGFpcnMgdG8gcGFzcyBpbmZvcm1hdGlvbiBzdWNoIGFzIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgKiB0b2tlbnMsIGV0Yy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgZXh0cmFIZWFkZXJzID0gZXh0cmFUdW5uZWxIZWFkZXJzIHx8IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgY29uZmlndXJlZCBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gdGhlIGdpdmVuIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdH0gcmVxdWVzdFxyXG4gICAgICogICAgIFRoZSByZXF1ZXN0IHdoZXJlIHRoZSBjb25maWd1cmVkIGV4dHJhIGhlYWRlcnMgd2lsbCBiZSBhZGRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xyXG4gICAgICogICAgIFRoZSBoZWFkZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZEV4dHJhSGVhZGVycyhyZXF1ZXN0LCBoZWFkZXJzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBoZWFkZXJzW25hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWF0ZXMgYSB0aW1lb3V0IHdoaWNoLCBpZiBkYXRhIGlzIG5vdCByZWNlaXZlZCwgY2F1c2VzIHRoZSB0dW5uZWxcclxuICAgICAqIHRvIGNsb3NlIHdpdGggYW4gZXJyb3IuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlc2V0X3RpbWVvdXQoKSB7XHJcblxyXG4gICAgICAgIC8vIEdldCByaWQgb2Ygb2xkIHRpbWVvdXRzIChpZiBhbnkpXHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChyZWNlaXZlX3RpbWVvdXQpO1xyXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodW5zdGFibGVUaW1lb3V0KTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgdW5zdGFibGUgc3RhdHVzXHJcbiAgICAgICAgaWYgKHR1bm5lbC5zdGF0ZSA9PT0gR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5VTlNUQUJMRSlcclxuICAgICAgICAgICAgdHVubmVsLnNldFN0YXRlKEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuT1BFTik7XHJcblxyXG4gICAgICAgIC8vIFNldCBuZXcgdGltZW91dCBmb3IgdHJhY2tpbmcgb3ZlcmFsbCBjb25uZWN0aW9uIHRpbWVvdXRcclxuICAgICAgICByZWNlaXZlX3RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNsb3NlX3R1bm5lbChuZXcgR3VhY2Ftb2xlLlN0YXR1cyhHdWFjYW1vbGUuU3RhdHVzLkNvZGUuVVBTVFJFQU1fVElNRU9VVCwgXCJTZXJ2ZXIgdGltZW91dC5cIikpO1xyXG4gICAgICAgIH0sIHR1bm5lbC5yZWNlaXZlVGltZW91dCk7XHJcblxyXG4gICAgICAgIC8vIFNldCBuZXcgdGltZW91dCBmb3IgdHJhY2tpbmcgc3VzcGVjdGVkIGNvbm5lY3Rpb24gaW5zdGFiaWxpdHlcclxuICAgICAgICB1bnN0YWJsZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdHVubmVsLnNldFN0YXRlKEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuVU5TVEFCTEUpO1xyXG4gICAgICAgIH0sIHR1bm5lbC51bnN0YWJsZVRocmVzaG9sZCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoaXMgdHVubmVsLCBzaWduYWxpbmcgdGhlIGdpdmVuIHN0YXR1cyBhbmQgY29ycmVzcG9uZGluZ1xyXG4gICAgICogbWVzc2FnZSwgd2hpY2ggd2lsbCBiZSBzZW50IHRvIHRoZSBvbmVycm9yIGhhbmRsZXIgaWYgdGhlIHN0YXR1cyBpc1xyXG4gICAgICogYW4gZXJyb3Igc3RhdHVzLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuU3RhdHVzfSBzdGF0dXMgVGhlIHN0YXR1cyBjYXVzaW5nIHRoZSBjb25uZWN0aW9uIHRvXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2xvc2VfdHVubmVsKHN0YXR1cykge1xyXG5cclxuICAgICAgICAvLyBHZXQgcmlkIG9mIG9sZCB0aW1lb3V0cyAoaWYgYW55KVxyXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocmVjZWl2ZV90aW1lb3V0KTtcclxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHVuc3RhYmxlVGltZW91dCk7XHJcblxyXG4gICAgICAgIC8vIENlYXNlIGNvbm5lY3Rpb24gdGVzdCBwaW5nc1xyXG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHBpbmdJbnRlcnZhbCk7XHJcblxyXG4gICAgICAgIC8vIElnbm9yZSBpZiBhbHJlYWR5IGNsb3NlZFxyXG4gICAgICAgIGlmICh0dW5uZWwuc3RhdGUgPT09IEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuQ0xPU0VEKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIElmIGNvbm5lY3Rpb24gY2xvc2VkIGFibm9ybWFsbHksIHNpZ25hbCBlcnJvci5cclxuICAgICAgICBpZiAoc3RhdHVzLmNvZGUgIT09IEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5TVUNDRVNTICYmIHR1bm5lbC5vbmVycm9yKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZ25vcmUgUkVTT1VSQ0VfTk9UX0ZPVU5EIGlmIHdlJ3ZlIGFscmVhZHkgY29ubmVjdGVkLCBhcyB0aGF0XHJcbiAgICAgICAgICAgIC8vIG9ubHkgc2lnbmFscyBlbmQtb2Ytc3RyZWFtIGZvciB0aGUgSFRUUCB0dW5uZWwuXHJcbiAgICAgICAgICAgIGlmICh0dW5uZWwuc3RhdGUgPT09IEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuQ09OTkVDVElOR1xyXG4gICAgICAgICAgICAgICAgICAgIHx8IHN0YXR1cy5jb2RlICE9PSBHdWFjYW1vbGUuU3RhdHVzLkNvZGUuUkVTT1VSQ0VfTk9UX0ZPVU5EKVxyXG4gICAgICAgICAgICAgICAgdHVubmVsLm9uZXJyb3Ioc3RhdHVzKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXNldCBvdXRwdXQgbWVzc2FnZSBidWZmZXJcclxuICAgICAgICBzZW5kaW5nTWVzc2FnZXMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gTWFyayBhcyBjbG9zZWRcclxuICAgICAgICB0dW5uZWwuc2V0U3RhdGUoR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5DTE9TRUQpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgdGhpcy5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byBzZW5kIG1lc3NhZ2VzIGlmIG5vdCBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoIXR1bm5lbC5pc0Nvbm5lY3RlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHNlbmQgZW1wdHkgbWVzc2FnZXNcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgdG8gYSBsZW5ndGgvc3RyaW5nIHBhaXIgZm9yIHVzZSBhcyBhblxyXG4gICAgICAgICAqIGVsZW1lbnQgaW4gYSBHdWFjYW1vbGUgaW5zdHJ1Y3Rpb24uXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29udmVydGVkIHZhbHVlLiBcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBnZXRFbGVtZW50KHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSBuZXcgU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGggKyBcIi5cIiArIHN0cmluZzsgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplZCBtZXNzYWdlIHdpdGggZmlyc3QgZWxlbWVudFxyXG4gICAgICAgIHZhciBtZXNzYWdlID0gZ2V0RWxlbWVudChhcmd1bWVudHNbMF0pO1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgcmVtYWluaW5nIGVsZW1lbnRzXHJcbiAgICAgICAgZm9yICh2YXIgaT0xOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBcIixcIiArIGdldEVsZW1lbnQoYXJndW1lbnRzW2ldKTtcclxuXHJcbiAgICAgICAgLy8gRmluYWwgdGVybWluYXRvclxyXG4gICAgICAgIG1lc3NhZ2UgKz0gXCI7XCI7XHJcblxyXG4gICAgICAgIC8vIEFkZCBtZXNzYWdlIHRvIGJ1ZmZlclxyXG4gICAgICAgIG91dHB1dE1lc3NhZ2VCdWZmZXIgKz0gbWVzc2FnZTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBpZiBub3QgY3VycmVudGx5IHNlbmRpbmdcclxuICAgICAgICBpZiAoIXNlbmRpbmdNZXNzYWdlcylcclxuICAgICAgICAgICAgc2VuZFBlbmRpbmdNZXNzYWdlcygpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gc2VuZFBlbmRpbmdNZXNzYWdlcygpIHtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gc2VuZCBtZXNzYWdlcyBpZiBub3QgY29ubmVjdGVkXHJcbiAgICAgICAgaWYgKCF0dW5uZWwuaXNDb25uZWN0ZWQoKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAob3V0cHV0TWVzc2FnZUJ1ZmZlci5sZW5ndGggPiAwKSB7XHJcblxyXG4gICAgICAgICAgICBzZW5kaW5nTWVzc2FnZXMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2VfeG1saHR0cHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgbWVzc2FnZV94bWxodHRwcmVxdWVzdC5vcGVuKFwiUE9TVFwiLCBUVU5ORUxfV1JJVEUgKyB0dW5uZWwudXVpZCk7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VfeG1saHR0cHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzO1xyXG4gICAgICAgICAgICBhZGRFeHRyYUhlYWRlcnMobWVzc2FnZV94bWxodHRwcmVxdWVzdCwgZXh0cmFIZWFkZXJzKTtcclxuICAgICAgICAgICAgbWVzc2FnZV94bWxodHRwcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gT25jZSByZXNwb25zZSByZWNlaXZlZCwgc2VuZCBuZXh0IHF1ZXVlZCBldmVudC5cclxuICAgICAgICAgICAgbWVzc2FnZV94bWxodHRwcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlX3htbGh0dHByZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRfdGltZW91dCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIHNlbmQsIGhhbmRsZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlX3htbGh0dHByZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVIVFRQVHVubmVsRXJyb3IobWVzc2FnZV94bWxodHRwcmVxdWVzdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY29udGludWUgdGhlIHNlbmQgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFBlbmRpbmdNZXNzYWdlcygpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIG1lc3NhZ2VfeG1saHR0cHJlcXVlc3Quc2VuZChvdXRwdXRNZXNzYWdlQnVmZmVyKTtcclxuICAgICAgICAgICAgb3V0cHV0TWVzc2FnZUJ1ZmZlciA9IFwiXCI7IC8vIENsZWFyIGJ1ZmZlclxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBzZW5kaW5nTWVzc2FnZXMgPSBmYWxzZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlSFRUUFR1bm5lbEVycm9yKHhtbGh0dHByZXF1ZXN0KSB7XHJcblxyXG4gICAgICAgIC8vIFB1bGwgc3RhdHVzIGNvZGUgZGlyZWN0bHkgZnJvbSBoZWFkZXJzIHByb3ZpZGVkIGJ5IEd1YWNhbW9sZVxyXG4gICAgICAgIHZhciBjb2RlID0gcGFyc2VJbnQoeG1saHR0cHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoXCJHdWFjYW1vbGUtU3RhdHVzLUNvZGVcIikpO1xyXG4gICAgICAgIGlmIChjb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0geG1saHR0cHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoXCJHdWFjYW1vbGUtRXJyb3ItTWVzc2FnZVwiKTtcclxuICAgICAgICAgICAgY2xvc2VfdHVubmVsKG5ldyBHdWFjYW1vbGUuU3RhdHVzKGNvZGUsIG1lc3NhZ2UpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZhaWxpbmcgdGhhdCwgZGVyaXZlIGEgR3VhY2Ftb2xlIHN0YXR1cyBjb2RlIGZyb20gdGhlIEhUVFAgc3RhdHVzXHJcbiAgICAgICAgLy8gY29kZSBwcm92aWRlZCBieSB0aGUgYnJvd3NlclxyXG4gICAgICAgIGVsc2UgaWYgKHhtbGh0dHByZXF1ZXN0LnN0YXR1cylcclxuICAgICAgICAgICAgY2xvc2VfdHVubmVsKG5ldyBHdWFjYW1vbGUuU3RhdHVzKFxyXG4gICAgICAgICAgICAgICAgR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLmZyb21IVFRQQ29kZSh4bWxodHRwcmVxdWVzdC5zdGF0dXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHhtbGh0dHByZXF1ZXN0LnN0YXR1c1RleHQpKTtcclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgc2VydmVyIGlzIHVucmVhY2hhYmxlXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBjbG9zZV90dW5uZWwobmV3IEd1YWNhbW9sZS5TdGF0dXMoR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlVQU1RSRUFNX05PVF9GT1VORCkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZSh4bWxodHRwcmVxdWVzdCkge1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBudWxsO1xyXG4gICAgICAgIHZhciBuZXh0UmVxdWVzdCA9IG51bGw7XHJcblxyXG4gICAgICAgIHZhciBkYXRhVXBkYXRlRXZlbnRzID0gMDtcclxuXHJcbiAgICAgICAgLy8gVGhlIGxvY2F0aW9uIG9mIHRoZSBsYXN0IGVsZW1lbnQncyB0ZXJtaW5hdG9yXHJcbiAgICAgICAgdmFyIGVsZW1lbnRFbmQgPSAtMTtcclxuXHJcbiAgICAgICAgLy8gV2hlcmUgdG8gc3RhcnQgdGhlIG5leHQgbGVuZ3RoIHNlYXJjaCBvciB0aGUgbmV4dCBlbGVtZW50XHJcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSAwO1xyXG5cclxuICAgICAgICAvLyBQYXJzZWQgZWxlbWVudHNcclxuICAgICAgICB2YXIgZWxlbWVudHMgPSBuZXcgQXJyYXkoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcGFyc2VSZXNwb25zZSgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIERvIG5vdCBoYW5kbGUgcmVzcG9uc2VzIGlmIG5vdCBjb25uZWN0ZWRcclxuICAgICAgICAgICAgaWYgKCF0dW5uZWwuaXNDb25uZWN0ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBpbnRlcnZhbCBpZiBwb2xsaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJ2YWwgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRG8gbm90IHBhcnNlIHJlc3BvbnNlIHlldCBpZiBub3QgcmVhZHlcclxuICAgICAgICAgICAgaWYgKHhtbGh0dHByZXF1ZXN0LnJlYWR5U3RhdGUgPCAyKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHJlYWQgc3RhdHVzXHJcbiAgICAgICAgICAgIHZhciBzdGF0dXM7XHJcbiAgICAgICAgICAgIHRyeSB7IHN0YXR1cyA9IHhtbGh0dHByZXF1ZXN0LnN0YXR1czsgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgc3RhdHVzIGNvdWxkIG5vdCBiZSByZWFkLCBhc3N1bWUgc3VjY2Vzc2Z1bC5cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgc3RhdHVzID0gMjAwOyB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdGFydCBuZXh0IHJlcXVlc3QgYXMgc29vbiBhcyBwb3NzaWJsZSBJRiByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsXHJcbiAgICAgICAgICAgIGlmICghbmV4dFJlcXVlc3QgJiYgc3RhdHVzID09PSAyMDApXHJcbiAgICAgICAgICAgICAgICBuZXh0UmVxdWVzdCA9IG1ha2VSZXF1ZXN0KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBQYXJzZSBzdHJlYW0gd2hlbiBkYXRhIGlzIHJlY2VpdmVkIGFuZCB3aGVuIGNvbXBsZXRlLlxyXG4gICAgICAgICAgICBpZiAoeG1saHR0cHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gMyB8fFxyXG4gICAgICAgICAgICAgICAgeG1saHR0cHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJlc2V0X3RpbWVvdXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBbHNvIHBvbGwgZXZlcnkgMzBtcyAoc29tZSBicm93c2VycyBkb24ndCByZXBlYXRlZGx5IGNhbGwgb25yZWFkeXN0YXRlY2hhbmdlIGZvciBuZXcgZGF0YSlcclxuICAgICAgICAgICAgICAgIGlmIChwb2xsaW5nTW9kZSA9PT0gUE9MTElOR19FTkFCTEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhtbGh0dHByZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDMgJiYgIWludGVydmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKHBhcnNlUmVzcG9uc2UsIDMwKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4bWxodHRwcmVxdWVzdC5yZWFkeVN0YXRlID09PSA0ICYmIGludGVydmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBjYW5jZWxlZCwgc3RvcCB0cmFuc2ZlclxyXG4gICAgICAgICAgICAgICAgaWYgKHhtbGh0dHByZXF1ZXN0LnN0YXR1cyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR1bm5lbC5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbHQgb24gZXJyb3IgZHVyaW5nIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHhtbGh0dHByZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSFRUUFR1bm5lbEVycm9yKHhtbGh0dHByZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byByZWFkIGluLXByb2dyZXNzIGRhdGFcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgdHJ5IHsgY3VycmVudCA9IHhtbGh0dHByZXF1ZXN0LnJlc3BvbnNlVGV4dDsgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHBhcnNlIGlmIGRhdGEgY291bGQgbm90IGJlIHJlYWRcclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdoaWxlIHNlYXJjaCBpcyB3aXRoaW4gY3VycmVudGx5IHJlY2VpdmVkIGRhdGFcclxuICAgICAgICAgICAgICAgIHdoaWxlIChlbGVtZW50RW5kIDwgY3VycmVudC5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHdhaXRpbmcgZm9yIGVsZW1lbnQgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50RW5kID49IHN0YXJ0SW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5vdyBoYXZlIGVub3VnaCBkYXRhIGZvciB0aGUgZWxlbWVudC4gUGFyc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY3VycmVudC5zdWJzdHJpbmcoc3RhcnRJbmRleCwgZWxlbWVudEVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hdG9yID0gY3VycmVudC5zdWJzdHJpbmcoZWxlbWVudEVuZCwgZWxlbWVudEVuZCsxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50IHRvIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBsYXN0IGVsZW1lbnQsIGhhbmRsZSBpbnN0cnVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVybWluYXRvciA9PT0gXCI7XCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgb3Bjb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3Bjb2RlID0gZWxlbWVudHMuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGluc3RydWN0aW9uIGhhbmRsZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHVubmVsLm9uaW5zdHJ1Y3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHVubmVsLm9uaW5zdHJ1Y3Rpb24ob3Bjb2RlLCBlbGVtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBzZWFyY2hpbmcgZm9yIGxlbmd0aCBhdCBjaGFyYWN0ZXIgYWZ0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCB0ZXJtaW5hdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBlbGVtZW50RW5kICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIGVuZCBvZiBsZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoRW5kID0gY3VycmVudC5pbmRleE9mKFwiLlwiLCBzdGFydEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoRW5kICE9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJzZUludChjdXJyZW50LnN1YnN0cmluZyhlbGVtZW50RW5kKzEsIGxlbmd0aEVuZCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgZG9uZSBwYXJzaW5nLCBoYW5kbGUgdGhlIG5leHQgcmVzcG9uc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBpbnRlcnZhbCBpZiBwb2xsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJ2YWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWxodHRwcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeG1saHR0cHJlcXVlc3QuYWJvcnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBoYW5kbGluZyBuZXh0IHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UmVxdWVzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVSZXNwb25zZShuZXh0UmVxdWVzdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uZSBwYXJzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzdGFydCBvZiBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBsZW5ndGhFbmQgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGxvY2F0aW9uIG9mIGVsZW1lbnQgdGVybWluYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50RW5kID0gc3RhcnRJbmRleCArIGxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIHBlcmlvZCB5ZXQsIGNvbnRpbnVlIHNlYXJjaCB3aGVuIG1vcmUgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIHJlY2VpdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBjdXJyZW50Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gLy8gZW5kIHBhcnNlIGxvb3BcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiByZXNwb25zZSBwb2xsaW5nIGVuYWJsZWQsIGF0dGVtcHQgdG8gZGV0ZWN0IGlmIHN0aWxsXHJcbiAgICAgICAgLy8gbmVjZXNzYXJ5ICh2aWEgd3JhcHBpbmcgcGFyc2VSZXNwb25zZSgpKVxyXG4gICAgICAgIGlmIChwb2xsaW5nTW9kZSA9PT0gUE9MTElOR19FTkFCTEVEKSB7XHJcbiAgICAgICAgICAgIHhtbGh0dHByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlY2VpdmUgdHdvIG9yIG1vcmUgcmVhZHlTdGF0ZT09MyBldmVudHMsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIHRvIHBvbGwuXHJcbiAgICAgICAgICAgICAgICBpZiAoeG1saHR0cHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVcGRhdGVFdmVudHMrKztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVVwZGF0ZUV2ZW50cyA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbGxpbmdNb2RlID0gUE9MTElOR19ESVNBQkxFRDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeG1saHR0cHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gcGFyc2VSZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcGFyc2VSZXNwb25zZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHBhcnNlXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB4bWxodHRwcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBwYXJzZVJlc3BvbnNlO1xyXG5cclxuICAgICAgICBwYXJzZVJlc3BvbnNlKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJiaXRyYXJ5IGludGVnZXIsIHVuaXF1ZSBmb3IgZWFjaCB0dW5uZWwgcmVhZCByZXF1ZXN0LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHJlcXVlc3RfaWQgPSAwO1xyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KCkge1xyXG5cclxuICAgICAgICAvLyBNYWtlIHJlcXVlc3QsIGluY3JlbWVudCByZXF1ZXN0IElEXHJcbiAgICAgICAgdmFyIHhtbGh0dHByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgeG1saHR0cHJlcXVlc3Qub3BlbihcIkdFVFwiLCBUVU5ORUxfUkVBRCArIHR1bm5lbC51dWlkICsgXCI6XCIgKyAocmVxdWVzdF9pZCsrKSk7XHJcbiAgICAgICAgeG1saHR0cHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzO1xyXG4gICAgICAgIGFkZEV4dHJhSGVhZGVycyh4bWxodHRwcmVxdWVzdCwgZXh0cmFIZWFkZXJzKTtcclxuICAgICAgICB4bWxodHRwcmVxdWVzdC5zZW5kKG51bGwpO1xyXG5cclxuICAgICAgICByZXR1cm4geG1saHR0cHJlcXVlc3Q7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29ubmVjdCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHJcbiAgICAgICAgLy8gU3RhcnQgd2FpdGluZyBmb3IgY29ubmVjdFxyXG4gICAgICAgIHJlc2V0X3RpbWVvdXQoKTtcclxuXHJcbiAgICAgICAgLy8gTWFyayB0aGUgdHVubmVsIGFzIGNvbm5lY3RpbmdcclxuICAgICAgICB0dW5uZWwuc2V0U3RhdGUoR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5DT05ORUNUSU5HKTtcclxuXHJcbiAgICAgICAgLy8gU3RhcnQgdHVubmVsIGFuZCBjb25uZWN0XHJcbiAgICAgICAgdmFyIGNvbm5lY3RfeG1saHR0cHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICBjb25uZWN0X3htbGh0dHByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbm5lY3RfeG1saHR0cHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGZhaWx1cmUsIHRocm93IGVycm9yXHJcbiAgICAgICAgICAgIGlmIChjb25uZWN0X3htbGh0dHByZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVIVFRQVHVubmVsRXJyb3IoY29ubmVjdF94bWxodHRwcmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc2V0X3RpbWVvdXQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBVVUlEIGZyb20gcmVzcG9uc2VcclxuICAgICAgICAgICAgdHVubmVsLnNldFVVSUQoY29ubmVjdF94bWxodHRwcmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFyayBhcyBvcGVuXHJcbiAgICAgICAgICAgIHR1bm5lbC5zZXRTdGF0ZShHdWFjYW1vbGUuVHVubmVsLlN0YXRlLk9QRU4pO1xyXG5cclxuICAgICAgICAgICAgLy8gUGluZyB0dW5uZWwgZW5kcG9pbnQgcmVndWxhcmx5IHRvIHRlc3QgY29ubmVjdGlvbiBzdGFiaWxpdHlcclxuICAgICAgICAgICAgcGluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gc2VuZFBpbmcoKSB7XHJcbiAgICAgICAgICAgICAgICB0dW5uZWwuc2VuZE1lc3NhZ2UoXCJub3BcIik7XHJcbiAgICAgICAgICAgIH0sIFBJTkdfRlJFUVVFTkNZKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IHJlYWRpbmcgZGF0YVxyXG4gICAgICAgICAgICBoYW5kbGVSZXNwb25zZShtYWtlUmVxdWVzdCgpKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29ubmVjdF94bWxodHRwcmVxdWVzdC5vcGVuKFwiUE9TVFwiLCBUVU5ORUxfQ09OTkVDVCwgdHJ1ZSk7XHJcbiAgICAgICAgY29ubmVjdF94bWxodHRwcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgYWRkRXh0cmFIZWFkZXJzKGNvbm5lY3RfeG1saHR0cHJlcXVlc3QsIGV4dHJhSGVhZGVycyk7XHJcbiAgICAgICAgY29ubmVjdF94bWxodHRwcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIpO1xyXG4gICAgICAgIGNvbm5lY3RfeG1saHR0cHJlcXVlc3Quc2VuZChkYXRhKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNsb3NlX3R1bm5lbChuZXcgR3VhY2Ftb2xlLlN0YXR1cyhHdWFjYW1vbGUuU3RhdHVzLkNvZGUuU1VDQ0VTUywgXCJNYW51YWxseSBjbG9zZWQuXCIpKTtcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuR3VhY2Ftb2xlLkhUVFBUdW5uZWwucHJvdG90eXBlID0gbmV3IEd1YWNhbW9sZS5UdW5uZWwoKTtcclxuXHJcbi8qKlxyXG4gKiBHdWFjYW1vbGUgVHVubmVsIGltcGxlbWVudGVkIG92ZXIgV2ViU29ja2V0IHZpYSBYTUxIdHRwUmVxdWVzdC5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXVnbWVudHMgR3VhY2Ftb2xlLlR1bm5lbFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHVubmVsVVJMIFRoZSBVUkwgb2YgdGhlIFdlYlNvY2tldCB0dW5uZWxpbmcgc2VydmljZS5cclxuICovXHJcbkd1YWNhbW9sZS5XZWJTb2NrZXRUdW5uZWwgPSBmdW5jdGlvbih0dW5uZWxVUkwpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGlzIFdlYlNvY2tldCB0dW5uZWwuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgdHVubmVsID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBXZWJTb2NrZXQgdXNlZCBieSB0aGlzIHR1bm5lbC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBzb2NrZXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgcmVjZWl2ZSB0aW1lb3V0IElELCBpZiBhbnkuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgcmVjZWl2ZV90aW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IGNvbm5lY3Rpb24gc3RhYmlsaXR5IHRpbWVvdXQgSUQsIGlmIGFueS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIHVuc3RhYmxlVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBjb25uZWN0aW9uIHN0YWJpbGl0eSB0ZXN0IHBpbmcgaW50ZXJ2YWwgSUQsIGlmIGFueS4gVGhpc1xyXG4gICAgICogd2lsbCBvbmx5IGJlIHNldCB1cG9uIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIHBpbmdJbnRlcnZhbCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgV2ViU29ja2V0IHByb3RvY29sIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3RvY29sIHVzZWQgZm9yIHRoZSBjdXJyZW50XHJcbiAgICAgKiBsb2NhdGlvbi5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciB3c19wcm90b2NvbCA9IHtcclxuICAgICAgICBcImh0dHA6XCI6ICBcIndzOlwiLFxyXG4gICAgICAgIFwiaHR0cHM6XCI6IFwid3NzOlwiXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuIGNvbm5lY3Rpb24gc3RhYmlsaXR5IHRlc3RcclxuICAgICAqIHBpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBQSU5HX0ZSRVFVRU5DWSA9IDUwMDtcclxuXHJcbiAgICAvLyBUcmFuc2Zvcm0gY3VycmVudCBVUkwgdG8gV2ViU29ja2V0IFVSTFxyXG5cclxuICAgIC8vIElmIG5vdCBhbHJlYWR5IGEgd2Vic29ja2V0IFVSTFxyXG4gICAgaWYgKCAgIHR1bm5lbFVSTC5zdWJzdHJpbmcoMCwgMykgIT09IFwid3M6XCJcclxuICAgICAgICAmJiB0dW5uZWxVUkwuc3Vic3RyaW5nKDAsIDQpICE9PSBcIndzczpcIikge1xyXG5cclxuICAgICAgICB2YXIgcHJvdG9jb2wgPSB3c19wcm90b2NvbFt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2xdO1xyXG5cclxuICAgICAgICAvLyBJZiBhYnNvbHV0ZSBVUkwsIGNvbnZlcnQgdG8gYWJzb2x1dGUgV1MgVVJMXHJcbiAgICAgICAgaWYgKHR1bm5lbFVSTC5zdWJzdHJpbmcoMCwgMSkgPT09IFwiL1wiKVxyXG4gICAgICAgICAgICB0dW5uZWxVUkwgPVxyXG4gICAgICAgICAgICAgICAgcHJvdG9jb2xcclxuICAgICAgICAgICAgICAgICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3RcclxuICAgICAgICAgICAgICAgICsgdHVubmVsVVJMO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGNvbnN0cnVjdCBhYnNvbHV0ZSBmcm9tIHJlbGF0aXZlIFVSTFxyXG4gICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHBhdGggZnJvbSBwYXRobmFtZVxyXG4gICAgICAgICAgICB2YXIgc2xhc2ggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUubGFzdEluZGV4T2YoXCIvXCIpO1xyXG4gICAgICAgICAgICB2YXIgcGF0aCAgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyaW5nKDAsIHNsYXNoICsgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgYWJzb2x1dGUgVVJMXHJcbiAgICAgICAgICAgIHR1bm5lbFVSTCA9XHJcbiAgICAgICAgICAgICAgICBwcm90b2NvbFxyXG4gICAgICAgICAgICAgICAgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdFxyXG4gICAgICAgICAgICAgICAgKyBwYXRoXHJcbiAgICAgICAgICAgICAgICArIHR1bm5lbFVSTDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYXRlcyBhIHRpbWVvdXQgd2hpY2gsIGlmIGRhdGEgaXMgbm90IHJlY2VpdmVkLCBjYXVzZXMgdGhlIHR1bm5lbFxyXG4gICAgICogdG8gY2xvc2Ugd2l0aCBhbiBlcnJvci5cclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVzZXRfdGltZW91dCgpIHtcclxuXHJcbiAgICAgICAgLy8gR2V0IHJpZCBvZiBvbGQgdGltZW91dHMgKGlmIGFueSlcclxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJlY2VpdmVfdGltZW91dCk7XHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh1bnN0YWJsZVRpbWVvdXQpO1xyXG5cclxuICAgICAgICAvLyBDbGVhciB1bnN0YWJsZSBzdGF0dXNcclxuICAgICAgICBpZiAodHVubmVsLnN0YXRlID09PSBHdWFjYW1vbGUuVHVubmVsLlN0YXRlLlVOU1RBQkxFKVxyXG4gICAgICAgICAgICB0dW5uZWwuc2V0U3RhdGUoR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5PUEVOKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IG5ldyB0aW1lb3V0IGZvciB0cmFja2luZyBvdmVyYWxsIGNvbm5lY3Rpb24gdGltZW91dFxyXG4gICAgICAgIHJlY2VpdmVfdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2xvc2VfdHVubmVsKG5ldyBHdWFjYW1vbGUuU3RhdHVzKEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5VUFNUUkVBTV9USU1FT1VULCBcIlNlcnZlciB0aW1lb3V0LlwiKSk7XHJcbiAgICAgICAgfSwgdHVubmVsLnJlY2VpdmVUaW1lb3V0KTtcclxuXHJcbiAgICAgICAgLy8gU2V0IG5ldyB0aW1lb3V0IGZvciB0cmFja2luZyBzdXNwZWN0ZWQgY29ubmVjdGlvbiBpbnN0YWJpbGl0eVxyXG4gICAgICAgIHVuc3RhYmxlVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0dW5uZWwuc2V0U3RhdGUoR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5VTlNUQUJMRSk7XHJcbiAgICAgICAgfSwgdHVubmVsLnVuc3RhYmxlVGhyZXNob2xkKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhpcyB0dW5uZWwsIHNpZ25hbGluZyB0aGUgZ2l2ZW4gc3RhdHVzIGFuZCBjb3JyZXNwb25kaW5nXHJcbiAgICAgKiBtZXNzYWdlLCB3aGljaCB3aWxsIGJlIHNlbnQgdG8gdGhlIG9uZXJyb3IgaGFuZGxlciBpZiB0aGUgc3RhdHVzIGlzXHJcbiAgICAgKiBhbiBlcnJvciBzdGF0dXMuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0d1YWNhbW9sZS5TdGF0dXN9IHN0YXR1cyBUaGUgc3RhdHVzIGNhdXNpbmcgdGhlIGNvbm5lY3Rpb24gdG9cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbG9zZV90dW5uZWwoc3RhdHVzKSB7XHJcblxyXG4gICAgICAgIC8vIEdldCByaWQgb2Ygb2xkIHRpbWVvdXRzIChpZiBhbnkpXHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChyZWNlaXZlX3RpbWVvdXQpO1xyXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodW5zdGFibGVUaW1lb3V0KTtcclxuXHJcbiAgICAgICAgLy8gQ2Vhc2UgY29ubmVjdGlvbiB0ZXN0IHBpbmdzXHJcbiAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwocGluZ0ludGVydmFsKTtcclxuXHJcbiAgICAgICAgLy8gSWdub3JlIGlmIGFscmVhZHkgY2xvc2VkXHJcbiAgICAgICAgaWYgKHR1bm5lbC5zdGF0ZSA9PT0gR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5DTE9TRUQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gSWYgY29ubmVjdGlvbiBjbG9zZWQgYWJub3JtYWxseSwgc2lnbmFsIGVycm9yLlxyXG4gICAgICAgIGlmIChzdGF0dXMuY29kZSAhPT0gR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlNVQ0NFU1MgJiYgdHVubmVsLm9uZXJyb3IpXHJcbiAgICAgICAgICAgIHR1bm5lbC5vbmVycm9yKHN0YXR1cyk7XHJcblxyXG4gICAgICAgIC8vIE1hcmsgYXMgY2xvc2VkXHJcbiAgICAgICAgdHVubmVsLnNldFN0YXRlKEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuQ0xPU0VEKTtcclxuXHJcbiAgICAgICAgc29ja2V0LmNsb3NlKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbihlbGVtZW50cykge1xyXG5cclxuICAgICAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byBzZW5kIG1lc3NhZ2VzIGlmIG5vdCBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoIXR1bm5lbC5pc0Nvbm5lY3RlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHNlbmQgZW1wdHkgbWVzc2FnZXNcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgdG8gYSBsZW5ndGgvc3RyaW5nIHBhaXIgZm9yIHVzZSBhcyBhblxyXG4gICAgICAgICAqIGVsZW1lbnQgaW4gYSBHdWFjYW1vbGUgaW5zdHJ1Y3Rpb24uXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29udmVydGVkIHZhbHVlLiBcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBnZXRFbGVtZW50KHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSBuZXcgU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGggKyBcIi5cIiArIHN0cmluZzsgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplZCBtZXNzYWdlIHdpdGggZmlyc3QgZWxlbWVudFxyXG4gICAgICAgIHZhciBtZXNzYWdlID0gZ2V0RWxlbWVudChhcmd1bWVudHNbMF0pO1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgcmVtYWluaW5nIGVsZW1lbnRzXHJcbiAgICAgICAgZm9yICh2YXIgaT0xOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBcIixcIiArIGdldEVsZW1lbnQoYXJndW1lbnRzW2ldKTtcclxuXHJcbiAgICAgICAgLy8gRmluYWwgdGVybWluYXRvclxyXG4gICAgICAgIG1lc3NhZ2UgKz0gXCI7XCI7XHJcblxyXG4gICAgICAgIHNvY2tldC5zZW5kKG1lc3NhZ2UpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24oZGF0YSkge1xyXG5cclxuICAgICAgICByZXNldF90aW1lb3V0KCk7XHJcblxyXG4gICAgICAgIC8vIE1hcmsgdGhlIHR1bm5lbCBhcyBjb25uZWN0aW5nXHJcbiAgICAgICAgdHVubmVsLnNldFN0YXRlKEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuQ09OTkVDVElORyk7XHJcblxyXG4gICAgICAgIC8vIENvbm5lY3Qgc29ja2V0XHJcbiAgICAgICAgc29ja2V0ID0gbmV3IFdlYlNvY2tldCh0dW5uZWxVUkwgKyBcIj9cIiArIGRhdGEsIFwiZ3VhY2Ftb2xlXCIpO1xyXG5cclxuICAgICAgICBzb2NrZXQub25vcGVuID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgcmVzZXRfdGltZW91dCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUGluZyB0dW5uZWwgZW5kcG9pbnQgcmVndWxhcmx5IHRvIHRlc3QgY29ubmVjdGlvbiBzdGFiaWxpdHlcclxuICAgICAgICAgICAgcGluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gc2VuZFBpbmcoKSB7XHJcbiAgICAgICAgICAgICAgICB0dW5uZWwuc2VuZE1lc3NhZ2UoR3VhY2Ftb2xlLlR1bm5lbC5JTlRFUk5BTF9EQVRBX09QQ09ERSxcclxuICAgICAgICAgICAgICAgICAgICBcInBpbmdcIiwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICB9LCBQSU5HX0ZSRVFVRU5DWSk7XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNvY2tldC5vbmNsb3NlID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFB1bGwgc3RhdHVzIGNvZGUgZGlyZWN0bHkgZnJvbSBjbG9zdXJlIHJlYXNvbiBwcm92aWRlZCBieSBHdWFjYW1vbGVcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnJlYXNvbilcclxuICAgICAgICAgICAgICAgIGNsb3NlX3R1bm5lbChuZXcgR3VhY2Ftb2xlLlN0YXR1cyhwYXJzZUludChldmVudC5yZWFzb24pLCBldmVudC5yZWFzb24pKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZhaWxpbmcgdGhhdCwgZGVyaXZlIGEgR3VhY2Ftb2xlIHN0YXR1cyBjb2RlIGZyb20gdGhlIFdlYlNvY2tldFxyXG4gICAgICAgICAgICAvLyBzdGF0dXMgY29kZSBwcm92aWRlZCBieSB0aGUgYnJvd3NlclxyXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5jb2RlKVxyXG4gICAgICAgICAgICAgICAgY2xvc2VfdHVubmVsKG5ldyBHdWFjYW1vbGUuU3RhdHVzKEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5mcm9tV2ViU29ja2V0Q29kZShldmVudC5jb2RlKSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgc2VydmVyIGlzIHVucmVhY2hhYmxlXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGNsb3NlX3R1bm5lbChuZXcgR3VhY2Ftb2xlLlN0YXR1cyhHdWFjYW1vbGUuU3RhdHVzLkNvZGUuVVBTVFJFQU1fTk9UX0ZPVU5EKSk7XHJcblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgc29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblxyXG4gICAgICAgICAgICByZXNldF90aW1lb3V0KCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRFbmQ7XHJcblxyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGRvIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIGVuZCBvZiBsZW5ndGhcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGhFbmQgPSBtZXNzYWdlLmluZGV4T2YoXCIuXCIsIHN0YXJ0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEVuZCAhPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KG1lc3NhZ2Uuc3Vic3RyaW5nKGVsZW1lbnRFbmQrMSwgbGVuZ3RoRW5kKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzdGFydCBvZiBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IGxlbmd0aEVuZCArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBsb2NhdGlvbiBvZiBlbGVtZW50IHRlcm1pbmF0b3JcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50RW5kID0gc3RhcnRJbmRleCArIGxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIElmIG5vIHBlcmlvZCwgaW5jb21wbGV0ZSBpbnN0cnVjdGlvbi5cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjbG9zZV90dW5uZWwobmV3IEd1YWNhbW9sZS5TdGF0dXMoR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlNFUlZFUl9FUlJPUiwgXCJJbmNvbXBsZXRlIGluc3RydWN0aW9uLlwiKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugbm93IGhhdmUgZW5vdWdoIGRhdGEgZm9yIHRoZSBlbGVtZW50LiBQYXJzZS5cclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gbWVzc2FnZS5zdWJzdHJpbmcoc3RhcnRJbmRleCwgZWxlbWVudEVuZCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVybWluYXRvciA9IG1lc3NhZ2Uuc3Vic3RyaW5nKGVsZW1lbnRFbmQsIGVsZW1lbnRFbmQrMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGVsZW1lbnQgdG8gYXJyYXlcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbGFzdCBlbGVtZW50LCBoYW5kbGUgaW5zdHJ1Y3Rpb25cclxuICAgICAgICAgICAgICAgIGlmICh0ZXJtaW5hdG9yID09PSBcIjtcIikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgb3Bjb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wY29kZSA9IGVsZW1lbnRzLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZSBhbmQgVVVJRCB3aGVuIGZpcnN0IGluc3RydWN0aW9uIHJlY2VpdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR1bm5lbC51dWlkID09PSBudWxsKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NvY2lhdGUgdHVubmVsIFVVSUQgaWYgcmVjZWl2ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wY29kZSA9PT0gR3VhY2Ftb2xlLlR1bm5lbC5JTlRFUk5BTF9EQVRBX09QQ09ERSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1bm5lbC5zZXRVVUlEKGVsZW1lbnRzWzBdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR1bm5lbCBpcyBub3cgb3BlbiBhbmQgVVVJRCBpcyBhdmFpbGFibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHVubmVsLnNldFN0YXRlKEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuT1BFTik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBpbnN0cnVjdGlvbiBoYW5kbGVyLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGNvZGUgIT09IEd1YWNhbW9sZS5UdW5uZWwuSU5URVJOQUxfREFUQV9PUENPREUgJiYgdHVubmVsLm9uaW5zdHJ1Y3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1bm5lbC5vbmluc3RydWN0aW9uKG9wY29kZSwgZWxlbWVudHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHNlYXJjaGluZyBmb3IgbGVuZ3RoIGF0IGNoYXJhY3RlciBhZnRlclxyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCB0ZXJtaW5hdG9yXHJcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gZWxlbWVudEVuZCArIDE7XHJcblxyXG4gICAgICAgICAgICB9IHdoaWxlIChzdGFydEluZGV4IDwgbWVzc2FnZS5sZW5ndGgpO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2xvc2VfdHVubmVsKG5ldyBHdWFjYW1vbGUuU3RhdHVzKEd1YWNhbW9sZS5TdGF0dXMuQ29kZS5TVUNDRVNTLCBcIk1hbnVhbGx5IGNsb3NlZC5cIikpO1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5HdWFjYW1vbGUuV2ViU29ja2V0VHVubmVsLnByb3RvdHlwZSA9IG5ldyBHdWFjYW1vbGUuVHVubmVsKCk7XHJcblxyXG4vKipcclxuICogR3VhY2Ftb2xlIFR1bm5lbCB3aGljaCBjeWNsZXMgYmV0d2VlbiBhbGwgc3BlY2lmaWVkIHR1bm5lbHMgdW50aWxcclxuICogbm8gdHVubmVscyBhcmUgbGVmdC4gQW5vdGhlciB0dW5uZWwgaXMgdXNlZCBpZiBhbiBlcnJvciBvY2N1cnMgYnV0XHJcbiAqIG5vIGluc3RydWN0aW9ucyBoYXZlIGJlZW4gcmVjZWl2ZWQuIElmIGFuIGluc3RydWN0aW9uIGhhcyBiZWVuXHJcbiAqIHJlY2VpdmVkLCBvciBubyB0dW5uZWxzIHJlbWFpbiwgdGhlIGVycm9yIGlzIHBhc3NlZCBkaXJlY3RseSBvdXRcclxuICogdGhyb3VnaCB0aGUgb25lcnJvciBoYW5kbGVyIChpZiBkZWZpbmVkKS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXVnbWVudHMgR3VhY2Ftb2xlLlR1bm5lbFxyXG4gKiBAcGFyYW0gey4uLip9IHR1bm5lbENoYWluXHJcbiAqICAgICBUaGUgdHVubmVscyB0byB1c2UsIGluIG9yZGVyIG9mIHByaW9yaXR5LlxyXG4gKi9cclxuR3VhY2Ftb2xlLkNoYWluZWRUdW5uZWwgPSBmdW5jdGlvbih0dW5uZWxDaGFpbikge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgY2hhaW5lZCB0dW5uZWwuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgY2hhaW5lZF90dW5uZWwgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGF0YSBwYXNzZWQgaW4gdmlhIGNvbm5lY3QoKSwgdG8gYmUgdXNlZCBmb3JcclxuICAgICAqIHdyYXBwZWQgY2FsbHMgdG8gb3RoZXIgdHVubmVscycgY29ubmVjdCgpIGZ1bmN0aW9ucy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBjb25uZWN0X2RhdGE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBhbGwgdHVubmVscyBwYXNzZWQgdG8gdGhpcyBDaGFpbmVkVHVubmVsIHRocm91Z2ggdGhlXHJcbiAgICAgKiBjb25zdHJ1Y3RvciBhcmd1bWVudHMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgdHVubmVscyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR1bm5lbCBjb21taXR0ZWQgdmlhIGNvbW1pdF90dW5uZWwoKSwgaWYgYW55LCBvciBudWxsIGlmIG5vIHR1bm5lbFxyXG4gICAgICogaGFzIHlldCBiZWVuIGNvbW1pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0d1YWNhbW9sZS5UdW5uZWx9XHJcbiAgICAgKi9cclxuICAgIHZhciBjb21taXR0ZWRUdW5uZWwgPSBudWxsO1xyXG5cclxuICAgIC8vIExvYWQgYWxsIHR1bm5lbHMgaW50byBhcnJheVxyXG4gICAgZm9yICh2YXIgaT0wOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB0dW5uZWxzLnB1c2goYXJndW1lbnRzW2ldKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdHVubmVsLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtHdWFjYW1vbGUuVHVubmVsfSB0dW5uZWwgVGhlIHR1bm5lbCB0byBzZXQgYXMgdGhlIGN1cnJlbnQgdHVubmVsLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhdHRhY2godHVubmVsKSB7XHJcblxyXG4gICAgICAgIC8vIFNldCBvd24gZnVuY3Rpb25zIHRvIHR1bm5lbCdzIGZ1bmN0aW9uc1xyXG4gICAgICAgIGNoYWluZWRfdHVubmVsLmRpc2Nvbm5lY3QgID0gdHVubmVsLmRpc2Nvbm5lY3Q7XHJcbiAgICAgICAgY2hhaW5lZF90dW5uZWwuc2VuZE1lc3NhZ2UgPSB0dW5uZWwuc2VuZE1lc3NhZ2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZhaWxzIHRoZSBjdXJyZW50bHktYXR0YWNoZWQgdHVubmVsLCBhdHRhY2hpbmcgYSBuZXcgdHVubmVsIGlmXHJcbiAgICAgICAgICogcG9zc2libGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7R3VhY2Ftb2xlLlN0YXR1c30gW3N0YXR1c11cclxuICAgICAgICAgKiAgICAgQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZmFpbHVyZSB0aGF0IG9jY3VyZWQgaW4gdGhlXHJcbiAgICAgICAgICogICAgIGN1cnJlbnRseS1hdHRhY2hlZCB0dW5uZWwsIGlmIGtub3duLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7R3VhY2Ftb2xlLlR1bm5lbH1cclxuICAgICAgICAgKiAgICAgVGhlIG5leHQgdHVubmVsLCBvciBudWxsIGlmIHRoZXJlIGFyZSBubyBtb3JlIHR1bm5lbHMgdG8gdHJ5IG9yXHJcbiAgICAgICAgICogICAgIGlmIG5vIG1vcmUgdHVubmVscyBzaG91bGQgYmUgdHJpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGZhaWxUdW5uZWwgPSBmdW5jdGlvbiBmYWlsVHVubmVsKHN0YXR1cykge1xyXG5cclxuICAgICAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gY29udGludWUgdXNpbmcgbmV4dCB0dW5uZWwgb24gc2VydmVyIHRpbWVvdXRcclxuICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiBzdGF0dXMuY29kZSA9PT0gR3VhY2Ftb2xlLlN0YXR1cy5Db2RlLlVQU1RSRUFNX1RJTUVPVVQpIHtcclxuICAgICAgICAgICAgICAgIHR1bm5lbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgbmV4dCB0dW5uZWxcclxuICAgICAgICAgICAgdmFyIG5leHRfdHVubmVsID0gdHVubmVscy5zaGlmdCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgSVMgYSBuZXh0IHR1bm5lbCwgdHJ5IHVzaW5nIGl0LlxyXG4gICAgICAgICAgICBpZiAobmV4dF90dW5uZWwpIHtcclxuICAgICAgICAgICAgICAgIHR1bm5lbC5vbmVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHR1bm5lbC5vbmluc3RydWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHR1bm5lbC5vbnN0YXRlY2hhbmdlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGF0dGFjaChuZXh0X3R1bm5lbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0X3R1bm5lbDtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlIHRoZSBjdXJyZW50IHR1bm5lbCBmcm9tIHRoaXMgcG9pbnQgZm9yd2FyZC4gRG8gbm90IHRyeSBhbnkgbW9yZVxyXG4gICAgICAgICAqIHR1bm5lbHMsIGV2ZW4gaWYgdGhlIGN1cnJlbnQgdHVubmVsIGZhaWxzLlxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gY29tbWl0X3R1bm5lbCgpIHtcclxuXHJcbiAgICAgICAgICAgIHR1bm5lbC5vbnN0YXRlY2hhbmdlID0gY2hhaW5lZF90dW5uZWwub25zdGF0ZWNoYW5nZTtcclxuICAgICAgICAgICAgdHVubmVsLm9uaW5zdHJ1Y3Rpb24gPSBjaGFpbmVkX3R1bm5lbC5vbmluc3RydWN0aW9uO1xyXG4gICAgICAgICAgICB0dW5uZWwub25lcnJvciA9IGNoYWluZWRfdHVubmVsLm9uZXJyb3I7XHJcbiAgICAgICAgICAgIHR1bm5lbC5vbnV1aWQgPSBjaGFpbmVkX3R1bm5lbC5vbnV1aWQ7XHJcblxyXG4gICAgICAgICAgICAvLyBBc3NpZ24gVVVJRCBpZiBhbHJlYWR5IGtub3duXHJcbiAgICAgICAgICAgIGlmICh0dW5uZWwudXVpZClcclxuICAgICAgICAgICAgICAgIGNoYWluZWRfdHVubmVsLnNldFVVSUQodHVubmVsLnV1aWQpO1xyXG5cclxuICAgICAgICAgICAgY29tbWl0dGVkVHVubmVsID0gdHVubmVsO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdyYXAgb3duIG9uc3RhdGVjaGFuZ2Ugd2l0aGluIGN1cnJlbnQgdHVubmVsXHJcbiAgICAgICAgdHVubmVsLm9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihzdGF0ZSkge1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIG9wZW4sIHVzZSB0aGlzIHR1bm5lbCBmcm9tIHRoaXMgcG9pbnQgZm9yd2FyZC5cclxuICAgICAgICAgICAgICAgIGNhc2UgR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5PUEVOOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdF90dW5uZWwoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhaW5lZF90dW5uZWwub25zdGF0ZWNoYW5nZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5lZF90dW5uZWwub25zdGF0ZWNoYW5nZShzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgY2xvc2VkLCBtYXJrIGZhaWx1cmUsIGF0dGVtcHQgbmV4dCB0dW5uZWxcclxuICAgICAgICAgICAgICAgIGNhc2UgR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5DTE9TRUQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmYWlsVHVubmVsKCkgJiYgY2hhaW5lZF90dW5uZWwub25zdGF0ZWNoYW5nZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5lZF90dW5uZWwub25zdGF0ZWNoYW5nZShzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBXcmFwIG93biBvbmluc3RydWN0aW9uIHdpdGhpbiBjdXJyZW50IHR1bm5lbFxyXG4gICAgICAgIHR1bm5lbC5vbmluc3RydWN0aW9uID0gZnVuY3Rpb24ob3Bjb2RlLCBlbGVtZW50cykge1xyXG5cclxuICAgICAgICAgICAgLy8gQWNjZXB0IGN1cnJlbnQgdHVubmVsXHJcbiAgICAgICAgICAgIGNvbW1pdF90dW5uZWwoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEludm9rZSBoYW5kbGVyXHJcbiAgICAgICAgICAgIGlmIChjaGFpbmVkX3R1bm5lbC5vbmluc3RydWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgY2hhaW5lZF90dW5uZWwub25pbnN0cnVjdGlvbihvcGNvZGUsIGVsZW1lbnRzKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQXR0YWNoIG5leHQgdHVubmVsIG9uIGVycm9yXHJcbiAgICAgICAgdHVubmVsLm9uZXJyb3IgPSBmdW5jdGlvbihzdGF0dXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE1hcmsgZmFpbHVyZSwgYXR0ZW1wdCBuZXh0IHR1bm5lbFxyXG4gICAgICAgICAgICBpZiAoIWZhaWxUdW5uZWwoc3RhdHVzKSAmJiBjaGFpbmVkX3R1bm5lbC5vbmVycm9yKVxyXG4gICAgICAgICAgICAgICAgY2hhaW5lZF90dW5uZWwub25lcnJvcihzdGF0dXMpO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBBdHRlbXB0IGNvbm5lY3Rpb25cclxuICAgICAgICB0dW5uZWwuY29ubmVjdChjb25uZWN0X2RhdGEpO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29ubmVjdCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgIFxyXG4gICAgICAgIC8vIFJlbWVtYmVyIGNvbm5lY3QgZGF0YVxyXG4gICAgICAgIGNvbm5lY3RfZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgIC8vIEdldCBjb21taXR0ZWQgdHVubmVsIGlmIGV4aXN0cyBvciB0aGUgZmlyc3QgdHVubmVsIG9uIHRoZSBsaXN0XHJcbiAgICAgICAgdmFyIG5leHRfdHVubmVsID0gY29tbWl0dGVkVHVubmVsID8gY29tbWl0dGVkVHVubmVsIDogdHVubmVscy5zaGlmdCgpO1xyXG5cclxuICAgICAgICAvLyBBdHRhY2ggZmlyc3QgdHVubmVsXHJcbiAgICAgICAgaWYgKG5leHRfdHVubmVsKVxyXG4gICAgICAgICAgICBhdHRhY2gobmV4dF90dW5uZWwpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGVyZSBJUyBubyBmaXJzdCB0dW5uZWwsIGVycm9yXHJcbiAgICAgICAgZWxzZSBpZiAoY2hhaW5lZF90dW5uZWwub25lcnJvcilcclxuICAgICAgICAgICAgY2hhaW5lZF90dW5uZWwub25lcnJvcihHdWFjYW1vbGUuU3RhdHVzLkNvZGUuU0VSVkVSX0VSUk9SLCBcIk5vIHR1bm5lbHMgdG8gdHJ5LlwiKTtcclxuXHJcbiAgICB9O1xyXG4gICAgXHJcbn07XHJcblxyXG5HdWFjYW1vbGUuQ2hhaW5lZFR1bm5lbC5wcm90b3R5cGUgPSBuZXcgR3VhY2Ftb2xlLlR1bm5lbCgpO1xyXG5cclxuLyoqXHJcbiAqIEd1YWNhbW9sZSBUdW5uZWwgd2hpY2ggcmVwbGF5cyBhIEd1YWNhbW9sZSBwcm90b2NvbCBkdW1wIGZyb20gYSBzdGF0aWMgZmlsZVxyXG4gKiByZWNlaXZlZCB2aWEgSFRUUC4gSW5zdHJ1Y3Rpb25zIHdpdGhpbiB0aGUgZmlsZSBhcmUgcGFyc2VkIGFuZCBoYW5kbGVkIGFzXHJcbiAqIHF1aWNrbHkgYXMgcG9zc2libGUsIHdoaWxlIHRoZSBmaWxlIGlzIGJlaW5nIGRvd25sb2FkZWQuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXVnbWVudHMgR3VhY2Ftb2xlLlR1bm5lbFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXHJcbiAqICAgICBUaGUgVVJMIG9mIGEgR3VhY2Ftb2xlIHByb3RvY29sIGR1bXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Nyb3NzRG9tYWluPWZhbHNlXVxyXG4gKiAgICAgV2hldGhlciB0dW5uZWwgcmVxdWVzdHMgd2lsbCBiZSBjcm9zcy1kb21haW4sIGFuZCB0aHVzIG11c3QgdXNlIENPUlNcclxuICogICAgIG1lY2hhbmlzbXMgYW5kIGhlYWRlcnMuIEJ5IGRlZmF1bHQsIGl0IGlzIGFzc3VtZWQgdGhhdCB0dW5uZWwgcmVxdWVzdHNcclxuICogICAgIHdpbGwgYmUgbWFkZSB0byB0aGUgc2FtZSBkb21haW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFUdW5uZWxIZWFkZXJzPXt9XVxyXG4gKiAgICAgS2V5IHZhbHVlIHBhaXJzIGNvbnRhaW5pbmcgdGhlIGhlYWRlciBuYW1lcyBhbmQgdmFsdWVzIG9mIGFueSBhZGRpdGlvbmFsXHJcbiAqICAgICBoZWFkZXJzIHRvIGJlIHNlbnQgaW4gdHVubmVsIHJlcXVlc3RzLiBCeSBkZWZhdWx0LCBubyBleHRyYSBoZWFkZXJzIHdpbGxcclxuICogICAgIGJlIGFkZGVkLlxyXG4gKi9cclxuR3VhY2Ftb2xlLlN0YXRpY0hUVFBUdW5uZWwgPSBmdW5jdGlvbiBTdGF0aWNIVFRQVHVubmVsKHVybCwgY3Jvc3NEb21haW4sIGV4dHJhVHVubmVsSGVhZGVycykge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoaXMgR3VhY2Ftb2xlLlN0YXRpY0hUVFBUdW5uZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIHR1bm5lbCA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCwgaW4tcHJvZ3Jlc3MgSFRUUCByZXF1ZXN0LiBJZiBubyByZXF1ZXN0IGlzIGN1cnJlbnRseSBpblxyXG4gICAgICogcHJvZ3Jlc3MsIHRoaXMgd2lsbCBiZSBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7WE1MSHR0cFJlcXVlc3R9XHJcbiAgICAgKi9cclxuICAgIHZhciB4aHIgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkaXRpb25hbCBoZWFkZXJzIHRvIGJlIHNlbnQgaW4gdHVubmVsIHJlcXVlc3RzLiBUaGlzIGRpY3Rpb25hcnkgY2FuIGJlXHJcbiAgICAgKiBwb3B1bGF0ZWQgd2l0aCBrZXkvdmFsdWUgaGVhZGVyIHBhaXJzIHRvIHBhc3MgaW5mb3JtYXRpb24gc3VjaCBhcyBhdXRoZW50aWNhdGlvblxyXG4gICAgICogdG9rZW5zLCBldGMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdmFyIGV4dHJhSGVhZGVycyA9IGV4dHJhVHVubmVsSGVhZGVycyB8fCB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGNvbmZpZ3VyZWQgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHRoZSBnaXZlbiByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHJlcXVlc3RcclxuICAgICAqICAgICBUaGUgcmVxdWVzdCB3aGVyZSB0aGUgY29uZmlndXJlZCBleHRyYSBoZWFkZXJzIHdpbGwgYmUgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnNcclxuICAgICAqICAgICBUaGUgaGVhZGVycyB0byBiZSBhZGRlZCB0byB0aGUgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhZGRFeHRyYUhlYWRlcnMocmVxdWVzdCwgaGVhZGVycykge1xyXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xyXG4gICAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIobmFtZSwgaGVhZGVyc1tuYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiBzZW5kTWVzc2FnZShlbGVtZW50cykge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmdcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24gY29ubmVjdChkYXRhKSB7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSBhbnkgZXhpc3RpbmcgY29ubmVjdGlvbiBpcyBraWxsZWRcclxuICAgICAgICB0dW5uZWwuZGlzY29ubmVjdCgpO1xyXG5cclxuICAgICAgICAvLyBDb25uZWN0aW9uIGlzIG5vdyBzdGFydGluZ1xyXG4gICAgICAgIHR1bm5lbC5zZXRTdGF0ZShHdWFjYW1vbGUuVHVubmVsLlN0YXRlLkNPTk5FQ1RJTkcpO1xyXG5cclxuICAgICAgICAvLyBTdGFydCBhIG5ldyBjb25uZWN0aW9uXHJcbiAgICAgICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XHJcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhY3Jvc3NEb21haW47XHJcbiAgICAgICAgYWRkRXh0cmFIZWFkZXJzKHhociwgZXh0cmFIZWFkZXJzKTtcclxuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ3RleHQnO1xyXG4gICAgICAgIHhoci5zZW5kKG51bGwpO1xyXG5cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIEd1YWNhbW9sZSBwcm90b2NvbCBwYXJzZXIgc3BlY2lmaWNhbGx5IGZvciB0aGlzIGNvbm5lY3Rpb25cclxuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IEd1YWNhbW9sZS5QYXJzZXIoKTtcclxuXHJcbiAgICAgICAgLy8gSW52b2tlIHR1bm5lbCdzIG9uaW5zdHJ1Y3Rpb24gaGFuZGxlciBmb3IgZWFjaCBwYXJzZWQgaW5zdHJ1Y3Rpb25cclxuICAgICAgICBwYXJzZXIub25pbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIGluc3RydWN0aW9uUmVjZWl2ZWQob3Bjb2RlLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIGlmICh0dW5uZWwub25pbnN0cnVjdGlvbilcclxuICAgICAgICAgICAgICAgIHR1bm5lbC5vbmluc3RydWN0aW9uKG9wY29kZSwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQ29udGludW91c2x5IHBhcnNlIHJlY2VpdmVkIGRhdGFcclxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gcmVhZHlTdGF0ZUNoYW5nZWQoKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBQYXJzZSB3aGlsZSBkYXRhIGlzIGJlaW5nIHJlY2VpdmVkXHJcbiAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMyB8fCB4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbm5lY3Rpb24gaXMgb3BlblxyXG4gICAgICAgICAgICAgICAgdHVubmVsLnNldFN0YXRlKEd1YWNhbW9sZS5UdW5uZWwuU3RhdGUuT1BFTik7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBvbmx5IHRoZSBwb3J0aW9uIG9mIGRhdGEgd2hpY2ggaXMgbmV3bHkgcmVjZWl2ZWRcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIucmVjZWl2ZShidWZmZXIuc3Vic3RyaW5nKG9mZnNldCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGFuZCBjbG9zZSB3aGVuIGRvbmVcclxuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KVxyXG4gICAgICAgICAgICAgICAgdHVubmVsLmRpc2Nvbm5lY3QoKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgc3RhdGUgYW5kIGNsb3NlIHVwb24gZXJyb3JcclxuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIGh0dHBFcnJvcigpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEZhaWwgaWYgZmlsZSBjb3VsZCBub3QgYmUgZG93bmxvYWRlZCB2aWEgSFRUUFxyXG4gICAgICAgICAgICBpZiAodHVubmVsLm9uZXJyb3IpXHJcbiAgICAgICAgICAgICAgICB0dW5uZWwub25lcnJvcihuZXcgR3VhY2Ftb2xlLlN0YXR1cyhcclxuICAgICAgICAgICAgICAgICAgICBHdWFjYW1vbGUuU3RhdHVzLkNvZGUuZnJvbUhUVFBDb2RlKHhoci5zdGF0dXMpLCB4aHIuc3RhdHVzVGV4dCkpO1xyXG5cclxuICAgICAgICAgICAgdHVubmVsLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kaXNjb25uZWN0ID0gZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcclxuXHJcbiAgICAgICAgLy8gQWJvcnQgYW5kIGRpc3Bvc2Ugb2YgWEhSIGlmIGEgcmVxdWVzdCBpcyBpbiBwcm9ncmVzc1xyXG4gICAgICAgIGlmICh4aHIpIHtcclxuICAgICAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgICAgIHhociA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb25uZWN0aW9uIGlzIG5vdyBjbG9zZWRcclxuICAgICAgICB0dW5uZWwuc2V0U3RhdGUoR3VhY2Ftb2xlLlR1bm5lbC5TdGF0ZS5DTE9TRUQpO1xyXG5cclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuR3VhY2Ftb2xlLlN0YXRpY0hUVFBUdW5uZWwucHJvdG90eXBlID0gbmV3IEd1YWNhbW9sZS5UdW5uZWwoKTtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIFRoZSB1bmlxdWUgSUQgb2YgdGhpcyB2ZXJzaW9uIG9mIHRoZSBHdWFjYW1vbGUgSmF2YVNjcmlwdCBBUEkuIFRoaXMgSUQgd2lsbFxyXG4gKiBiZSB0aGUgdmVyc2lvbiBzdHJpbmcgb2YgdGhlIGd1YWNhbW9sZS1jb21tb24tanMgTWF2ZW4gcHJvamVjdCwgYW5kIGNhbiBiZVxyXG4gKiB1c2VkIGluIGRvd25zdHJlYW0gYXBwbGljYXRpb25zIGFzIGEgc2FuaXR5IGNoZWNrIHRoYXQgdGhlIHByb3BlciB2ZXJzaW9uXHJcbiAqIG9mIHRoZSBBUElzIGlzIGJlaW5nIHVzZWQgKGluIGNhc2UgYW4gb2xkZXIgdmVyc2lvbiBpcyBjYWNoZWQsIGZvciBleGFtcGxlKS5cclxuICpcclxuICogQHR5cGUge1N0cmluZ31cclxuICovXHJcbkd1YWNhbW9sZS5BUElfVkVSU0lPTiA9IFwiMS4zLjBcIjtcclxuXG4vKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG52YXIgR3VhY2Ftb2xlID0gR3VhY2Ftb2xlIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIEFic3RyYWN0IHZpZGVvIHBsYXllciB3aGljaCBhY2NlcHRzLCBxdWV1ZXMgYW5kIHBsYXlzIGJhY2sgYXJiaXRyYXJ5IHZpZGVvXHJcbiAqIGRhdGEuIEl0IGlzIHVwIHRvIGltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGNsYXNzIHRvIHByb3ZpZGUgc29tZSBtZWFucyBvZlxyXG4gKiBoYW5kbGluZyBhIHByb3ZpZGVkIEd1YWNhbW9sZS5JbnB1dFN0cmVhbSBhbmQgcmVuZGVyaW5nIHRoZSByZWNlaXZlZCBkYXRhIHRvXHJcbiAqIHRoZSBwcm92aWRlZCBHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXIuIERhdGEgcmVjZWl2ZWQgYWxvbmcgdGhlXHJcbiAqIHByb3ZpZGVkIHN0cmVhbSBpcyB0byBiZSBwbGF5ZWQgYmFjayBpbW1lZGlhdGVseS5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5HdWFjYW1vbGUuVmlkZW9QbGF5ZXIgPSBmdW5jdGlvbiBWaWRlb1BsYXllcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vdGlmaWVzIHRoaXMgR3VhY2Ftb2xlLlZpZGVvUGxheWVyIHRoYXQgYWxsIHZpZGVvIHVwIHRvIHRoZSBjdXJyZW50XHJcbiAgICAgKiBwb2ludCBpbiB0aW1lIGhhcyBiZWVuIGdpdmVuIHZpYSB0aGUgdW5kZXJseWluZyBzdHJlYW0sIGFuZCB0aGF0IGFueVxyXG4gICAgICogZGlmZmVyZW5jZSBpbiB0aW1lIGJldHdlZW4gcXVldWVkIHZpZGVvIGRhdGEgYW5kIHRoZSBjdXJyZW50IHRpbWUgY2FuIGJlXHJcbiAgICAgKiBjb25zaWRlcmVkIGxhdGVuY3kuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XHJcbiAgICAgICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiAtIGRvIG5vdGhpbmdcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gbWltZXR5cGUgaXMgc3VwcG9ydGVkIGJ5IGFueSBidWlsdC1pblxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBHdWFjYW1vbGUuVmlkZW9QbGF5ZXIsIGFuZCB0aHVzIHdpbGwgYmUgcHJvcGVybHkgaGFuZGxlZFxyXG4gKiBieSBHdWFjYW1vbGUuVmlkZW9QbGF5ZXIuZ2V0SW5zdGFuY2UoKS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWV0eXBlXHJcbiAqICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2suXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKiAgICAgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbWltZXR5cGUgaXMgc3VwcG9ydGVkIGJ5IGFueSBidWlsdC1pblxyXG4gKiAgICAgR3VhY2Ftb2xlLlZpZGVvUGxheWVyLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5HdWFjYW1vbGUuVmlkZW9QbGF5ZXIuaXNTdXBwb3J0ZWRUeXBlID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRUeXBlKG1pbWV0eXBlKSB7XHJcblxyXG4gICAgLy8gVGhlcmUgYXJlIGN1cnJlbnRseSBubyBidWlsdC1pbiB2aWRlbyBwbGF5ZXJzIChhbmQgdGhlcmVmb3JlIG5vXHJcbiAgICAvLyBzdXBwb3J0ZWQgdHlwZXMpXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBtaW1ldHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBidWlsdC1pblxyXG4gKiBHdWFjYW1vbGUuVmlkZW9QbGF5ZXIsIGluIHJvdWdoIG9yZGVyIG9mIHByaW9yaXR5LiBCZXdhcmUgdGhhdCBvbmx5IHRoZSBjb3JlXHJcbiAqIG1pbWV0eXBlcyB0aGVtc2VsdmVzIHdpbGwgYmUgbGlzdGVkLiBBbnkgbWltZXR5cGUgcGFyYW1ldGVycywgZXZlbiByZXF1aXJlZFxyXG4gKiBvbmVzLCB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgbGlzdC5cclxuICpcclxuICogQHJldHVybnMge1N0cmluZ1tdfVxyXG4gKiAgICAgQSBsaXN0IG9mIGFsbCBtaW1ldHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBidWlsdC1pbiBHdWFjYW1vbGUuVmlkZW9QbGF5ZXIsXHJcbiAqICAgICBleGNsdWRpbmcgYW55IHBhcmFtZXRlcnMuXHJcbiAqL1xyXG5HdWFjYW1vbGUuVmlkZW9QbGF5ZXIuZ2V0U3VwcG9ydGVkVHlwZXMgPSBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRUeXBlcygpIHtcclxuXHJcbiAgICAvLyBUaGVyZSBhcmUgY3VycmVudGx5IG5vIGJ1aWx0LWluIHZpZGVvIHBsYXllcnMgKGFuZCB0aGVyZWZvcmUgbm9cclxuICAgIC8vIHN1cHBvcnRlZCB0eXBlcylcclxuICAgIHJldHVybiBbXTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBHdWFjYW1vbGUuVmlkZW9QbGF5ZXIgcHJvdmlkaW5nIHN1cHBvcnQgZm9yIHRoZSBnaXZlblxyXG4gKiB2aWRlbyBmb3JtYXQuIElmIHN1cHBvcnQgZm9yIHRoZSBnaXZlbiB2aWRlbyBmb3JtYXQgaXMgbm90IGF2YWlsYWJsZSwgbnVsbFxyXG4gKiBpcyByZXR1cm5lZC5cclxuICpcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuSW5wdXRTdHJlYW19IHN0cmVhbVxyXG4gKiAgICAgVGhlIEd1YWNhbW9sZS5JbnB1dFN0cmVhbSB0byByZWFkIHZpZGVvIGRhdGEgZnJvbS5cclxuICpcclxuICogQHBhcmFtIHtHdWFjYW1vbGUuRGlzcGxheS5WaXNpYmxlTGF5ZXJ9IGxheWVyXHJcbiAqICAgICBUaGUgZGVzdGluYXRpb24gbGF5ZXIgaW4gd2hpY2ggdGhpcyBHdWFjYW1vbGUuVmlkZW9QbGF5ZXIgc2hvdWxkIHBsYXlcclxuICogICAgIHRoZSByZWNlaXZlZCB2aWRlbyBkYXRhLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcclxuICogICAgIFRoZSBtaW1ldHlwZSBvZiB0aGUgdmlkZW8gZGF0YSBpbiB0aGUgcHJvdmlkZWQgc3RyZWFtLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtHdWFjYW1vbGUuVmlkZW9QbGF5ZXJ9XHJcbiAqICAgICBBIEd1YWNhbW9sZS5WaWRlb1BsYXllciBpbnN0YW5jZSBzdXBwb3J0aW5nIHRoZSBnaXZlbiBtaW1ldHlwZSBhbmRcclxuICogICAgIHJlYWRpbmcgZnJvbSB0aGUgZ2l2ZW4gc3RyZWFtLCBvciBudWxsIGlmIHN1cHBvcnQgZm9yIHRoZSBnaXZlbiBtaW1ldHlwZVxyXG4gKiAgICAgaXMgYWJzZW50LlxyXG4gKi9cclxuR3VhY2Ftb2xlLlZpZGVvUGxheWVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0SW5zdGFuY2Uoc3RyZWFtLCBsYXllciwgbWltZXR5cGUpIHtcclxuXHJcbiAgICAvLyBUaGVyZSBhcmUgY3VycmVudGx5IG5vIGJ1aWx0LWluIHZpZGVvIHBsYXllcnNcclxuICAgIHJldHVybiBudWxsO1xyXG5cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBHdWFjYW1vbGU7IiwiZXhwb3J0IGNsYXNzIEdyZWV0ZXJcclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBncmVldChtZXNzYWdlOiBzdHJpbmcpOiBzdHJpbmdcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYEhlbGxvLCAke21lc3NhZ2V9IWA7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBUZXN0Q2xhc3MyXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgSGVsbG8yKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWRcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkhlbGxvIFwiICsgbWVzc2FnZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBUZXN0Q2xhc3MxXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgSGVsbG8obWVzc2FnZTogc3RyaW5nKTogdm9pZFxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSGVsbG8gXCIgKyBtZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIFNsZWVwQXN5bmMobXNlYzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPlxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShcclxuICAgICAgICAgICAgZnVuY3Rpb24gKHJlc29sdmUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9LCBtc2VjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgSGVsbG9Bc3luYygpOiBQcm9taXNlPHZvaWQ+XHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydFwiKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoaSA+PSAxMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJUaGlzIGlzIEVycm9yICEhIVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuU2xlZXBBc3luYyg1MCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTmVrb18gMTExIDogXCIgKyBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJlbmRcIik7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcblx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZTsgfTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgXCJjb3JlLWpzL2VzL3Byb21pc2VcIjtcclxuXHJcbmltcG9ydCB7IEdyZWV0ZXIsIFRlc3RDbGFzczEsIFRlc3RDbGFzczIgfSBmcm9tIFwiLi9EbkxpYlwiO1xyXG5cclxuaW1wb3J0IEd1YWNhbW9sZSBmcm9tIFwiZ3VhY2Ftb2xlLWNvbW1vbi1qc1wiO1xyXG4vL2ltcG9ydCAqIGFzIEd1YWNhbW9sZSBmcm9tIFwiLi9ndWFjYW1vbGUtY29tbW9uXCI7XHJcblxyXG5cclxuLy9jb25zb2xlLmxvZyhcIkhlbGxvIFdvcmxkXCIpO1xyXG5cclxuLy9hbGVydChHcmVldGVyLmdyZWV0KFwid29ybGQgMDIxXCIpKTtcclxuXHJcblRlc3RDbGFzczIuSGVsbG8yKFwiSW51XCIpO1xyXG5UZXN0Q2xhc3MxLkhlbGxvKFwiTmVrb1wiKTtcclxuXHJcbi8vVGVzdEZ1bmMxKCk7XHJcblxyXG5mdW5jdGlvbiB4KCk6IHZvaWRcclxueyB9XHJcblxyXG5mdW5jdGlvbiBUZXN0RnVuYzEoKTogdm9pZFxyXG57XHJcbiAgICBjb25zb2xlLmxvZyhcIi0tYVwiKTtcclxuICAgIGNvbnN0IHRhc2sgPSBUZXN0Q2xhc3MxLkhlbGxvQXN5bmMoKTtcclxuICAgIHRhc2suY2F0Y2goeCA9PlxyXG4gICAge1xyXG4gICAgICAgIGFsZXJ0KHgpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZyhcIi0tYlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRvbVxyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIEh0bWxUZXN0MSgpOiB2b2lkXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJUb20gSHRtbCB0ZXN0IDFcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBHdWFjYW1vbGVUZXN0MShkaXNwbGF5OiBIVE1MRWxlbWVudCk6IHZvaWRcclxuICAgIHtcclxuICAgICAgICBjb25zdCB0dW5uZWwgPSBuZXcgR3VhY2Ftb2xlLldlYlNvY2tldFR1bm5lbChcIk1vZGVsLldlYlNvY2tldFVybFwiKTtcclxuXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgdHVubmVsLm9uZXJyb3IgPSBmdW5jdGlvbiAoc3RhdHVzOiBhbnkpOiB2b2lkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0dXMpO1xyXG4gICAgICAgICAgICBhbGVydChcIlR1bm5lbCBFcnJvciBDb2RlOiBcIiArIHN0YXR1cy5jb2RlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBJbnN0YW50aWF0ZSBjbGllbnQsIHVzaW5nIGEgV2ViU29ja2V0IHR1bm5lbCBmb3IgY29tbXVuaWNhdGlvbnMuXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGNvbnN0IGd1YWMgPSBuZXcgR3VhY2Ftb2xlLkNsaWVudCh0dW5uZWwpO1xyXG5cclxuICAgICAgICAvLyBBZGQgY2xpZW50IHRvIGRpc3BsYXkgZGl2XHJcbiAgICAgICAgZGlzcGxheS5hcHBlbmRDaGlsZChndWFjLmdldERpc3BsYXkoKS5nZXRFbGVtZW50KCkpO1xyXG5cclxuICAgICAgICAvLyBFcnJvciBoYW5kbGVyXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBndWFjLm9uZXJyb3IgPSBmdW5jdGlvbiAoc3RhdHVzOiBhbnkpOiB2b2lkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0dXMpO1xyXG4gICAgICAgICAgICBhbGVydChcIlJlbW90ZSBEZXNrdG9wIEVycm9yIENvZGU6IFwiICsgc3RhdHVzLmNvZGUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGd1YWMuY29ubmVjdChcImlkPU1vZGVsLlNlc3Npb25JZFwiKTtcclxuXHJcbiAgICAgICAgd2luZG93Lm9udW5sb2FkID0gZnVuY3Rpb24gKCk6IHZvaWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGd1YWMuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2FtcGxlRnVuY3Rpb25FeHBvcnRlZDEoKTogdm9pZFxyXG57XHJcbiAgICBjb25zb2xlLmxvZyhcInNhbXBsZUZ1bmN0aW9uRXhwb3J0ZWQxXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gVGVzdEZ1bmMyKCk6IHZvaWRcclxue1xyXG4gICAgY29uc29sZS5sb2coXCJUZXN0RnVuYzJcIik7XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==