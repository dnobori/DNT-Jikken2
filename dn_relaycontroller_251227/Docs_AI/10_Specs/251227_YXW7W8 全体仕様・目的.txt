このファイルは、このプロジェクトで作成するプログラムの全体仕様・目的を記述したものである。

1. このプログラムの目的
(1) このブログラムは、Raspberry Pi 4 上の Linux (Ubuntu 20.04 環境) で動作する、軽量なコマンドラインプロセスであり、実行する度に、以下の処理を実施することを目標としている。

(2) このプログラムは、起動すると、ユーザーが Ctrl + C 等でプロセスを強制終了しない限り、プロセスを勝手に終了せず、ずっと継続して動作し続ける。
  なお、このプログラムは、root 権限で起動される。

(3) 起動すると、HTTP サーバーを、TCPポート7001で、「0.0.0.0:7001」に対して bind / listen して起動する。このHTTPサーバーは、Kestrelのような重たいライブラリを使用するのではなく、BCLにおけTCPリスナーを用いて、必要最小限のHTTP 0.9/1.0/1.1 サーバーを自前でC#で実装する。並列処理は、できるだけ Task を使用する。コーディンク規約の「11. 同期・非同期」に従うこと。
  - TCPリスナーで、ポートのbindまたはlistenに成功した場合は、その旨のメッセージをコンソールに表示する。
  - TCPリスナーで、ポートのbindまたはlistenに失敗した場合は、その旨の例外を表示し、成功するまで繰り返しbindまたはlistenを10秒ごとに試行する。
  - このHTTPサーバーは、多数のWebクライアントからの接続を同時に受付けることができる。ただし、接続されたTCPコネクションにおける送受信タイムアウトは、60秒とし、接続されたけれども何も通信していないソケットは強制切断する。
  - このHTTPサーバーは、通常のHTTP 1.0/1.1にあるような、Connection Keep Aliveなどの標準的機能をサポートし、通常のWebブラウザやcurl/wget/各種プログラミング言語のHTTPクライアントからの通信操作に正しく応答くる。

(4) (3) のHTTPサーバーは、
   (a) http://xxxx/keep_lock
   という固定 URL を受付ける。このURLに対して、GETメソッドで取得要求があった場合、[251227_ZAMUX5] に関連するグローバル変数設定処理を行なった上で、応答として「Ok.」という text/plain を応答する。
   
   (b) http://xxxx/unlock
   という固定 URL を受付ける。このURLに対して、GETメソッドで取得要求があった場合、[251227_ZAMUX5] に関連するグローバル変数設定処理を行なった上で、応答として「Ok.」という text/plain を応答する。[251228_BFR2CM]
   
   これ以外の URL に対しては、404 の Not Found を応答する。

(5) (3) の HTTP サーバーが起動したら、それとは別に、1つのループスレッドを開始する。タスクではなく、独立したスレッドを使用する。
  - このループスレッドは、リレー装置の制御を掌る。リレー装置は、このプログラムが動作する Raspberry Pi 4 の USB ポート上に接続されている。
  - このループスレッドが起動したら、最初に、ループに入る前に、リレーを「OFF」に設定 (リセット) する。そして、(c) と同様のメッセージ表示する。リレー制御の詳細は、[251227_ZDYJ3U] による。
  - ループスレッドは、while (true) のループになっている。そして、0.1秒に1回、次の処理を行なう。
   (a) 直近 5 秒間に 1 回以上、(4) の「http://xxxx/keep_lock」または「http://xxxx/unlock」の URL への正常なアクセスがあったかどうか、(4) によってグローバル変数に設定された情報を確認して、判断する [251227_ZAMUX5]。
   (b) 直近 5 秒間に 1 回以上、(4) の「http://xxxx/keep_lock」のURL への正常なアクセスがあったことがある場合は、リレーを「ON」に設定する。そうでない場合は、リレーを「OFF」に設定する。リレー制御の詳細は、[251227_ZDYJ3U] による。
   (b-2) (b) にかかわらず、最後に (4) の「http://xxxx/keep_lock」 にアクセスがあった時よりも、最後に (4) の「http://xxxx/unlock」にアクセスがあった時のほうが後の場合は、必ず、リレーを「OFF」に設定する。つまり、「http://xxxx/unlock」へのアクセスにより、リレーは強制 OFF 状態となる。この unlock 指示は、常に、それ以前の「http://xxxx/keep_lock」よりも優先される。ただし、「http://xxxx/unlock」の指示があった時よりも後に、「http://xxxx/keep_lock」指示があった場合は、その「http://xxxx/unlock」のあった事実は考慮しなくても良いことになる。[251228_BFR2CM]
   (c) (a) または (b) または (b-2) の処理でリレーへの書き込みに成功し、リレーの ON/OFF 状態が前回から「変化した」場合は、コンソールにその旨 (リレー状態が変化したという旨と、新しい状態が ON/OFF のどちらか) を表示する。ここでいう「変化した」について、前のリレー状態の推定は、変数等にして、自ら覚えておくこと。(リレーから現在の値を取得することはしない。リレーには一方的に信号を書き込むのみである。)
  - このループは決して終了しない。
  - ループの途中で、ハンドリングされていないエラーが発生した場合は、そのメッセージをコンソールに表示した上で、1.0 秒待機し、ループを続ける。

(6) (5) のループスレッドとは別に、(5) のループスレッド開始と同時に、watchdog timer スレッドを起動する。この watchdog timer スレッドは、(5) のループスレッドを見張っており、(5) のループスレッドの 1 回のループ処理ごとにインクリメントされるループが回った回数を計測するカウンタを監視する。そして、そのカウンタが、30秒経過しても1つも増加しない場合は、(5) のループスレッドが何らかの原因でフリーズしているとみなし、その旨をコンソール出力に記載した後に、直ちに、このプログラムのプロセスを強制終了する。

2. リレー制御の詳細 [251227_ZDYJ3U]
(1) リレー装置のデバイス名の検索方法は、まず、「/dev/serial/by-id/」というディレクトリを列挙する。すると、シンボリックリンクとして、「USB-RELAY」という文字列を含んだデバイスが1つ以上存在する。複数存在する場合は、そのシンボリックリンクの名前を文字列ソートして最も小さいものを用いる。
    Linux ユーザーが、bashシェルで、上記と同等の方法で検索を試みた際のコンソールログを [251227_ZCL858] に示す。ここでは、「/dev/serial/by-id/usb-Microchip_Technology_Inc._USB-RELAY1-if00」というデバイスが、リレーデバイスである。このコマンドライン (ls) を子プロセスとして呼び出すのではなく、C# プログラム内から、シリアル制御ライブラリ関数等を用いて制御すること。

(2) このリレーデバイスは、仮想シリアルデバイスとして Linux に見える。このデバイスに対して、何か制御を送付する際には、必ず、「9600 8N1 / フロー制御なし」という設定をこの仮想シリアルデバイスに対して設定してから、制御通信を開始する。Linux ユーザーが、bashシェルで、上記と同等の方法で設定をする際のコマンドライン例を [251227_ZFDUS6] に示す。このコマンドライン (print) を子プロセスとして呼び出すのではなく、C# プログラム内から、シリアル制御ライブラリ関数等を用いて制御すること。

(3) このリレーデバイスを ON するためには、'1' という 1 バイトを、仮想シリアルデバイスに送付する。
  (a) この際、送付するたびにシリアルデバイスを open し、送付を行ない、送付を行なったら flush をしてから、念のため 0.5 秒の delay を入れて、最後に close する。
  (b) 念のため、「ON」操作の際には、(a) を 3 回繰り返す。繰り返すたびに 0.5秒の delay を入れる。
  (c) Linux ユーザーが、bashシェルで、上記 (a) と同等の方法で制御をする際のコマンドライン例を [251227_ZGECX3] に示す (delay の処理はなし)。このコマンドライン (print) を子プロセスとして呼び出すのではなく、C# プログラム内から、シリアル制御ライブラリ関数等を用いて制御すること。

(4) このリレーデバイスを OFF するためには、'0' という 1 バイトを、仮想シリアルデバイスに送付する。
  (a) この際、送付するたびにシリアルデバイスを open し、送付を行ない、送付を行なったら flush をしてから、念のため 0.5 秒の delay を入れて、最後に close する。
  (b) 念のため、「OFF」操作の際には、(a) を 3 回繰り返す。繰り返すたびに 0.5秒の delay を入れる。
  (c) Linux ユーザーが、bashシェルで、上記 (a) と同等の方法で制御をする際のコマンドライン例を [251227_ZGM8N5] に示す (delay の処理はなし)。このコマンドライン (print) を子プロセスとして呼び出すのではなく、C# プログラム内から、シリアル制御ライブラリ関数等を用いて制御すること。

(5) (1) ～ (4) の処理の途中で、一時的に、例外が発生することがある (一時的にシリアルコンソールデバイスが不調であるとか、他プログラムによって開かれている等)。例外発生時は、プログラムがクラッシュしないように例外ハンドリングを行ない、例外内容をコンソールに表示すること。また、例外が発生したら、5 回リトライを行ない、リトライ間隔は 1.0 秒とすること。


--- [251227_ZCL858] ここから ---
# ls -la /dev/serial/by-id/
total 0
drwxr-xr-x 2 root root 60 2025/12/27 23:00:17 .
drwxr-xr-x 4 root root 80 2025/12/27 23:00:17 ..
lrwxrwxrwx 1 root root 13 2025/12/27 23:00:17 usb-Microchip_Technology_Inc._USB-RELAY1-if00 -> ../../ttyACM0
--- ここまで ---

--- [251227_ZFDUS6] ここから ---
# $DEV にデバイスファイル名が入っている
stty -F "$DEV" 9600 cs8 -cstopb -parenb -ixon -ixoff -crtscts -echo
--- ここまで ---

--- [251227_ZGECX3] ここから ---
# $DEV にデバイスファイル名が入っている
# ON（'1' を送る）
printf '1' > "$DEV"
--- ここまで ---

--- [251227_ZGM8N5] ここから ---
# $DEV にデバイスファイル名が入っている
# OFF（'0' を送る）
printf '0' > "$DEV"
--- ここまで ---

3. その他
(1) コンソール出力へのメッセージは、「YYYY/MM/DD HH:MM:SS +xx:00」 という日時を示す文字列 (タイムゾーンを表示する。タイムゾーンは Linux のローカルタイムゾーンとする) に続いて、英語で記載すること。

